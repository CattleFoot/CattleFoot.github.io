<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CallteFoot&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/4/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="CallteFoot&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CallteFoot&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cattlefoot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-git命令和使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/git命令和使用/" class="article-date">
  <time datetime="2017-06-24T12:23:20.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/24/git命令和使用/">git命令和使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="git命令详解"><a href="#git命令详解" class="headerlink" title="git命令详解"></a>git命令详解</h3><p>git命令形式：<br>usage: git [–version] [–help] [-C &lt; path &gt;] [ -c name=value ]<br>           [–exec-path[ = &lt; path &gt; ] ] [–html-path] [–man-path] [–info-path]<br>           [-p | –paginate | –no-pager] [–no-replace-objects] [–bare]<br>           [–git-dir=&lt; path &gt;] [–work-tree=&lt; path &gt;] [–namespace=&lt; name &gt;]<br>           &lt; command &gt; [&lt; args &gt;]</p>
<p>These are common Git commands used in various situations:</p>
<ol>
<li><p>start a working area (see also: git help tutorial)</p>
<ul>
<li>clone  :    Clone a repository into a new directory</li>
<li>init    :   Create an empty Git repository or reinitialize an existing one</li>
</ul>
</li>
<li><p>work on the current change (see also: git help everyday)</p>
<ul>
<li>add     :   Add file contents to the index</li>
<li>mv      :   Move or rename a file, a directory, or a symlink</li>
<li>reset   :   Reset current HEAD to the specified state</li>
<li>rm      :   Remove files from the working tree and from the index</li>
</ul>
</li>
<li><p>examine the history and state (see also: git help revisions)</p>
<ul>
<li>bisect :    Use binary search to find the commit that introduced a bug</li>
<li>grep    :   Print lines matching a pattern</li>
<li>log     :   Show commit logs</li>
<li>show    :   Show various types of objects</li>
<li>status    : Show the working tree status</li>
</ul>
</li>
<li><p>grow, mark and tweak your common history</p>
<ul>
<li>branch :    List, create, or delete branches</li>
<li>checkout:   Switch branches or restore working tree files</li>
<li>commit   :  Record changes to the repository</li>
<li>diff      : Show changes between commits, commit and working tree, etc</li>
<li>merge  :    Join two or more development histories together</li>
<li>rebase  :   Reapply commits on top of another base tip</li>
<li>tag        :Create, list, delete or verify a tag object signed with GPG</li>
</ul>
</li>
<li><p>collaborate (see also: git help workflows)</p>
<ul>
<li>fetch    :  Download objects and refs from another repository</li>
<li>pull     :  Fetch from and integrate with another repository or a local branch</li>
<li>push    :   Update remote refs along with associated objects</li>
</ul>
</li>
</ol>
<p>‘git help -a’ and ‘git help -g’ list available subcommands and some<br>concept guides. See ‘git help &lt; command &gt;’ or ‘git help &lt; concept &gt;’<br>to read about a specific subcommand or concept.</p>
<h3 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h3><h4 id="git诞生"><a href="#git诞生" class="headerlink" title="git诞生"></a>git诞生</h4><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
<h4 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h4><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><img src="images/inCenter.jpg" alt="集中式管理"></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="images/onNode.jpg" alt="分布式管理"></p>
<p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>
<p>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p>
<p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p>
<p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p>
<p>》》》》读者解读<br>Git与SVN的主要差别：这两个工具主要的区别在于历史版本维护的位置。<br>Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史；<br>而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行；<br>这样的好处在于：<br>1、自己可以在脱机环境查看开发的版本历史<br>2、多人开发时如果充当中央仓库的Git仓库挂了，任何一个开发者的仓库都可以作为中央仓库进行服务<br>》》》</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<ol>
<li>在linux上安装Git<br>首先，你可以试着输入git，看看系统有没有安装Git：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program <span class="string">'git'</span> is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>安装Git</p>
<p>阅读: 1563566<br>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<p>在Linux上安装Git</p>
<p>首先，你可以试着输入git，看看系统有没有安装Git：</p>
<p>$ git<br>The program ‘git’ is currently not installed. You can install it by typing:<br>sudo apt-get install git<br>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<ol>
<li>在Mac OS X上安装Git<br>如果你正在使用Mac做开发，有两种安装Git的方法。</li>
</ol>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。<br><img src="images/MacInstallGit.jpg" alt="Mac下安装Git"></p>
<ol>
<li>在Windows上安装Git</li>
</ol>
<p>Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。</p>
<p>msysgit是Windows版的Git，从<a href="https://git-for-windows.github.io下载（网速慢的同学请移步国内镜像），然后按默认选项安装即可。" target="_blank" rel="noopener">https://git-for-windows.github.io下载（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</a></p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br><img src="images/WindowsInstallGit.jpg" alt="windows下安装Git"></p>
<p><strong>安装好最后</strong></p>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure></p>
<p>pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。</p>
<p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p>
<p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></p>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p>
<p><strong>把文件添加到版本库</strong></p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>使用Windows的童鞋要特别注意：</p>
<p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发的记事本会在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：<br><img src="images/notepad++.jpg" alt="notepad++设置"><br>言归正传，现在我们编写一个readme.txt文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令git add告诉Git，把文件添加到仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令git commit告诉Git，把文件提交到仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"wrote a readme file"</span></span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p>
<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p>git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步：</p>
<p>第一步，使用命令git add &lt; file &gt;，注意，可反复多次使用，添加多个文件；</p>
<p>第二步，使用命令git commit，完成。</p>
<h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>现在，运行git status命令看看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。</p>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add distributed"</span></span><br><span class="line">[master ea34578] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。<br><strong>小结</strong></p>
<ul>
<li>要随时掌握工作区的状态，使用git status命令。</li>
<li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容</li>
</ul>
<p>》》》读者解读</p>
<ol>
<li><p>git add 的各种区别:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A   // 添加所有改动</span><br><span class="line">git add *    // 添加新建文件和修改，但是不包括删除</span><br><span class="line">git add .    // 添加新建文件和修改，但是不包括删除</span><br><span class="line">git add -u   // 添加修改和删除，但是不包括新建文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 commit 前撤销 add:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt; // 撤销提交单独文件</span><br><span class="line">git reset        // unstage all due changes</span><br></pre></td></tr></table></figure>
</li>
<li><p>add/commit 前撤销对文件的修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- README.md  // 注意, add添加后(同commit提交后)就无法通过这种方式撤销修改</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>》》》</p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>然后尝试提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m <span class="string">"append GPL"</span></span><br><span class="line">[master 3628164] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>版本2：add distributed<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>版本3：append GPL<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL</span><br><span class="line">ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85 add distributed</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>需要友情提示的是，你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：<br><img src="images/timeline.jpg" alt="时间线"><br>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ea34578 add distributed</span><br></pre></td></tr></table></figure></p>
<p>–hard参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看readme.txt的内容是不是版本add distributed：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3628164</span><br><span class="line">HEAD is now at 3628164 append GPL</span><br><span class="line">``` </span><br><span class="line">版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</span><br><span class="line"></span><br><span class="line">再小心翼翼地看看readme.txt的内容：</span><br><span class="line">```bash</span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：<br><img src="images/headFirst.jpg" alt="head指向"><br>改为指向add distributed：</p>
<p><img src="images/headtwo.jpg" alt="修改head指向"><br>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<p> 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。<br><strong>小结</strong></p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。<br>》》》读者解读<br>git reflog  与 git log区别:</li>
<li>git log :是当你回退到某个版本，此版本之后的记录，就自动抹去了</li>
<li>git reflog:是你提交的完整的命令历史，回退到某个版本，仍然可以查到位于此版本之后的版本号。<br>》》》</li>
</ul>
<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br><strong> 工作区（Working Directory）</strong><br>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：<br><img src="images/workingDirect.png" alt="工作区"></p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="images/Repository.jpg" alt="版本库"></p>
<p>分支和HEAD的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure></p>
<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       LICENSE</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   LICENSE</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="images/gitAdd.jpg" alt="存放暂存区"><br>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master 27c9860] understand how stage works</span><br><span class="line"> 2 files changed, 675 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：<br><img src="images/gitCommit.jpg" alt="提交到本地仓库"><br>》》》读者解读</p>
<ul>
<li>git diff    #是工作区(work dict)和暂存区(stage)的比较</li>
<li>git diff –cached    #是暂存区(stage)和分支(master)的比较<br>》》》</li>
</ul>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure></p>
<p>然后，添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>然后，再修改readme.txt：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"git tracks changes"</span></span><br><span class="line">[master d4f25b6] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>提交后，再看看状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>咦，怎么第二次的修改没有被提交？</p>
<p>别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>
<p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>可见，第二次修改确实没有被提交。那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit<br>好，现在，把第二次修改提交了。</p>
<p><strong>小结</strong></p>
<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p>
<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>现在，看看readme.txt的文件内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files</span><br></pre></td></tr></table></figure>
<p>文件内容果然复原了。<br>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p>再用git status查看一下，现在暂存区是干净的，工作区有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>整个世界终于清静了！</p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong><br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。<br>》》》读者解读<br><img src="images/basic-usage.svg" alt="文件层面操作"></p>
<ul>
<li>git add files 把当前文件放入暂存区域。</li>
<li>git commit 给暂存区域生成快照并提交。</li>
<li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li>
<li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改</li>
</ul>
<p><img src="iamges/checkout-files.svg" alt="checkout"><br>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当给定某个文件名时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，git checkout HEAD~ foo.c会将提交节点HEAD~(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。<br><img src="images/checkout-branch.svg" alt="checkout-branch."><br>当不指定文件名，而是给出一个（本地）分支时，那么HEAD标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和HEAD对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。<br><img src="images/checkout-detached.svg" alt="checkout-detached"><br>如果既没有指定文件, 也没有指定分枝. 而是只给出一段提交的历史Hash, 只有HEAD会移动到相应的历史提交. 这会造成HEAD分离, 非常危险的操作, 这个命令的说明只是为了满足你的好奇心而已, 不要使用这个命令.<br><img src="images/reset-commit.svg" alt="reset-commit"><br>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变。</p>
<p><img src="images/reset.svg" alt="reset"><br>如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard选项，工作目录也同样。<br>》》》</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m <span class="string">"add test.txt"</span></span><br><span class="line">[master 94cdc44] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure></p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleted:    test.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">'test.txt'</span></span><br><span class="line">$ git commit -m <span class="string">"remove test.txt"</span></span><br><span class="line">[master d17efd8] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></p>
<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p><strong>小结</strong><br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure></p>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br><img src="images/addSshKey.png" alt="addSshKey"><br>点“Add Key”，你就应该看到已经添加的Key：<br><img src="images/SSHkeys.png" alt="keys"><br>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><img src="images/createRepo.png" alt="createRepo"><br>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库:<br><img src="images/seeRepo.png" alt="confirm repo"><br>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (19/19), 13.73 KiB, done.</span><br><span class="line">Total 23 (delta 6), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin</span><br></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：<br><img src="images/repoFiles.png" alt="files lise"><br>从现在起，只要本地作了提交，就可以通过命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！<br>SSH警告<br>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'github.com (xx.xx.xx.xx)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is xx.xx.xx.xx.xx.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'github.com'</span> (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。<br>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p>
<p><strong>小结</strong><br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；<br>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；<br>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>当远程库已经准备好了，下一步是用命令git clone克隆一个本地库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into <span class="string">'gitskills'</span>...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p>
<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。<br> 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。<br>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/**.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="noopener">https://github.com/michaelliao/**.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<p><strong>小结</strong><br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！<br>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="images/head_master.png" alt="head master"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="images/head_dev.png" alt="head dev"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p><img src="images/head_dev_new.png" alt="head pointer new"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="images/head_merge.png" alt="head merge"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="images/head_new.png" alt="head new"><br>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。<br>首先，我们创建dev分支，然后切换到dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>
<p>然后，用git branch命令查看当前分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure></p>
<p>然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev fec145a] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：<br><img src="images/head_master_dev.png" alt="head pointer master"></p>
<p>现在，我们把dev分支的工作成果合并到master分支上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure>
<p>删除后，查看branch，就只剩下master分支了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
<p><strong>小结</strong><br>Git鼓励大量使用分支：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch &lt; name &gt;</li>
<li>切换分支：git checkout &lt; name &gt;</li>
<li>创建+切换分支：git checkout -b &lt; name &gt;</li>
<li>合并某分支到当前分支：git merge &lt; name &gt;</li>
<li>删除分支：git branch -d &lt; name &gt;</li>
</ul>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的feature1分支，继续我们的新分支开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt最后一行，改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure></p>
<p>在feature1分支上提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 75a857c] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>切换到master分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br></pre></td></tr></table></figure></p>
<p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 400b400] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：</p>
<p><img src="images/head_master_branch.png" alt="master not same with branch"><br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></p>
<p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/master' by 2 commits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unmerged paths:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." as appropriate to mark resolution)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       both modified:      readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接查看readme.txt的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure></p>
<p>再提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master 59bc1cb] conflict fixed</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支变成了下图所示：<br><img src="images/head_branch_fix.png" alt="branch fix on master"></p>
<p>用带参数的git log也可以看到分支的合并情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 75a857c AND simple</span><br><span class="line">* | 400b400 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* fec145a branch <span class="built_in">test</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>最后，删除feature1分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> feature1</span><br><span class="line">Deleted branch feature1 (was 75a857c).</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用git log –graph命令可以看到分支合并图。</p>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt文件，并提交一个新的commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"add merge"</span></span><br><span class="line">[dev 6224937] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们切换回master：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></p>
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   7825a50 merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 6224937 add merge</span><br><span class="line">|/</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到，不使用Fast forward模式，merge后就像这样：<br><img src="images/head_merge_without_ff.png" alt="merge without fast forward"></p>
<p><strong>分支策略</strong><br>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：<br><img src="images/branchs.png" alt="分支管理"></p>
<p><strong>小结</strong><br>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   hello.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class="line">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure></p>
<p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure></p>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-101 cc17032] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">$ git branch <span class="_">-d</span> issue-101</span><br><span class="line">Deleted branch issue-101 (was cc17032).</span><br></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>
<p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</span><br></pre></td></tr></table></figure></p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   hello.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure></p>
<p>再用git stash list查看，就看不到任何stash内容了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure></p>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch <span class="string">'feature-vulcan'</span></span><br></pre></td></tr></table></figure></p>
<p>5分钟后，开发完毕：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch feature-vulcan</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   vulcan.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ git commit -m <span class="string">"add feature vulcan"</span></span><br><span class="line">[feature-vulcan 756d4af] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure></p>
<p>切回dev，准备合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> feature-vulcan</span><br><span class="line">error: The branch <span class="string">'feature-vulcan'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D feature-vulcan'</span>.</span><br></pre></td></tr></table></figure></p>
<p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p>
<p>现在我们强行删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 756d4af).</span><br></pre></td></tr></table></figure></p>
<p>终于删除成功！</p>
<p><strong>小结</strong></p>
<p>开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt; name &gt;强行删除。</p>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用git remote：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>或者，用git remote -v显示更详细的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<p><strong>推送分支</strong></p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>如果要推送其他分支，比如dev，就改成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p><strong>抓取分支</strong><br>多人协作时，大家都会往master和dev分支上推送各自的修改。<br>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 46, done.</span><br><span class="line">remote: Compressing objects: 100% (26/26), done.</span><br><span class="line">remote: Total 46 (delta 16), reused 45 (delta 15)</span><br><span class="line">Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (16/16), done.</span><br></pre></td></tr></table></figure></p>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>
<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add /usr/bin/env"</span></span><br><span class="line">[dev 291bea8] add /usr/bin/env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 349 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line">   <span class="built_in">fc</span>38031..291bea8  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.py </span><br><span class="line">$ git commit -m <span class="string">"add coding: utf-8"</span></span><br><span class="line">[dev bd6ae48] add coding: utf-8</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Merge the remote changes (e.g. <span class="string">'git pull'</span>)</span><br><span class="line">hint: before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure></p>
<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   <span class="built_in">fc</span>38031..291bea8  dev        -&gt; origin/dev</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream dev origin/&lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream dev origin/dev</span><br><span class="line">Branch dev <span class="built_in">set</span> up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure></p>
<p>再pull：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.py</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></p>
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"merge &amp; fix hello.py"</span></span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 10, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 747 bytes, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line">   291bea8..adca45d  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>因此，多人协作的工作模式通常是这样：</p>
<ul>
<li>首先，可以试图用git push origin branch-name推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<pre><code>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。
</code></pre></li>
</ul>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<ul>
<li>查看远程库信息，使用git remote -v；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li>
<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”，“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”，“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>然后，敲命令git tag &lt; name &gt;就可以打一个新标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p>
<p>可以用命令git tag查看所有标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">6a5819e merged bug fix 101</span><br><span class="line">cc17032 fix bug 101</span><br><span class="line">7825a50 merge with no-ff</span><br><span class="line">6224937 add merge</span><br><span class="line">59bc1cb conflict fixed</span><br><span class="line">400b400 &amp; simple</span><br><span class="line">75a857c AND simple</span><br><span class="line">fec145a branch <span class="built_in">test</span></span><br><span class="line">d17efd8 remove test.txt</span><br></pre></td></tr></table></figure></p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 6224937</span><br></pre></td></tr></table></figure>
<p>再用命令git tag查看标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt; tagname &gt;查看标签信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 11:22:08 2013 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到，v0.9确实打在add merge这次提交上，还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-a</span> v0.1 -m <span class="string">"version 0.1 released"</span> 3628164</span><br></pre></td></tr></table></figure></p>
<p>用命令git show &lt; tagname &gt;可以看到说明文字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 26 07:28:11 2013 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure>
<p>还可以通过-s用私钥签名一个标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-s</span> v0.2 -m <span class="string">"signed version 0.2 released"</span> fec145a</span><br></pre></td></tr></table></figure></p>
<p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: signing failed: secret key not available</span><br><span class="line">error: gpg failed to sign the data</span><br><span class="line">error: unable to sign the tag</span><br></pre></td></tr></table></figure></p>
<p>如果报错，请参考GnuPG帮助文档配置Key，用命令git show &lt; tagname &gt;可以看到PGP签名信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.2</span><br><span class="line">tag v0.2</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 26 07:28:33 2013 +0800</span><br><span class="line"></span><br><span class="line">signed version 0.2 released</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1.4.12 (Darwin)</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">commit fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 10:37:30 2013 +0800</span><br><span class="line"></span><br><span class="line">    branch <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令git tag &lt; name &gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li>git tag -a &lt; tagname &gt; -m “blablabla…”可以指定标签信息；</li>
<li>git tag -s &lt; tagname &gt; -m “blablabla…”可以用PGP签名标签；</li>
<li>命令git tag可以查看所有标签。</li>
</ul>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-d</span> v0.1</span><br><span class="line">Deleted tag <span class="string">'v0.1'</span> (was e078af9)</span><br></pre></td></tr></table></figure></p>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。<br>如果要推送某个标签到远程，使用命令git push origin &lt; tagname &gt;：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure></p>
<p>或者，一次性推送全部尚未推送到远程的本地标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 554 bytes, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.2 -&gt; v0.2</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-d</span> v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was 6224937)</span><br></pre></td></tr></table></figure></p>
<p>然后，从远程删除。删除命令也是push，但是格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></p>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令git push origin &lt; tagname &gt;可以推送一个本地标签；</li>
<li>命令git push origin –tags可以推送全部未推送过的本地标签；</li>
<li>命令git tag -d &lt; tagname&gt;可以删除一个本地标签；</li>
<li>命令git push origin :refs/tags/&lt; tagname &gt;(git push origin –delete tag v0.9  )?可以删除一个远程标签。</li>
</ul>
<h3 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure></p>
<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：<br><img src="images/gitclone.png" alt="git clone"><br>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull" target="_blank" rel="noopener">https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，我会视心情而定是否接受。</p>
<p><strong>小结</strong></p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h3 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h3><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。比如，让Git显示颜色，会让命令输出看起来更醒目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>这样，Git会适当地显示不同的颜色，比如git status命令：<br><img src="images/gitcolor.png" alt="git设置好颜色后"><br>文件名就会标上颜色,我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。</p>
<h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动3. 生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>举个例子：<br>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python:</span></span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure></p>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python:</span></span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"><span class="comment"># My configurations:</span></span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure></p>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use <span class="_">-f</span> <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure></p>
<p>如果你确实想添加该文件，可以用-f强制添加到Git：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="_">-f</span> App.class</span><br></pre></td></tr></table></figure>
<p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class    App.class</span><br></pre></td></tr></table></figure></p>
<p>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p><strong>小结</strong></p>
<ul>
<li>忽略某些文件时，需要编写.gitignore；</li>
<li>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</li>
</ul>
<h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。我们只需要敲一行命令，告诉Git，以后st就表示status：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure></p>
<p>好了，现在敲git st看看效果，当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure></p>
<p>以后提交就可以简写成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m <span class="string">"bala bala bala..."</span></span><br></pre></td></tr></table></figure></p>
<p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br></pre></td></tr></table></figure></p>
<p>当你敲入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure></p>
<p>实际上Git执行的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure></p>
<p>配置一个git last，让其显示最后一次提交信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last <span class="string">'log -1'</span></span><br></pre></td></tr></table></figure></p>
<p>这样，用git last就能显示最近一次的提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure>
<p>甚至还有人丧心病狂地把lg配置成了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure></p>
<p>来看看git lg的效果：<br><img src="images/gitcustom.png" alt="git 别名配置"><br>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p>
<p><strong>配置文件</strong></p>
<p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure></p>
<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure></p>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h4 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h4><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>第二步，创建一个git用户，用来运行git服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure></p>
<p>第三步，创建证书登录：<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure></p>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></p>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@server:/srv/sample.git</span><br><span class="line">Cloning into <span class="string">'sample'</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p>
<p>剩下的推送就简单了。</p>
<p><strong>管理公钥</strong></p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p>这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>
<p><strong>管理权限</strong></p>
<p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。</p>
<p>这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p>
<p><strong>小结</strong></p>
<ul>
<li>搭建Git服务器非常简单，通常10分钟即可完成；</li>
<li>要方便管理公钥，用Gitosis；</li>
<li>要像SVN那样变态地控制权限，用Gitolite。</li>
</ul>
<p>来源<br>教程：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/24/git命令和使用/" data-id="cjlc1dmvd005ja4s6nad7i8ic" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/">Tool</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bitmap压缩" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/Bitmap压缩/" class="article-date">
  <time datetime="2017-06-21T15:44:41.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/Bitmap压缩/">Bitmap压缩</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>&ensp;&ensp;要做图片压缩首先我们的了解bitmap占用内存的计算方式：<br>bitmap大小=图片长度X图片宽度X一个像素点占用的字节数<br>&ensp;&ensp;而像素点占用的字节数通过压缩格式来指定：</p>
<table>
<thead>
<tr>
<th style="text-align:center">来源</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">所占字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ALPHA_8</td>
<td style="text-align:center">表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ARGB_4444</td>
<td style="text-align:center">表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ARGB_8888</td>
<td style="text-align:center">表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">RGB_565</td>
<td style="text-align:center">表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节</td>
</tr>
</tbody>
</table>
<h3 id="压缩方法介绍"><a href="#压缩方法介绍" class="headerlink" title="压缩方法介绍"></a>压缩方法介绍</h3><p>&ensp;&ensp;下面我们开始介绍几种压缩方式：</p>
<ol>
<li>质量压缩<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> quality = Integer.valueOf(editText.getText().toString());</span><br><span class="line">            <span class="comment">//quality-压缩率：1~100的整数，越小压缩出的图片越小质量越差，100则不压缩。</span></span><br><span class="line">            bit.compress(CompressFormat.JPEG, quality, baos);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            bm = BitmapFactory.decodeByteArray(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight()</span><br><span class="line">                    + <span class="string">"bytes.length=  "</span> + (bytes.length / <span class="number">1024</span>) + <span class="string">"KB"</span></span><br><span class="line">                    + <span class="string">"quality="</span> + quality)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;其中quality是从edittext获取的数字或自己制定，可以从1–100改变，100表示百分百，也就是不压缩，原型输出，数字越小表示质量越差当然内存也就越小。<strong>注意</strong>bit.compress(CompressFormat.PNG, quality, baos);<em>设定png格式，quality就没有作用了，bytes.length不会变化，因为png图片是无损的?(待验证，网上资料都是通过减小这个值来减少内存)</em>，不能进行压缩，CompressFormat还有一个属性是，CompressFormat.WEBP格式，该格式是google自己推出来一个图片格式。</p>
<ol>
<li>采样率压缩<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果把options.inJustDecodeBounds 设置成true,表示只返回宽高。</span></span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options.inSampleSize = <span class="number">2</span>;</span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">"/DCIM/Camera/test.jpg"</span>, options);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;设置inSampleSize的值(int类型)后，假如设为2，则宽和高都为原来的1/2，宽高都减少了，自然内存也降低了。上面的代码没用过options.inJustDecodeBounds = true; 因为我是固定来取样的数据，为什么这个压缩方法叫采样率压缩，是因为配合inJustDecodeBounds，先获取图片的宽、高【这个过程就是取样】，然后通过获取的宽高，动态的设置inSampleSize的值，当inJustDecodeBounds设置为true的时候，BitmapFactory通过decodeResource或者decodeFile解码图片时，将会返回空(null)的Bitmap对象，这样可以避免Bitmap的内存分配，但是它可以返回Bitmap的宽度、高度以及MimeType。</p>
<ol>
<li>缩放法压缩(martix)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">            matrix.setScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            bm = Bitmap.createBitmap(bit, <span class="number">0</span>, <span class="number">0</span>, bit.getWidth(),</span><br><span class="line">                    bit.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;通过scale的设定，bitmap的长度和宽度分别缩小了一半，图片大小缩小了四分之一。</p>
<ol>
<li>RGB_565法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options2 = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options2.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line"></span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">"/DCIM/Camera/test.jpg"</span>, options2);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;图片大小会直接缩小了一半，长度和宽度也没有变，相比argb_8888减少了一半的内存。</p>
<p><strong>注意</strong>：由于ARGB_4444的画质惨不忍睹，一般假如对图片没有透明度要求的话，可以改成RGB_565，相比ARGB_8888将节省一半的内存开销。</p>
<ol>
<li>createScaleBitmap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bm = Bitmap.createScaledBitmap(bit, <span class="number">150</span>, <span class="number">150</span>, <span class="keyword">true</span>);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span>) + <span class="string">"KB宽度为"</span></span><br><span class="line">                    + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;这里是将图片压缩成用户所期望的长度和宽度，但是这里要说，如果用户期望的长度和宽度和原图长度宽度相差太多的话，图片会很不清晰。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&ensp;&ensp;以上就是5种图片压缩的方法，需要强调的是他们的压缩仅仅只是对android中的bitmap来说的。如果将这些压缩后的bitmap另存为sd中，他们的内存大小并不一样。android手机中，图片的所占的内存大小和很多因素相关，计算起来也很麻烦。为了计算出一个图片的内存大小，可以将图片当做一个文件来间接计算，用如下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory()</span><br><span class="line">         .getAbsolutePath() + <span class="string">"/DCIM/Camera/test.jpg"</span>);</span><br><span class="line">         Log.i(<span class="string">"wechat"</span>, <span class="string">"file.length()="</span> + file.length() / <span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"fis.available()="</span> + fis.available() / <span class="number">1024</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;上面两个方法计算的结果是一样的。其实说白了，Bitmap压缩都是围绕公式：Bitmap所占用的内存 = 图片长度 x 图片宽度 x 一个像素点占用的字节数 ，3个参数，任意减少一个的值，就达到了压缩的效果。</p>
<p><strong>注意</strong> 当我们通过BitmapFactory来decode网络或者本地图片是需要提前计算出压缩出来的图片大小，如果不提前处理会出现OOM，举个栗子：从本地读取一个4M的图片到bitmap时，bitmap的内存占用可能是20M，而系统分配给app的内存最大空间可能为16M，结果就是OOM了，-^-。</p>
<p>来源：<a href="http://blog.csdn.net/harryweasley/article/details/51955467" target="_blank" rel="noopener">http://blog.csdn.net/harryweasley/article/details/51955467</a><br>参考：<br>Android Bitmap 优化(1) - 图片压缩 <a href="http://anany.me/2015/10/15/bitmap1/" target="_blank" rel="noopener">http://anany.me/2015/10/15/bitmap1/</a><br>多图比较谷歌WebP和JPEG图像格式<a href="http://www.win7china.com/html/8668.html" target="_blank" rel="noopener">http://www.win7china.com/html/8668.html</a><br>Android-使用Matrix对Bitmap进行处理<a href="http://blog.csdn.net/nupt123456789/article/details/24600055" target="_blank" rel="noopener">http://blog.csdn.net/nupt123456789/article/details/24600055</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/21/Bitmap压缩/" data-id="cjlc1dmt8000ba4s64f5rh9ek" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Options/">Options</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-download-manager使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/19/android-download-manager使用/" class="article-date">
  <time datetime="2017-06-19T14:51:02.000Z" itemprop="datePublished">2017-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/19/android-download-manager使用/">android_download_manager使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&ensp;&ensp;从Android 2.3（Api level 9）开始Android用系统服务的方式提供了Download Manager来优化处理长时间的下载操作。Download Manager处理<strong>HTTP/HTTPS</strong>连接并监控连接中的状态变化以及重启来确保每一个下载任务顺利完成。<br>&ensp;&ensp;在大多数涉及到下载的情况中使用Download Manager都是不错的选择，特别是当用户切换不同的应用以后下载需要在后台继续进行，以及当下载任务顺利完成非常重要的情况（DownloadManager对于断点续传功能支持很好）。<br>&ensp;&ensp;要想使用Download Manager，使用getSystemService方法请求系统的DOWNLOAD_SERVICE服务，代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String serviceString = Context.DOWNLOAD_SERVICE;  </span><br><span class="line">DownloadManager downloadManager;  </span><br><span class="line">downloadManager = (DownloadManager) getSystemService(serviceString);</span><br></pre></td></tr></table></figure></p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>&ensp;&ensp;需要一个请求下载操作，创建一个DownloadManager.Request对象，将要请求下载的文件的Uri传递给Download Manager的enqueue方法，代码片段如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"http://developer.android.com/shareables/icon_templates-v4.0.zip"</span>);  </span><br><span class="line">DownloadManager.Request request = <span class="keyword">new</span> Request(uri);  </span><br><span class="line"><span class="keyword">long</span> reference = downloadManager.enqueue(request);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;在这里返回的reference变量是系统为当前的下载请求分配的一个唯一的ID，我们可以通过这个ID重新获得这个下载任务，进行一些自己想要进行的操作或者查询下载的状态以及取消下载等等。</p>
<p>&ensp;&ensp;我们可以通过addRequestHeader方法为DownloadManager.Request对象request添加HTTP头，也可以通过setMimeType方法重写从服务器返回的mime type。</p>
<p>&ensp;&ensp;我们还可以指定在什么连接状态下执行下载操作。setAllowedNetworkTypes方法可以用来限定在WiFi还是手机网络下进行下载，setAllowedOverRoaming方法可以用来阻止手机在漫游状态下下载。</p>
<p>&ensp;&ensp;下面的代码片段用于指定一个较大的文件只能在WiFi下进行下载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setAllowedNetworkTypes(Request.NETWORK_WIFI);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Android API level 11 介绍了getRecommendedMaxBytesOverMobile类方法（静态方法），返回一个当前手机网络连接下的最大建议字节数，可以来判断下载是否应该限定在WiFi条件下。</p>
<p>&ensp;&ensp;调用enqueue方法之后，只要数据连接可用并且Download Manager可用，下载就会开始。</p>
<p>&ensp;&ensp;要在下载完成的时候获得一个系统通知（notification）,注册一个广播接受者来接收<strong>ACTION_DOWNLOAD_COMPLETE</strong>广播，这个广播会包含一个<br><strong>EXTRA_DOWNLOAD_ID</strong>信息在intent中包含了已经完成的这个下载的ID,代码片段如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);       </span><br><span class="line">BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (myDownloadReference == reference) &#123;  </span><br><span class="line">      <span class="comment">//do something </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;使用Download Manager的openDownloadedFile方法可以打开一个已经下载完成的文件，返回一个ParcelFileDescriptor对象。我们可以通过Download Manager来查询下载文件的保存地址，如果在下载时制定了路径和文件名，我们也可以直接操作文件。</p>
<p>&ensp;&ensp;我们可以为<strong>ACTION_NOTIFICATION_CLICKED</strong> action注册一个广播接受者，当用户从通知栏点击了一个下载项目或者从Downloads app点击可一个下载的项目的时候，系统就会发出一个点击下载项的广播。<br>代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(DownloadManager.ACTION_NOTIFICATION_CLICKED);    </span><br><span class="line">BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">    String extraID = DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS;  </span><br><span class="line">    <span class="keyword">long</span>[] references = intent.getLongArrayExtra(extraID);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> reference : references)  </span><br><span class="line">      <span class="keyword">if</span> (reference == myDownloadReference) &#123;  </span><br><span class="line">        <span class="comment">// Do something with downloading file.  </span></span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<h3 id="定制Download-Manager-Notifications的样式"><a href="#定制Download-Manager-Notifications的样式" class="headerlink" title="定制Download Manager Notifications的样式"></a>定制Download Manager Notifications的样式</h3><p>&ensp;&ensp;默认情况下，通知栏中会显示被Download Manager管理的每一个download每一个Notification会显示当前的下载进度和文件的名字。通过Download Manager可以为每一个download request定制Notification的样式，包括完全隐藏Notification。下面的代码片段显示了通过setTitle和setDescription方法来定制显示在文件下载Notification中显示的文字（下载的通知icon不可更改？）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setTitle(“Earthquakes”);  </span><br><span class="line">request.setDescription(“Earthquake XML”);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;request.setNotificationVisibility方法可以用来控制什么时候显示Notification，甚至隐藏该request的Notification。有以下几个参数：</p>
<ol>
<li>Request.VISIBILITY_VISIBLE：在下载进行的过程中，通知栏中会一直显示该下载的Notification，当下载完成时，该Notification会被移除，这是默认的参数值；</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED：在下载过程中通知栏会一直显示该下载的Notification，在下载完成后该Notification会继续显示，直到用户点击该Notification或者消除该Notification；</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION：只有在下载完成后该Notification才会被显示；</li>
<li>Request.VISIBILITY_HIDDEN：不显示该下载请求的Notification。如果要使用这个参数，需要在应用的清单文件中加上DOWNLOAD_WITHOUT_NOTIFICATION权限。</li>
</ol>
<h3 id="指定下载保存地址"><a href="#指定下载保存地址" class="headerlink" title="指定下载保存地址"></a>指定下载保存地址</h3><p>&ensp;&ensp;默认情况下，所有通过Download Manager下载的文件都保存在一个共享下载缓存中，使用系统生成的文件名每一个Request对象都可以制定一个下载保存的地址，通常情况下，所有的下载文件都应该保存在外部存储中，所以我们需要在应用清单文件中加上WRITE_EXTERNAL_STORAGE权限：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE”/&gt;</span><br></pre></td></tr></table></figure></p>
<p> 下面的代码片段是在外部存储中指定一个任意的保存位置的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationUri(Uri.fromFile(f));   <span class="comment">// f是一个File对象</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果下载的这个文件是你的应用所专用的，你可能会希望把这个文件放在你的应用在外部存储中的一个专有文件夹中。注意这个文件夹不提供访问控制，所以其他的应用也可以访问这个文件夹。在这种情况下，如果你的应用卸载了，那么在这个文件夹也会被删除。<br>&ensp;&ensp;下面的代码片段是指定存储文件的路径是应用在外部存储中的专用文件夹的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationInExternalFilesDir(<span class="keyword">this</span>,  </span><br><span class="line">  Environment.DIRECTORY_DOWNLOADS, “Bugdroid.png”);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果下载的文件希望被其他的应用共享，特别是那些你下载下来希望被Media Scanner扫描到的文件（比如音乐文件），那么你可以指定你的下载路径在外部存储的公共文件夹之下，下面的代码片段是将文件存放到外部存储中的公共音乐文件夹的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationInExternalPublicDir(Environment.DIRECTORY_MUSIC,  </span><br><span class="line">     <span class="string">"Android_Rock.mp3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;在默认的情况下，通过Download Manager下载的文件是不能被Media Scanner扫描到的，进而这些下载的文件（音乐、视频等）就不会在Gallery和Music Player这样的应用中看到。为了让下载的音乐文件可以被其他应用扫描到，我们需要调用Request对象的allowScaningByMediaScanner方法。如果我们希望下载的文件可以被系统的Downloads应用扫描到并管理，我们需要调用Request对象的setVisibleInDownloadsUi方法，传递参数true。</p>
<h3 id="取消或删除下载"><a href="#取消或删除下载" class="headerlink" title="取消或删除下载"></a>取消或删除下载</h3><p>&ensp;&ensp;Download Manager的remove方法可以用来取消一个准备进行的下载，中止一个正在进行的下载，或者删除一个已经完成的下载。remove方法接受若干个download 的ID作为参数，你可以设置一个或者几个你想要取消的下载的ID，如下代码段所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该方法返回成功取消的下载的个数，如果一个下载被取消了，所有相关联的文件，部分下载的文件和完全下载的文件都会被删除。 </p>
<h3 id="查询Download-Manager"><a href="#查询Download-Manager" class="headerlink" title="查询Download Manager"></a>查询Download Manager</h3><p>&ensp;&ensp;你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS<em><em>常量，可以指定正在<em>*进行、暂停、失败、完成</em></em>四种状态。Download Manager包含了一系列COLUMN</em><em>静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括<em>*状态，文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI</em></em>。</p>
<p>&ensp;&ensp;下面的代码段是通过注册监听下载完成事件的广播接受者来查询下载完成文件的本地文件名和URI的实现方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">long</span> reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -<span class="number">1</span>);  </span><br><span class="line">      <span class="keyword">if</span> (myDownloadReference == reference) &#123;  </span><br><span class="line">        Query myDownloadQuery = <span class="keyword">new</span> Query();  </span><br><span class="line">        myDownloadQuery.setFilterById(reference);  </span><br><span class="line">        Cursor myDownload = downloadManager.query(myDownloadQuery);  </span><br><span class="line">        <span class="keyword">if</span> (myDownload.moveToFirst()) &#123;</span><br><span class="line">        <span class="comment">//文件名称索引  </span></span><br><span class="line">          <span class="keyword">int</span> fileNameIdx =   </span><br><span class="line">     myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME);</span><br><span class="line">     <span class="comment">//下载文件存放地址uri索引</span></span><br><span class="line">          <span class="keyword">int</span> fileUriIdx =   </span><br><span class="line">myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI);  </span><br><span class="line"><span class="comment">//下载状态</span></span><br><span class="line">            <span class="keyword">int</span> status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));  </span><br><span class="line">             <span class="keyword">switch</span> (status) &#123;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_PAUSED:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_PAUSED"</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_PENDING:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_PENDING"</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_RUNNING:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_RUNNING"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_SUCCESSFUL:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_SUCCESSFUL"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_FAILED:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_FAILED"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                statusMsg = <span class="string">"未知状态"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">          String fileName = myDownload.getString(fileNameIdx);  </span><br><span class="line">          String fileUri = myDownload.getString(fileUriIdx);  </span><br><span class="line">          <span class="comment">// TODO Do something with the file.  </span></span><br><span class="line">          Log.d(TAG, fileName + <span class="string">" : "</span> + fileUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">        myDownload.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。</p>
<ol>
<li>对于STATUS<em>PAUSED状态的下载，可以通过DownloadManager.PAUSED</em>* 静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。</li>
<li>对于STATUS<em>FAILED状态的下载，我们可以通过DownloadManager.ERROR</em>*来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。<br>&ensp;&ensp;下面的代码是如何查询出当前所有的暂停的下载任务，提取出暂停的原因以及文件名称，下载标题以及当前进度的实现方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain the Download Manager Service.  </span></span><br><span class="line">String serviceString = Context.DOWNLOAD_SERVICE;  </span><br><span class="line">DownloadManager downloadManager;  </span><br><span class="line">downloadManager = (DownloadManager)getSystemService(serviceString);  </span><br><span class="line"><span class="comment">// Create a query for paused downloads.  </span></span><br><span class="line">Query pausedDownloadQuery = <span class="keyword">new</span> Query();  </span><br><span class="line">pausedDownloadQuery.setFilterByStatus(DownloadManager.STATUS_PAUSED);  </span><br><span class="line"><span class="comment">// Query the Download Manager for paused downloads.  </span></span><br><span class="line">Cursor pausedDownloads = downloadManager.query(pausedDownloadQuery);  </span><br><span class="line"><span class="comment">// Find the column indexes for the data we require.  </span></span><br><span class="line"><span class="keyword">int</span> reasonIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_REASON);  </span><br><span class="line"><span class="keyword">int</span> titleIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TITLE);  </span><br><span class="line"><span class="keyword">int</span> fileSizeIdx =   </span><br><span class="line"> pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES);      </span><br><span class="line"><span class="keyword">int</span> bytesDLIdx =   </span><br><span class="line">pausedDownloads.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR);  </span><br><span class="line"><span class="comment">// Iterate over the result Cursor.  </span></span><br><span class="line"><span class="keyword">while</span> (pausedDownloads.moveToNext()) &#123;  </span><br><span class="line">  <span class="comment">// Extract the data we require from the Cursor.  </span></span><br><span class="line">  String title = pausedDownloads.getString(titleIdx);  </span><br><span class="line">  <span class="keyword">int</span> fileSize = pausedDownloads.getInt(fileSizeIdx);  </span><br><span class="line">  <span class="keyword">int</span> bytesDL = pausedDownloads.getInt(bytesDLIdx);  </span><br><span class="line">  <span class="comment">// Translate the pause reason to friendly text.  </span></span><br><span class="line">  <span class="keyword">int</span> reason = pausedDownloads.getInt(reasonIdx);  </span><br><span class="line">  String reasonString = <span class="string">"Unknown"</span>;  </span><br><span class="line">  <span class="keyword">switch</span> (reason) &#123;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_QUEUED_FOR_WIFI :   </span><br><span class="line">      reasonString = <span class="string">"Waiting for WiFi"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_WAITING_FOR_NETWORK :   </span><br><span class="line">      reasonString = <span class="string">"Waiting for connectivity"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_WAITING_TO_RETRY :  </span><br><span class="line">      reasonString = <span class="string">"Waiting to retry"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">default</span> : <span class="keyword">break</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// Construct a status summary  </span></span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">  sb.append(title).append(<span class="string">"\n"</span>);  </span><br><span class="line">  sb.append(reasonString).append(<span class="string">"\n"</span>);  </span><br><span class="line">  sb.append(<span class="string">"Downloaded "</span>).append(bytesDL).append(<span class="string">" / "</span> ).append(fileSize);  </span><br><span class="line">  <span class="comment">// Display the status   </span></span><br><span class="line">  Log.d(<span class="string">"DOWNLOAD"</span>, sb.toString());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Close the result Cursor.  </span></span><br><span class="line">pausedDownloads.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DownloadManager原理"><a href="#DownloadManager原理" class="headerlink" title="DownloadManager原理"></a>DownloadManager原理</h3><p>&ensp;&ensp;通过介绍我们已经可以灵活的使用DownloadManaged为我们服务了，为了更好的使用这个工具，得先了解它的工作原理、工作流程。下面就是整个工作流程的时序图：<br><img src="/images/DownloadManager.png" alt="Download Manager时序图"><br>&ensp;&ensp;从上面的时序图我们可以大致了解整个流程。从添加请求，到最后开启下载线程进行文件的下载。为了更好的理解这个下载工具的思想，下面将从源码上对一些重要的函数进行分析。</p>
<p>&ensp;&ensp;一开始，调用DownloadManager的enqueue()法进行下载请求的添加，然后就会调用DownloadProvider的insert()方法进行数据库的数据的插入，insert()不单单是把数据插入到数据库，还会启动DownloadService这个服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(<span class="keyword">final</span> Uri uri, <span class="keyword">final</span> ContentValues values)</span> </span>&#123;  </span><br><span class="line">    checkInsertPermissions(values);  </span><br><span class="line">    SQLiteDatabase db = mOpenHelper.getWritableDatabase();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// note we disallow inserting into ALL_DOWNLOADS  </span></span><br><span class="line">       <span class="keyword">if</span> (pckg != <span class="keyword">null</span> &amp;&amp; (clazz != <span class="keyword">null</span> || isPublicApi)) &#123;  </span><br><span class="line">        <span class="keyword">int</span> uid = Binder.getCallingUid();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span> || mSystemFacade.userOwnsPackage(uid, pckg)) &#123;  </span><br><span class="line">                filteredValues.put(Downloads.COLUMN_NOTIFICATION_PACKAGE,  </span><br><span class="line">                        pckg);  </span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    filteredValues.put(Downloads.COLUMN_NOTIFICATION_CLASS,  </span><br><span class="line">                            clazz);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ex) &#123;  </span><br><span class="line">    <span class="comment">/* ignored for now */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    copyString(Downloads.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_COOKIE_DATA, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_USER_AGENT, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_REFERER, values, filteredValues);  </span><br><span class="line">    <span class="keyword">if</span> (getContext().checkCallingPermission(  </span><br><span class="line">            Downloads.PERMISSION_ACCESS_ADVANCED) == PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">        copyInteger(Downloads.COLUMN_OTHER_UID, values, filteredValues);  </span><br><span class="line">    &#125;  </span><br><span class="line">    filteredValues.put(Constants.UID, Binder.getCallingUid());  </span><br><span class="line">    <span class="keyword">if</span> (Binder.getCallingUid() == <span class="number">0</span>) &#123;  </span><br><span class="line">        copyInteger(Constants.UID, values, filteredValues);  </span><br><span class="line">    &#125;  </span><br><span class="line">    copyStringWithDefault(Downloads.COLUMN_TITLE, values, filteredValues,  </span><br><span class="line">            <span class="string">""</span>);  </span><br><span class="line">    copyStringWithDefault(Downloads.COLUMN_DESCRIPTION, values,  </span><br><span class="line">            filteredValues, <span class="string">""</span>);  </span><br><span class="line">    filteredValues.put(Downloads.COLUMN_TOTAL_BYTES, -<span class="number">1</span>);  </span><br><span class="line">    filteredValues.put(Downloads.COLUMN_CURRENT_BYTES, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    Context context = getContext();  </span><br><span class="line">    context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> rowID = db.insert(DB_TABLE, <span class="keyword">null</span>, filteredValues);  </span><br><span class="line">    <span class="keyword">if</span> (rowID == -<span class="number">1</span>) &#123;  </span><br><span class="line">        Log.d(Constants.TAG, <span class="string">"couldn't insert into downloads database"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    insertRequestHeaders(db, rowID, values);  </span><br><span class="line">    context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));  </span><br><span class="line">    notifyContentChanged(uri, match);  </span><br><span class="line">    <span class="keyword">return</span> ContentUris.withAppendedId(Downloads.CONTENT_URI, rowID);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到上面的代码很长，但是我们只需要关注一些核心的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rowID = db.insert(DB_TABLE, <span class="keyword">null</span>, filteredValues);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这行代码的作用主要是把下载的任务信息保存到数据库中，包括下载的URL、下载的控制状态、下载状态、总的文件大小、已下载的文件大小等默认的数据更新到数据库中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这行代码的作用就是启动DownloadService服务。</p>
<p>&ensp;&ensp;当我们启动DownloadService之后，DownloadService服务的onCreate()数就会被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">super</span>.onCreate();  </span><br><span class="line"><span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">    Log.v(Constants.TAG, <span class="string">"Service onCreate"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (mSystemFacade == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    mSystemFacade = <span class="keyword">new</span> RealSystemFacade(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mObserver = <span class="keyword">new</span> DownloadManagerContentObserver();  </span><br><span class="line">getContentResolver().registerContentObserver(  </span><br><span class="line">   Downloads.ALL_DOWNLOADS_CONTENT_URI, <span class="keyword">true</span>, mObserver);  </span><br><span class="line">  </span><br><span class="line">mNotifier = <span class="keyword">new</span> DownloadNotification(<span class="keyword">this</span>, mSystemFacade);  </span><br><span class="line">mSystemFacade.cancelAllNotifications();  </span><br><span class="line">  </span><br><span class="line">updateFromProvider();  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到，在onCreate()数中，会注册一个数据库变化监听器DownloadManagerContentObserver，就是说Downloads.ALL_DOWNLOADS_CONTENT_URI这个数据库的数据发生变化的时候，该监听器的监听函数onChange()会被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> selfChange)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">   Log.v(Constants.TAG,  </span><br><span class="line">      <span class="string">"Service ContentObserver received notification"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    updateFromProvider();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到onChange()函数会调用updateFromProvider()这个函数，从上面可以看到，onCreate()函数也会调到这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFromProvider</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </span><br><span class="line">    mPendingUpdate = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">if</span> (mUpdateThread == <span class="keyword">null</span>) &#123;  </span><br><span class="line">   mUpdateThread = <span class="keyword">new</span> UpdateThread();  </span><br><span class="line">   mSystemFacade.startThread(mUpdateThread);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到，updateFormProvider()函数其实就是会启动UpdateThread()这个线程。</p>
<p>&ensp;&ensp; 下面就进入到UpdateThread这个线程中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line">  </span><br><span class="line">    trimDatabase();  </span><br><span class="line">    removeSpuriousFiles();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">boolean</span> keepService = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="comment">// for each update from the database, remember which download is  </span></span><br><span class="line">    <span class="comment">// supposed to get restarted soonest in the future  </span></span><br><span class="line">    <span class="keyword">long</span> wakeUp = Long.MAX_VALUE;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">   <span class="keyword">synchronized</span> (DownloadService.<span class="keyword">this</span>) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (mUpdateThread != <span class="keyword">this</span>) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(  </span><br><span class="line">         <span class="string">"multiple UpdateThreads in DownloadService"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (!mPendingUpdate) &#123;  </span><br><span class="line">      mUpdateThread = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">if</span> (!keepService) &#123;  </span><br><span class="line">          stopSelf();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (wakeUp != Long.MAX_VALUE) &#123;  </span><br><span class="line">          scheduleAlarm(wakeUp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       mPendingUpdate = <span class="keyword">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">long</span> now = mSystemFacade.currentTimeMillis();  </span><br><span class="line">   keepService = <span class="keyword">false</span>;  </span><br><span class="line">   wakeUp = Long.MAX_VALUE;  </span><br><span class="line">   Set&lt;Long&gt; idsNoLongerInDatabase = <span class="keyword">new</span> HashSet&lt;Long&gt;(  </span><br><span class="line">      mDownloads.keySet());  </span><br><span class="line">  </span><br><span class="line">   Cursor cursor = getContentResolver().query(  </span><br><span class="line">      Downloads.ALL_DOWNLOADS_CONTENT_URI, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,  </span><br><span class="line">      <span class="keyword">null</span>);  </span><br><span class="line">   <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;  </span><br><span class="line">       <span class="keyword">continue</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">       DownloadInfo.Reader reader = <span class="keyword">new</span> DownloadInfo.Reader(  </span><br><span class="line">          getContentResolver(), cursor);  </span><br><span class="line">       <span class="keyword">int</span> idColumn = cursor.getColumnIndexOrThrow(Downloads._ID);  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">for</span> (cursor.moveToFirst(); !cursor.isAfterLast(); cursor  </span><br><span class="line">          .moveToNext()) &#123;  </span><br><span class="line">      <span class="keyword">long</span> id = cursor.getLong(idColumn);  </span><br><span class="line">      idsNoLongerInDatabase.remove(id);  </span><br><span class="line">      DownloadInfo info = mDownloads.get(id);  </span><br><span class="line">      <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;  </span><br><span class="line">          updateDownload(reader, info, now);  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          info = insertDownload(reader, now);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (info.hasCompletionNotification()) &#123;  </span><br><span class="line">          keepService = <span class="keyword">true</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">long</span> next = info.nextAction(now);  </span><br><span class="line">      <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;  </span><br><span class="line">          keepService = <span class="keyword">true</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next &gt; <span class="number">0</span> &amp;&amp; next &lt; wakeUp) &#123;  </span><br><span class="line">          wakeUp = next;  </span><br><span class="line">      &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">       cursor.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> (Long id : idsNoLongerInDatabase) &#123;  </span><br><span class="line">       deleteDownload(id);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// is there a need to start the DownloadService? yes, if there  </span></span><br><span class="line">   <span class="comment">// are rows to be deleted.  </span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> (DownloadInfo info : mDownloads.values()) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (info.mDeleted) &#123;  </span><br><span class="line">      keepService = <span class="keyword">true</span>;  </span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   mNotifier.updateNotification(mDownloads.values());  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// look for all rows with deleted flag set and delete the rows  </span></span><br><span class="line">   <span class="comment">// from the database  </span></span><br><span class="line">   <span class="comment">// permanently  </span></span><br><span class="line">   <span class="keyword">for</span> (DownloadInfo info : mDownloads.values()) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (info.mDeleted) &#123;  </span><br><span class="line">      Helpers.deleteFile(getContentResolver(), info.mId,  </span><br><span class="line">         info.mFileName, info.mMimeType);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到UpdateThread这个线程也是很长，我们大概分析一下它的作用。</p>
<p>&ensp;&ensp; 可以看到这里有一个for(;;)的死循环，它的作用是保证数据库中的下载任务都会被加载出来，然后启动所有的下载任务，同时会更新下载任务，包括更新下载任务的状态，删除一些下载任务。</p>
<p>&ensp;&ensp; 它会从数据库中取出所有的下载任务，然后根据id从mDownloads集合中找到对应的下载任务，如果没找到就会新建一个下载任务DownloadInfo。然后就会调用updateDown()和insertDown()，启动下载任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDownload</span><span class="params">(DownloadInfo.Reader reader, DownloadInfo info,  </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">int</span> oldVisibility = info.mVisibility;  </span><br><span class="line"><span class="keyword">int</span> oldStatus = info.mStatus;  </span><br><span class="line">  </span><br><span class="line">reader.updateFromDatabase(info);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> lostVisibility = oldVisibility == Downloads.VISIBILITY_VISIBLE_NOTIFY_COMPLETED  </span><br><span class="line">   &amp;&amp; info.mVisibility != Downloads.VISIBILITY_VISIBLE_NOTIFY_COMPLETED  </span><br><span class="line">   &amp;&amp; Downloads.isStatusCompleted(info.mStatus);  </span><br><span class="line"><span class="keyword">boolean</span> justCompleted = !Downloads.isStatusCompleted(oldStatus)  </span><br><span class="line">   &amp;&amp; Downloads.isStatusCompleted(info.mStatus);  </span><br><span class="line"><span class="keyword">if</span> (lostVisibility || justCompleted) &#123;  </span><br><span class="line">    mSystemFacade.cancelNotification(info.mId);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">info.startIfReady(now);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到该函数调用startIfReady()进行下载任务的启动。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startIfReady</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isReadyToStart(now)) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">        Log.v(Constants.TAG, <span class="string">"Service spawning thread to handle download "</span> + mId);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mHasActiveThread) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Multiple threads on same download"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mStatus != Downloads.STATUS_RUNNING) &#123;  </span><br><span class="line">        mStatus = Downloads.STATUS_RUNNING;  </span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();  </span><br><span class="line">        values.put(Downloads.COLUMN_STATUS, mStatus);  </span><br><span class="line">        mContext.getContentResolver().update(getAllDownloadsUri(), values, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    DownloadThread downloader = <span class="keyword">new</span> DownloadThread(mContext, mSystemFacade, <span class="keyword">this</span>);  </span><br><span class="line">    mHasActiveThread = <span class="keyword">true</span>;  </span><br><span class="line">    mSystemFacade.startThread(downloader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该函数是一个挺重要的函数，它会根据不同的情况判断下载任务是否需要启动。判断函数是isReadyToStart。这个函数十分关键，在我们要实现暂停下载，继续下载这个功能，都是在这里起作用的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReadyToStart</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mHasActiveThread) &#123;  </span><br><span class="line">        <span class="comment">// already running  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mControl == Downloads.CONTROL_PAUSED) &#123;  </span><br><span class="line">        <span class="comment">// the download is paused, so it's not going to start  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">switch</span> (mStatus) &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// status hasn't been initialized yet, this is a new download  </span></span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_PENDING: <span class="comment">// download is explicit marked as ready to start  </span></span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_RUNNING: <span class="comment">// download interrupted (process killed etc) while  </span></span><br><span class="line">                                            <span class="comment">// running, without a chance to update the database  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_WAITING_FOR_NETWORK:  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_QUEUED_FOR_WIFI:  </span><br><span class="line">            <span class="keyword">return</span> checkCanUseNetwork() == NETWORK_OK;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_WAITING_TO_RETRY:  </span><br><span class="line">            <span class="comment">// download was waiting for a delayed restart  </span></span><br><span class="line">            <span class="keyword">return</span> restartTime(now) &lt;= now;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到，当下载任务正在进行，或者下载任务状态为暂停状态，或者网络状态是否正常，这时会返回false，就是没有准备好，就不会启动下载任务。当返回true的时候，就会把当前下载任务的状态刷新为Downloads.STATUS_RUNNING,同时会启动DownloadThread下载线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line">  </span><br><span class="line">    State state = <span class="keyword">new</span> State(mInfo);  </span><br><span class="line">    PowerManager.WakeLock wakeLock = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">int</span> finalStatus = Downloads.STATUS_UNKNOWN_ERROR;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        PowerManager pm = (PowerManager) mContext  </span><br><span class="line">                .getSystemService(Context.POWER_SERVICE);  </span><br><span class="line">        wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,  </span><br><span class="line">                Constants.TAG);  </span><br><span class="line">        wakeLock.acquire();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"initiating download for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;  </span><br><span class="line">            Log.i(Constants.TAG, <span class="string">"Initiating request for download "</span>  </span><br><span class="line">                    + mInfo.mId);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">            Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder();  </span><br><span class="line">            InnerState innerState = <span class="keyword">new</span> InnerState();  </span><br><span class="line">            setupDestinationFile(state, innerState);  </span><br><span class="line">            addRequestHeaders(innerState, requestBuilder);  </span><br><span class="line">            requestBuilder.url(state.mRequestUri);  </span><br><span class="line">  </span><br><span class="line">            Request request = requestBuilder.build();  </span><br><span class="line">            Call call = mOkHttpClient.newCall(request);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                executeDownload(innerState, state, call);  </span><br><span class="line">                finished = <span class="keyword">true</span>;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RetryDownload exc) &#123;  </span><br><span class="line">                <span class="comment">// fall through  </span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                call.cancel();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"download completed for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">        finalizeDestinationFile(state);  </span><br><span class="line">        finalStatus = Downloads.STATUS_SUCCESS;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (StopRequest error) &#123;  </span><br><span class="line">        <span class="comment">// remove the cause before printing, in case it contains PII  </span></span><br><span class="line">        Log.w(Constants.TAG, <span class="string">"Aborting request for download "</span> + mInfo.mId  </span><br><span class="line">                + <span class="string">": "</span> + error.getMessage());  </span><br><span class="line">        finalStatus = error.mFinalStatus;  </span><br><span class="line">        <span class="comment">// fall through to finally block  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">// sometimes the socket code throws unchecked  </span></span><br><span class="line">        <span class="comment">// exceptions  </span></span><br><span class="line">        Log.w(Constants.TAG, <span class="string">"Exception for id "</span> + mInfo.mId + <span class="string">": "</span> + ex);  </span><br><span class="line">        finalStatus = Downloads.STATUS_UNKNOWN_ERROR;  </span><br><span class="line">        <span class="comment">// falls through to the code that reports an error  </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (wakeLock != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            wakeLock.release();  </span><br><span class="line">            wakeLock = <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (mOkHttpClient != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mOkHttpClient.cancel(<span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        cleanupDestination(state, finalStatus);  </span><br><span class="line">        notifyDownloadCompleted(finalStatus, state.mCountRetry,  </span><br><span class="line">                state.mRetryAfter, state.mGotData, state.mFilename,  </span><br><span class="line">                state.mNewUri, state.mMimeType);  </span><br><span class="line">        mInfo.mHasActiveThread = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setupDestinationFile(state, innerState);</span><br></pre></td></tr></table></figure></p>
<p>这个方法是实现断点续传的关键点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDestinationFile</span><span class="params">(State state, InnerState innerState)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(state.mFilename)) &#123; <span class="comment">// only true if we've already  </span></span><br><span class="line">        <span class="comment">// run a thread for this  </span></span><br><span class="line">        <span class="comment">// download  </span></span><br><span class="line">        <span class="keyword">if</span> (!Helpers.isFilenameValid(state.mFilename)) &#123;  </span><br><span class="line">            <span class="comment">// this should never happen  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_FILE_ERROR,  </span><br><span class="line">                    <span class="string">"found invalid internal destination filename"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// We're resuming a download that got interrupted  </span></span><br><span class="line">        File f = <span class="keyword">new</span> File(state.mFilename);  </span><br><span class="line">        <span class="keyword">if</span> (f.exists()) &#123;  </span><br><span class="line">            <span class="keyword">long</span> fileLength = f.length();  </span><br><span class="line">            <span class="keyword">if</span> (fileLength == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// The download hadn't actually started, we can restart from  </span></span><br><span class="line">                <span class="comment">// scratch  </span></span><br><span class="line">                f.delete();  </span><br><span class="line">                state.mFilename = <span class="keyword">null</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInfo.mETag == <span class="keyword">null</span> &amp;&amp; !mInfo.mNoIntegrity) &#123;  </span><br><span class="line">                <span class="comment">// This should've been caught upon failure  </span></span><br><span class="line">                f.delete();  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_CANNOT_RESUME,  </span><br><span class="line">                        <span class="string">"Trying to resume a download that can't be resumed"</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// All right, we'll be able to resume this download  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    state.mStream = <span class="keyword">new</span> FileOutputStream(state.mFilename,  </span><br><span class="line">                            <span class="keyword">true</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException exc) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_FILE_ERROR,  </span><br><span class="line">                            <span class="string">"while opening destination for resuming: "</span>  </span><br><span class="line">                                    + exc.toString(), exc);  </span><br><span class="line">                &#125;  </span><br><span class="line">                innerState.mBytesSoFar = (<span class="keyword">int</span>) fileLength;  </span><br><span class="line">                <span class="keyword">if</span> (mInfo.mTotalBytes != -<span class="number">1</span>) &#123;  </span><br><span class="line">                    innerState.mHeaderContentLength = Long  </span><br><span class="line">                            .toString(mInfo.mTotalBytes);  </span><br><span class="line">                &#125;  </span><br><span class="line">                innerState.mHeaderETag = mInfo.mETag;  </span><br><span class="line">                innerState.mContinuingDownload = <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (state.mStream != <span class="keyword">null</span>  </span><br><span class="line">            &amp;&amp; mInfo.mDestination == Downloads.DESTINATION_EXTERNAL) &#123;  </span><br><span class="line">        closeDestination(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 方法的流程大概是：先根据文件名建立一个文件对象，判断文件对象是否存在，如果存在再判断文件的大小，当文件大小为0的时候，把文件删除。同时，会把当前的文件的输出流保存到state.mStream，把当前文件的长度、要下载文件的总长度、文件继续下载状态保存到innerState中。<br>&ensp;&ensp; 再分析addRequestHeader（）方法，该方法也是实现断点续传的关键。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRequestHeaders</span><span class="params">(InnerState innerState, Request.Builder requestBuilder)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (Pair&lt;String, String&gt; header : mInfo.getHeaders()) &#123;  </span><br><span class="line">        requestBuilder.addHeader(header.first, header.second);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (innerState.mContinuingDownload) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (innerState.mHeaderETag != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            requestBuilder.addHeader(<span class="string">"If-Match"</span>, mInfo.mETag);  </span><br><span class="line">        &#125;  </span><br><span class="line">        requestBuilder.addHeader(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + innerState.mBytesSoFar + <span class="string">"-"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该方法会把请求头添加到请求中，最重要的是：如果是断点续传的话，会把当前的文件大小也放到请求头中，这样服务器就会知道当前的文件已经下载了多少。</p>
<p>&ensp;&ensp; 下面来分析最重要的executeDownload方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeDownload</span><span class="params">(InnerState innerState, State state, Call call)</span> <span class="keyword">throws</span> StopRequest, RetryDownload, IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[Constants.BUFFER_SIZE];  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// check just before sending the request to avoid using an invalid  </span></span><br><span class="line">    <span class="comment">// connection at all  </span></span><br><span class="line">    checkConnectivity(state);  </span><br><span class="line">  </span><br><span class="line">    Response response = call.execute();  </span><br><span class="line">    handleExceptionalStatus(state, innerState, response);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">        Log.v(Constants.TAG, <span class="string">"received response for "</span> + mInfo.mUri);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    processResponseHeaders(state, innerState, response);  </span><br><span class="line">    InputStream entityStream = openResponseEntity(state, response);  </span><br><span class="line">    transferData(state, innerState, data, entityStream);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到这个下载工具用到okhttp这个开源库进行网络的请求。使用okhttp得到了Response对象。</p>
<ul>
<li>先分析processResponseHeaders（）这个方法，这个方法中会获取Http请求的header，同时，根据这次下载是否为断点下载，如果是则返回，如果不是，则会把要下载的文件的输入流对象保存到state.mStream变量中。</li>
<li>再分析openResponseEntity()这个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">openResponseEntity</span><span class="params">(State state, Response response)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> response.body().byteStream();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">        logNetworkState();  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(getFinalStatusForHttpError(state),  </span><br><span class="line">                <span class="string">"while getting entity: "</span> + ex.toString(), ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp; 该方法是获取Response对象的输出流变量,最后是transferData（）方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(State state, InnerState innerState, <span class="keyword">byte</span>[] data,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          InputStream entityStream)</span> <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;  </span><br><span class="line">        <span class="keyword">int</span> bytesRead = readFromResponse(state, innerState, data,  </span><br><span class="line">                entityStream);  </span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123; <span class="comment">// success, end of stream already reached  </span></span><br><span class="line">            handleEndOfStream(state, innerState);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        state.mGotData = <span class="keyword">true</span>;  </span><br><span class="line">        writeDataToDestination(state, data, bytesRead);  </span><br><span class="line">        innerState.mBytesSoFar += bytesRead;  </span><br><span class="line">        reportProgress(state, innerState);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"downloaded "</span> + innerState.mBytesSoFar  </span><br><span class="line">                    + <span class="string">" for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        checkPausedOrCanceled(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到，这是一个for(;;)死循环，用于读取下载的文件流。</p>
<ul>
<li>先调用readFromResponse()函数，从文件输出流中读取数据，保存到data字节数组中。</li>
<li>然后调用writeDataToDestination()数，把data字节数组中的数据写到本地的文件中。</li>
<li>然后调用reportProgress()数，把已下载的文件的大小更新到数据库中。用于更新进度条的显示。</li>
</ul>
<p>&ensp;&ensp; 可以看到checkPauseOrCanceled()数。这是实现暂停下载的关键函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPausedOrCanceled</span><span class="params">(State state)</span> <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (mInfo) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mInfo.mControl == Downloads.CONTROL_PAUSED) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_PAUSED_BY_APP,  </span><br><span class="line">                    <span class="string">"download paused by owner"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mInfo.mStatus == Downloads.STATUS_CANCELED) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_CANCELED,  </span><br><span class="line">                <span class="string">"download canceled"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以分析，这里会根据下载任务的当前状态进行判断，如果当前的任务状态被更改为Downloads.CONTROL_PAUSED时，就会抛出StopRequest的异常，当前的文件下载就会被终止，这样就可以实现暂停下载了。</p>
<p> 到此为止，DownloadManager下载的整个流程就分析完了。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>&ensp;&ensp;通过上面的分析，我们几乎理解了DownloadManager的整个工作流程。在我们下载文件的时候，我们几乎都是需要暂停下载和继续下载还有断点续传的功能。DownloadProvider代码是可以让我们能够实现这个功能了。</p>
<p>&ensp;&ensp;实现断点续传的原理其实就是我们每次添加下载任务，都会把任务的信息保存到数据库中，包括下载的URL，已下载的文件大小，总的文件大小。下次我们再进行下载的时候，把已下载的大小传到服务器中，就可以从上一次已下载的文件的基础上继续下载，就可以实现断点下载了。</p>
<p>&ensp;&ensp;暂停下载和继续下载的实现，其实只需要更新下载任务的状态就可以实现了。因为从上面的下载可以知道，在下载文件的过程中，都会检验当前的下载任务的状态，若是暂停状态，就会停止下载，跳出死循环。当我们再次改变状态为继续下载时，下载任务会被再次启动。</p>
<p>来源：<br><a href="http://blog.csdn.net/carrey1989/article/details/8060155" target="_blank" rel="noopener">http://blog.csdn.net/carrey1989/article/details/8060155</a><br><a href="http://blog.csdn.net/garment1991/article/details/54178557" target="_blank" rel="noopener">http://blog.csdn.net/garment1991/article/details/54178557</a><br><a href="http://www.trinea.cn/android/android-downloadmanager-pro/" target="_blank" rel="noopener">http://www.trinea.cn/android/android-downloadmanager-pro/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/19/android-download-manager使用/" data-id="cjlc1dmth000wa4s6ghm17hq2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rxjava2基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/03/rxjava2基础/" class="article-date">
  <time datetime="2017-06-03T00:21:13.000Z" itemprop="datePublished">2017-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/03/rxjava2基础/">rxjava2基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="RxJava2基础"><a href="#RxJava2基础" class="headerlink" title="RxJava2基础"></a>RxJava2基础</h3><p>&ensp;&ensp;RxJava核心思想是观察者模式和响应式编程，因此其核心的东西主要有两个：Observable（被观察者） 和 Observer（观察者），Observable可以发出一系列的 事件（例如网络请求、复杂计算、数据库操作、文件读取等），事件执行结束后交给Observer的回调处理。</p>
<ol>
<li>RxJava2 的观察者模式</li>
</ol>
<p>&ensp;&ensp;观察者模式是对象的行为模式，也叫做发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p>
<ol>
<li>RxJava2 响应式编程结构</li>
</ol>
<p>&ensp;&ensp;什么是响应式编程？举个栗子，a = b + c; 这句代码将b+c的值赋给a，而之后如果b和c的值改变了不会影响到a，然而，对于响应式编程，之后b和c的值的改变也动态影响着a，意味着a会随着b和c的变化而变化。<br>响应式编程的组成为Observable/Operator/Subscriber，RxJava在响应式编程中的基本流程如下：</p>
<ul>
<li>Observable发出一系列事件，他是事件的产生者；</li>
<li>Subscriber负责处理事件，他是事件的消费者；</li>
<li>Operator是对Observable发出的事件进行修改和变换；</li>
<li>若事件从产生到消费不需要其他处理，则可以省略掉中间的Operator，从而流程变为Obsevable -&gt; Subscriber；</li>
<li>Subscriber通常在主线程执行，所以原则上不要去处理太多的事务，而这些复杂的处理则交给Operator；</li>
</ul>
<p>&ensp;&ensp;这个流程，可以简单的理解为：Observable -&gt; Operator1 -&gt; …….-&gt; OperatorN -&gt; Subscriber。</p>
<ol>
<li>背压 </li>
</ol>
<p>&ensp;&ensp;背压简单理解即生产者的生产速度大于消费者的消费速度带来的问题，这个并非新概念，只是在RxJava2中新增了新的实现者Flowable及其子类：</p>
<h3 id="初步体验"><a href="#初步体验" class="headerlink" title="初步体验"></a>初步体验</h3><p>&ensp;&ensp;使用前需要添加相应的依赖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.reactivex.rxjava2:rxjava:2.0.7'</span></span><br><span class="line">compile <span class="string">'org.reactivestreams:reactive-streams:1.0.0'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：不同的版本在使用上可能略微有差异。</p>
<p>RxJava2的使用主要有三个步骤：</p>
<ol>
<li>创建一个Observable</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察者</span></span><br><span class="line">        Observable&lt;Integer&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="number">1</span>);</span><br><span class="line">                e.onNext(<span class="number">2</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个Observer</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者，观察者中onError和onComplete两个方法是互斥的，只有其中一个会执行。</span></span><br><span class="line">        Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">//该实例用于解除订阅关系</span></span><br><span class="line">            <span class="keyword">private</span> Disposable disposable;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"subscribe"</span>);</span><br><span class="line">                disposable = d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"next"</span> + value);</span><br><span class="line">                <span class="keyword">if</span> (value &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// &gt;3 时为异常数据，解除订阅</span></span><br><span class="line">                    disposable.dispose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>建立订阅关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;通过以上可以看出，首先，创建Observable时，回调的是ObservableEmitter，字面意思即发射器，用于发射数据（onNext）和通知（onError/onComplete）；其次，创建的Observer中多了一个回调方法onSubscrible，传递参数为Disposable，Disposable用于解除订阅关系。</p>
<h3 id="包解析和类说明"><a href="#包解析和类说明" class="headerlink" title="包解析和类说明"></a>包解析和类说明</h3><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>&ensp;&ensp;目前只解析标准包中的操作符。对于扩展包，待查阅相应资料再补上。</p>
<h4 id="创建操作符：用于创建Observable"><a href="#创建操作符：用于创建Observable" class="headerlink" title="创建操作符：用于创建Observable"></a>创建操作符：用于创建Observable</h4><ol>
<li><p>create：使用OnSubscribe从头创建一个Observable。需要注意的是，使用该方法创建时，建议在ObservableOnSubscribe#subscribe方法中检查订阅状态，以便及时停止发射数据或者运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String &gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>from*： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String &gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        Observable.fromArray(list).subscribe(<span class="keyword">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Observable.fromFuture(future).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Observable.just(strings).subscribe(<span class="keyword">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>empty： 创建一个什么都不做直接通知完成的Observable。</p>
</li>
<li>error： 创建一个什么都不做直接通知错误的Observable。</li>
<li><p>never： 创建一个什么都不做的Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty();  <span class="comment">//直接调用onCompleted。</span></span><br><span class="line">Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"adb"</span>));<span class="comment">//直接调用onError。这里可以自定义异常</span></span><br><span class="line">Observable.never();<span class="comment">//啥都不做</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">1000</span>, TimeUnit.MILLISECONDS).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>interval：创建一个按照给定时间间隔发射从0开始的整数序列的Observable，内部通过ObservableInterval工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">2</span>,TimeUnit.MILLISECONDS).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>range：创建一个发射指定范围的整数序列的Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">3</span>,<span class="number">9</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>defer：只有当订阅者订阅才创建Observable，为每个订阅者创建一个新的Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.defer(<span class="keyword">new</span> Callable&lt;ObservableSource&lt;String &gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;String &gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><p>&ensp;&ensp;用户组合多个Observable。<br><strong>注意</strong> 为了使结构更加清晰以及缩小代码量，之后例子都使用Lamdda表达式。</p>
<ol>
<li><p>concat：按顺序链接多个Observable，需要注意的是Observable。concat(a,b)等价与a.concatWith(b)，内部调用的是concatArray。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1=Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        Observable&lt;Integer&gt; observable2=Observable.just(<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        Observable.concat(observable1,observable2).subscribe(item -&gt; System.out.println(item));</span><br><span class="line">        observable1.concatWith(observable2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>startWith：在数据序列的开头增加一个数据项，其内部也是调用concatArray。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .startWith(<span class="number">1</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.print(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>merge：将多个Observable合并为一个，不同于concat，merge不是按照添加顺序链接，而是按照时间线来链接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。<br><img src="./merge.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String &gt; observable1=Observable.just(<span class="string">"4"</span>,<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">        Observable&lt;String &gt; observable2=Observable.just(<span class="string">"4"</span>,<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">        Observable.merge(observable1,observable2).subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>zip：使用一个函数组合多个Observab发射的数据集合，然后发射这个结果。然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String &gt; observable1=Observable.just(<span class="string">"4"</span>,<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">        Observable&lt;String &gt; observable2=Observable.just(<span class="string">"4"</span>,<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">        Observable.zip(observable1, observable2, <span class="keyword">new</span> BiFunction&lt;String, String, String &gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s, String s2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s+<span class="string">" and "</span>+s2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="./zip.png" alt="Alt text"></p>
<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><ol>
<li><p>filter：过滤数据，内部通过ObservableFilter所虑数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">                .filter(integer -&gt; integer &gt; <span class="number">3</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>ofType：过滤制定的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"aad"</span>)</span><br><span class="line">                .ofType(Integer.class)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>take：只发射开始的N想数据或者一定时间内的数据，内部通过ObservableTake和ObservableTakeUntil过滤数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"aad"</span>)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .take(<span class="number">100</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>takeLast：只发射最后的N项数据或者一定时间内的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">               .takeLast(<span class="number">2</span>)</span><br><span class="line">               .take(<span class="number">100</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>last/lastOrError：只发射最后一项数据。</p>
</li>
<li>first/firstOrError：只发射第一项数据。</li>
<li>skip：跳过开始的N项数据或者一定时间内的数据。</li>
<li>skiplast：跳过最后的N想数据或者一定时间内的数据。</li>
<li>elementAt/elementAtOrError：发射某项数据，如果超过了范围可以指定默认值。</li>
<li>ignoreElements：丢弃所有数据，只发射错误或者正确终止的通知。</li>
<li>distinct：过滤重复数据。</li>
<li>distinctUntilChanged：过滤掉连续重复的数据。</li>
<li>throttleFirst：定期发射Observable发射的第一项数据。</li>
<li>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时才进行发射。</li>
<li>sample/throttleLast：定期发射Observable最近的数据。</li>
<li>timeout：如果原始Observable过了指定的一段时长没有发射数据，就发射一个异常或者使用备用的Observable。</li>
</ol>
<h4 id="条件或者布尔操作"><a href="#条件或者布尔操作" class="headerlink" title="条件或者布尔操作"></a>条件或者布尔操作</h4><ol>
<li><p>all ：判断<strong>所有</strong>的数据项是否满足某个条件，内部通过ObservableAllSingle实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">                .all(integer -&gt; integer&gt;<span class="number">3</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));<span class="comment">//得到boolean值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>contains：判断在发射的所有数据项中是否包含指定的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">                .contains(<span class="number">3</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到boolean值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sequenceEqual：用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable1 = Observable.just(<span class="string">"4"</span>, <span class="string">"3"</span>, <span class="string">"1"</span>);</span><br><span class="line">        Observable&lt;String&gt; observable2 = Observable.just(<span class="string">"4"</span>, <span class="string">"3"</span>, <span class="string">"1"</span>);</span><br><span class="line">        Observable.sequenceEqual(observable1,observable2)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到boolean值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isEmpty：用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">                .isEmpty()</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));  <span class="comment">//得到boolean值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>amb：给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他的Observable将会被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ambArray：给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他的Observable将会被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.just(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">       Observable&lt;Integer&gt; observable2 = Observable.just(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">       Observable.ambArray(observable1,observable2)</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>switchIfEmpty：如果原始Observable正常终止后仍然没有发射任何的数据，就使用备用的Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">                .switchIfEmpty(Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultIfEmpty：如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">               .defaultIfEmpty(Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>takeUtil：当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .takeUntil(integer -&gt; integer==<span class="number">4</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到2，3，4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>takeWhile：当发射的数据满足某个条件时（不包含该数据），Observab终止发射数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">               .takeWhile(integer -&gt; integer==<span class="number">4</span>)</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipUntil：丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</p>
</li>
<li>skipWhile：丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）。</li>
</ol>
<h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><ol>
<li><p>reduce/reduceInto：对序列使用reduce()函数并发射最终的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">               .reduce((integer, integer2) -&gt; integer+integer2)</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));  <span class="comment">//得到14</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>collect：使用collect收集数据到一个可变的数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">               .collect((Callable&lt;List&lt;Integer&gt;&gt;) () -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">                       (s, integer) -&gt; s.add(integer))</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));  <span class="comment">//得到列表[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>count：计算发射的数量。</p>
</li>
</ol>
<h4 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h4><ol>
<li><p>toList：收集原始Observable发射的所有数据到一个列表，然后返回列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .toList()</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到列表[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>toSortedList：收集原始Observable发射的所有数据到一个有序的列表，然后返回这个列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">                .toSortedList((o1, o2) -&gt; o1-o2)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>toMap：将序列数据转换为一个Map，可以根据数据项生成key和生成value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//根据数据项生成map的key，//根据数据项生成map的kvalue</span></span><br><span class="line">                .toMap(integer -&gt; integer+<span class="string">"-"</span>, integer -&gt; integer+<span class="string">"+"</span>)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到&#123;8-=8+, 6-=6+, 5-=5+, 3-=3+&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>toMultiMap：类似toMap，不同的地方在于map的value是一个集合。</p>
</li>
</ol>
<h4 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h4><ol>
<li><p>map：对Observable发射的每一项数据都应用一个函数来变换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">                .map(integer -&gt; <span class="string">"item"</span>+integer)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到item8，item3，item6，item5</span></span><br><span class="line">``` </span><br><span class="line"><span class="number">2</span>. cast：在发射之前将Observable发射的所有数据转换为指定类型。</span><br><span class="line"><span class="number">3</span>. flatMap：将Observable发射的数据变换为Observable集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</span><br><span class="line">```java</span><br><span class="line">Observable.just(<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">                .flatMap((Function&lt;Integer, ObservableSource&lt;?&gt;&gt;) integer -&gt; Observable.create((ObservableOnSubscribe&lt;String&gt;) observableEmitter -&gt; &#123;</span><br><span class="line">                    observableEmitter.onNext(integer+<span class="string">""</span>);</span><br><span class="line">                    observableEmitter.onComplete();</span><br><span class="line">                &#125;))</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到8，3，6，5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flatMapIterable：和flatMap的作用一样，只不过生产的是Iterable而不是Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.just(<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">                .flatMapIterable(integer -&gt; Arrays.asList(<span class="string">"item"</span>+integer))</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>concatMap：类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</p>
</li>
<li><p>SwitchMap：和flatMap很像，将Observable发射的数据变换为Observable集合，将原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.create((ObservableOnSubscribe&lt;Integer&gt;) observableEmitter -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">                observableEmitter.onNext(i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            observableEmitter.onComplete();</span><br><span class="line">        &#125;)</span><br><span class="line">                .switchMap((Function&lt;Integer, ObservableSource&lt;?&gt;&gt;) integer -&gt; Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        observableEmitter.onNext(integer*<span class="number">10</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        observableEmitter.onComplete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;))</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));  <span class="comment">//得到 0 10 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>scan：与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序一次发射每个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">            .scan((integer, integer2) -&gt; integer+integer2)</span><br><span class="line">            .subscribe(integer -&gt; System.out.println(integer));  <span class="comment">//得到 2 5 9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>groupBy：将Observab分拆为Observable集合，将原始Observable发射的数据按key分组，每一个Observable发射一组不同的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">            .groupBy(integer -&gt; integer%<span class="number">2</span>==<span class="number">0</span>?<span class="string">"偶数"</span>:<span class="string">"奇数"</span>)</span><br><span class="line">            .subscribe(stringIntegerGroupedObservable -&gt; stringIntegerGroupedObservable.subscribe(integer -&gt;</span><br><span class="line">                    System.out.println(stringIntegerGroupedObservable.getKey()+<span class="string">":"</span>+integer)));<span class="comment">//得到</span></span><br><span class="line"><span class="comment">//偶数:2</span></span><br><span class="line"><span class="comment">//奇数:3</span></span><br><span class="line"><span class="comment">//偶数:4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>buffer：定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">            .buffer(<span class="number">2</span>)</span><br><span class="line">            .subscribe(integers -&gt; System.out.println(integers)); <span class="comment">//得到 [2, 3]  [4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>window：定期将来自Observable的数据分拆成一些Observable窗口，饭后发射这些窗口数据，而不是每次发射一项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">           .window(<span class="number">2</span>)</span><br><span class="line">           .subscribe(integerObservable -&gt; integerObservable.subscribe(integer -&gt; System.out.println(integer)));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="错误处理-重试机制"><a href="#错误处理-重试机制" class="headerlink" title="错误处理/重试机制"></a>错误处理/重试机制</h4><ol>
<li><p>onErrorResumeNext：当原始Observable在遇到错误时，使用备用的Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="string">"3"</span>,<span class="number">4</span>)</span><br><span class="line">            .cast(Integer.class)</span><br><span class="line">            .onErrorResumeNext(Observable.just(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line">            .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到 2，5，6，7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>onErrorReturn：当原始Observable在遇到错误时发射一个特定的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="string">"3"</span>,<span class="number">4</span>)</span><br><span class="line">            .cast(Integer.class)</span><br><span class="line">            .onErrorReturn(throwable -&gt; <span class="number">0</span>)</span><br><span class="line">            .subscribe(integer -&gt; System.out.println(integer)); <span class="comment">//得到2，0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>retry：当原始Observable在遇到错误时进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="string">"3"</span>,<span class="number">4</span>)</span><br><span class="line">            .cast(Integer.class)</span><br><span class="line">            .retry(<span class="number">3</span>)</span><br><span class="line">            .subscribe(integer -&gt; System.out.println(integer),throwable -&gt;System.out.println(<span class="string">"error"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>retryWhen：当原始Observable在遇到错误时，将错误传递给另一个Observable类决定是否要重新订阅这个Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>,<span class="string">"3"</span>,<span class="number">4</span>)</span><br><span class="line">            .cast(Integer.class)</span><br><span class="line">            .retryWhen(throwableObservable -&gt; throwableObservable.retry(<span class="number">1</span>))</span><br><span class="line">            .subscribe(integer -&gt; System.out.println(integer),throwable -&gt;System.out.println(<span class="string">"error"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="链接操作"><a href="#链接操作" class="headerlink" title="链接操作"></a>链接操作</h4><p>&ensp;&ensp;ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。<br> &ensp;&ensp;ConnectableObservable.connect()指示一个可连接的Observable开始发射数据。<br>&ensp;&ensp;Observable.publish()将一个Observable转换为一个可连接的Observable 。<br>&ensp;&ensp;Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。<br>&ensp;&ensp;ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConnectableObservable co=  ConnectableObservable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">                .publish();</span><br><span class="line">                 co.subscribe(integer -&gt; System.out.println(integer));</span><br><span class="line">                co.connect();</span><br></pre></td></tr></table></figure></p>
<h4 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h4><p>&ensp;&ensp;BlockingObservable是一个阻塞的Observable。普通的Observable 转换为 BlockingObservable，可以使用 Observable.blocking<em>( )方法。内部通过CountDownLatch实现了阻塞操作。<br>&ensp;&ensp;以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.blocking</em>()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<ol>
<li>blockingForEach：对BlockingObservable发射的每一项数据调用一个方法，会阻塞到Observable完成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .blockingForEach(integer -&gt;System.out.println(integer) );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h4><ol>
<li><p>materialize：将Observable转换成一个通知列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">               .materialize()</span><br><span class="line">               .subscribe(integerNotification -&gt;System.out.println(integerNotification.isOnNext()) );</span><br></pre></td></tr></table></figure>
</li>
<li><p>dematerialize：与上面的作用相反，将通知逆转回一个Observable。？</p>
</li>
<li><p>timestamp：给Observable发射的每个数据项添加一个时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .timestamp()</span><br><span class="line">                .subscribe(integerTimed -&gt;System.out.println( integerTimed.time()+<span class="string">" "</span>+integerTimed.value()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中。？</p>
</li>
<li>serialize：强制Observable按次序发射数据并且要求功能是完好的。</li>
<li>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者。</li>
<li>observeOn： 指定观察者观察Observable的调度器。</li>
<li>subscribeOn： 指定Observable执行任务的调度器。</li>
<li><p>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">               .doOnEach(integerNotification -&gt; integerNotification.getValue())</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnCompleted： 注册一个动作，对正常完成的Observable使用。</p>
</li>
<li>doOnError： 注册一个动作，对发生错误的Observable使用。</li>
<li><p>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .doOnTerminate(() -&gt; System.out.println(<span class="string">"do torminate"</span>))</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .doOnSubscribe(disposable -&gt; disposable.isDisposed())</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。 </p>
</li>
<li><p>doFinally： 注册一个动作，在Observable完成时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .doFinally(() -&gt; &#123;&#125;)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</p>
</li>
<li><p>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .delaySubscription(<span class="number">200</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>single/singleOrError： 强制返回单个数据，否则抛出异常或默认数据。</p>
</li>
</ol>
<p>参考：</p>
<ul>
<li><strong><a href="https://mcxiaoke.gitbooks.io/rxdocs/" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/rxdocs/</a></strong></li>
<li><a href="http://www.sohu.com/a/138462889_468731" target="_blank" rel="noopener">http://www.sohu.com/a/138462889_468731</a></li>
<li><a href="http://blog.csdn.net/maplejaw_/article/details/52442065" target="_blank" rel="noopener">http://blog.csdn.net/maplejaw_/article/details/52442065</a></li>
<li><a href="http://blog.csdn.net/maplejaw_/article/details/52396175" target="_blank" rel="noopener">http://blog.csdn.net/maplejaw_/article/details/52396175</a></li>
<li><a href="http://www.cnblogs.com/dragonfei/p/6263253.html" target="_blank" rel="noopener">http://www.cnblogs.com/dragonfei/p/6263253.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/03/rxjava2基础/" data-id="cjlc1dmuw004ia4s6s6as9kxg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/20/python爬虫/" class="article-date">
  <time datetime="2017-05-20T04:15:28.000Z" itemprop="datePublished">2017-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/20/python爬虫/">python爬虫</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>urllib2的运用</li>
</ol>
<p>&ensp;&ensp;urllib2获取网页内容时可以设定超时时间，防止运行过程中假死；在获取网页时需要做异常处理，防止部分网页访问不到程序终止。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    f = urllib2.urlopen(url, timeout=<span class="number">0</span>) <span class="comment">#timeout设置超时的时间</span></span><br><span class="line">    result = f.read()</span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">except</span> Exception,e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a'</span>,str(e)</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;urlopen error timed out&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>异常处理</strong><br>&ensp;&ensp;如果想在代码中处理URLError和HTTPError有两种方法，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url=<span class="string">"xxxxxx"</span>  <span class="comment">#需要访问的URL</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response=urllib2.urlopen(url)</span><br><span class="line"><span class="keyword">except</span> urllib2.HTTPError,e:    <span class="comment">#HTTPError必须排在URLError的前面</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"The server couldn't fulfill the request"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error code:"</span>,e.code</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Return content:"</span>,e.read()</span><br><span class="line"><span class="keyword">except</span> urllib2.URLError,e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Failed to reach the server"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"The reason:"</span>,e.reason</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#something you should do</span></span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment">#其他异常的处理</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url=<span class="string">"http://xxx"</span>  <span class="comment">#需要访问的URL</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response=urllib2.urlopen(url)</span><br><span class="line"><span class="keyword">except</span> urllib2.URLError,e:</span><br><span class="line">    <span class="keyword">if</span> hasattr(e,<span class="string">"reason"</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Failed to reach the server"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The reason:"</span>,e.reason</span><br><span class="line">    <span class="keyword">elif</span> hasattr(e,<span class="string">"code"</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The server couldn't fulfill the request"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error code:"</span>,e.code</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Return content:"</span>,e.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment">#其他异常的处理</span></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;相比较而言，第二种异常处理方法更优。</p>
<ol>
<li>re正则的运用</li>
</ol>
<p>字符匹配过成功中，re匹配模式很难定义，主要还是不熟；主要用到以下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">r'''&lt;a href="http://wiki.jikexueyuan.com/project/start-learning-python/(.+?).html" &gt;.+?&lt;/a&gt;'''</span>)</span><br><span class="line">matchs = p.findall(contents)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这个主要匹配出所有的网页名称出来，结果是得到一个包含list的tuple列表；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linkpatten = re.compile(<span class="string">r'''href="/.+?/css'''</span>)</span><br><span class="line">contents = re.sub(linkpatten, <span class="string">r'href="./css'</span>, contents)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这个主要是将contents中的href=”/.+?/css字符串替换成./css形式，所有的哦。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linkpatten = re.compile(<span class="string">r'''href="/assets/(.+?)\.ico"'''</span>)</span><br><span class="line">contents = re.sub(linkpatten, <span class="string">r'href="./images/\g&lt;1&gt;.ico"'</span>, contents)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这个主要是将contents中的href=”/assets/(.+?).ico”字符串并提取ico的名称用来后台替换，替换成href=”./images/\g<1>.ico”形式，其中\g<1>部分或用提取出来的名称替换，同样是所有的哦.</1></1></p>
<p><strong>小结</strong><br>&ensp;&ensp;正则中（）代表需要提取出来的内容；re.sub(linkpatten, r’href=”./images/\g<1>.ico”‘, contents)解析；反斜杠加g以及中括号内一个名字，即：\g<name>，对应着命了名的组，named group；文件保存推荐使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                       cssfile.write(req.read())</span><br></pre></td></tr></table></figure></name></1></p>
<p>&ensp;&ensp;同样需要注意的是在保存图片文件(png或jpg)时，写入模式是“w+b”（以二进制形式保存），但是有的网站图片可能是压缩过的，保存下来是看不了的，可以通过如下格式保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename,<span class="string">"wb"</span>) <span class="keyword">as</span> code:</span><br><span class="line">  decompresser = zlib.decompressobj(<span class="number">16</span>+zlib.MAX_WBITS)</span><br><span class="line">  data = decompresser.decompress(f.read())</span><br><span class="line">  code.write(data)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;目前不知道如何判断图片是否压缩及压缩格式，有知道的可以交流下。</p>
<ol>
<li>贪婪 vs 不贪婪<br>&ensp;&ensp;当重复一个正则表达式时，如用 a*，操作结果是尽可能多地匹配模式。当你试着匹配一对对称的定界符，如 HTML 标志中的尖括号时这个事实经常困扰你。匹配单个 HTML 标志的模式不能正常工作，因为 .* 的本质是“贪婪”的</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> re.match(<span class="string">'&lt;.*&gt;'</span>, s).span()</span><br><span class="line">(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> re.match(<span class="string">'&lt;.*&gt;'</span>, s).group()</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;RE 匹配 在 “<html>“ 中的 “&lt;”，.* 消耗掉字符串的剩余部分。在 RE 中保持更多的左，虽然 &gt; 不能匹配在字符串结尾，因此正则表达式必须一个字符一个字符地回溯，直到它找到 &gt; 的匹配。最终的匹配从 “<html" 中的="" "<"="" 到="" "<="" title="">“ 中的 “&gt;”,这并不是你所想要的结果。</html"></html></p>
<p>&ensp;&ensp;在这种情况下，解决方案是使用不贪婪的限定符 *?、+?、?? 或 {m,n}?，尽可能匹配小的文本。在上面的例子里， “&gt;” 在第一个 “&lt;” 之后被立即尝试，当它失败时，引擎一次增加一个字符，并在每步重试 “&gt;”。这个处理将得到正确的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> re.match(<span class="string">'&lt;.*?&gt;'</span>, s).group()</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure></p>
<p>###最后附上最近写的原始版的极客python教程内容爬取的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">main_dir = <span class="string">r'D:\mugwort\book\python\base_python'</span></span><br><span class="line">main_url = <span class="string">r'http://wiki.jikexueyuan.com/project/start-learning-python/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sava_css</span><span class="params">(contents)</span>:</span></span><br><span class="line">    p = re.compile(<span class="string">r'''&lt;link rel="stylesheet" type="text/css" href="(.+?)"&gt;'''</span>)</span><br><span class="line">    matchs = p.findall(contents)</span><br><span class="line">    <span class="keyword">for</span> match <span class="keyword">in</span> matchs:</span><br><span class="line">        logging.info(match)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match.startswith(<span class="string">"//"</span>):</span><br><span class="line">            match = <span class="string">"http://wiki.jikexueyuan.com"</span> + match</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            match = <span class="string">"http:"</span> + match</span><br><span class="line">        logging.info(<span class="string">"format:"</span> + match)</span><br><span class="line">        req = urllib2.urlopen(match)</span><br><span class="line">        contents = req.read()</span><br><span class="line">        names = re.compile(<span class="string">r'''.+?/(.*?)\.css'''</span>).findall(match)</span><br><span class="line">        name = names.pop(len(names) - <span class="number">1</span>)</span><br><span class="line">        logging.info(name)</span><br><span class="line">        logging.info(<span class="string">"rindex %d  length %d "</span> % (name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>, len(name)))</span><br><span class="line">        logging.info(<span class="string">"name format:"</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)])</span><br><span class="line">        filename = main_dir + <span class="string">'\\css\\'</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)] + <span class="string">".css"</span></span><br><span class="line">        <span class="keyword">if</span> filename:</span><br><span class="line">            logging.info(filename)</span><br><span class="line">            <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                cssfile.write(contents)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sava_js</span><span class="params">(contents)</span>:</span></span><br><span class="line">    p = re.compile(<span class="string">r'''&lt;script type="text/javascript" src="(.+?)"&gt;'''</span>)</span><br><span class="line">    matchs = p.findall(contents)</span><br><span class="line">    <span class="keyword">for</span> match <span class="keyword">in</span> matchs:</span><br><span class="line">        logging.info(match)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match.startswith(<span class="string">"//"</span>):</span><br><span class="line">            match = <span class="string">"http://wiki.jikexueyuan.com"</span> + match</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            match = <span class="string">"http:"</span> + match</span><br><span class="line">        logging.info(<span class="string">"format:"</span> + match)</span><br><span class="line">        req = urllib2.urlopen(match)</span><br><span class="line">        contents = req.read()</span><br><span class="line">        names = re.compile(<span class="string">r'''.+?/(.*?)\.js'''</span>).findall(match)</span><br><span class="line">        logging.info(names)</span><br><span class="line">        name = names.pop(len(names) - <span class="number">1</span>)</span><br><span class="line">        logging.info(name)</span><br><span class="line">        logging.info(<span class="string">"rindex %d  length %d "</span> % (name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>, len(name)))</span><br><span class="line">        logging.info(<span class="string">"name format:"</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)])</span><br><span class="line">        filename = main_dir + <span class="string">'\\js\\'</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)] + <span class="string">".js"</span></span><br><span class="line">        <span class="keyword">if</span> filename:</span><br><span class="line">            logging.info(filename)</span><br><span class="line">            <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                cssfile.write(contents)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sava_img</span><span class="params">(contents)</span>:</span></span><br><span class="line">    p = re.compile(<span class="string">r'''&lt;img src="(.+?)".+?&gt;|&lt;link.+?href="(.+?)".+?type="image/x-icon".+?&gt;'''</span>)</span><br><span class="line">    matchs = p.findall(contents)</span><br><span class="line">    <span class="keyword">for</span> matchT <span class="keyword">in</span> matchs:</span><br><span class="line">        logging.info(matchT)</span><br><span class="line">        match = matchT[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">            match = matchT[<span class="number">1</span>]</span><br><span class="line">        logging.info(match)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match.startswith(<span class="string">"//"</span>):</span><br><span class="line">            match = <span class="string">"http://wiki.jikexueyuan.com"</span> + match</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            match = <span class="string">"http:"</span> + match</span><br><span class="line">        logging.info(<span class="string">"format:"</span> + match)</span><br><span class="line">        logging.info(<span class="string">"rindex %d  length %d "</span> % (match.rindex(<span class="string">r"."</span>), len(match)))</span><br><span class="line">        subfix = match[match.rindex(<span class="string">"."</span>):len(match)]</span><br><span class="line">        logging.info(<span class="string">"subfix:"</span> + subfix)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            req = urllib2.urlopen(match)</span><br><span class="line">            names = re.compile(<span class="string">r'''.+?/(.*?)\.png|.+?/(.*?)\.jpg|.+?/(.*?)\.ico'''</span>).findall(match)</span><br><span class="line">            logging.info(names)</span><br><span class="line">            nameT = names.pop(<span class="number">0</span>)</span><br><span class="line">            name = nameT[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">                name = nameT[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">                name = nameT[<span class="number">2</span>]</span><br><span class="line">            logging.info(name)</span><br><span class="line">            logging.info(<span class="string">"rindex %d  length %d "</span> % (name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>, len(name)))</span><br><span class="line">            logging.info(<span class="string">"name format:"</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)])</span><br><span class="line">            filename = main_dir + <span class="string">'\\images\\'</span> + name[name.rindex(<span class="string">"/"</span>) + <span class="number">1</span>:len(name)] + subfix</span><br><span class="line">            <span class="keyword">if</span> filename:</span><br><span class="line">                logging.info(filename)</span><br><span class="line">                <span class="comment"># 对于png文件需要解压且以二进制保存</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">".png"</span> == subfix:</span><br><span class="line">                    <span class="keyword">with</span> open(filename, <span class="string">'w+b'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                        cssfile.write(req.read())</span><br><span class="line">                <span class="comment"># 对于jpg文件需要以二进制写入</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">".jpg"</span> == subfix:</span><br><span class="line">                    <span class="keyword">with</span> open(filename, <span class="string">'w+b'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                        cssfile.write(req.read())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> cssfile:</span><br><span class="line">                        cssfile.write(req.read())</span><br><span class="line">        <span class="keyword">except</span> urllib2.URLError, e:</span><br><span class="line">            <span class="keyword">if</span> hasattr(e, <span class="string">"reason"</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"The reason:"</span>, e.reason</span><br><span class="line">            <span class="keyword">elif</span> hasattr(e, <span class="string">"code"</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Error code:"</span>, e.code</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Return content:"</span>, e.read()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span>  <span class="comment"># 其他异常处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_html</span><span class="params">(urlname)</span>:</span></span><br><span class="line">    <span class="comment"># 打开并保存hmtl</span></span><br><span class="line">    url = main_url + urlname + <span class="string">'.html'</span></span><br><span class="line">    file_name = main_dir + <span class="string">'\\'</span> + urlname + <span class="string">'.html'</span></span><br><span class="line">    req = urllib2.urlopen(url)</span><br><span class="line">    contents = req.read()</span><br><span class="line">    sava_css(contents)</span><br><span class="line">    sava_js(contents)</span><br><span class="line">    sava_img(contents)</span><br><span class="line">    <span class="comment"># 替换掉地址信息，让其变为本地</span></span><br><span class="line">    <span class="comment"># 规范css文件保存</span></span><br><span class="line">    contents = re.sub(main_url, <span class="string">r""</span>, contents)</span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''href="/.+?/css'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'href="./css'</span>, contents)</span><br><span class="line">    <span class="comment"># 规范js文件保存</span></span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''src=".*?/js/(.+?)\.js.*?"'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'src="./js/\g&lt;1&gt;.js"'</span>, contents)</span><br><span class="line">    linkpatten = re.compile(<span class="string">r"src='.*?/js/(.+?)\.js.*?'"</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'src="./js/\g&lt;1&gt;.js"'</span>, contents)</span><br><span class="line">    <span class="comment"># 规范js文件保存</span></span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''src=".*?/src/(.+?)\.js.*?"'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'src="./js/\g&lt;1&gt;.js"'</span>, contents)</span><br><span class="line">    <span class="comment"># 规范img文件保存</span></span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''src=".*?/images/(.+?)\.png"'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'src="./images/\g&lt;1&gt;.png"'</span>, contents)</span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''src=".*?/images/(.+?)\.jpg"'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'src="./images/\g&lt;1&gt;.jpg"'</span>, contents)</span><br><span class="line">    linkpatten = re.compile(<span class="string">r'''href="/assets/(.+?)\.ico"'''</span>)</span><br><span class="line">    contents = re.sub(linkpatten, <span class="string">r'href="./images/\g&lt;1&gt;.ico"'</span>, contents)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'w'</span>) <span class="keyword">as</span> urlfile:</span><br><span class="line">        urlfile.write(contents)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">req = urllib2.urlopen(<span class="string">r'http://wiki.jikexueyuan.com/project/start-learning-python/'</span>)</span><br><span class="line">p = re.compile(<span class="string">r'''&lt;a href="http://wiki.jikexueyuan.com/project/start-learning-python/(.+?).html" &gt;.+?&lt;/a&gt;'''</span>)</span><br><span class="line">contents = req.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">matchs = p.findall(contents)</span><br><span class="line">logging.info(len(matchs))</span><br><span class="line">logging.info(time.time())</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> matchs:</span><br><span class="line">    save_html(row)</span><br><span class="line">logging.info(time.time())</span><br></pre></td></tr></table></figure></p>
<p>参考地址：</p>
<ul>
<li>正则速查表 <a href="http://www.jb51.net/shouce/jquery1.82/regexp.html" target="_blank" rel="noopener">http://www.jb51.net/shouce/jquery1.82/regexp.html</a></li>
<li>urllib2异常处理 <a href="http://wangxiaoxu.iteye.com/blog/1844989" target="_blank" rel="noopener">http://wangxiaoxu.iteye.com/blog/1844989</a></li>
<li>Python正则表达式操作指南 <a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97</a></li>
<li>re.sub使用示例 <a href="http://www.programcreek.com/python/example/21/re.sub" target="_blank" rel="noopener">http://www.programcreek.com/python/example/21/re.sub</a></li>
<li>python替换函数  <a href="http://blog.csdn.net/zcmlimi/article/details/47709049" target="_blank" rel="noopener">http://blog.csdn.net/zcmlimi/article/details/47709049</a></li>
<li>re.sub 五个参数解析 <a href="http://www.crifan.com/python_re_sub_detailed_introduction/" target="_blank" rel="noopener">http://www.crifan.com/python_re_sub_detailed_introduction/</a></li>
<li>压缩问题 <a href="http://stackoverflow.com/questions/3122145/zlib-error-error-3-while-decompressing-incorrect-header-check" target="_blank" rel="noopener">http://stackoverflow.com/questions/3122145/zlib-error-error-3-while-decompressing-incorrect-header-check</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/20/python爬虫/" data-id="cjlc1dmtv001sa4s6d6ejg1nh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-raspberryWithPython" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/raspberryWithPython/" class="article-date">
  <time datetime="2017-05-10T15:31:45.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/raspberryWithPython/">raspberryWithPython</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="树莓派gpio接口操作"><a href="#树莓派gpio接口操作" class="headerlink" title="树莓派gpio接口操作"></a>树莓派gpio接口操作</h1><ol>
<li>基础知识介绍</li>
</ol>
<p>&ensp;&ensp;General Purpose Input Output （通用输入/输出）简称为GPIO，或总线扩展器，人们利用工业标准I2C、SMBus或SPI接口简化了I/O口的扩展。当微控制器或芯片组没有足够的I/O端口，或当系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。(摘自百度)<br>&ensp;&ensp;树莓派gpio接口示意图<img src="/images/Raspberry-Pi-GPIO-Layout-Model-B-Plus.png" alt="树莓派针脚图">，<a href="http://www.raspberrypi-spy.co.uk/2014/07/raspberry-pi-b-gpio-header-details-and-pinout/" target="_blank" rel="noopener">图片来源</a>。</p>
<ol>
<li>使用python操作gpio接口<br>##安装python gpio库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir gpio</span><br><span class="line">cd gpio</span><br><span class="line">wget https://pypi.python.org/packages/source/R/RPi.GPIO/RPi.GPIO-0.5.7.tar.gz</span><br><span class="line">#或者到这里下载最新版本：https://pypi.python.org/pypi/RPi.GPIO</span><br><span class="line">tar xvzf RPi.GPIO-*.tar.gz</span><br><span class="line">cd RPi.GPIO-*/</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>安装的时候出现错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source/py_gpio.c:23:20: fatal error: Python.h: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>缺少Python.h文件,没安装python编译环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br></pre></td></tr></table></figure></p>
<p>再次安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure></p>
<h2 id="点亮led灯"><a href="#点亮led灯" class="headerlink" title="点亮led灯"></a>点亮led灯</h2><p>先测试下输出,新建个led.py文件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">GPIO.setmode(GPIO.BOARD)</span><br><span class="line">GPIO.setup(<span class="number">11</span>,GPIO.OUT)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">     GPIO.output(<span class="number">11</span>,<span class="keyword">True</span>)</span><br><span class="line">     time.sleep(<span class="number">1</span>)</span><br><span class="line">     GPIO.output(<span class="number">11</span>,<span class="keyword">False</span>)</span><br><span class="line">     time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;注意: 这里使用GPIO.BOARD模式,所以对于引脚号的排序,是按26个pin的顺序,不是gpio1这样的.也就是说pin1就是板子上的3V3.   把led的负极接到板子上的pin11.正极接一个3K3的电阻,在接到3V3上,防止烧坏. 特别注意python的缩进.</p>
<p>终端下运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python led.py</span><br></pre></td></tr></table></figure></p>
<p>如果LED出现一闪一闪就表示成功了.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/10/raspberryWithPython/" data-id="cjlc1dmty001xa4s6sgcaj5xh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python第三方库beatifulSoup使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/python第三方库beatifulSoup使用/" class="article-date">
  <time datetime="2017-05-08T15:03:56.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/python第三方库beatifulSoup使用/">python第三方库beatifulSoup使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="python中BeautifulSoup使用"><a href="#python中BeautifulSoup使用" class="headerlink" title="python中BeautifulSoup使用"></a>python中BeautifulSoup使用</h1><p>&ensp;&ensp;BeautifulSoup是一个可以从Html或xml文件中提取数据的python库，它能够通过不同的转换器实现惯用的文档导航、查找、修改文档的方式。<br>&ensp;&ensp;首先看看它的一些基本用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">"""&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;"""</span></span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br><span class="line"><span class="comment"># 通过prettify方法格式化文档</span></span><br><span class="line"><span class="comment"># print(soup.prettify())</span></span><br><span class="line"><span class="comment"># 输出文件对象的title标签内容</span></span><br><span class="line"><span class="keyword">print</span> soup.title</span><br><span class="line"><span class="comment"># 输出标签的名字</span></span><br><span class="line"><span class="keyword">print</span> soup.title.name</span><br><span class="line"><span class="comment"># 输出标签的文本内容</span></span><br><span class="line"><span class="keyword">print</span> soup.title.string</span><br><span class="line"><span class="comment"># 输出标签title的父节点名字</span></span><br><span class="line"><span class="keyword">print</span> soup.title.parent.name</span><br><span class="line"><span class="comment"># 输出标签的属性class的值,!前提是该标签有定义了该属性，要不会报错</span></span><br><span class="line"><span class="keyword">print</span> soup.p[<span class="string">"class"</span>]</span><br><span class="line"><span class="comment"># 输出文档中所有a标签的节点</span></span><br><span class="line"><span class="keyword">print</span> soup.findAll(<span class="string">"a"</span>)</span><br><span class="line"><span class="comment"># 输出节点带有id属性且id属性值为"link3"的节点</span></span><br><span class="line"><span class="keyword">print</span> soup.find(id=<span class="string">"link3"</span>)</span><br><span class="line"><span class="comment"># 从文档中找到所有a标签的链接</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.findAll(<span class="string">"a"</span>):</span><br><span class="line">    print(link.get(<span class="string">"href"</span>))</span><br><span class="line"><span class="comment"># 从文档中获取所有文字内容,text属性是调用getText()方法,getText()方法可以添加分隔符,有的本版是这个方法名：get_text()</span></span><br><span class="line">print(soup.text)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;大致浏览了下BeautifulSoup用法，接着我们看看如何在中用。</p>
<p>#首先是安装</p>
<ol>
<li><p>ubuntu或者Debain系统安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install Python-bs4</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接命令安装，Beautiful Soup 4 通过PyPi发布,所以如果你无法使用系统包管理安装，那么也可以通过 easy_install 或 pip 来安装。包的名字是 beautifulsoup4 ，这个包兼容Python2和Python3。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">c:\&gt; <span class="title">easy_install</span> <span class="title">beautifulsoup4</span></span></span><br><span class="line"><span class="function"><span class="title">c</span>:\&gt; <span class="title">pip</span> <span class="title">install</span> <span class="title">beautifulsoup4</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;<strong>注意</strong>在PyPi中还有一个名字是 BeautifulSoup 的包，但那可能不是你想要的,那是 Beautiful Soup3 的发布版本，因为很多项目还在使用BS3, 所以 BeautifulSoup 包依然有效。但是如果你在编写新项目，那么你应该安装的 beautifulsoup4。</p>
<ol>
<li><p>通过下载<a href="http://www.crummy.com/software/BeautifulSoup/download/4.x/" target="_blank" rel="noopener">源码</a>安装，解压进入源码包，然后运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ide辅助安装，在代码中输入一下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本 3.x.x引入方式</span></span><br><span class="line"><span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本4以上含，引入方式</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;然后ide会提示BeautifulSoup找不到，再根据提示安装即可。</p>
<p><strong>安装完成后可能遇到的问题</strong></p>
<hr>
<ol>
<li>代码中抛出ImportError的异常：“No module named HTMLParser”，这是因为你在Python3版本中执行Python2版本的代码。</li>
<li>代码抛出了 ImportError 的异常: “No module named html.parser”, 这是因为你在Python2版本中执行Python3版本的代码.<br>&ensp;&ensp;如果遇到上述2种情况,最好的解决方法是重新安装BeautifulSoup4。</li>
</ol>
<p>#安装解析器<br>&ensp;&ensp;Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml .根据操作系统不同,可以选择下列方法来安装lxml:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install Python-lxml</span><br><span class="line">$ easy_install lxml</span><br><span class="line">$ pip install lxml</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;另一个可供选择的解析器是纯Python实现的 html5lib , html5lib的解析方式与浏览器相同,可以选择下列方法来安装html5lib:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install Python-html5lib</span><br><span class="line">$ easy_install html5lib</span><br><span class="line">$ pip install html5lib</span><br></pre></td></tr></table></figure></p>
<p>python中主要的一些解析器和各自优缺点：</p>
<table>
<thead>
<tr>
<th style="text-align:left">解析器</th>
<th style="text-align:left">使用方法</th>
<th style="text-align:left">优势</th>
<th style="text-align:left">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python标准库</td>
<td style="text-align:left">BeautifulSoup(markup, “html.parser”)</td>
<td style="text-align:left">Python的内置标准库;执行速度适中;文档容错能力强</td>
<td style="text-align:left">Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td>
</tr>
<tr>
<td style="text-align:left">lxml HTML 解析器</td>
<td style="text-align:left">BeautifulSoup(markup, “lxml”)</td>
<td style="text-align:left">速度快;文档容错能力强</td>
<td style="text-align:left">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:left">lxml XML 解析器</td>
<td style="text-align:left">BeautifulSoup(markup, [“lxml-xml”])<br>BeautifulSoup(markup, “xml”)</td>
<td style="text-align:left">速度快;唯一支持XML的解析器</td>
<td style="text-align:left">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:left">html5lib</td>
<td style="text-align:left">BeautifulSoup(markup, “html5lib”)</td>
<td style="text-align:left">最好的容错性;以浏览器的方式解析文档;生成HTML5格式的文档</td>
<td style="text-align:left">速度慢;不依赖外部扩展</td>
</tr>
</tbody>
</table>
<p>&ensp;&ensp;推荐使用lxml作为解析器,因为效率更高. 在Python2.7.3之前的版本和Python3中3.2.2之前的版本,必须安装lxml或html5lib, 因为那些Python版本的标准库中内置的HTML解析方法不够稳定.</p>
<p>&ensp;&ensp;<strong>提示</strong> 如果一段HTML或XML文档格式不正确的话,那么在不同的解析器中返回的结果可能是不一样的,查看 [解析器之间的区别] (<a href="http://doc.iplaypy.com/bs4/#id49)了解更多细节。" target="_blank" rel="noopener">http://doc.iplaypy.com/bs4/#id49)了解更多细节。</a></p>
<p>#使用<br>&ensp;&ensp;将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(open(<span class="string">"index.html"</span>))</span><br><span class="line">soup = BeautifulSoup(<span class="string">"&lt;html&gt;data&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;首先文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码，然后，Beautiful Soup选择最合适的解析器来解析这段文档，如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档。</p>
<p>##对象的种类<br>&ensp;&ensp;Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种: Tag ，NavigableString ，BeautifulSoup，Comment 。</p>
<p>###Tag<br>&ensp;&ensp;Tag 对象与XML或HTML原生文档中的tag相同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span>)</span><br><span class="line">tag = soup.b</span><br><span class="line">type(tag)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.Tag'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Tag有很多方法和属性，在遍历文档树和搜索文档树中有详细解释。现在介绍一下tag中最重要的属性: name和attributes</p>
<ol>
<li><p><strong>Name</strong>：每个tag都有自己的名字，通过 .name 来获取:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag.name</span><br><span class="line"><span class="comment"># u'b'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Attributes</strong>：一个tag可能有很多个属性.。tag <b class="boldest"> 有一个 “class” 的属性，值为 “boldest” 。 tag的属性的操作方法与字典相同:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># u'boldest'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以直接”点“取属性，比如：.attrs:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag.attrs</span><br><span class="line"><span class="comment"># &#123;u'class': u'boldest'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;tag的属性可以被添加,删除或修改。<strong>tag的属性操作方法与字典一样</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tag[<span class="string">'class'</span>] = <span class="string">'verybold'</span></span><br><span class="line">tag[<span class="string">'id'</span>] = <span class="number">1</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'class'</span>]</span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'id'</span>]</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br><span class="line">tag[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># KeyError: 'class'</span></span><br><span class="line"></span><br><span class="line">print(tag.get(<span class="string">'class'</span>))</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>多值属性：HTML 4定义了一系列可以包含多个值的属性。在HTML5中移除了一些，却增加更多。最常见的多值的属性是 class (一个tag可以有多个CSS的class). 、。还有一些属性 rel , rev , accept-charset , headers , accesskey 。在Beautiful Soup中多值属性的返回类型是list:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body", "strikeout"]</span></span><br><span class="line"></span><br><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id_soup = BeautifulSoup(<span class="string">'&lt;p id="my id"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">id_soup.p[<span class="string">'id'</span>]</span><br><span class="line"><span class="comment"># 'my id'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;将tag转换成字符串时,多值属性会合并为一个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rel_soup = BeautifulSoup(<span class="string">'&lt;p&gt;Back to the &lt;a rel="index"&gt;homepage&lt;/a&gt;&lt;/p&gt;'</span>)</span><br><span class="line">rel_soup.a[<span class="string">'rel'</span>]</span><br><span class="line"><span class="comment"># ['index']</span></span><br><span class="line"></span><br><span class="line">rel_soup.a[<span class="string">'rel'</span>] = [<span class="string">'index'</span>, <span class="string">'contents'</span>]</span><br><span class="line">print(rel_soup.p)</span><br><span class="line"><span class="comment"># &lt;p&gt;Back to the &lt;a rel="index contents"&gt;homepage&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果转换的文档是XML格式，那么tag中不包含多值属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xml_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>, <span class="string">'xml'</span>)</span><br><span class="line"></span><br><span class="line">xml_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># u'body strikeout'</span></span><br></pre></td></tr></table></figure></p>
<p>###NavigableString:可以遍历的字符串<br>&ensp;&ensp;字符串常被包含在tag内。Beautiful Soup用 NavigableString 类来包装tag中的字符串:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tag.string</span><br><span class="line"><span class="comment"># u'Extremely bold'</span></span><br><span class="line"></span><br><span class="line">type(tag.string)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.NavigableString'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;一个 NavigableString 字符串与Python中的Unicode字符串相同,并且还支持包含在 遍历文档树 和 搜索文档树 中的一些特性. 通过 unicode() 方法可以直接将 NavigableString 对象转换成Unicode字符串:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unicode_string = unicode(tag.string)</span><br><span class="line"></span><br><span class="line">unicode_string</span><br><span class="line"><span class="comment"># u'Extremely bold'</span></span><br><span class="line"></span><br><span class="line">type(unicode_string)</span><br><span class="line"><span class="comment"># &lt;type 'unicode'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 replaceWith() 方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag.string.replaceWith(<span class="string">"No longer bold"</span>)</span><br><span class="line"></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;NavigableString 对象支持 遍历文档树 和 搜索文档树 中定义的大部分属性, 并非全部。尤其是一个字符串不能包含其它内容(tag能够包含字符串或是其它tag)，字符串不支持 .contents 或 .string 属性或 find() 方法。<br>&ensp;&ensp;如果想在Beautiful Soup之外使用 NavigableString 对象，需要调用 unicode() 方法，将该对象转换成普通的Unicode字符串，否则就算Beautiful Soup的方法已经执行结束,该对象的输出也会带有对象的引用地址，这样会浪费内存。</p>
<p>###BeautifulSoup<br>&ensp;&ensp;BeautifulSoup 对象表示的是一个文档的全部内容。大部分时候，可以把它当作 Tag 对象，它支持遍历文档树 和 搜索文档树 中描述的大部分的方法。<br>&ensp;&ensp;因为 BeautifulSoup 对象并不是真正的HTML或XML的tag，所以它没有name和attribute属性。但有时查看它的 .name 属性是很方便的，所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.name</span><br><span class="line"><span class="comment"># u'[document]'</span></span><br></pre></td></tr></table></figure></p>
<p>###Comment<br>&ensp;&ensp;注释及特殊字符串,Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容，但是还有一些特殊对象。容易让人担心的内容是文档的注释部分:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">comment = soup.b.string</span><br><span class="line"></span><br><span class="line">type(comment)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.Comment'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Comment 对象是一个特殊类型的 NavigableString 对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comment</span><br><span class="line"><span class="comment"># u'Hey, buddy. Want to buy a used parser'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;但是当它出现在HTML文档中时, Comment 对象会使用特殊的格式输出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(soup.b.prettify())</span><br><span class="line"><span class="comment"># &lt;b&gt;</span></span><br><span class="line"><span class="comment">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span></span><br><span class="line"><span class="comment"># &lt;/b&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Beautiful Soup中定义的其它类型都可能会出现在XML的文档中: CData , ProcessingInstruction , Declaration , Doctype 。与 Comment 对象类似，这些类都是 NavigableString 的子类，只是添加了一些额外的方法的字符串独享。下面是用CDATA来替代注释的例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> CData</span><br><span class="line">cdata = CData(<span class="string">"A CDATA block"</span>)</span><br><span class="line">comment.replaceWith(cdata)</span><br><span class="line"></span><br><span class="line">print(soup.b.prettify())</span><br><span class="line"><span class="comment"># &lt;b&gt;</span></span><br><span class="line"><span class="comment">#  &lt;![CDATA[A CDATA block]]&gt;</span></span><br><span class="line"><span class="comment"># &lt;/b&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>##遍历文档树<br>&ensp;&ensp;还拿开头的html_doc文档来做例子</p>
<p>###子节点<br>&ensp;&ensp;一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.<br><strong>注意:</strong> Beautiful Soup中字符串节点不支持这些属性，因为字符串没有子节点。</p>
<ol>
<li>tag的名字</li>
</ol>
<p>&ensp;&ensp;操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 <head> 标签,只要用 soup.head :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.head</span><br><span class="line"><span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"></span><br><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br></pre></td></tr></table></figure></head></p>
<p>&ensp;&ensp;这是个获取tag的小窍门，可以在文档树的tag中多次调用这个方法。下面的代码可以获取<body>标签中的第一个<b>标签：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.body.b</span><br><span class="line"><span class="comment"># &lt;b&gt;The Dormouse's story&lt;/b&gt;</span></span><br></pre></td></tr></table></figure></b></body></p>
<p>&ensp;&ensp;通过<strong>点</strong>取属性的方式<strong>只能获得当前名字的第一个tag</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.a</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果想要得到所有的<a>标签，或是通过名字得到比一个tag更多的内容的时候，就需要用到 Searching the tree 中描述的方法，比如: find_all()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></a></p>
<ol>
<li>.contents 和 .children</li>
</ol>
<p>&ensp;&ensp;tag的 .contents 属性可以将tag的子节点以列表的方式输出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">head_tag = soup.head</span><br><span class="line">head_tag</span><br><span class="line"><span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"></span><br><span class="line">head_tag.contents</span><br><span class="line">[&lt;title&gt;The Dormouse<span class="string">'s story&lt;/title&gt;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">title_tag = head_tag.contents[0]</span></span><br><span class="line"><span class="string">title_tag</span></span><br><span class="line"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">title_tag.contents</span><br><span class="line"><span class="comment"># [u'The Dormouse's story']</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;BeautifulSoup 对象本身一定会包含子节点，也就是说<html>标签也是 BeautifulSoup 对象的子节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len(soup.contents)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">soup.contents[<span class="number">0</span>].name</span><br><span class="line"><span class="comment"># u'html'</span></span><br></pre></td></tr></table></figure></html></p>
<p>&ensp;&ensp;字符串没有 .contents 属性,因为字符串没有子节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = title_tag.contents[<span class="number">0</span>]</span><br><span class="line">text.contents</span><br><span class="line"><span class="comment"># AttributeError: 'NavigableString' object has no attribute 'contents'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;通过tag的 .children 生成器,可以对tag的子节点进行循环:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> title_tag.children:</span><br><span class="line">    print(child)</span><br><span class="line">    <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>.descendants</li>
</ol>
<p>&ensp;&ensp;.contents 和 .children 属性仅包含tag的直接子节点。例如，<head>标签只有一个直接子节点<title><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head_tag.contents</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br></pre></td></tr></table></figure></title></head></p>
<p>&ensp;&ensp;但是<title>标签也包含一个子节点:字符串 “The Dormouse’s story”,这种情况下字符串 “The Dormouse’s story”也属于<head>标签的子孙节点. .descendants 属性可以对所有tag的子孙节点进行递归循环 :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> head_tag.descendants:</span><br><span class="line">    print(child)</span><br><span class="line">    <span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">    <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure></head></title></p>
<ol>
<li>.string</li>
</ol>
<p>&ensp;&ensp;如果tag<strong>只有一个 NavigableString 类型子节点</strong>,那么这个tag可以使用 .string 得到子节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title_tag.string</span><br><span class="line"><span class="comment"># u'The Dormouse's story'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head_tag.contents</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">head_tag.string</span><br><span class="line"><span class="comment"># u'The Dormouse's story'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果tag包含了多个子节点,tag就无法确定 .string 方法应该调用哪个子节点的内容, .string 的输出结果是 None :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.html.string)</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>.stings和stipped_strings<br>&ensp;&ensp;如果tag中包含多个字符串 ,可以使用 .strings 来循环获取:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.strings:</span><br><span class="line">    print(repr(string))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br><span class="line">    <span class="comment"># u'\n\n'</span></span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br><span class="line">    <span class="comment"># u'\n\n'</span></span><br><span class="line">    <span class="comment"># u'Once upon a time there were three little sisters; and their names were\n'</span></span><br><span class="line">    <span class="comment"># u'Elsie'</span></span><br><span class="line">    <span class="comment"># u',\n'</span></span><br><span class="line">    <span class="comment"># u'Lacie'</span></span><br><span class="line">    <span class="comment"># u' and\n'</span></span><br><span class="line">    <span class="comment"># u'Tillie'</span></span><br><span class="line">    <span class="comment"># u';\nand they lived at the bottom of a well.'</span></span><br><span class="line">    <span class="comment"># u'\n\n'</span></span><br><span class="line">    <span class="comment"># u'...'</span></span><br><span class="line">    <span class="comment"># u'\n'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.stripped_strings:</span><br><span class="line">    print(repr(string))</span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br><span class="line">    <span class="comment"># u'Once upon a time there were three little sisters; and their names were'</span></span><br><span class="line">    <span class="comment"># u'Elsie'</span></span><br><span class="line">    <span class="comment"># u','</span></span><br><span class="line">    <span class="comment"># u'Lacie'</span></span><br><span class="line">    <span class="comment"># u'and'</span></span><br><span class="line">    <span class="comment"># u'Tillie'</span></span><br><span class="line">    <span class="comment"># u';\nand they lived at the bottom of a well.'</span></span><br><span class="line">    <span class="comment"># u'...'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;全部是空格的行会被忽略掉,段首和段末的空白会被删除。</p>
<p>###父节点<br>&ensp;&ensp;每个tag或字符串都有父节点:被包含在某个tag中.</p>
<ol>
<li>.parent </li>
</ol>
<p>&ensp;&ensp;通过 .parent 属性来获取某个元素的父节点.在例子“爱丽丝”的文档中,<head>标签是<title>标签的父节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title_tag = soup.title</span><br><span class="line">title_tag</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line">title_tag.parent</span><br><span class="line"><span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br></pre></td></tr></table></figure></title></head></p>
<p>&ensp;&ensp;文档title的字符串也有父节点:<title>标签<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title_tag.string.parent</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br></pre></td></tr></table></figure></title></p>
<p>&ensp;&ensp;文档的顶层节点比如<html>的父节点是 BeautifulSoup 对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html_tag = soup.html</span><br><span class="line">type(html_tag.parent)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.BeautifulSoup'&gt;</span></span><br></pre></td></tr></table></figure></html></p>
<p>&ensp;&ensp;BeautifulSoup 对象的 .parent 是None:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.parent)</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>.parents</li>
</ol>
<p>&ensp;&ensp;通过元素的 .parents 属性可以递归得到元素的所有父辈节点,下面的例子使用了 .parents 方法遍历了a标签到根节点的所有节点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">link = soup.a</span><br><span class="line">link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> link.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># [document]</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<p>###兄弟节点<br>&ensp;&ensp;节点同属于同一个元素的子节点,那么这些节点可以被称为兄弟节点。一段文档以标准格式输出时，兄弟节点有相同的缩进级别。在代码中也可以使用这种关系。</p>
<ol>
<li>.next_sibling和.previous_sibling</li>
</ol>
<p>&ensp;&ensp;在文档树中,使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sibling_soup = BeautifulSoup(<span class="string">"&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sibling_soup.b.next_sibling</span><br><span class="line"><span class="comment"># &lt;c&gt;text2&lt;/c&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sibling_soup.c.previous_sibling</span><br><span class="line"><span class="comment"># &lt;b&gt;text1&lt;/b&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;b标签有 .next_sibling 属性,但是没有 .previous_sibling 属性,因为b标签在同级节点中是第一个.同理,c标签有 .previous_sibling 属性,却没有 .next_sibling 属性:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(sibling_soup.b.previous_sibling)</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">print(sibling_soup.c.next_sibling)</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;例子中的字符串“text1”和“text2”不是兄弟节点,因为它们的父节点不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sibling_soup.b.string</span><br><span class="line"><span class="comment"># u'text1'</span></span><br><span class="line"></span><br><span class="line">print(sibling_soup.b.string.next_sibling)</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>.next_siblings 和 .previous_siblings</li>
</ol>
<p>&ensp;&ensp;通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next_siblings:</span><br><span class="line">    print(repr(sibling))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># u',\n'</span></span><br><span class="line">    <span class="comment"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u' and\n'</span></span><br><span class="line">    <span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u'; and they lived at the bottom of a well.'</span></span><br><span class="line">    <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.find(id=<span class="string">"link3"</span>).previous_siblings:</span><br><span class="line">    print(repr(sibling))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ' and\n'</span></span><br><span class="line">    <span class="comment"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u',\n'</span></span><br><span class="line">    <span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u'Once upon a time there were three little sisters; and their names were\n'</span></span><br><span class="line">    <span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<p>###回退和前进</p>
<ol>
<li>.next_element 和 .previous_element<br>&ensp;&ensp;.next_element 属性指向解析过程中下一个被解析的对象(字符串或tag),结果可能与 .next_sibling 相同,但通常是不一样的.<br>&ensp;&ensp;这是“爱丽丝”文档中最后一个a标签,它的 .next_sibling 结果是一个字符串,因为当前的解析过程 [2] 因为当前的解析过程因为遇到了a标签而中断了:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">last_a_tag = soup.find(<span class="string">"a"</span>, id=<span class="string">"link3"</span>)</span><br><span class="line"><span class="keyword">print</span> last_a_tag</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> last_a_tag.next_sibling</span><br><span class="line"><span class="comment"># '; and they lived at the bottom of a well.'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;但这个a标签的 .next_element 属性结果是在a标签被解析之后的解析内容，不是a标签后的句子部分,应该是字符串”Tillie”:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> last_a_tag.next_element</span><br><span class="line"><span class="comment"># u'Tillie'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这是因为在原始文档中,字符串“Tillie” 在分号前出现,解析器先进入a标签,然后是字符串“Tillie”,然后关闭a标签,然后是分号和剩余部分.分号与a标签在同一层级,但是字符串“Tillie”会被先解析.</p>
<p>&ensp;&ensp;.previous_element 属性刚好与 .next_element 相反,它指向当前被解析的对象的前一个解析对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> last_a_tag.previous_element</span><br><span class="line"><span class="comment"># u' and\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> last_a_tag.previous_element.next_element</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>.next_elements 和 .previous_elements</li>
</ol>
<p>&ensp;&ensp;通过 .next_elements 和 .previous_elements 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> last_a_tag.next_elements:</span><br><span class="line">    print(repr(element))</span><br><span class="line"><span class="comment"># u'Tillie'</span></span><br><span class="line"><span class="comment"># u';\nand they lived at the bottom of a well.'</span></span><br><span class="line"><span class="comment"># u'\n\n'</span></span><br><span class="line"><span class="comment"># &lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="comment"># u'...'</span></span><br><span class="line"><span class="comment"># u'\n'</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<p>###搜索文档树<br>&ensp;&ensp;Beautiful Soup定义了很多搜索方法，这里着重介绍2个: find() 和 find_all() ，其它方法的参数和用法类似,请读者举一反三。</p>
<ol>
<li>过滤器</li>
</ol>
<p>&ensp;&ensp;介绍 find_all() 方法前，先介绍一下过滤器的类型 ，这些过滤器贯穿整个搜索的API。过滤器可以被用在tag的name中,节点的属性中，字符串中或他们的混合中。</p>
<ul>
<li>字符串：最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的b标签:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse's story&lt;/b&gt;]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&ensp;&ensp;如果传入字节码参数，Beautiful Soup会当作UTF-8编码，可以传入一段Unicode 编码来避免Beautiful Soup解析编码出错。</p>
<ul>
<li>正则表达式：如果传入正则表达式作为参数，Beautiful Soup会通过正则表达式的 match() 来匹配内容。下面例子中找出所有以b开头的标签,这表示body和b标签都应该被找到:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.compile(<span class="string">"^b"</span>)):</span><br><span class="line">    print(tag.name)</span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># b</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面代码找出所有名字中包含”t”的标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.compile(<span class="string">"t"</span>)):</span><br><span class="line">    print(tag.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># title</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>列表 </li>
</ol>
<p>&ensp;&ensp;如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有a标签和b标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all([<span class="string">"a"</span>, <span class="string">"b"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse's story&lt;/b&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>True</li>
</ol>
<p>&ensp;&ensp;True 可以匹配任何值,下面代码查找到所有的tag，但是不会返回字符串节点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="keyword">True</span>):</span><br><span class="line">    print(tag.name)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># head</span></span><br><span class="line"><span class="comment"># title</span></span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># b</span></span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># p</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>方法</li>
</ol>
<p>&ensp;&ensp;如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数  ，如果这个方法返回 True 表示当前元素匹配并且被找到，如果不是则反回 False。<br>&ensp;&ensp;下面方法校验了当前元素，如果包含 class 属性却不包含 id 属性，那么将返回 True:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_class_but_no_id</span><span class="params">(tag)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;将这个方法作为参数传入 find_all() 方法,将得到所有p标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(has_class_but_no_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p class="story"&gt;Once upon a time there were...&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p class="story"&gt;...&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;返回结果中只有p标签没有a标签,因为a标签还定义了”id”,没有返回html和head，因为html和head中没有定义”class”属性.<br>&ensp;&ensp;通过一个方法来过滤一类标签属性的时候, 这个方法的参数是要被过滤的属性的值, 而不是这个标签. 下面的例子是找出 href 属性不符合指定正则的 a 标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_lacie</span><span class="params">(href)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> href <span class="keyword">and</span> <span class="keyword">not</span> re.compile(<span class="string">"lacie"</span>).search(href)</span><br><span class="line">        </span><br><span class="line">soup.find_all(href=not_lacie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;标签过滤方法可以使用复杂方法. 下面的例子可以过滤出前后都有文字的标签.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> NavigableString</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">surrounded_by_strings</span><span class="params">(tag)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (isinstance(tag.next_element, NavigableString)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">and</span> isinstance(tag.previous_element, NavigableString))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(surrounded_by_strings):</span><br><span class="line">    <span class="keyword">print</span> tag.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># p</span></span><br></pre></td></tr></table></figure></p>
<p>##find_all()方法剖析<br>find_all( name , attrs , recursive , string , **kwargs )</p>
<p>find_all() 方法搜索当前tag的所有tag子节点，并判断是否符合过滤器的条件。</p>
<ol>
<li>name参数</li>
</ol>
<p>&ensp;&ensp;name 参数可以查找所有名字为 name 的tag，字符串对象会被自动忽略掉。<br>&ensp;&ensp;<strong>重申:</strong> 搜索 name 参数的值可以使任一类型的 过滤器 ，字符窜，正则表达式，列表，方法或是 True 。</p>
<ol>
<li>keyword 参数</li>
</ol>
<p>&ensp;&ensp;如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数，Beautiful Soup会搜索每个tag的”id”属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(id=<span class="string">'link2'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果传入 href 参数，Beautiful Soup会搜索每个tag的”href”属性:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(href=re.compile(<span class="string">"elsie"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;<strong>重申:</strong>搜索指定名字的属性时可以使用的参数值包括 字符串 , 正则表达式 , 列表, True 。<br>&ensp;&ensp;使用多个指定名字的参数可以同时过滤tag的多个属性:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(href=re.compile(<span class="string">"elsie"</span>), id=<span class="string">'link1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;three&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>attrs<br>&ensp;&ensp;有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_soup = BeautifulSoup(<span class="string">'&lt;div data-foo="value"&gt;foo!&lt;/div&gt;'</span>)</span><br><span class="line">data_soup.find_all(data-foo=<span class="string">"value"</span>)</span><br><span class="line"><span class="comment"># SyntaxError: keyword can't be an expression</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_soup.find_all(attrs=&#123;<span class="string">"data-foo"</span>: <span class="string">"value"</span>&#125;)</span><br><span class="line"><span class="comment"># [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>按CSS搜索</li>
</ol>
<p>&ensp;&ensp;按照CSS类名搜索tag的功能非常实用，但标识CSS类名的关键字 class 在Python中是保留字，使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">"a"</span>, class_=<span class="string">"sister"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>重申:</strong>class_ 参数同样接受不同类型的 过滤器 ,字符串,正则表达式,方法或 True :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(class_=re.compile(<span class="string">"itl"</span>))</span><br><span class="line"><span class="comment"># [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_six_characters</span><span class="params">(css_class)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> css_class <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> len(css_class) == <span class="number">6</span></span><br><span class="line"></span><br><span class="line">soup.find_all(class_=has_six_characters)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;tag的 class 属性是 多值属性 。按照CSS类名搜索tag时，可以分别搜索tag中的每个CSS类名:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line">css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"strikeout"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span></span><br><span class="line">css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"body"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>搜索 class 属性时也可以通过CSS值完全匹配:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"body strikeout"</span>)</span><br><span class="line"><span class="comment"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>完全匹配 class 的值时，如果CSS类名的顺序与实际不符，将搜索不到结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">"a"</span>, attrs=&#123;<span class="string">"class"</span>: <span class="string">"sister"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>string 参数</li>
</ol>
<p>&ensp;&ensp;通过 string 参数可以搜搜文档中的字符串内容。与 name 参数的可选值一样,，<strong>重申</strong>string 参数接受 字符串 , 正则表达式 , 列表, True . 看例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(string=<span class="string">"Elsie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [u'Elsie']</span></span><br><span class="line"></span><br><span class="line">soup.find_all(string=[<span class="string">"Tillie"</span>, <span class="string">"Elsie"</span>, <span class="string">"Lacie"</span>])</span><br><span class="line"><span class="comment"># [u'Elsie', u'Lacie', u'Tillie']</span></span><br><span class="line"></span><br><span class="line">soup.find_all(string=re.compile(<span class="string">"Dormouse"</span>))</span><br><span class="line"></span><br><span class="line">[<span class="string">u"The Dormouse's story"</span>, <span class="string">u"The Dormouse's story"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_the_only_string_within_a_tag</span><span class="params">(s)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">""</span>Return <span class="keyword">True</span> <span class="keyword">if</span> this string <span class="keyword">is</span> the only child of its parent tag.<span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> (s == s.parent.string)</span><br><span class="line"></span><br><span class="line">soup.find_all(string=is_the_only_string_within_a_tag)</span><br><span class="line"><span class="comment"># [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;虽然 string 参数用于搜索字符串，还可以与其它参数混合使用来过滤tag。Beautiful Soup会找到 .string 方法与 string 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的a标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">"a"</span>, string=<span class="string">"Elsie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>limit 参数</li>
</ol>
<p>&ensp;&ensp;find_all() 方法返回全部的搜索结构，如果文档树很大那么搜索会很慢；如果我们不需要全部结果，可以使用 limit 参数限制返回结果的数量。效果与SQL中的limit关键字类似，当搜索到的结果数量达到 limit 的限制时，就停止搜索返回结果。<br>&ensp;&ensp;文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">"a"</span>, limit=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>recuresive参数<br>&ensp;&ensp;调用tag的 find_all() 方法时，Beautiful Soup会检索当前tag的所有子孙节点，如果只想搜索tag的直接子节点，可以使用参数 recursive=False 。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.html.find_all(<span class="string">"title"</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.html.find_all(<span class="string">"title"</span>, recursive=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong>Beautiful Soup 提供了多种DOM树搜索方法。这些方法都使用了类似的参数定义。 比如这些方法: find_all(): name, attrs, text, limit. 但是只有 find_all() 和 find() 支持 recursive 参数。</p>
<ol>
<li>像调用 find_all() 一样调用tag</li>
</ol>
<p>&ensp;&ensp;find_all() 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 find_all() 方法相同,下面两行代码是等价的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">"a"</span>)</span><br><span class="line">soup(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">soup.title.find_all(string=<span class="keyword">True</span>)</span><br><span class="line">soup.title(string=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>##find()方法剖析<br>find( name , attrs , recursive , string , **kwargs )</p>
<p>&ensp;&ensp;find_all() 方法将返回文档中符合条件的所有tag，尽管有时候我们只想得到一个结果.比如文档中只有一个<body>标签,那么使用 find_all() 方法来查找body标签就不太合适， 使用 find_all 方法并设置 limit=1 参数不如直接使用 find() 方法。下面两行代码是等价的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'title'</span>, limit=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.find(<span class="string">'title'</span>)</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br></pre></td></tr></table></figure></body></p>
<p>&ensp;&ensp;唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表，而 find() 方法直接返回结果。<br>&ensp;&ensp;find_all() 方法没有找到目标是返回空列表，find() 方法找不到目标时，返回 None 。</p>
<p>##find_parents() 和 find_parent()<br>find_parents( name , attrs , recursive , string , <strong>kwargs )<br>find_parent( name , attrs , recursive , string , </strong>kwargs )</p>
<p>&ensp;&ensp;我们已经用了很大篇幅来介绍 find_all() 和 find() 方法,Beautiful Soup中还有10个用于搜索的API.它们中的五个用的是与 find_all() 相同的搜索参数,另外5个与 find() 方法的搜索参数类似.区别仅是它们搜索文档的不同部分.</p>
<p>&ensp;&ensp;记住: find_all() 和 find() 只搜索当前节点的所有子节点,孙子节点等. find_parents() 和 find_parent() 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容. 我们从一个文档中的一个叶子节点开始:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">a_string = soup.find(string=<span class="string">"Lacie"</span>)</span><br><span class="line"></span><br><span class="line">a_string</span><br><span class="line"></span><br><span class="line"><span class="comment"># u'Lacie'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_string.find_parents(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_string.find_parent(<span class="string">"p"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_string.find_parents("p", class="title")</span><br><span class="line"></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;文档中的一个a标签是是当前叶子节点的直接父节点,所以可以被找到.还有一个p标签,是目标叶子节点的间接父辈节点,所以也可以被找到.包含class值为”title”的p标签不是不是目标叶子节点的父辈节点,所以通过 find_parents() 方法搜索不到.</p>
<p>&ensp;&ensp;find_parent() 和 find_parents() 方法会让人联想到 .parent 和 .parents 属性.它们之间的联系非常紧密.搜索父辈节点的方法实际上就是对 .parents 属性的迭代搜索.</p>
<p>##find_next_siblings()和find_next_sibling()<br>find_next_siblings( name , attrs , recursive , string , **kwargs )</p>
<p>find_next_sibling( name , attrs , recursive , string , **kwargs )</p>
<p>&ensp;&ensp;这2个方法通过 .next_siblings 属性对当tag的所有后面解析 的兄弟tag节点进行迭代, find_next_siblings() 方法返回所有符合条件的后面的兄弟节点, find_next_sibling() 只返回符合条件的后面的第一个tag节点.</p>
<p>##find_previous_siblings() 和 find_previous_sibling()<br>find_previous_siblings( name , attrs , recursive , string , <strong>kwargs )<br>find_previous_sibling( name , attrs , recursive , string , </strong>kwargs )</p>
<p>&ensp;&ensp;这2个方法通过 .previous_siblings 属性对当前tag的前面解析 的兄弟tag节点进行迭代, find_previous_siblings() 方法返回所有符合条件的前面的兄弟节点, find_previous_sibling() 方法返回第一个符合条件的前面的兄弟节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">last_link = soup.find(<span class="string">"a"</span>, id=<span class="string">"link3"</span>)</span><br><span class="line"></span><br><span class="line">last_link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">last_link.find_previous_siblings(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">first_story_paragraph = soup.find(<span class="string">"p"</span>, <span class="string">"story"</span>)</span><br><span class="line">first_story_paragraph.find_previous_sibling(<span class="string">"p"</span>)</span><br><span class="line"><span class="comment"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>##find_all_next() 和 find_next()<br>&ensp;&ensp;这2个方法通过 .next_elements 属性对当前tag的之后的 tag和字符串进行迭代, find_all_next() 方法返回所有符合条件的节点, find_next() 方法返回第一个符合条件的节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first_link = soup.a</span><br><span class="line">first_link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">first_link.find_all_next(string=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># [u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',</span></span><br><span class="line"><span class="comment">#  u';\nand they lived at the bottom of a well.', u'\n\n', u'...', u'\n']</span></span><br><span class="line"></span><br><span class="line">first_link.find_next(<span class="string">"p"</span>)</span><br><span class="line"><span class="comment"># &lt;p class="story"&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;第一个例子中,字符串 “Elsie”也被显示出来,尽管它被包含在我们开始查找的a标签的里面.第二个例子中,最后一个p标签也被显示出来,尽管它与我们开始查找位置的a标签不属于同一部分.例子中,搜索的重点是要匹配过滤器的条件,并且在文档中出现的顺序而不是开始查找的元素的位置.</p>
<p>##find_all_previous() 和 find_previous()<br>find_all_previous( name , attrs , recursive , string , <strong>kwargs )<br>find_previous( name , attrs , recursive , string , </strong>kwargs )</p>
<p>&ensp;&ensp;这2个方法通过 .previous_elements 属性对当前节点前面 的tag和字符串进行迭代, find_all_previous() 方法返回所有符合条件的节点, find_previous() 方法返回第一个符合条件的节点.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first_link = soup.a</span><br><span class="line">first_link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">first_link.find_all_previous(<span class="string">"p"</span>)</span><br><span class="line"><span class="comment"># [&lt;p class="story"&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]</span></span><br><span class="line"></span><br><span class="line">first_link.find_previous(<span class="string">"title"</span>)</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;find_all_previous(“p”) 返回了文档中的第一段(class=”title”的那段),但还返回了第二段,p标签包含了我们开始查找的a标签.不要惊讶,这段代码的功能是查找所有出现在指定a标签之前的p标签,因为这个p标签包含了开始的a标签,所以p标签一定是在a之前出现的.</p>
<p>##CSS选择器<br>Beautiful Soup支持大部分的CSS<a href="http://www.w3.org/TR/CSS2/selector.html" target="_blank" rel="noopener">选择器</a> , 在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"title"</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"p nth-of-type(3)"</span>)</span><br><span class="line"><span class="comment"># [&lt;p class="story"&gt;...&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过tag标签逐层查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"body a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie"  id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"html head title"</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>找到某个tag标签下的直接子标签 :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"head &gt; title"</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"p &gt; a"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie"  id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"p &gt; a:nth-of-type(2)"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"p &gt; #link1"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"body &gt; a"</span>)</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure></p>
<p>找到兄弟节点标签:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"#link1 ~ .sister"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie"  id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"#link1 + .sister"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过CSS的类名查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过CSS的类名查找:</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">".sister"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"[class~=sister]"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过tag的id查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"#link1"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">"a#link2"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>同时用多种CSS选择器查询元素:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">"#link1,#link2"</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过是否存在某个属性来查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">'a[href]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过属性的值来查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">'a[href="http://example.com/elsie"]'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">'a[href^="http://example.com/"]'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">'a[href$="tillie"]'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">'a[href*=".com/el"]'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>通过语言设置来查找:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multilingual_markup = <span class="string">"""</span></span><br><span class="line"><span class="string"> &lt;p lang="en"&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang="fr"&gt;Bonjour mes amis&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">multilingual_soup = BeautifulSoup(multilingual_markup)</span><br><span class="line">multilingual_soup.select(<span class="string">'p[lang|=en]'</span>)</span><br><span class="line"><span class="comment"># [&lt;p lang="en"&gt;Hello&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>返回查找到的元素的第一个:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select_one(<span class="string">".sister"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;对于熟悉CSS选择器语法的人来说这是个非常方便的方法.Beautiful Soup也支持CSS选择器API, 如果你仅仅需要CSS选择器的功能,那么直接使用 lxml 也可以, 而且速度更快,支持更多的CSS选择器语法,但Beautiful Soup整合了CSS选择器的语法和自身方便使用API。</p>
<p>##修改文档树<br>BeautifuSoup的<strong>强项是文档树的搜索</strong>，当同时也可以方便的修改文档树。</p>
<ol>
<li>修改tag的名称和属性</li>
</ol>
<p>&ensp;&ensp;在 Attributes 的章节中已经介绍过这个功能,但是再看一遍也无妨. 重命名一个tag,改变属性的值,添加或删除属性:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span>)</span><br><span class="line">tag = soup.b</span><br><span class="line">tag.name = <span class="string">"blockquote"</span></span><br><span class="line">tag[<span class="string">'class'</span>] = <span class="string">'verybold'</span></span><br><span class="line">tag[<span class="string">'id'</span>] = <span class="number">1</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'class'</span>]</span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'id'</span>]</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>修改.string</li>
</ol>
<p>&ensp;&ensp;给tag的 .string 属性赋值,就相当于用当前的内容替代了原来的内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">tag = soup.a</span><br><span class="line">tag.string = <span class="string">"New link text."</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;New link text.&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong> 如果当前的tag包含了其它tag，那么给它的 .string 属性赋值会覆盖掉原有的所有内容包括子tag。</p>
<ol>
<li><p>append()<br>&ensp;&ensp;Tag.append() 方法想tag中添加内容,就好像Python的列表的 .append() 方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&lt;a&gt;Foo&lt;/a&gt;"</span>)</span><br><span class="line">soup.a.append(<span class="string">"Bar"</span>)</span><br><span class="line">soup</span><br><span class="line"><span class="comment"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line">soup.a.contents</span><br><span class="line"><span class="comment"># [u'Foo', u'Bar']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NavigableString() 和 .new_tag()</p>
</li>
</ol>
<p>&ensp;&ensp;如果想添加一段文本内容到文档中也没问题,可以调用Python的 append() 方法 或调用 NavigableString 的构造方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>)</span><br><span class="line">tag = soup.b</span><br><span class="line">tag.append(<span class="string">"Hello"</span>)</span><br><span class="line">new_string = NavigableString(<span class="string">" there"</span>)</span><br><span class="line">tag.append(new_string)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;b&gt;Hello there.&lt;/b&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u'Hello', u' there']</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果想要创建一段注释,或 NavigableString 的任何子类, 只要调用 NavigableString 的构造方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> Comment</span><br><span class="line">new_comment = soup.new_string(<span class="string">"Nice to see you."</span>, Comment)</span><br><span class="line">tag.append(new_comment)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u'Hello', u' there', u'Nice to see you.']</span></span><br></pre></td></tr></table></figure></p>
<p><strong>这是Beautiful Soup 4.2.1 中新增的方法</strong></p>
<ul>
<li>创建一个tag最好的方法是调用工厂方法 BeautifulSoup.new_tag() :</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>)</span><br><span class="line">original_tag = soup.b</span><br><span class="line">new_tag = soup.new_tag(<span class="string">"a"</span>, href=<span class="string">"http://www.example.com"</span>)</span><br><span class="line">original_tag.append(new_tag)</span><br><span class="line">original_tag</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;&lt;/a&gt;&lt;/b&gt;</span></span><br><span class="line">new_tag.string = <span class="string">"Link text."</span></span><br><span class="line">original_tag</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;第一个参数作为tag的name,是必填,其它参数选填。</p>
<ol>
<li>insert()</li>
</ol>
<p>&ensp;&ensp;Tag.insert() 方法与 Tag.append() 方法类似,区别是不会把新元素添加到父节点 .contents 属性的最后,而是把元素插入到指定的位置.与Python列表总的 .insert() 方法的用法下同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">tag = soup.a</span><br><span class="line">tag.insert(<span class="number">1</span>, <span class="string">"but did not endorse "</span>)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u'I linked to ', u'but did not endorse', &lt;i&gt;example.com&lt;/i&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>insert_before()和insert_after()</li>
</ol>
<p>insert_before() 方法在当前tag或文本节点前插入内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&lt;b&gt;stop&lt;/b&gt;"</span>)</span><br><span class="line">tag = soup.new_tag(<span class="string">"i"</span>)</span><br><span class="line">tag.string = <span class="string">"Don't"</span></span><br><span class="line">soup.b.string.insert_before(tag)</span><br><span class="line">soup.b</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>insert_after() 方法在当前tag或文本节点后插入内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.b.i.insert_after(soup.new_string(<span class="string">" ever "</span>))</span><br><span class="line">soup.b</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; ever stop&lt;/b&gt;</span></span><br><span class="line">soup.b.contents</span><br><span class="line"><span class="comment"># [&lt;i&gt;Don't&lt;/i&gt;, u' ever ', u'stop']</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>clear()</li>
</ol>
<p>Tag.clear() 方法移除当前tag的内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">tag = soup.a</span><br><span class="line">tag.clear()</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>extract()</li>
</ol>
<p>PageElement.extract() 方法将当前tag移除文档树,并作为方法结果返回:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line">i_tag = soup.i.extract()</span><br><span class="line">a_tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;I linked to&lt;/a&gt;</span></span><br><span class="line">i_tag</span><br><span class="line"><span class="comment"># &lt;i&gt;example.com&lt;/i&gt;</span></span><br><span class="line">print(i_tag.parent)</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法实际上产生了2个文档树: 一个是用来解析原始文档的 BeautifulSoup 对象,另一个是被移除并且返回的tag.被移除并返回的tag可以继续调用 extract 方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_string = i_tag.string.extract()</span><br><span class="line">my_string</span><br><span class="line"><span class="comment"># u'example.com'</span></span><br><span class="line">print(my_string.parent)</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line">i_tag</span><br><span class="line"><span class="comment"># &lt;i&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>decompose()</li>
</ol>
<p>Tag.decompose() 方法将当前节点移除文档树并完全销毁:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line">soup.i.decompose()</span><br><span class="line">a_tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;I linked to&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>replace_with()</li>
</ol>
<p>PageElement.replace_with() 方法移除文档树中的某段内容,并用新tag或文本节点替代它:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line">new_tag = soup.new_tag(<span class="string">"b"</span>)</span><br><span class="line">new_tag.string = <span class="string">"example.net"</span></span><br><span class="line">a_tag.i.replace_with(new_tag)</span><br><span class="line">a_tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>replace_with() 方法<strong>返回</strong>被替代的tag或文本节点,可以用来浏览或添加到文档树其它地方.</p>
<ol>
<li><p>wrap()</p>
<p>PageElement.wrap() 方法可以对指定的tag元素进行包装 ,并返回包装后的结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&lt;p&gt;I wish I was bold.&lt;/p&gt;"</span>)</span><br><span class="line">soup.p.string.wrap(soup.new_tag(<span class="string">"b"</span>))</span><br><span class="line"><span class="comment"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span></span><br><span class="line">soup.p.wrap(soup.new_tag(<span class="string">"div"</span>))</span><br><span class="line"><span class="comment"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong>该方法在 Beautiful Soup 4.0.5 中添加</p>
<ol>
<li>unwra()<br>Tag.unwrap() 方法与 wrap() 方法相反.将移除tag内的所有tag标签,该方法常被用来进行标记的解包:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line">a_tag.i.unwrap()</span><br><span class="line">a_tag</span><br><span class="line"><span class="comment"># &lt;a href="http://example.com/"&gt;I linked to example.com&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>与 replace_with() 方法相同, unwrap() 方法返回被移除的tag</p>
<p>##输出</p>
<ol>
<li>格式化输出</li>
</ol>
<p>&ensp;&ensp;prettify() 方法将Beautiful Soup的文档树格式化后以Unicode编码输出,每个XML/HTML标签都独占一行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">soup.prettify()</span><br><span class="line"><span class="comment"># '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href="http://example.com/"&gt;\n...'</span></span><br><span class="line">print(soup.prettify())</span><br><span class="line"><span class="comment"># &lt;html&gt;</span></span><br><span class="line"><span class="comment">#  &lt;head&gt;</span></span><br><span class="line"><span class="comment">#  &lt;/head&gt;</span></span><br><span class="line"><span class="comment">#  &lt;body&gt;</span></span><br><span class="line"><span class="comment">#   &lt;a href="http://example.com/"&gt;</span></span><br><span class="line"><span class="comment">#    I linked to</span></span><br><span class="line"><span class="comment">#    &lt;i&gt;</span></span><br><span class="line"><span class="comment">#     example.com</span></span><br><span class="line"><span class="comment">#    &lt;/i&gt;</span></span><br><span class="line"><span class="comment">#   &lt;/a&gt;</span></span><br><span class="line"><span class="comment">#  &lt;/body&gt;</span></span><br><span class="line"><span class="comment"># &lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>BeautifulSoup 对象和它的tag节点都可以调用 prettify() 方法.</p>
<ol>
<li>压缩输出</li>
</ol>
<p>&ensp;&ensp;如果只想得到结果字符串,不重视格式,那么可以对一个 BeautifulSoup 对象或 Tag 对象使用Python的 unicode() 或 str() 方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str(soup)</span><br><span class="line"><span class="comment"># '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line">unicode(soup.a)</span><br><span class="line"><span class="comment"># u'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;str() 方法返回UTF-8编码的字符串,可以指定 编码 的设置.还可以调用 encode() 方法获得字节码或调用 decode() 方法获得Unicode.</p>
<ol>
<li>输出格式</li>
</ol>
<p>Beautiful Soup输出是会将HTML中的特殊字符转换成Unicode,比如“&lquot;”:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">"&amp;ldquo;Dammit!&amp;rdquo; he said."</span>)</span><br><span class="line">unicode(soup)</span><br><span class="line"><span class="comment"># u'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果将文档转换成字符串,Unicode编码会被编码成UTF-8.这样就无法正确显示HTML特殊字符了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str(soup)</span><br><span class="line"><span class="comment"># '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>get_text()</li>
</ol>
<p>如果只想得到tag中包含的文本内容,那么可以调用 get_text() 方法,这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">'&lt;a href="http://example.com/"&gt;\nI linked to &lt;i&gt;example.com&lt;/i&gt;\n&lt;/a&gt;'</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">soup.get_text()</span><br><span class="line"><span class="string">u'\nI linked to example.com\n'</span></span><br><span class="line">soup.i.get_text()</span><br><span class="line"><span class="string">u'example.com'</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过参数指定tag的文本内容的分隔符:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># soup.get_text("|")</span></span><br><span class="line"><span class="string">u'\nI linked to |example.com|\n'</span></span><br></pre></td></tr></table></figure></p>
<p>还可以去除获得文本内容的前后空白:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># soup.get_text("|", strip=True)</span></span><br><span class="line"><span class="string">u'I linked to|example.com'</span></span><br></pre></td></tr></table></figure></p>
<p>或者使用 .stripped_strings 生成器,获得文本列表后手动处理列表:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[text <span class="keyword">for</span> text <span class="keyword">in</span> soup.stripped_strings]</span><br><span class="line"><span class="comment"># [u'I linked to', u'example.com']</span></span><br></pre></td></tr></table></figure></p>
<p>##解析器</p>
<ol>
<li>指定文档的解析器</li>
</ol>
<p>&ensp;&ensp;如果仅是想要解析HTML文档,只要用文档创建 BeautifulSoup 对象就可以了.Beautiful Soup会自动选择一个解析器来解析文档.但是还可以通过参数指定使用那种解析器来解析当前文档.</p>
<p>&ensp;&ensp;BeautifulSoup 第一个参数应该是要被解析的文档字符串或是文件句柄,第二个参数用来标识怎样解析文档.如果第二个参数为空,那么Beautiful Soup根据当前系统安装的库自动选择解析器,解析器的优先数序: lxml, html5lib, Python标准库.在下面两种条件下解析器优先顺序会变化:</p>
<ul>
<li>要解析的文档是什么类型: 目前支持, “html”, “xml”, 和 “html5”</li>
<li>指定使用哪种解析器: 目前支持, “lxml”, “html5lib”, 和 “html.parser”<br>&ensp;&ensp;安装解析器 章节介绍了可以使用哪种解析器,以及如何安装.</li>
</ul>
<p>&ensp;&ensp;如果指定的解析器没有安装,Beautiful Soup会自动选择其它方案.目前只有 lxml 解析器支持XML文档的解析,在没有安装lxml库的情况下,创建 beautifulsoup 对象时无论是否指定使用lxml,都无法得到解析后的对象。</p>
<ol>
<li>解析器之间的区别</li>
</ol>
<p>&ensp;&ensp;Beautiful Soup为不同的解析器提供了相同的接口,但解析器本身时有区别的.同一篇文档被不同的解析器解析后可能会生成不同结构的树型文档.区别最大的是HTML解析器和XML解析器,看下面片段被解析成HTML结构:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(<span class="string">"&lt;a&gt;&lt;b /&gt;&lt;/a&gt;"</span>)</span><br><span class="line"><span class="comment"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;因为空标签b不符合HTML标准，所以解析器把它解析成b&gt;/b<br>&ensp;&ensp;同样的文档使用XML解析如下(解析XML需要安装lxml库).注意,空标签b 依然被保留,并且文档前添加了XML头,而不是被包含在html标签内:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(<span class="string">"&lt;a&gt;&lt;b /&gt;&lt;/a&gt;"</span>, <span class="string">"xml"</span>)</span><br><span class="line"><span class="comment"># &lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="comment"># &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;HTML解析器之间也有区别,如果被解析的HTML文档是标准格式,那么解析器之间没有任何差别,只是解析速度不同,结果都会返回正确的文档树.</p>
<p>&ensp;&ensp;但是如果被解析文档不是标准格式,那么不同的解析器返回结果可能不同.下面例子中,使用lxml解析错误格式的文档,结果p标签被直接忽略掉了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(<span class="string">"&lt;a&gt;&lt;/p&gt;"</span>, <span class="string">"lxml"</span>)</span><br><span class="line"><span class="comment"># &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;使用html5lib库解析相同的文档会得到不同的结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(<span class="string">"&lt;a&gt;&lt;/p&gt;"</span>, <span class="string">"html5lib"</span>)</span><br><span class="line"><span class="comment"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;html5lib库没有忽略掉p标签,而是自动补全了标签,还给文档树添加了head标签.使用pyhton内置库解析结果如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(<span class="string">"&lt;a&gt;&lt;/p&gt;"</span>, <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment"># &lt;a&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;与lxml库类似的,Python内置库忽略掉了p标签,与html5lib库不同的是标准库没有尝试创建符合标准的文档格式或将文档片段包含在body标签内,与lxml不同的是标准库甚至连html标签都没有尝试去添加.<br>&ensp;&ensp;因为文档片段“a/p”是错误格式,所以以上解析方式都能算作”正确”,html5lib库使用的是HTML5的部分标准,所以最接近”正确”.不过所有解析器的结构都能够被认为是”正常”的.<br>&ensp;&ensp;不同的解析器可能影响代码执行结果,如果在分发给别人的代码中使用了 BeautifulSoup ,那么最好注明使用了哪种解析器,以减少不必要的麻烦.</p>
<p>##编码<br>&ensp;&ensp;任何HTML或XML文档都有自己的编码方式,比如ASCII 或 UTF-8,但是使用Beautiful Soup解析后,文档都被转换成了Unicode:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">"&lt;h1&gt;Sacr\xc3\xa9 bleu!&lt;/h1&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">soup.h1</span><br><span class="line"><span class="comment"># &lt;h1&gt;Sacré bleu!&lt;/h1&gt;</span></span><br><span class="line">soup.h1.string</span><br><span class="line"><span class="comment"># u'Sacr\xe9 bleu!'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这不是魔术(但很神奇),Beautiful Soup用了 编码自动检测 子库来识别当前文档编码并转换成Unicode编码. BeautifulSoup 对象的 .original_encoding 属性记录了自动识别编码的结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.original_encoding</span><br><span class="line"><span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;编码自动检测 功能大部分时候都能猜对编码格式,但有时候也会出错.有时候即使猜测正确,也是在逐个字节的遍历整个文档后才猜对的,这样很慢.如果预先知道文档编码,可以设置编码参数来减少自动检查编码出错的概率并且提高文档解析速度.在创建 BeautifulSoup 对象的时候设置 from_encoding 参数.<br>&ensp;&ensp;下面一段文档用了ISO-8859-8编码方式,这段文档太短,结果Beautiful Soup以为文档是用ISO-8859-7编码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">b"&lt;h1&gt;\xed\xe5\xec\xf9&lt;/h1&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">soup.h1</span><br><span class="line">&lt;h1&gt;νεμω&lt;/h1&gt;</span><br><span class="line">soup.original_encoding</span><br><span class="line"><span class="comment"># 'ISO-8859-7'</span></span><br></pre></td></tr></table></figure></p>
<p>通过传入 from_encoding 参数来指定编码方式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(markup, from_encoding=<span class="string">"iso-8859-8"</span>)</span><br><span class="line">soup.h1</span><br><span class="line">&lt;h1&gt;םולש&lt;/h1&gt;</span><br><span class="line">soup.original_encoding</span><br><span class="line"><span class="comment"># 'iso8859-8'</span></span><br></pre></td></tr></table></figure></p>
<p>&esnp;&ensp;如果仅知道文档采用了Unicode编码, 但不知道具体编码. 可以先自己猜测, 猜测错误(依旧是乱码)时, 可以把错误编码作为 exclude_encodings 参数, 这样文档就不会尝试使用这种编码了解码了. <strong>译者备注:</strong> 在没有指定编码的情况下, BS会自己猜测编码, 把不正确的编码排除掉, BS就更容易猜到正确编码.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(markup, exclude_encodings=[<span class="string">"ISO-8859-7"</span>])</span><br><span class="line">soup.h1</span><br><span class="line">&lt;h1&gt;םולש&lt;/h1&gt;</span><br><span class="line">soup.original_encoding</span><br><span class="line"><span class="comment"># 'WINDOWS-1255'</span></span><br></pre></td></tr></table></figure></p>
<p>&esnp;&ensp;猜测结果是 Windows-1255 编码, 猜测结果可能不够准确, 但是 Windows-1255 编码是 ISO-8859-8 的扩展集, 所以猜测结果已经十分接近了, 并且不影响使用. (exclude_encodings 参数是 4.4.0版本的新功能)</p>
<p>&esnp;&ensp;少数情况下(通常是UTF-8编码的文档中包含了其它编码格式的文件),想获得正确的Unicode编码就不得不将文档中少数特殊编码字符替换成特殊Unicode编码,“REPLACEMENT CHARACTER” (U+FFFD, �) [9] . 如果Beautifu Soup猜测文档编码时作了特殊字符的替换,那么Beautiful Soup会把 UnicodeDammit 或 BeautifulSoup 对象的 .contains_replacement_characters 属性标记为 True .这样就可以知道当前文档进行Unicode编码后丢失了一部分特殊内容字符.如果文档中包含�而 .contains_replacement_characters 属性是 False ,则表示�就是文档中原来的字符,不是转码失败.</p>
<ol>
<li>输出编码</li>
</ol>
<p>&esnp;&ensp;通过Beautiful Soup输出文档时,不管输入文档是什么编码方式,输出编码均为UTF-8编码,下面例子输入文档是Latin-1编码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">b'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type" /&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">print(soup.prettify())</span><br><span class="line"><span class="comment"># &lt;html&gt;</span></span><br><span class="line"><span class="comment">#  &lt;head&gt;</span></span><br><span class="line"><span class="comment">#   &lt;meta content="text/html; charset=utf-8" http-equiv="Content-type" /&gt;</span></span><br><span class="line"><span class="comment">#  &lt;/head&gt;</span></span><br><span class="line"><span class="comment">#  &lt;body&gt;</span></span><br><span class="line"><span class="comment">#   &lt;p&gt;</span></span><br><span class="line"><span class="comment">#    Sacré bleu!</span></span><br><span class="line"><span class="comment">#   &lt;/p&gt;</span></span><br><span class="line"><span class="comment">#  &lt;/body&gt;</span></span><br><span class="line"><span class="comment"># &lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&esnp;&ensp;注意,输出文档中的meta标签的编码设置已经修改成了与输出编码一致的UTF-8.</p>
<p>&esnp;&ensp;如果不想用UTF-8编码输出,可以将编码方式传入 prettify() 方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(soup.prettify(<span class="string">"latin-1"</span>))</span><br><span class="line"><span class="comment"># &lt;html&gt;</span></span><br><span class="line"><span class="comment">#  &lt;head&gt;</span></span><br><span class="line"><span class="comment">#   &lt;meta content="text/html; charset=latin-1" http-equiv="Content-type" /&gt;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;还可以调用 BeautifulSoup 对象或任意节点的 encode() 方法,就像Python的字符串调用 encode() 方法一样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.p.encode(<span class="string">"latin-1"</span>)</span><br><span class="line"><span class="comment"># '&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;'</span></span><br><span class="line">soup.p.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment"># '&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果文档中包含当前编码不支持的字符,那么这些字符将呗转换成一系列XML特殊字符引用,下面例子中包含了Unicode编码字符SNOWMAN:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">u"&lt;b&gt;\N&#123;SNOWMAN&#125;&lt;/b&gt;"</span></span><br><span class="line">snowman_soup = BeautifulSoup(markup)</span><br><span class="line">tag = snowman_soup.b</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;SNOWMAN字符在UTF-8编码中可以正常显示(看上去像是☃),但有些编码不支持SNOWMAN字符,比如ISO-Latin-1或ASCII,那么在这些编码中SNOWMAN字符会被转换成“&amp;#9731”:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(tag.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment"># &lt;b&gt;☃&lt;/b&gt;</span></span><br><span class="line"><span class="keyword">print</span> tag.encode(<span class="string">"latin-1"</span>)</span><br><span class="line"><span class="comment"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span></span><br><span class="line"><span class="keyword">print</span> tag.encode(<span class="string">"ascii"</span>)</span><br><span class="line"><span class="comment"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Unicode, Dammit! (乱码, 靠!)</li>
</ol>
<p>&ensp;&ensp;译者备注: UnicodeDammit 是BS内置库, 主要用来猜测文档编码.</p>
<p>&ensp;&ensp;编码自动检测 功能可以在Beautiful Soup以外使用,检测某段未知编码时,可以使用这个方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> UnicodeDammit</span><br><span class="line">dammit = UnicodeDammit(<span class="string">"Sacr\xc3\xa9 bleu!"</span>)</span><br><span class="line">print(dammit.unicode_markup)</span><br><span class="line"><span class="comment"># Sacré bleu!</span></span><br><span class="line">dammit.original_encoding</span><br><span class="line"><span class="comment"># 'utf-8'</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果Python中安装了 chardet 或 cchardet 那么编码检测功能的准确率将大大提高. 输入的字符越多,检测结果越精确,如果事先猜测到一些可能编码, 那么可以将猜测的编码作为参数,这样将优先检测这些编码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dammit = UnicodeDammit(<span class="string">"Sacr\xe9 bleu!"</span>, [<span class="string">"latin-1"</span>, <span class="string">"iso-8859-1"</span>])</span><br><span class="line">print(dammit.unicode_markup)</span><br><span class="line"><span class="comment"># Sacré bleu!</span></span><br><span class="line">dammit.original_encoding</span><br><span class="line"><span class="comment"># 'latin-1'</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>智能引导</li>
</ol>
<p>使用Unicode时,Beautiful Soup还会智能的把引号  转换成HTML或XML中的特殊字符:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">b"&lt;p&gt;I just \x93love\x94 Microsoft Word\x92s smart quotes&lt;/p&gt;"</span></span><br><span class="line">UnicodeDammit(markup, [<span class="string">"windows-1252"</span>], smart_quotes_to=<span class="string">"html"</span>).unicode_markup</span><br><span class="line"><span class="comment"># u'&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;'</span></span><br><span class="line">UnicodeDammit(markup, [<span class="string">"windows-1252"</span>], smart_quotes_to=<span class="string">"xml"</span>).unicode_markup</span><br><span class="line"><span class="comment"># u'&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>也可以把引号转换为ASCII码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDammit(markup, [<span class="string">"windows-1252"</span>], smart_quotes_to=<span class="string">"ascii"</span>).unicode_markup</span><br><span class="line"><span class="comment"># u'&lt;p&gt;I just "love" Microsoft Word\'s smart quotes&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>很有用的功能,但是Beautiful Soup没有使用这种方式.默认情况下,Beautiful Soup把引号转换成Unicode:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDammit(markup, [<span class="string">"windows-1252"</span>]).unicode_markup</span><br><span class="line"><span class="comment"># u'&lt;p&gt;I just \u201clove\u201d Microsoft Word\u2019s smart quotes&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>矛盾的编码</li>
</ol>
<p>&ensp;&ensp;有时文档的大部分都是用UTF-8,但同时还包含了Windows-1252编码的字符,就像微软的智能引号 一样. 一些包含多个信息的来源网站容易出现这种情况. UnicodeDammit.detwingle() 方法可以把这类文档转换成纯UTF-8编码格式,看个简单的例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">snowmen = (<span class="string">u"\N&#123;SNOWMAN&#125;"</span> * <span class="number">3</span>)</span><br><span class="line">quote = (<span class="string">u"\N&#123;LEFT DOUBLE QUOTATION MARK&#125;I like snowmen!\N&#123;RIGHT DOUBLE QUOTATION MARK&#125;"</span>)</span><br><span class="line">doc = snowmen.encode(<span class="string">"utf8"</span>) + quote.encode(<span class="string">"windows_1252"</span>)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这段文档很杂乱,snowmen是UTF-8编码,引号是Windows-1252编码,直接输出时不能同时显示snowmen和引号,因为它们编码不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(doc)</span><br><span class="line"><span class="comment"># ☃☃☃�I like snowmen!�</span></span><br><span class="line"></span><br><span class="line">print(doc.decode(<span class="string">"windows-1252"</span>))</span><br><span class="line"><span class="comment"># â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果对这段文档用UTF-8解码就会得到 UnicodeDecodeError 异常,如果用Windows-1252解码就回得到一堆乱码. 幸好, UnicodeDammit.detwingle() 方法会吧这段字符串转换成UTF-8编码,允许我们同时显示出文档中的snowmen和引号:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_doc = UnicodeDammit.detwingle(doc)</span><br><span class="line">print(new_doc.decode(<span class="string">"utf8"</span>))</span><br><span class="line"><span class="comment"># ☃☃☃“I like snowmen!”</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;UnicodeDammit.detwingle() 方法只能解码包含在UTF-8编码中的Windows-1252编码内容,但这解决了最常见的一类问题.</p>
<p>&ensp;&ensp;在创建 BeautifulSoup 或 UnicodeDammit 对象前一定要先对文档调用 UnicodeDammit.detwingle() 确保文档的编码方式正确.如果尝试去解析一段包含Windows-1252编码的UTF-8文档,就会得到一堆乱码,比如: â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”.<br>&ensp;&ensp;UnicodeDammit.detwingle() 方法在Beautiful Soup 4.1.0版本中新增</p>
<p>###比较对象是否相同<br>&ensp;&ensp;两个 NavigableString 或 Tag 对象具有相同的HTML或XML结构时, Beautiful Soup就判断这两个对象相同. 这个例子中, 2个 b标签在 BS 中是相同的, 尽管他们在文档树的不同位置, 但是具有相同的表象: “b pizza /b”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">"&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup, <span class="string">'html.parser'</span>)</span><br><span class="line">first_b, second_b = soup.find_all(<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">print</span> first_b == second_b</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> first_b.previous_element == second_b.previous_element</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></p>
<p>如果想判断两个对象是否严格的指向同一个对象可以通过 is 来判断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> first_b <span class="keyword">is</span> second_b</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></p>
<p>###复制Beautiful Soup对象<br>copy.copy() 方法可以复制任意 Tag 或 NavigableString 对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">p_copy = copy.copy(soup.p)</span><br><span class="line"><span class="keyword">print</span> p_copy</span><br><span class="line"><span class="comment"># &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>复制后的对象跟与对象是相等的, 但指向不同的内存地址<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.p == p_copy</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> soup.p <span class="keyword">is</span> p_copy</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;源对象和复制对象的区别是源对象在文档树中, 而复制后的对象是独立的还没有添加到文档树中. 复制后对象的效果跟调用了 extract() 方法相同.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> p_copy.parent</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为相等的对象不能同时插入相同的位置</p>
<p>###解析部分文档<br>&ensp;&ensp;如果仅仅因为想要查找文档中的a&gt;标签而将整片文档进行解析,实在是浪费内存和时间.最快的方法是从一开始就把a&gt;标签以外的东西都忽略掉. SoupStrainer 类可以定义文档的某段内容,这样搜索文档时就不必先解析整篇文档,只会解析在 SoupStrainer 中定义过的文档. 创建一个 SoupStrainer 对象并作为 parse_only 参数给 BeautifulSoup 的构造方法即可</p>
<ol>
<li>SoupStrainer<br>&ensp;&ensp;SoupStrainer 类接受与典型搜索方法相同的参数：name , attrs , recursive , string , **kwargs 。下面举例说明三种 SoupStrainer 对象：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> SoupStrainer</span><br><span class="line">only_a_tags = SoupStrainer(<span class="string">"a"</span>)</span><br><span class="line">only_tags_with_id_link2 = SoupStrainer(id=<span class="string">"link2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_short_string</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(string) &lt; <span class="number">10</span></span><br><span class="line">only_short_strings = SoupStrainer(string=is_short_string)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再拿“爱丽丝”文档来举例，来看看使用三种 SoupStrainer 对象做参数会有什么不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(BeautifulSoup(html_doc, <span class="string">"html.parser"</span>, parse_only=only_a_tags).prettify())</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span></span><br><span class="line"><span class="comment">#  Elsie</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span></span><br><span class="line"><span class="comment">#  Lacie</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span></span><br><span class="line"><span class="comment">#  Tillie</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br><span class="line">print(BeautifulSoup(html_doc, <span class="string">"html.parser"</span>, parse_only=only_tags_with_id_link2).prettify())</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span></span><br><span class="line"><span class="comment">#  Lacie</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br><span class="line">print(BeautifulSoup(html_doc, <span class="string">"html.parser"</span>, parse_only=only_short_strings).prettify())</span><br><span class="line"><span class="comment"># Elsie</span></span><br><span class="line"><span class="comment"># ,</span></span><br><span class="line"><span class="comment"># Lacie</span></span><br><span class="line"><span class="comment"># and</span></span><br><span class="line"><span class="comment"># Tillie</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>还可以将 SoupStrainer 作为参数传入 搜索文档树 中提到的方法.这可能不是个常用用法,所以还是提一下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html_doc)</span><br><span class="line">soup.find_all(only_short_strings)</span><br><span class="line"><span class="comment"># [u'\n\n', u'\n\n', u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',</span></span><br><span class="line"><span class="comment">#  u'\n\n', u'...', u'\n']</span></span><br></pre></td></tr></table></figure></p>
<p>###常见问题</p>
<ol>
<li>代码诊断</li>
</ol>
<p>&ensp;&ensp;如果想知道Beautiful Soup到底怎样处理一份文档,可以将文档传入 diagnose() 方法(Beautiful Soup 4.2.0中新增),Beautiful Soup会输出一份报告,说明不同的解析器会怎样处理这段文档,并标出当前的解析过程会使用哪种解析器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4.diagnose <span class="keyword">import</span> diagnose</span><br><span class="line">data = open(<span class="string">"bad.html"</span>).read()</span><br><span class="line">diagnose(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Diagnostic running on Beautiful Soup 4.2.0</span></span><br><span class="line"><span class="comment"># Python version 2.7.3 (default, Aug  1 2012, 05:16:07)</span></span><br><span class="line"><span class="comment"># I noticed that html5lib is not installed. Installing it may help.</span></span><br><span class="line"><span class="comment"># Found lxml version 2.3.2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Trying to parse your data with html.parser</span></span><br><span class="line"><span class="comment"># Here's what html.parser did with the document:</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;diagnose() 方法的输出结果可能帮助你找到问题的原因,如果不行,还可以把结果复制出来以便寻求他人的帮助.</p>
<ol>
<li>文档解析错误</li>
</ol>
<p>&ensp;&ensp;文档解析错误有两种.<strong>一种</strong>是崩溃,Beautiful Soup尝试解析一段文档结果却抛除了异常,通常是 HTMLParser.HTMLParseError;<strong>一种</strong>异常情况,是Beautiful Soup解析后的文档树看起来与原来的内容相差很多.</p>
<p>&ensp;&ensp;这些错误几乎都不是Beautiful Soup的原因,这不是因为Beautiful Soup得代码写的太优秀,而是因为Beautiful Soup没有包含任何文档解析代码.异常产生自被依赖的解析器,如果解析器不能很好的解析出当前的文档,那么最好的办法是换一个解析器.更多细节查看 安装解析器 章节.</p>
<p>&ensp;&ensp;最常见的解析错误是 HTMLParser.HTMLParseError: malformed start tag 和 HTMLParser.HTMLParseError: bad end tag .这都是由Python内置的解析器引起的,解决方法是 安装lxml或html5lib</p>
<p>&ensp;&ensp;最常见的异常现象是当前文档找不到指定的Tag,而这个Tag光是用眼睛就足够发现的了. find_all() 方法返回 [] ,而 find() 方法返回 None .这是Python内置解析器的又一个问题: 解析器会跳过那些它不知道的tag.解决方法还是 安装lxml或html5lib</p>
<ol>
<li>版本错误</li>
</ol>
<p>;</p>
<ul>
<li>SyntaxError: Invalid syntax (异常位置在代码行: ROOT_TAG_NAME = u’[document]’ ),因为Python2版本的代码没有经过迁移就在Python3中窒息感</li>
<li>ImportError: No module named HTMLParser 因为在Python3中执行Python2版本的Beautiful Soup</li>
<li>ImportError: No module named html.parser 因为在Python2中执行Python3版本的Beautiful Soup</li>
<li>ImportError: No module named BeautifulSoup 因为在没有安装BeautifulSoup3库的Python环境下执行代码,或忘记了BeautifulSoup4的代码需要从 bs4 包中引入</li>
<li>ImportError: No module named bs4 因为当前Python环境下还没有安装BeautifulSoup4</li>
</ul>
<p>###解析成XML</p>
<p>&ensp;&ensp;默认情况下,Beautiful Soup会将当前文档作为HTML格式解析,如果要解析XML文档,要在 BeautifulSoup 构造方法中加入第二个参数 “xml”:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(markup, <span class="string">"xml"</span>)</span><br></pre></td></tr></table></figure></p>
<p>当然,还需要 <a href="http://doc.iplaypy.com/bs4/#id8" target="_blank" rel="noopener">安装lxml</a><br><strong>解析器的错误</strong></p>
<ul>
<li>如果同样的代码在不同环境下结果不同,可能是因为两个环境下使用不同的解析器造成的.例如这个环境中安装了lxml,而另一个环境中只有html5lib, 解析器之间的区别 中说明了原因.修复方法是在 BeautifulSoup 的构造方法中中指定解析器</li>
<li>因为HTML标签是 大小写敏感 的,所以3种解析器再出来文档时都将tag和属性转换成小写.例如文档中的 TAG会被转换为 tag.如果想要保留tag的大写的话,那么应该将文档 解析成XML .</li>
</ul>
<p><strong>杂项错误</strong></p>
<ul>
<li>UnicodeEncodeError: ‘charmap’ codec can’t encode character u’\xfoo’ in position bar (或其它类型的 UnicodeEncodeError )的错误,主要是两方面的错误(都不是Beautiful Soup的原因),第一种是正在使用的终端(console)无法显示部分Unicode,参考 Python wiki ,第二种是向文件写入时,被写入文件不支持部分Unicode,这时只要用 u.encode(“utf8”) 方法将编码转换为UTF-8.</li>
<li>KeyError: [attr] 因为调用 tag[‘attr’] 方法而引起,因为这个tag没有定义该属性.出错最多的是 KeyError: ‘href’ 和 KeyError: ‘class’ .<strong>如果不确定某个属性是否存在时,用 tag.get(‘attr’) 方法去获取它,跟获取Python字典的key一样</strong></li>
<li>AttributeError: ‘ResultSet’ object has no attribute ‘foo’ 错误通常是因为把 find_all() 的返回结果当作一个tag或文本节点使用,实际上返回结果是一个列表或 ResultSet 对象的字符串,需要对结果进行循环才能得到每个节点的 .foo 属性.或者使用 find() 方法仅获取到一个节点</li>
<li>AttributeError: ‘NoneType’ object has no attribute ‘foo’ 这个错误通常是在调用了 find() 方法后直节点取某个属性 .foo 但是 find() 方法并没有找到任何结果,所以它的返回值是 None .需要找出为什么 find() 的返回值是 None .</li>
</ul>
<p><strong>如何提高效率</strong></p>
<p>&ensp;&ensp;Beautiful Soup对文档的解析速度不会比它所依赖的解析器更快,如果对计算时间要求很高或者计算机的时间比程序员的时间更值钱,那么就应该直接使用 lxml .<br>&ensp;&ensp;换句话说,还有提高Beautiful Soup效率的办法,使用lxml作为解析器.Beautiful Soup用lxml做解析器比用html5lib或Python内置解析器速度快很多.<br>&ensp;&ensp;安装 cchardet 后文档的解码的编码检测会速度更快<br>&ensp;&ensp;<strong>解析部分文档</strong> 不会节省多少解析时间,但是会节省很多内存,并且搜索时也会变得更快.</p>
<p><strong>需要的解析器</strong><br>&ensp;&ensp;Beautiful Soup 3曾使用Python的 SGMLParser 解析器,这个模块在Python3中已经被移除了.Beautiful Soup 4默认使用系统的 html.parser ,也可以使用lxml或html5lib扩展库代替.查看 安装解析器 章节</p>
<p>&ensp;&ensp;因为解析器 html.parser 与 SGMLParser 不同. BS4 和 BS3 处理相同的文档会产生不同的对象结构. 使用lxml或html5lib解析文档的时候, 如果添加了 html.parser 参数, 解析的对象又回发生变化. 如果发生了这种情况, 只能修改对应的处文档结果处理代码了.</p>
<p><strong>方法名的变化</strong></p>
<ul>
<li>renderContents -&gt; encode_contents</li>
<li>replaceWith -&gt; replace_with</li>
<li>replaceWithChildren -&gt; unwrap</li>
<li>findAll -&gt; find_all</li>
<li>findAllNext -&gt; find_all_next</li>
<li>findAllPrevious -&gt; find_all_previous</li>
<li>findNext -&gt; find_next</li>
<li>findNextSibling -&gt; find_next_sibling</li>
<li>findNextSiblings -&gt; find_next_siblings</li>
<li>findParent -&gt; find_parent</li>
<li>findParents -&gt; find_parents</li>
<li>findPrevious -&gt; find_previous</li>
<li>findPreviousSibling -&gt; find_previous_sibling</li>
<li>findPreviousSiblings -&gt; find_previous_siblings</li>
<li>nextSibling -&gt; next_sibling</li>
<li>previousSibling -&gt; previous_sibling</li>
</ul>
<p>Beautiful Soup构造方法的参数部分也有名字变化:</p>
<ul>
<li>BeautifulSoup(parseOnlyThese=…) -&gt; BeautifulSoup(parse_only=…)</li>
<li>BeautifulSoup(fromEncoding=…) -&gt; BeautifulSoup(from_encoding=…)</li>
</ul>
<p>为了适配Python3,修改了一个方法名:</p>
<ul>
<li>Tag.has_key() -&gt; Tag.has_attr()</li>
</ul>
<p>修改了一个属性名,让它看起来更专业点:</p>
<ul>
<li>Tag.isSelfClosing -&gt; Tag.is_empty_element</li>
</ul>
<p>&ensp;&ensp;修改了下面3个属性的名字,以免与Python保留字冲突.这些变动不是向下兼容的,如果在BS3中使用了这些属性,那么在BS4中这些代码无法执行.</p>
<ul>
<li>UnicodeDammit.Unicode -&gt; UnicodeDammit.Unicode_markup``</li>
<li>Tag.next -&gt; Tag.next_element</li>
<li>Tag.previous -&gt; Tag.previous_element</li>
</ul>
<p><strong>生成器</strong><br>&ensp;&ensp;将下列生成器按照PEP8标准重新命名,并转换成对象的属性:</p>
<ul>
<li>childGenerator() -&gt; children</li>
<li>nextGenerator() -&gt; next_elements</li>
<li>nextSiblingGenerator() -&gt; next_siblings</li>
<li>previousGenerator() -&gt; previous_elements</li>
<li>previousSiblingGenerator() -&gt; previous_siblings</li>
<li>recursiveChildGenerator() -&gt; descendants</li>
<li>parentGenerator() -&gt; parents</li>
</ul>
<p>&ensp;&ensp;BS3中有的生成器循环结束后会返回 None 然后结束.这是个bug.新版生成器不再返回 None .</p>
<p>&ensp;&ensp;BS4中增加了2个新的生成器, .strings 和 stripped_strings . .strings 生成器返回NavigableString对象, .stripped_strings 方法返回去除前后空白的Python的string对象.</p>
<p><strong>XML</strong></p>
<p>&ensp;&ensp;BS4中移除了解析XML的 BeautifulStoneSoup 类.如果要解析一段XML文档,使用 BeautifulSoup 构造方法并在第二个参数设置为“xml”.同时 BeautifulSoup 构造方法也不再识别 isHTML 参数.</p>
<p>&ensp;&ensp;Beautiful Soup处理XML空标签的方法升级了.旧版本中解析XML时必须指明哪个标签是空标签. 构造方法的 selfClosingTags 参数已经不再使用.新版Beautiful Soup将所有空标签解析为空元素,如果向空元素中添加子节点,那么这个元素就不再是空元素了.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/08/python第三方库beatifulSoup使用/" data-id="cjlc1dmvd005ia4s683clg6xx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python的List与tuple操作方法详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/07/python的List与tuple操作方法详解/" class="article-date">
  <time datetime="2017-05-07T01:40:40.000Z" itemprop="datePublished">2017-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/07/python的List与tuple操作方法详解/">python的List与tuple操作方法详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&ensp;&ensp;列表是Python中最基本的数据结构，列表是最常用的Python数据类型，列表的数据项不需要具有相同的类型。列表中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>&ensp;&ensp;Python有6个序列的内置类型，但最常见的是列表和元组，因为列表和元组操作基本相似，只是tuple一旦初始化就不能修改，這里只介绍列表的。序列都可以进行的操作包括索引，切片，加，乘，检查成员。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<ol>
<li>创建一个列表<br>&ensp;&ensp;只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line">list3 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<ol>
<li>访问列表中的值<br>&ensp;&ensp;使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符， 如下所示:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"list1[0]: "</span>, list1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"list2[1:5]: "</span>, list2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1[<span class="number">0</span>]:  physics</span><br><span class="line">list2[<span class="number">1</span>:<span class="number">5</span>]:  [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>更新列表<br>&ensp;&ensp;你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">list = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Value available at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</span><br><span class="line">list[<span class="number">2</span>] = <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"New value available at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value available at index <span class="number">2</span> :</span><br><span class="line"><span class="number">1997</span></span><br><span class="line">New value available at index <span class="number">2</span> :</span><br><span class="line"><span class="number">2001</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>删除列表元素<br>&ensp;&ensp;可以使用 del 语句来删除列表的的元素，如下实例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line"><span class="keyword">print</span> list1;</span><br><span class="line"><span class="keyword">del</span> list1[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"After deleting value at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list1;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">After deleting value at index <span class="number">2</span> :</span><br><span class="line">[<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Python列表脚本操作符<br>&ensp;&ensp;列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。如下所示： </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Python 表达式</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">len([1, 2, 3])</td>
<td style="text-align:left">3</td>
<td style="text-align:left">长度</td>
</tr>
<tr>
<td style="text-align:left">[1, 2, 3] + [4, 5, 6]</td>
<td style="text-align:left">[1, 2, 3, 4, 5, 6]</td>
<td style="text-align:left">组合</td>
</tr>
<tr>
<td style="text-align:left">[‘Hi!’] * 4</td>
<td style="text-align:left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td style="text-align:left">重复</td>
</tr>
<tr>
<td style="text-align:left">3 in [1, 2, 3]</td>
<td style="text-align:left">True</td>
<td style="text-align:left">元素是否存在于列表中</td>
</tr>
<tr>
<td style="text-align:left">for x in [1, 2, 3]: print x,</td>
<td style="text-align:left">1 2 3</td>
<td style="text-align:left">迭代</td>
</tr>
</tbody>
</table>
<ol>
<li>Python列表截取或切片<br>Python的列表截取与字符串操作类型，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'spam'</span>, <span class="string">'Spam'</span>, <span class="string">'SPAM!'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python 表达式</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">L[2]</td>
<td style="text-align:left"></td>
<td style="text-align:left">‘SPAM!’</td>
<td>读取列表中第三个元素</td>
</tr>
<tr>
<td style="text-align:left">L[-2]</td>
<td style="text-align:left">‘Spam’</td>
<td style="text-align:left">读取列表中倒数第二个元素</td>
</tr>
<tr>
<td style="text-align:left">L[1:]</td>
<td style="text-align:left">[‘Spam’, ‘SPAM!’]</td>
<td style="text-align:left">从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<ol>
<li>Python列表操作的函数和方法<br>列表操作包含以下函数:</li>
</ol>
<ul>
<li>cmp(list1, list2)：比较两个列表的元素 </li>
<li>len(list)：列表元素个数 </li>
<li>max(list)：返回列表元素最大值 </li>
<li>min(list)：返回列表元素最小值 </li>
<li>list(seq)：将元组转换为列表<br>列表操作包含以下方法:</li>
<li>list.append(obj)：在列表末尾添加新的对象</li>
<li>list.count(obj)：统计某个元素在列表中出现的次数</li>
<li>list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li>list.index(obj)：从列表中找出某个值第一个匹配项的索引位置,<strong>注意</strong>这个有个前提，obj必须在list中不然会抛异常</li>
<li>list.insert(index, obj)：将对象插入列表</li>
<li>list.pop(obj=list[-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li>
<li>list.remove(obj)：移除列表中某个值的第一个匹配项</li>
<li>list.reverse()：反向列表中元素</li>
<li>list.sort([func])：对原列表进行排序</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://www.jb51.net/article/47978.htm" target="_blank" rel="noopener">http://www.jb51.net/article/47978.htm</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819318453af120e8751ea4d2696d8a1ffa5ffdfd7000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819318453af120e8751ea4d2696d8a1ffa5ffdfd7000</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/07/python的List与tuple操作方法详解/" data-id="cjlc1dmtx001va4s6oejwrrz9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python编码中问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/06/python编码中问题/" class="article-date">
  <time datetime="2017-05-06T13:02:51.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/06/python编码中问题/">python编码中问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.mysql 模块集成：<br>&ensp;&ensp;通过pycharm IDE引入mysql模块时会报错<img src="/images/python_mysql_error.png" alt="mysql引入错误">，此时到<a href="https://dev.mysql.com/downloads/connector/python/" target="_blank" rel="noopener">mysql conenctor</a>下载对应系统的mysql 模块安装包即可。</p>
<ol>
<li>关于BeautifulSoup使用时引入问题：<br>&ensp;&ensp;网上普遍的引入方法是：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最近在使用是发现此方法报错，因此尝试使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;发下该方法才正确，My god。<br><strong>注意</strong>具体那个版本使用那种形式暂时不是很清楚，希望有人告知。</p>
<ol>
<li>python中import x和from x import y的区别<br>&ensp;&ensp;简单解释：<br>import x：把x给我；from x import y：从x里把y拿出来给我。<br>举例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.datetime.now())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;引入的是整个datetime包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.now())</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;只引入datetime包里的datetime类<br><strong>注意</strong>两者的意义何在？：主要是引入内存中的东西大小不一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/06/python编码中问题/" data-id="cjlc1dmtw001ua4s64n8no2zq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python切片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/06/python切片/" class="article-date">
  <time datetime="2017-05-06T07:21:32.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/06/python切片/">python切片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原理上分析切片运算：<br>&ensp;&ensp;list的切片，内部是调用<strong>getitem</strong>，<strong>setitem</strong>,<strong>delitem</strong>和slice函数。而slice函数又是和range()函数相关的，给切片传递的键是一个特殊的slice对象。该对象拥有可描述所请求切片方位的属性，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</span><br><span class="line">x = a [ <span class="number">1</span> : <span class="number">5</span> ]   <span class="comment">#  x = a.__getitem__( slice ( 1, 5, None ) )</span></span><br><span class="line">a [ <span class="number">1</span> : <span class="number">3</span> ] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> ]<span class="comment">#  a.__setitem__( slice ( 1, 3, None ), [ 10, 11, 12 ] )</span></span><br><span class="line"><span class="keyword">del</span> a [ <span class="number">1</span> : <span class="number">4</span> ]  <span class="comment">#  a.__delitem__( slice ( 1, 4, None ) )</span></span><br></pre></td></tr></table></figure></p>
<p>Python 的切片功能实际上比很多程序员认为的更强大，其形式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=m[start:end:step]   <span class="comment">#  带步进的切片（步进值=step）</span></span><br></pre></td></tr></table></figure></p>
<p>可见，列表的下标有三个参数：start（起始下标），end（终止下标），step（变化量），简单解释如下：</p>
<ul>
<li>当step大于0时，beg默认为0，end默认为最末之后；</li>
<li>当step小于0时，start默认为len（array）-1，end默认为开头之前；</li>
<li>当step未给出时：start默认为1；</li>
</ul>
<p>比较复杂的解释如下：<br>&ensp;&ensp;<strong>注意：</strong>步进值为step</p>
<ol>
<li>当step &gt; 0 时切片从 start(含start)处开始，到end（不含end）处结束，<strong>从左往右</strong>，每隔（step-1）（索引之间的差仍为step，但相隔的元素是step-1个）个元素进行一次截取。这时，start 指向的位置应该在end指向的位置的左边，否则返回值为空；</li>
<li>当step &lt; 0 时，切片从 start(含start)处开始，到end（不含end）处结束，<strong>从右往左</strong>，每隔（step-1）（索引之间的差仍为step，但相隔的元素是step-1个）个元素进行一次截取。这时，start 指向的位置应该在end指向的位置的右边，否则返回值为空；</li>
</ol>
<p>示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"abcdefh"</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#截取第一位到第三位的字符</span></span><br><span class="line"><span class="keyword">print</span> str[:] <span class="comment">#截取字符串的全部字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">6</span>:] <span class="comment">#截取第七个字符到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-3</span>] <span class="comment">#截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>] <span class="comment">#截取第三个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-1</span>] <span class="comment">#截取倒数第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[::<span class="number">-1</span>] <span class="comment">#创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment">#截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:] <span class="comment">#截取倒数第三位到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取,从末尾到倒数第五个，每三步截取一个；</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取,从末尾到开始，每三步截取一个；</span></span><br></pre></td></tr></table></figure></p>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cnblogs.com/weidiao/p/6428681.html" target="_blank" rel="noopener">http://www.cnblogs.com/weidiao/p/6428681.html</a></li>
<li><a href="http://www.pythontab.com/html/2013/pythonjichu_0128/182.html" target="_blank" rel="noopener">http://www.pythontab.com/html/2013/pythonjichu_0128/182.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/05/06/python切片/" data-id="cjlc1dmtt001oa4s6uv12et3b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/7/">7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/">Android Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Support/">Android Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/">Annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsynListUtil/">AsynListUtil</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-DataCallback/">AsyncListUtil.DataCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-ViewCallback/">AsyncListUtil.ViewCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Buffer/">Buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ByteBuffer/">ByteBuffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DynamicLoadApk/">DynamicLoadApk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Error/">Error</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-App/">First App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Instant-Run/">Instant Run</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interceptors/">Interceptors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinearLayout/">LinearLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC-MVP-MVVM/">MVC MVP MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Media/">Media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaExtractor/">MediaExtractor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MulitiDex/">MulitiDex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NNotificationChannelGroup/">NNotificationChannelGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NestedScrolling/">NestedScrolling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notification/">Notification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NotificationChannel/">NotificationChannel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Options/">Options</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Small/">Small</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SourceCode/">SourceCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Support/">Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Uri/">Uri</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/andrid/">andrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boolen/">boolen</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/byte/">byte</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera2/">camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/char/">char</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/double/">double</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle-plugin/">gradle plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/head/">head</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ide/">ide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/install/">install</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/int/">int</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/long/">long</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/okhttp/">okhttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/short/">short</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start/">start</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/7/" style="font-size: 10px;">7</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-Studio/" style="font-size: 10px;">Android Studio</a> <a href="/tags/Android-Support/" style="font-size: 10px;">Android Support</a> <a href="/tags/Annotation/" style="font-size: 12.5px;">Annotation</a> <a href="/tags/AsynListUtil/" style="font-size: 10px;">AsynListUtil</a> <a href="/tags/AsyncListUtil-DataCallback/" style="font-size: 10px;">AsyncListUtil.DataCallback</a> <a href="/tags/AsyncListUtil-ViewCallback/" style="font-size: 10px;">AsyncListUtil.ViewCallback</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/BitmapFactory/" style="font-size: 10px;">BitmapFactory</a> <a href="/tags/Buffer/" style="font-size: 10px;">Buffer</a> <a href="/tags/ByteBuffer/" style="font-size: 10px;">ByteBuffer</a> <a href="/tags/Camera2/" style="font-size: 12.5px;">Camera2</a> <a href="/tags/Download-Manager/" style="font-size: 12.5px;">Download Manager</a> <a href="/tags/DynamicLoadApk/" style="font-size: 10px;">DynamicLoadApk</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/First-App/" style="font-size: 10px;">First App</a> <a href="/tags/Flutter/" style="font-size: 17.5px;">Flutter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Instant-Run/" style="font-size: 10px;">Instant Run</a> <a href="/tags/Interceptors/" style="font-size: 10px;">Interceptors</a> <a href="/tags/LinearLayout/" style="font-size: 10px;">LinearLayout</a> <a href="/tags/MVC-MVP-MVVM/" style="font-size: 10px;">MVC MVP MVVM</a> <a href="/tags/Media/" style="font-size: 15px;">Media</a> <a href="/tags/MediaCodeC/" style="font-size: 10px;">MediaCodeC</a> <a href="/tags/MediaExtractor/" style="font-size: 12.5px;">MediaExtractor</a> <a href="/tags/MulitiDex/" style="font-size: 10px;">MulitiDex</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/NNotificationChannelGroup/" style="font-size: 10px;">NNotificationChannelGroup</a> <a href="/tags/NestedScrolling/" style="font-size: 10px;">NestedScrolling</a> <a href="/tags/Notification/" style="font-size: 10px;">Notification</a> <a href="/tags/NotificationChannel/" style="font-size: 10px;">NotificationChannel</a> <a href="/tags/Options/" style="font-size: 10px;">Options</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Small/" style="font-size: 10px;">Small</a> <a href="/tags/SourceCode/" style="font-size: 10px;">SourceCode</a> <a href="/tags/Support/" style="font-size: 10px;">Support</a> <a href="/tags/Tool/" style="font-size: 12.5px;">Tool</a> <a href="/tags/Uri/" style="font-size: 10px;">Uri</a> <a href="/tags/andrid/" style="font-size: 15px;">andrid</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/boolen/" style="font-size: 10px;">boolen</a> <a href="/tags/byte/" style="font-size: 10px;">byte</a> <a href="/tags/camera2/" style="font-size: 10px;">camera2</a> <a href="/tags/char/" style="font-size: 10px;">char</a> <a href="/tags/double/" style="font-size: 10px;">double</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gradle-plugin/" style="font-size: 10px;">gradle plugin</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/ide/" style="font-size: 10px;">ide</a> <a href="/tags/install/" style="font-size: 12.5px;">install</a> <a href="/tags/int/" style="font-size: 10px;">int</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/long/" style="font-size: 10px;">long</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/okhttp/" style="font-size: 10px;">okhttp</a> <a href="/tags/short/" style="font-size: 10px;">short</a> <a href="/tags/start/" style="font-size: 10px;">start</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/27/基础数据与byte间的转化/">基础数据与byte间的转化</a>
          </li>
        
          <li>
            <a href="/2018/08/23/NIO-Buffer解析/">NIO-Buffer解析</a>
          </li>
        
          <li>
            <a href="/2018/08/16/根据Uri获取文档的路径/">根据Uri获取文档的路径</a>
          </li>
        
          <li>
            <a href="/2018/08/12/LinearLayout源码解读/">LinearLayout源码解读</a>
          </li>
        
          <li>
            <a href="/2018/07/22/android-camera2预览拍照录制/">android-camera2预览拍照录制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 CallteFoot<br>
      Powered by <a href="https://cattlefoot.github.io" target="_blank">CallteFoot</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>