<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="the blog from a anroid coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/2/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="the blog from a anroid coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="the blog from a anroid coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/page/2/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/13/Android开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/13/Android开发记录/" itemprop="url">Android开发记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-13T13:45:40+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="Android-studio中如何修改运行环境中最低版本和目标版本"><a href="#Android-studio中如何修改运行环境中最低版本和目标版本" class="headerlink" title="Android studio中如何修改运行环境中最低版本和目标版本"></a>Android studio中如何修改运行环境中最低版本和目标版本</h4><p>最近发现使用Android Studio创建的项目中，最低版本和目标版本已经不在AndroidManifest.xml中显示了。那我们应该去那里需改呢？</p>
<p>原来放到了File -&gt; Project Structure中了。直接上图吧，一目了然。<br><a href="&quot;images/AndroidDownBuildVersion.jpg&quot;">修改最低版本和目标版本</a></p>
<p>参考地址：   </p>
<ul>
<li><a href="https://blog.csdn.net/kingroc/article/details/50947143" target="_blank" rel="noopener">https://blog.csdn.net/kingroc/article/details/50947143</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/Flutter编写第一个应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/Flutter编写第一个应用/" itemprop="url">编写第一个Flutter应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T19:07:44+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="&quot;images/startup-namer-app.gif&quot;">Animated GIF of the app that you will be building.</a><br>这篇教程将指导你创建第一个 Flutter 应用程序。如果你熟悉面向对象程序设计和基本的编程概念（如变量，循环和条件），即可完成本教程。无需具有使用 Dart 语言或移动编程的相关经验。</p>
<ul>
<li>第1步：创建初始Flutter应用</li>
<li>第2步：使用外部 package</li>
<li>第3步：添加有状态的widget</li>
<li>第4步：创建一个无限滚动的 ListView</li>
<li>第5步：添加可交互性</li>
<li>第6步：导航到新页面</li>
<li>第7步：使用主题更改UI</li>
<li>干得漂亮！<h3 id="你需要做什么"><a href="#你需要做什么" class="headerlink" title="你需要做什么"></a>你需要做什么</h3></li>
</ul>
<p>完成一个简单的移动应用程序，为一家创业公司进行命名推荐。用户可以选择和取消选择名称，并保存最好的一个。代码一次生成十个名称。当用户滚动时，会新生成一批名称。用户可以点击应用栏右上方的列表图标，跳转到仅显示已被收藏的名称的列表页面。</p>
<p>这个GIF动画可以显示出该应用是如何工作的。</p>
<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会学到</strong>:<br>- Flutter 应用程序的基本结构 。<br>- 查找和使用 package 来扩展功能。<br>- 使用热加载加快开发效率。<br>- 如何实现一个有状态的 widget 。<br>- 如何创建一个无限长度的延迟加载列表。<br>- 如何创建并导航到第二个页面。<br>- 如何使用主题更改应用程序的外观。<br></td></tr></table>

<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会用到</strong>:<br><br>需要安装以下工具:<br><br>- Flutter SDK<br>Flutter SDK 包括 Flutter 的引擎，框架，控件，工具和 Dart SDK 。这个 codelab 需要 v0.1.4 或更高版本。<br><br>-  Android Studio IDE<br>这个 codelab 基于 Android Studio IDE 构建，但也可以使用其他 IDE ，或者从命令行运行。<br><br>- 安装 IDE 插件<br>插件必须为您的编译器单独安装 Flutter 和 Dart 插件。除了Android Studio，Flutter和Dart插件也可用于 <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">VS Code</a> 和 <a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">IntelliJ IDE</a>。<br><br>有关如何设置环境的信息，<a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">请参阅 Flutter安装和配置</a>。<br></td></tr></table>

<h3 id="第1步：创建初始Flutter应用"><a href="#第1步：创建初始Flutter应用" class="headerlink" title="第1步：创建初始Flutter应用"></a>第1步：创建初始Flutter应用</h3><p>使用<a href="http://doc.flutter-dev.cn/get-started/test-drive/#create-app" target="_blank" rel="noopener">第一个入门 Flutter 应用</a>中的说明创建一个简单的模板化 Flutter 应用。将项目命名为 <strong>startup_namer</strong>（而不是myapp）。你将修改这个应用并最终完成它。</p>
<p>在这个 codelab 中，将主要编辑 Dart 代码所在的 lib / main.dart。</p>
<table><tr><td bgcolor="#f0f0f0"><br> 小贴士： 将代码粘贴到应用程序中时，缩进可能会错位。你可以使用 Flutter 工具自动修复此问题：<br><br>1. Android Studio / IntelliJ IDEA: 右键单击 dart 代码，然后选择 <strong>Reformat Code with dartfmt</strong>。<br>2. VS Code: 单击右键，选择 <strong>Format Document</strong>.<br>3. 命令行: 运行 flutter format <filename>.<br></filename></td></tr></table>

<ol>
<li><p>替换 lib / main.dart 。<br>删除 lib / main.dart 中的所有代码。替换为下面的代码，它在屏幕中心显示 “Hello World” 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Text(&apos;Hello World&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行应用程序。现在应该可以看到下面的页面。<br><a href="hello-world-screenshot.png">screenshot of hello world app</a></p>
<p>小结</p>
<ul>
<li><p>本示例创建了一个 Material app 。 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material</a> 设计语言是一套移动设备和网页上的视觉设计标准。Flutter 提供了一套丰富的 Material Widgets 。</p>
</li>
<li><p>main 方法采用了 fat arrow (=&gt;) 表示法，这是一种用于单行函数或方法的简写。</p>
</li>
<li><p>该 app 继承了使它本身成为一个 widget 的 StatelessWidget 类。在 Flutter 中，大多数时候一切都可以看作 widget , 包括 alignment，padding 和 layout 。</p>
</li>
<li><p>Material 库中的 Scaffold widget 提供了默认的应用栏 (app bar)，标题和构成主页面 widget 树结构的 body 属性。 widget 的子树可以非常复杂。</p>
</li>
<li><p>widget 的主要工作是提供一个build()方法，描述如何根据其他更低层级的 widget，来对这个 widget 进行展示。</p>
</li>
<li><p>本示例的 widget 树由包含了 Text child widget 的 Center widget 组成。Center widget 可将它的所有子树对齐到屏幕中心。</p>
</li>
</ul>
<h3 id="第2步：使用外部-package"><a href="#第2步：使用外部-package" class="headerlink" title="第2步：使用外部 package"></a>第2步：使用外部 package</h3><p>在这一步，将开始使用名为 <strong>english_words</strong> 的开源软件包 ，其中包含数千个最常用的英文单词以及一些实用功能。</p>
<p>可以在 <a href="https://pub.dartlang.org/flutter/" target="_blank" rel="noopener">pub.dartlang.org</a> 上找到 <a href="https://pub.dartlang.org/packages/english_words" target="_blank" rel="noopener">english_words</a> 软件包以及其他许多开源软件包。</p>
<ol>
<li><p>pubspec 文件管理着 Flutter 应用程序的静态资源文件(assets)。 在 <strong>pubspec.yaml</strong> 文件中， 将 <strong>english_words</strong>（3.1.0或更高版本）添加到依赖列表。新的一行高亮如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  cupertino_icons: ^0.1.0</span><br><span class="line">  english_words: ^3.1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Android Studio 的 editor 视图中查看 pubspec 时, 点击右上角的 <strong>Packages get</strong> ，将把 package 拉取到项目中。现在应该可以在控制台中看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br><span class="line">Running &quot;flutter packages get&quot; in startup_namer...</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <strong>lib/main.dart</strong> 中，为 english_words 添加导入，如高亮的行所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br></pre></td></tr></table></figure>
<p>在键入该行时， Android Studio 会提供有关库导入的建议。然后将导入字符串显示为灰色，让你知道导入的库尚未使用（到目前为止）。</p>
</li>
<li><p>改用英文单词的 package 来生成文本，而不是字符串 “Hello World” 。</p>
<table><tr><td bgcolor="#f0f0f0"><br>小贴士： “Pascal case”（也被称为“大骆驼拼写法”），意味着字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，“uppercamelcase” 变成 “UpperCamelCase” 。<br></td></tr></table>

</li>
</ol>
<p>对代码进行以下更改，如!!!所示：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final wordPair = new WordPair.random();   //!!!!</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          //child: new Text(&apos;Hello World&apos;), // Replace the highlighted text...</span><br><span class="line">          child: new Text(wordPair.asPascalCase),  // With this highlighted text. !!!</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果应用正在运行，请使用 Flutter Hot Reload (热重载)按钮 (lightning bolt icon)更新应用程序。每次单击按钮或保存项目时，都会看到随机的词组文本，这是因为配对的词组是在 build 方法内部生成的，每次应用需要渲染时，或在 Flutter Inspector 中切换 Platform 时都会运行  </li>
</ol>
<p><a href="&quot;images/step2-screenshot.png&quot;">screenshot at completion of second step</a>  </p>
<h4 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h4><p>如果应用程序运行不正常，请检查拼写错误。如有需要，可使用以下链接中的代码使项目恢复正常</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/pubspec.yaml" target="_blank" rel="noopener">pubspec.yaml</a> (pubspec.yaml文件不会再更改。)</li>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/main.dart" target="_blank" rel="noopener">lib/main.dart</a>   </li>
</ul>
<h3 id="第3步：添加有状态的widget"><a href="#第3步：添加有状态的widget" class="headerlink" title="第3步：添加有状态的widget"></a>第3步：添加有状态的widget</h3><p>Stateless widgets 是不可改变的，这意味着它们的属性不能改变——所有的值都是 final 的。</p>
<p>Statefulwidget 在其 <strong>生命周期</strong> 保持的状态可能会变化，<strong>实现一个有状态的 widget 至少需要两个类</strong>：StatefulWidgets类和State类，其中StatefulWidgets类创建了一个State类的实例。StatefulWidget类本身是不可变的，但State类可存在于Widget的整个生命周期中。</p>
<p>在这一步，将添加一个有状态的 RandomWords widget ，它可以创建其 State 类 RandomWordsState 。 State 类会为 widget 保存被推荐和被收藏的词组。  </p>
<ol>
<li><p>将有状态的 RandomWords widget 添加到 main.dart 。它可以在 MyApp 类之外的任何位置使用，但当前将把它放在文件底部。 RandomWords widget 除了创建 State 类之外几乎没有任何其他代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class RandomWords extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  createState() =&gt; new RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 RandomWordsState 类。这个类保存了 RandomWords widget 的状态，该应用程序的大部分代码都放在该类中。这个类将保存随着用户的滑动操作而生成的无限增长的词组，以及保存用户收藏的词组，用户通过触发心形图标来添加或删除收藏的词组列表。  </p>
</li>
</ol>
<p>你可以一点点建立这个类。首先，通过以下!!!代码，创建一个最简的类：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  class RandomWordsState extends State&lt;RandomWords&gt; &#123; //!!!</span><br><span class="line">  &#125;</span><br><span class="line">  ```   </span><br><span class="line"></span><br><span class="line">3. 添加这个 state 类之后，IDE 会提示该类缺少 build 方法。接下来，需要添加一个基本的 build 方法，并将生成单词的代码行从 MyApp 类移动到 RandomWordsState 类的 build 方法中，生成词组。  </span><br><span class="line">将 build 方法添加到 RandomWordState 中，如!!!代码所示：</span><br></pre></td></tr></table></figure>
<p>  class RandomWordsState extends State<randomwords> {<br>    @override     //-!!!<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();<br>      return new Text(wordPair.asPascalCase);<br>    }  //-!!!<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 根据!!!部分的更改，从 MyApp 中删除生成单词的代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();  // !!! Delete this line</p>
<pre><code>  return new MaterialApp(
    title: &apos;Welcome to Flutter&apos;,
    home: new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Welcome to Flutter&apos;),
     ),
      body: new Center(
        //child: new Text(wordPair.asPascalCase), // !!!Change the highlighted text to...
        child: new RandomWords(), // !!!... this highlighted text
      ),
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启应用。如果尝试热重载，则可能会看到警告:</span><br></pre></td></tr></table></figure></p>
<p>  Reloading…<br>  Not all changed program elements ran during view reassembly; consider<br>  restarting.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这可能是一个误报，但可以考虑重启应用，以确保更改能正常反映在应用的 UI 界面中。</span><br><span class="line"></span><br><span class="line">应用程序应该像之前一样运行，每次热重载或保存应用程序时都会显示一个词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of third step](step3-screenshot.png)   </span><br><span class="line">#### 有问题吗? ####</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](lib/main.dart)</span><br><span class="line"></span><br><span class="line">### 第4步：创建一个无限滚动的 ListView ###</span><br><span class="line">在这一步，可以扩展 RandomWordsState 类，生成并展示词组列表。当用户滑动列表，ListView widget 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许按需建立一个延迟加载的列表 view 。</span><br><span class="line"></span><br><span class="line">1. \_suggestions 变量向 RandomWordsState 类中添加一个数组列表，用来保存推荐词组。 该变量以下划线(\_)开头，在 Dart 语言中使用下划线前缀表示强制私有。   </span><br><span class="line">此外，添加一个 biggerFont 变量来增大字体。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_buildSuggestions() 函数，用于构建一个显示词组的 ListView 。   </span><br><span class="line">ListView 类提供了一个 itemBuilder 属性，这是一个工厂 builder 并作为匿名函数进行回调。它有两个传入参数— BuildContext 上下文和行迭代器 i 。对于每个推荐词组都会执行一次函数调用，迭代器从 0 开始，每调用一次函数就累加 1 。这个模块允许推荐列表在用户滑动时无限增长。  </span><br><span class="line">添加如下代码行：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …<br>    Widget _buildSuggestions() {<br>      return new ListView.builder(<br>        padding: const EdgeInsets.all(16.0),<br>        // The itemBuilder callback is called once per suggested word pairing,<br>        // and places each suggestion into a ListTile row.<br>        // For even rows, the function adds a ListTile row for the word pairing.<br>        // For odd rows, the function adds a Divider widget to visually<br>        // separate the entries. Note that the divider may be difficult<br>        // to see on smaller devices.<br>        itemBuilder: (context, i) {<br>          // Add a one-pixel-high divider widget before each row in theListView.<br>          if (i.isOdd) return new Divider();</randomwords></p>
<pre><code>      // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.
      // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
      // This calculates the actual number of word pairings in the ListView,
      // minus the divider widgets.
      final index = i ~/ 2;
      // If you&apos;ve reached the end of the available word pairings...
      if (index &gt;= _suggestions.length) {
        // ...then generate 10 more and add them to the suggestions list.
        _suggestions.addAll(generateWordPairs().take(10));
      }
      return _buildRow(_suggestions[index]);
    }
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.  函数都调用一次 \_buildRow 函数。这个函数每次会在一个 ListTile widget 中展示一条新词组，这将在下一步操作中，使一行数据更有表现力。    </span><br><span class="line">  添加 \_buildRow 函数到 RandomWordsState 类中：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …</randomwords></p>
<pre><code>Widget _buildRow(WordPair pair) {
  return new ListTile(
    title: new Text(
      pair.asPascalCase,
      style: _biggerFont,
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 更新 RandomWordsState 类的 build 方法来使用 \_buildSuggestions() 函数，而不是直接调用单词生成库。对部分进行修改：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    final wordPair = new WordPair.random(); // Delete these two lines.<br>    Return new Text(wordPair.asPascalCase);<br>    return new Scaffold (<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>      ),<br>    body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 更新 MyApp 类的 build 方法。从 MyApp 中删除 Scaffold 和 AppBar 实例。这些将由 RandomWordsState 类进行统一管理，这样在下一步操作中，可以使用户从一个页面导航到另一页面时，更方便的更改应用栏中的页面名称。</span><br><span class="line"></span><br><span class="line">  用下面高亮的 build 方法替换原始代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      return new MaterialApp(<br>        title: ‘Startup Name Generator’,<br>        home: new RandomWords(),<br>      );<br>    }<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重启应用程序，将可以看到一个词组清单。尽量向下滑动，将继续看到新的词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of fourth step](step4-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/d6f9460a04d3a429eb6ac0b0f07da564/raw/34fe240f4122435c871bb737708ee0357741801c/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第5步：添加可交互性 ###</span><br><span class="line">在这一步，将为每一行添加可点击的心形图标。当用户点击列表中的条目，切换其“收藏”状态，词组就会添加到收藏栏，或从已保存词组的收藏栏中删除。</span><br><span class="line"></span><br><span class="line">1. 添加一个 Set 集合 \_saved 到 RandomWordsState 类。保存用户收藏的词组。Set 集合比 List 更适用于此，因为它不允许重复元素。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _saved = new Set<wordpair>();</wordpair></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 在 \_buildRow 函数中，添加 alreadySaved 标志检查来确保一个词组还没有被添加到收藏。</span><br></pre></td></tr></table></figure></p>
<p>Widget _buildRow(WordPair pair) {<br>  final alreadySaved = _saved.contains(pair);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3. 在 \_buildRow() 的 ListTiles widget 中，添加一个心形图标来使用收藏功能，随后将添加与心形图标进行交互的功能。  </span><br><span class="line"></span><br><span class="line">  添加以下高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4. 重启应用。现在应该可以在每一行看到心形图标，但还没有交互功能。</span><br><span class="line"></span><br><span class="line">5. 在 \_buildRow 函数中使心形可点击。如果词条已经被加入收藏，再次点击它将从收藏中删除。当心形图标被点击，函数将调用 setState() 通知应用框架state已经改变。</span><br><span class="line"></span><br><span class="line">  添加高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>      onTap: () {<br>        setState(() {<br>          if (alreadySaved) {<br>            _saved.remove(pair);<br>          } else {<br>            _saved.add(pair);<br>          }<br>        });<br>      },<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f0f0f0&gt;</span><br><span class="line">  小贴士： 在 Flutter 的响应式风格框架中，调用 setState() ，将为 State 对象触发 build() 方法的调用，从而实现对UI的更新。</span><br><span class="line">  &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">热重载应用。可以点击任意一行来收藏或取消收藏条目。 请注意，点击一行可以产生从心形图标展开的泼墨动画效果。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 5th step](step5-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/936ce0059029a8c6e88aaa826a3789cd/raw/a3065d5c681a81eff32f75a9cd5f4d9a5b24f9ff/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第6步：导航到新页面 ###</span><br><span class="line">在这一步，将添加一个显示收藏夹的新页面(在 Flutter 中称为 route(路由))。你将学习如何在主路由和新路由之间导航。</span><br><span class="line"></span><br><span class="line">在 Flutter 中， Navigator 管理着包含了应用程序所有路由的一个堆栈。将一个路由push到 Navigator 的堆栈，将显示更新为新页面路由。将一个路由 pull 出 Navigator 的堆栈，显示将返回到前一个页面路由。</span><br><span class="line"></span><br><span class="line">1. 在 RandomWordsState 类的 build 方法中，向 AppBar 添加一个列表图标。当用户点击列表图标时，包含了已收藏条目的新路由将被 push 到 Navigator 堆栈并显示新页面。</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f1f1f1&gt;</span><br><span class="line"> 小贴士： 某些 widget 属性使用独立 widget(child) 和其他属性例如 action 组成一个子 widget 数组(children)，用方括号([])表示。</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">将该图标及其相应的 action 操作添加到 build 方法中：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    return new Scaffold(<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>        actions: <widget>[<br>          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),<br>        ],<br>      ),<br>      body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_pushSaved() 函数。</span><br></pre></td></tr></table></figure></widget></randomwords></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  void _pushSaved() {<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重新加载应用程序。列表图标将出现在应用栏中。点击它不会有任何响应，因为 \_pushSaved 这个函数还未实现功能。</span><br><span class="line"></span><br><span class="line">3. 当用户点击应用栏中的列表图标时，将建立一个新路由并 push 到 Navigator 的路由堆栈中，这个操作将改变界面显示，展示新的路由页面。   </span><br><span class="line"></span><br><span class="line">  新页面的内容使用匿名函数在 MaterialPageRoute widget的builder属性中创建。</span><br><span class="line"></span><br><span class="line">  将函数调用添加到 Navigator.push 中作为参数,如高亮代码所示，将路由 push 到 Navigator 的堆栈中。</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  void _pushSaved() {<br>    Navigator.of(context).push(<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 添加 MaterialPageRoute widget 及其 builder 属性。先添加生成 ListTile widget 的代码。其中 ListTile 的 divideTiles() 方法为每个 ListTile widget 之间添加水平间距。divided变量保存最终生成的所有行，并用 toList() 函数转换为列表。</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();<br>      },<br>    ),<br>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. builder 属性返回一个 Scaffold widget ，其中包含了应用栏标题名为 “Saved Suggestions” 的新路由页面。新页面的body属性由包含多个 ListTile widget 的 ListView 组成。</span><br><span class="line"></span><br><span class="line">  添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();</p>
<pre><code>    return new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Saved Suggestions&apos;),
      ),
      body: new ListView(children: divided),
    );
  },
),
</code></pre><p>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6. 热重载应用程序。对一些条目点击收藏，然后点击应用栏右侧的列表图标。显示出包含收藏夹列表的新页面。注意，Navigator 会在应用栏左侧添加一个“返回”按钮。不必再显式实现 Navigator.pop 。点击返回按钮会返回到主页面。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 6th stepsecond route](step6a-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.github.com/Sfshaza/bc5547e112e4dc3a1aa87afdf917caeb)</span><br><span class="line"></span><br><span class="line">### 第7步：使用主题更改UI ##</span><br><span class="line">在最后一步中，将使用该应用的主题。 theme 控制的是应用程序的观感。可以使用默认主题，该主题取决于使用的模拟器或真机，也可以自定义主题以反映你的品牌。</span><br><span class="line"></span><br><span class="line">可以通过配置 ThemeData 类轻松更改应用程序的主题。应用程序目前使用默认主题，现在将更改主要颜色为白色。</span><br><span class="line"></span><br><span class="line">1. 将高亮代码添加到 MyApp 类中，可以把应用程序的主题更改为白色：</span><br></pre></td></tr></table></figure></p>
<p>class MyApp extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return new MaterialApp(<br>      title: ‘Startup Name Generator’,<br>      theme: new ThemeData(<br>        primaryColor: Colors.white,<br>      ),<br>      home: new RandomWords(),<br>    );<br>  }<br>}<br>```</p>
<ol>
<li><p>热重载应用程序。请注意，整个背景都是白色的，甚至包括应用栏。</p>
</li>
<li><p>作为读者的练习，可使用 <a href="https://docs.flutter.io/flutter/material/ThemeData-class.html" target="_blank" rel="noopener">ThemeData</a> 来改变用户界面的其他方面。 Material 库中的 <a href="https://docs.flutter.io/flutter/material/Colors-class.html" target="_blank" rel="noopener">Colors</a> 类提供了多种可以使用的颜色常量，而热重载使用户界面的修改变得简单快捷。<br><a href="step7-themes.png">screenshot at completion of 7th step</a><br>有问题吗?</p>
</li>
</ol>
<p>如果又不能正常运行了，请使用以下链接中的代码查看最终应用的代码。</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/c07c91a4061fce4b5eacaaf4d82e4993/raw/4001a72c0133b97c8e16bdeb3195ca03525696bd/main.dart" target="_blank" rel="noopener">lib/main.dart</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter初体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter初体验/" itemprop="url">flutter初体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T16:44:17+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在这篇文档中你将了解如何在 Flutter 开发中进行调试和修改：从我们提供的项目模板创建一个 Flutter 应用程序，运行然后学习如何使用热重载来修改程序。</p>
<p>Flutter 是一个扩展性极强的工具集，因此你可以选择你钟爱的开发工具或者平台来写代码，编译以及运行 Flutter 应用程序。</p>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p>Android Studio: 一个完整的，高度集成的 Flutter 开发编辑器。</p>
<h4 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>依次选择 <strong>File&gt;New Flutter Project</strong></li>
<li>选择 <strong>Flutter application</strong> 作为项目类型，然后点击下一步</li>
<li>输入项目名称（例如：myapp），然后点击下一步</li>
<li>点击 Finish</li>
<li>等待 Android Studio 安装好 SDK 和创建好这个项目。<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <strong><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a></strong> 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序"><a href="#运行这个程序" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>找到 Android Studio 的主工具栏：<br><a href="&quot;images/main-toolbar.png&quot;">IntelliJ 的主工具栏</a></li>
<li>在 <strong>target selector</strong> 中，选择一个已连接的 Android 设备来运行这个程序。如果列表中没有可用的设备， 那么依次选择 <strong>Tools&gt;Android&gt;AVD Manager</strong> 创建一个可用的模拟器。了解更多，请查看 管理 AVDs。</li>
<li>点击工具栏中的 <strong>Run icon</strong>，或者在菜单栏中一次选择 <strong>Run &gt; Run</strong>。</li>
<li>如果一切正常，那么你现在就可以在你的手机或者模拟器上看到程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载"><a href="#尝试一下热重载" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p><strong>VS Code</strong>: 包含了运行和调试 Flutter 应用程序的轻量级编辑器。</p>
<h4 id="创建应用程序-1"><a href="#创建应用程序-1" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>启动 VS Code</li>
<li>依次执行 View&gt;Command Palette…</li>
<li>输入 ‘flutter’，选择 ‘Flutter: New Project’ 命令</li>
<li>输入项目名称（例如：myapp），回车</li>
<li>找到一个用于保存项目的目录，然后点击蓝色的确认按钮</li>
<li>项目会自动进行创建，创建完毕之后，main.dart 文件会被自动打开<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 Material 组件 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序-1"><a href="#运行这个程序-1" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>确保在 VS Code 的右下角能看到目标设备的名称</li>
<li>使用键盘上的 F5 按钮，或者依次执行 Debug&gt;Start Debugging</li>
<li>等待应用程序启动</li>
<li>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载-1"><a href="#尝试一下热重载-1" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="控制台-文本编辑器"><a href="#控制台-文本编辑器" class="headerlink" title="控制台 + 文本编辑器"></a>控制台 + 文本编辑器</h3><p>控制台 + 文本编辑器 你自己选择的代码编辑器加上 Flutter 提供的命令行工具来运行和构建 Flutter 应用程序。</p>
<p>创建应用程序</p>
<ol>
<li>使用 flutter create 命令来创建一个新的应用程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create myapp</span><br><span class="line">$ cd myapp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a> 的项目。</p>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 lib/main.dart 中。</p>
<h4 id="运行这个程序-2"><a href="#运行这个程序-2" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ul>
<li><p>确保 Android 设备当前处于运行状态。如果没有发现在运行的设备，查看 <a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">安装</a> 页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter devices</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 flutter run 命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></p>
</li>
</ul>
<h4 id="尝试一下热重载-2"><a href="#尝试一下热重载-2" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-开发记录/" itemprop="url">flutter-开发记录（错误或技巧）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T15:04:29+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ol>
<li>flutter doctor 显示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方案一：<br>根据提示运行flutter doctor –android-licenses 一路y就好了。</p>
<ol>
<li>Row中包含TextField时在弹出软键盘时会overflow（TextField inside of Row causes layout exception: Unable to calculate size）</li>
</ol>
<p>解决：在TextField外层在包一个Flexible组件即可；</p>
<p>参考：<a href="https://stackoverflow.com/questions/45986093/textfield-inside-of-row-causes-layout-exception-unable-to-calculate-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/45986093/textfield-inside-of-row-causes-layout-exception-unable-to-calculate-size</a> （译文：（假设您正在使用Row，因为您希望将来在TextField旁边放置其他小部件。）Row小部件想要确定其非灵活子节点的内在大小，以便它知道它为灵活子节点留下了多少空间。 但是，TextField没有固有宽度; 它只知道如何将自身大小调整到其父容器的整个宽度。 尝试将其包装在Flexible或Expanded中，告诉Row您希望TextField占用剩余空间：）</p>
<ol>
<li>Keyboard overflows TextField creating yellow/black stripes<br>文本域获取焦点时，弹出软键盘，导致overflowed错误，<br>修正：通过设置Scaffold的属性resizeToAvoidBottomPadding: false即可，</li>
</ol>
<p>原因：猜测（可能键盘的弹出导致，内容视图的高度+键盘的高度超出了一个屏幕的高度从而产生了overflowed）。</p>
<p>参考网址：<a href="https://github.com/flutter/flutter/issues/13339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13339</a> （译文：当你点击文本字段键盘显示白色内容溢出整个脚手架区域时，是的还有同样的问题。 使用resizeToAvoidBottomPadding它确实有效但我认为禁用此选项键盘不会尊重焦点文本字段，也不会将内容滚动到适当的焦点框<br>）</p>
<ol>
<li>使用cipher时报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The parameter &apos;m&apos; of the method &apos;BigIntegerV8::modPowInt&apos; has type bignum::BigIntegerV8, which does not match the corresponding type in the overridden method (dynamic).</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时我在使用依赖cipher: ^0.7.1时遇到的，后来查看Dart版本，和cipher的发布日志发现，cipher: ^0.7.1只使用与Dart 1，而开发当前用的时Dart 2，因此出现该错误，加密/解密依赖目前开发用的是 <a href="https://pub.dartlang.org/packages/crypto#-readme-tab-" target="_blank" rel="noopener">crypto</a>.</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>!!! 谨记：Flutter 中是基于数据驱动，Java中是基于事件驱动。</p>
<ol>
<li>Dart中字符串转换为字节数组或列表（How do I convert a UTF-8 String into an array of bytes in Dart?）</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:convert&apos;;</span><br><span class="line">List&lt;int&gt; bytes = utf8.encode(&quot;Some data&quot;);   //UTF8 is deprecated sind Dart 2. But it was just renamed to utf8: List&lt;int&gt; bytes = utf8.encode(&quot;Some data&quot;);</span><br><span class="line">print(bytes) //[115, 111, 109, 101, 32, 100, 97, 116, 97]</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://stackoverflow.com/questions/10404147/how-do-i-convert-a-utf-8-string-into-an-array-of-bytes-in-dart" target="_blank" rel="noopener">https://stackoverflow.com/questions/10404147/how-do-i-convert-a-utf-8-string-into-an-array-of-bytes-in-dart</a></p>
<ol>
<li>Dart json操作：<br>在Dart中json的构建和将对象转换为json字符很简单，麻烦在将json转换为一个对象,关于json的操作依赖于dart:convert；</li>
</ol>
<ul>
<li><p>构建一个json字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Smith&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;john@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对象转换为一个字符串</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json = json.encode(user);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>序列化json对象：</p>
<ul>
<li><p>序列化JSON内联  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, dynamic&gt; user = json.decode(json);</span><br><span class="line">print(&apos;Howdy, $&#123;user[&apos;name&apos;]&#125;!&apos;);</span><br><span class="line">print(&apos;We sent the verification link to $&#123;user[&apos;email&apos;]&#125;.&apos;);</span><br></pre></td></tr></table></figure>
<p>通过上面我们知道，json.decode（）只返回一个Map <string，dynamic>，这意味着我们直到运行时才知道值的类型。 使用这种方法，我们失去了大多数静态类型语言功能：类型安全，自动完成以及最重要的编译时异常。 我们的代码可能会立即变得更容易出错。<br>例如，每当我们访问名称或电子邮件字段时，我们都会很快引入拼写错误。 由于我们的整个JSON仅存在于地图结构中，因此我们的编译器不知道这是一个错字。</string，dynamic></p>
</li>
<li><p>在模型类中序列化JSON</p>
<p>我们可以通过引入一个普通的模型类来解决前面提到的问题，我们称之为User。 在User类中，我们有：<br> User.fromJson构造函数，用于从地图结构构造新的User实例<br>一个toJson方法，它将User实例转换为map。<br>这样，调用代码现在可以具有类型安全性，名称和电子邮件字段的自动完成以及编译时异常。 如果我们使用拼写错误或将字段视为int而不是字符串，我们的应用程序甚至不会编译，而不是在运行时崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final String email;</span><br><span class="line"></span><br><span class="line">  User(this.name, this.email);</span><br><span class="line"></span><br><span class="line">  User.fromJson(Map&lt;String, dynamic&gt; json)</span><br><span class="line">      : name = json[&apos;name&apos;],</span><br><span class="line">        email = json[&apos;email&apos;];</span><br><span class="line"></span><br><span class="line">  Map&lt;String, dynamic&gt; toJson() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      &apos;name&apos;: name,</span><br><span class="line">      &apos;email&apos;: email,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，序列化逻辑的责任在模型本身内部移动。 通过这种新方法，我们可以非常轻松地反序列化用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map userMap = json.decode(json);</span><br><span class="line">var user = new User.fromJson(userMap);</span><br><span class="line"></span><br><span class="line">print(&apos;Howdy, $&#123;user.name&#125;!&apos;);</span><br><span class="line">print(&apos;We sent the verification link to $&#123;user.email&#125;.&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>参考地址：  </p>
<ul>
<li><a href="https://flutter.io/json/" target="_blank" rel="noopener">https://flutter.io/json/</a></li>
</ul>
<ol>
<li>Flutter中获取设备信息：</li>
</ol>
<p>依赖于 import ‘dart:io’;和 device_info : ^0.2.0；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DeviceInfoPlugin deviceInfo = new DeviceInfoPlugin();</span><br><span class="line">if(Platform.isIOS)&#123;</span><br><span class="line">  IosDeviceInfo iosInfo = await deviceInfo.iosInfo;</span><br><span class="line">  print(&apos;Running on $&#123;iosInfo.utsname.machine&#125;&apos;);  // e.g. &quot;iPod7,1&quot;</span><br><span class="line">      //ios相关代码</span><br><span class="line">    &#125;else if(Platform.isAndroid)&#123;</span><br><span class="line">      AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;</span><br><span class="line">      print(&apos;Running on $&#123;androidInfo.model&#125;&apos;);  // e.g. &quot;Moto G (4)&quot;</span><br><span class="line">      //android相关代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考地址：  </p>
<ul>
<li>官网参考：<a href="https://github.com/flutter/plugins/tree/master/packages/device_info" target="_blank" rel="noopener">https://github.com/flutter/plugins/tree/master/packages/device_info</a></li>
<li><a href="https://segmentfault.com/a/1190000014913010?utm_source=index-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014913010?utm_source=index-hottest</a></li>
<li>网络请求简单示例 <a href="https://segmentfault.com/a/1190000013712168" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013712168</a></li>
<li>列表操作 list、map、set <a href="https://blog.csdn.net/hekaiyou/article/details/51374093" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/51374093</a></li>
<li>下拉刷新、加载更多  <a href="https://www.jianshu.com/p/0a64d84b0937" target="_blank" rel="noopener">https://www.jianshu.com/p/0a64d84b0937</a></li>
<li>flutter导航 <a href="https://blog.csdn.net/hekaiyou/article/details/72853738" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/72853738</a></li>
</ul>
<ol>
<li>Flutter加载本地资源</li>
</ol>
<p>通过异步加载本地Json资源，需要先在pubspec.yaml文件添加资源文件，然后再通过异步加载资源文件，以下为实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">flutter:</span><br><span class="line">  uses-material-design: true</span><br><span class="line">  assets:</span><br><span class="line">    - assets/config.json     //资源所在位置</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:convert&apos;;</span><br><span class="line">import &apos;dart:async&apos; show Future;</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:flutter/services.dart&apos; show rootBundle;</span><br><span class="line">Future&lt;String&gt; loadAsset() async &#123;</span><br><span class="line">  return await rootBundle.loadString(&apos;assets/config.json&apos;);</span><br><span class="line">&#125;</span><br><span class="line">void _loadJson() &#123;</span><br><span class="line">  loadAsset().then((value)&#123;</span><br><span class="line">    JsonDecoder decoder = new JsonDecoder();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; json = decoder.convert(value);</span><br><span class="line">    print(&apos;姓名：&apos;+json[0][0]+&apos;，年龄：&apos;+json[0][1]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考地址：  </p>
<ul>
<li><a href="https://blog.csdn.net/hekaiyou/article/details/54602103" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/54602103</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-配置编辑器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-配置编辑器/" itemprop="url">flutter-配置编辑器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T14:52:32+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你可以使用任意一款文本编辑器结合我们提供的命令行工具来构建 Flutter 应用程序。当然，我们更推荐的是使用我们开发的文本编辑器插件之一，来优化开发的使用体验。安装好编辑器插件之后，你会获得代码自动补全，关键词高亮，组件编辑助手，运行&amp;调试的支持等一系列实用的功能。</p>
<p>请跟随下面的步骤来为你的编辑器添加这些插件，我们支持 Android Studio, IntelliJ 以及 VS Code。如果你使用的是另外的编辑器，也没有问题，跳过这一步，直接进入 <a href="http://doc.flutter-dev.cn/get-started/test-drive/" target="_blank" rel="noopener">下一步：创建并运行你的第一个应用程序</a>。</p>
<h3 id="Android-Studio-配置"><a href="#Android-Studio-配置" class="headerlink" title="Android Studio 配置"></a>Android Studio 配置</h3><p>Android Studio: 一个完整的，高度集成的 Flutter 开发编辑器。</p>
<h4 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h4><ul>
<li>Android Studio, 3.0 或者更高的版本。</li>
</ul>
<p>当然，你也可以选择使用 IntelliJ：</p>
<ul>
<li>IntelliJ IDEA 社区版, 2017.1 或者更高的版本。</li>
<li>IntelliJ IDEA 高级版, 2017.1 或者更高的版本。</li>
</ul>
<h4 id="安装-Flutter-和-Dart-插件"><a href="#安装-Flutter-和-Dart-插件" class="headerlink" title="安装 Flutter 和 Dart 插件"></a>安装 Flutter 和 Dart 插件</h4><p>Flutter 的开发支持需要安装 2 个插件：</p>
<ul>
<li>Flutter 插件可以提高 Flutter 在开发过程中的开发效率（运行，调试，热重载等等）。</li>
<li>Dart 插件提提升了代码层面的开发效率（在你敲代码的同时进行代码校验，代码自动补全等等）。</li>
</ul>
<p>安装步骤：</p>
<ol>
<li>启动 Android Studio。</li>
<li>打开插件设置（在 macOS 上路径为<br><strong>Preferences&gt;Plugins</strong>，在 Windows 和 Linux 上路径为 <strong>File&gt;Settings&gt;Plugins</strong>）。</li>
<li>选择 <strong>Browse repositories…</strong>，找到或者在搜索栏输入 Flutter，然后点击 install。</li>
<li>当弹出对话框提示要安装 Dart 插件的时候，点击 Yes 接受。</li>
<li>如果弹出 <strong>Restart</strong> 需要重启编辑器的时候，点击 Yes 接受。</li>
</ol>
<h3 id="Visual-Studio-Code-VS-Code-配置"><a href="#Visual-Studio-Code-VS-Code-配置" class="headerlink" title="Visual Studio Code (VS Code) 配置"></a>Visual Studio Code (VS Code) 配置</h3><p><strong>VS Code</strong>: 包含了运行和调试 Flutter 应用程序的轻量级编辑器。</p>
<h4 id="安装-VS-Code"><a href="#安装-VS-Code" class="headerlink" title="安装 VS Code"></a>安装 VS Code</h4><ul>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a>,   <ol>
<li>20.1 或更高版本。</li>
</ol>
</li>
</ul>
<h4 id="安装-Dart-Code-插件"><a href="#安装-Dart-Code-插件" class="headerlink" title="安装 Dart Code 插件"></a>安装 Dart Code 插件</h4><ol>
<li>启动 VS Code</li>
<li>依次执行 View&gt;Command Palette…</li>
<li>在扩展插件安装面板的输入框输入 dart code 关键词，在显示的列表中选择 ‘Dart Code’ 插件，然后点击 Install</li>
<li>点击 ‘OK’ 重新加载 VS Code</li>
</ol>
<h4 id="使用-Flutter-Doctor-来验证你的配置"><a href="#使用-Flutter-Doctor-来验证你的配置" class="headerlink" title="使用 Flutter Doctor 来验证你的配置"></a>使用 Flutter Doctor 来验证你的配置</h4><ol>
<li>依次执行 View&gt;Command Palette…</li>
<li>输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ 命令</li>
<li>在日志打印窗口的 ‘OUTPUT’ 标签中查看打印出的日志信息，看看有没有报错</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-install/" itemprop="url">Flutter_install</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T09:06:17+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章目录：  </p>
<ul>
<li>系统要求</li>
<li>获取Flutter Sdk<ul>
<li>克隆仓库</li>
<li>运行flutter doctor</li>
<li>更新系统路径</li>
</ul>
</li>
<li>编译器设置</li>
<li>平台设置</li>
<li>IOS设置<ul>
<li>安装Xcode</li>
<li>设置IOS模拟器</li>
<li>部署到IOS设备</li>
</ul>
</li>
<li>Android设置<ul>
<li>安装Android Studio</li>
<li>设置Android设备</li>
<li>设置Android模拟器</li>
</ul>
</li>
</ul>
<h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>安装并运行 Flutter ，你的开发环境必须满足这些最低要求：  </p>
<ul>
<li><strong>操作系统</strong>：macOS （64-bit）。</li>
<li><strong>磁盘空间</strong>： 700 MB （不包括 Xcode 和 Android Studio 的磁盘空间）。</li>
<li><strong>工具</strong>：Flutter 依赖你环境中可用的这些命令行工具。<ul>
<li>bash， mkdir，rm，git， curl，unzip，which   </li>
</ul>
</li>
</ul>
<h3 id="获取-Flutter-SDK"><a href="#获取-Flutter-SDK" class="headerlink" title="获取 Flutter SDK"></a>获取 Flutter SDK</h3><p>获取 Flutter ，你可使用 <strong>git</strong> 去克隆 Flutter 的仓库然后添加 <strong>flutter</strong> 工具到你的路径，运行 flutter doctor 显示你可能要安装的依赖。</p>
<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>如果你是第一次在你机器上安装 Flutter ，克隆 <strong>beta</strong> 分支的仓库然后添加 <strong>flutter</strong> 工具到你的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b beta https://github.com/flutter/flutter.git</span><br><span class="line">$ export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p>上面的命令会在当前的终端窗口暂时设置 PATH 变量，要永久添加 Flutter 到你的路径，请参阅 <a href="http://doc.flutter-dev.cn/setup-macos/#update-your-path" target="_blank" rel="noopener">更新你的路径</a>。</p>
<p>要更新一个现有版本的 Flutter ，请参阅<a href="http://doc.flutter-dev.cn/upgrading/" target="_blank" rel="noopener">更新 Flutter</a> 。</p>
<h4 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h4><p>运行以下命令可以看到你是否需要安装任何依赖来完成安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter doctor</span><br></pre></td></tr></table></figure></p>
<p>这个命令会检查你的环境并显示一份报告在终端窗口，Dart SDK 已和 Flutter 捆绑在一起，所以你不需要额外安装 Dart 。仔细检查输出信息是否需要安装其他软件或者执行其他任务（以 <strong>粗体</strong> 字显示）。</p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-] Android toolchain - develop for Android devices</span><br><span class="line">    • Android SDK at /Users/obiwan/Library/Android/sdk</span><br><span class="line">    ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</span><br><span class="line">    • Try re-installing or updating your Android SDK,</span><br><span class="line">      visit https://flutter.io/setup/#android-setup for detailed instructions.</span><br></pre></td></tr></table></figure></p>
<p>这是你第一次去运行 flutter 命令（比如 <strong>flutter doctor</strong> ），它会下载依赖库，并且自行编译。后续运行这条命令就会更加快了。</p>
<p>接下来的章节就是描述怎么执行这些任务和完成设置过程。你会看到 <strong>flutter doctor</strong> 输出了,假如你是用了 IDE ，就会显示 IntelliJ IDEA ， Android Studio 和 VS Code 这些编译器的可用插件。请参阅<a href="http://doc.flutter-dev.cn/get-started/editor/" target="_blank" rel="noopener">编译器设置</a>根据步骤去安装 Flutter 和 Dart 插件。</p>
<p>当你安装好了所有缺失的依赖库，运行 <strong>flutter doctor</strong> 命令去验证你的设置是否正确。</p>
<p>这个 <strong>flutter</strong> 工具使用了 Google Analytics 匿名分析 报告功能，使用情况信息和基本崩溃报告。这些数据用于帮助改进 Flutter 工具。并且这个分析报告是不会在第一次运行或者任何涉及到 <strong>flutter config</strong> 的设置运行时发送，因此你可以在任何分析之前退出分析。要禁用分析的话，输入 <strong>flutter config –no-analytics</strong> ，要显示当前配置的话输入 <strong>flutter config</strong> 。详情请参阅 Google 的隐私政策：www.google.com/intl/en/policies/privacy。</p>
<h4 id="更新你的路径"><a href="#更新你的路径" class="headerlink" title="更新你的路径"></a>更新你的路径</h4><p>你只能在命令行中更新你当前会话窗口的 PATH 变量，如<a href="http://doc.flutter-dev.cn/setup-macos/#clone-the-repo" target="_blank" rel="noopener">克隆 Flutter</a> 库所示。当永久更新这个变量，这样子你就可以在任意终端会话中运行 flutter 命令了。</p>
<p>对于计算机来说，永久给全部终端会话修改这个变量这些操作都是不同的。通常，你会打开新窗口时将命令输入。举个例子：</p>
<ol>
<li>确定好放置 Flutter SDK 的目录，你会在步骤 3 用到它。</li>
<li>打开（或者创建） <strong>$HOME/.bash_profile</strong> 这个文件或者文件名可能不同于你计算机的。</li>
<li><p>添加下面命令行并将 <strong>[PATH_TO_FLUTTER_GIT_DIRECTORY]</strong> 改为你克隆 Flutter 仓库的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <strong>source $HOME/.bash_profile</strong> 刷新当前窗口。</p>
</li>
<li>验证 <strong>flutter/bin</strong> 是否在你的路径上：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多的细节，可以参阅<a href="https://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path" target="_blank" rel="noopener">StackExchange 上的问题</a>。</p>
<h3 id="编译器设置"><a href="#编译器设置" class="headerlink" title="编译器设置"></a>编译器设置</h3><p>使用 <strong>flutter</strong> 命令行工具，你可以使用任何编辑器去开发 Flutter 应用。在命令提示符窗口输入 flutter help 可以显示可用的操作。</p>
<p>我推荐使用我们的插件来获取<a href="http://doc.flutter-dev.cn/using-ide/" target="_blank" rel="noopener">丰富的 IDE 体验</a> ，支持编辑，运行和调试 Flutter 应用。参阅<a href="http://doc.flutter-dev.cn/get-started/editor/" target="_blank" rel="noopener">编译器设置</a>了解详细步骤。</p>
<h3 id="平台设置"><a href="#平台设置" class="headerlink" title="平台设置"></a>平台设置</h3><p>macOS 支持为 iOS 和 Android 开发 Flutter 应用程序。现在只要在两个系统平台中的一个完成设置，就可以构建运行你的第一个 Flutter 应用程序了。</p>
<h3 id="iOS-设置"><a href="#iOS-设置" class="headerlink" title="iOS 设置"></a>iOS 设置</h3><h4 id="安装-Xcode"><a href="#安装-Xcode" class="headerlink" title="安装 Xcode"></a>安装 Xcode</h4><p>为 iOS 开发 Flutter 应用，你需要一台安装了 Xcode 7.2 或者更新版本的 Mac 。</p>
<ol>
<li>安装 Xcode 7.2 或者更新版本（通过<a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">网页下载</a>或者 <a href="https://itunes.apple.com/us/app/xcode/id497799835" target="_blank" rel="noopener">App Store</a> 安装）。</li>
<li>通过在在命令行运行 <strong>sudo xcode-select –switch /Applications/Xcode.app/Contents/Developer</strong> 来配置 Xcode 命令行工具来使用安装好的最新版本 Xcode 。</li>
</ol>
<p>大多数情况下，这是安装最新版 Xcode 的正确的路径。如果你想使用不同的版本，请改为指定的路径。</p>
<p>3.确保 Xcode 许可协议是通过打开一次 Xcode 或者从命令行中运行 <strong>sudo xcodebuild -license</strong> 来签署的。<br>使用 Xcode ，你就可以在你的 iOS 设备或者在模拟器上运行 Flutter 应用。</p>
<h4 id="设置-iOS-模拟器"><a href="#设置-iOS-模拟器" class="headerlink" title="设置 iOS 模拟器"></a>设置 iOS 模拟器</h4><p>准备在 iOS 模拟器上运行并测试你的 Flutter 应用，根据以下步骤：</p>
<p>在你的 Mac 上，可以通过 Spotlight 或者使用以下命令找到模拟器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open -a Simulator</span><br></pre></td></tr></table></figure></p>
<ol>
<li>通过检查模拟器的 <strong>Hardware &gt; Device</strong> 设置，确保你的模拟器运行 64 位的设备（iPhone 5s 或者更高版本）。</li>
<li>根据你开发设备的屏幕尺寸，模拟高屏幕密度的 iOS 设备可能会溢出你的屏幕，在模拟器的 <strong>Window &gt; Scale</strong> 菜单设置设备的比例。</li>
<li>运行 <strong>flutter run</strong> 来启动你的应用</li>
</ol>
<h4 id="部署到-iOS-设备"><a href="#部署到-iOS-设备" class="headerlink" title="部署到 iOS 设备"></a>部署到 iOS 设备</h4><p>部署你的 Flutter 应用程序到物理的 iOS 设备，你需要一些额外的工具和一个 Apple 账号。你还需要在 Xcode 中设置物理设备的部署。</p>
<ol>
<li>安装 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a>。</li>
<li>打开终端运行这些命令来安装部署 Flutter 应用程序到 iOS 设备的工具<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install --HEAD libimobiledevice</span><br><span class="line">$ brew install ideviceinstaller ios-deploy cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果这些命令中的任何一个命令失败出现错误，运行 <strong>brew doctor</strong> 并根据说明解决问题。</p>
<ol>
<li><p>遵循 Xcode 的签名流程来配置你的项目：</p>
<ol>
<li>打开默认的 Xcode 工作空间，找到你的 Flutter 项目目录并打开终端运行 <strong>open ios/Runner.xcworkspace</strong> 。</li>
<li>在 Xcode 左边的导航面板，选择 <strong>Runner</strong> 项目。</li>
<li><p>在 <strong>Runner</strong> 目标设置界面，确保在 <strong>General &gt; Signing &gt; Team</strong> 选择了你的开发团队，当你选择了开发团队，Xcode 创建和下载一个开发证书，向你的设备注册你的账户，并创建和下载配置文件（如果你需要的话）。</p>
<ul>
<li>要开始你的第一个 iOS 开发项目，你可能需要在 Xcode 上注册你的 Apple ID。<br>Xcode account add<br>任意的 Apple ID 都支持开发和测试。需要注册 Apple 开发者计划才能分发你的应用到 App Store 。请参阅 <a href="https://developer.apple.com/support/compare-memberships/" target="_blank" rel="noopener">Apple 会员类型之间的差异</a>。</li>
<li>你第一次用物理设备开发 iOS 时，你需要同时信任该设备上的 Mac 和开发证书。 当你的 iOS 设备第一次连接到你的 Mac 时，在对话框提示中选择 <strong>Trust</strong>。<br><a href="&quot;images/trust-computer.png&quot;">Trust Mac</a><br>然后，打开 iOS 设备上的设置，选择 <strong>常规 &gt; 设备管理</strong> 然后信任你的证书。<br>如果 Xcode 的自动签名失败，验证项目的 <strong>General &gt; Identity &gt; Bundle Identifier</strong> 是否唯一。<br><a href="&quot;xcode-unique-bundle-id.png&quot;">Check the app’s Bundle ID</a><br>运行flutter run 启动你的应用程序。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Android设置"><a href="#Android设置" class="headerlink" title="Android设置"></a>Android设置</h3><h4 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h4><p>为 Android 开发 Flutter 应用，你可以使用 Mac ，Windows 或者是 Linux（64 位）机器。</p>
<p>Flutter 要求安装和配置 Android Studio：</p>
<ol>
<li><p>下载并安装 <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>。</p>
</li>
<li><p>启动 Android Studio，并执行 Android Studio 安装向导。这将会安装 Flutter 为 Android 开发所需的最新的 Android SDK ，Android SDK 平台工具和 Android SDK 构建工具。</p>
</li>
</ol>
<h4 id="设置你的-Android-设备"><a href="#设置你的-Android-设备" class="headerlink" title="设置你的 Android 设备"></a>设置你的 Android 设备</h4><p>为了在 Android 设备上运行和测试你的 Flutter 应用，你需要一台运行 Android 4.1（ API 级别 16 ）或者更高版本的 Android 设备。</p>
<ol>
<li>在你的设备上启动 <strong>开发者选项</strong> 和 <strong>USB 调试</strong>，详情说明可在 <a href="https://developer.android.com/studio/debug/dev-options.html" target="_blank" rel="noopener">Android 文档</a>中找到。</li>
<li>使用 USB 线将设备插入电脑。如果在设备上出现提示，请授权你的电脑访问你的设备。</li>
<li>在终端运行 flutter devices 命令来验证 Flutter 识别到你连接的 Android 设备。</li>
<li>运行 flutter run 来启动的你的应用。<br>通常情况下， Flutter 使用了 adb 工具所基于的 Android SDK 版本，如果你要安装使用不同的 Android SDK 版本，就必须设置 ANDROID_HOME 环境变量设置为安装目录。</li>
</ol>
<h4 id="设置-Android-模拟器"><a href="#设置-Android-模拟器" class="headerlink" title="设置 Android 模拟器"></a>设置 Android 模拟器</h4><p>准备在 Android 模拟器上运行和测试你的 Flutter 应用，需要按照以下几个步骤来操作：</p>
<ol>
<li>在你的电脑上启动 <a href="https://developer.android.com/studio/run/emulator-acceleration.html" target="_blank" rel="noopener">VM 加速</a>。<ol>
<li>启动 <strong>Android Studio &gt; Tools &gt; Android &gt; AVD Manager</strong> 和选择 <strong>Create Virtual Device</strong> 。</li>
<li>选择一个设备的定义和选择 <strong>Next</strong> 。</li>
<li>为你的模拟器 Android 版本选择一个或者多个系统镜像，和选择 <strong>Next</strong> 。推荐使用 x86 or x86_64 镜像。</li>
<li>为了提高模拟器性能，选择 <strong>Hardware - GLES 2.0</strong> 来启动<a href="https://developer.android.com/studio/run/emulator-acceleration.html" target="_blank" rel="noopener">硬件加速</a>。</li>
<li>验证 AVD 的配置是否正确，然后选择 Finish 。</li>
</ol>
</li>
</ol>
<p>有关上述步骤的详细信息,请查阅<a href="https://developer.android.com/studio/run/managing-avds.html" target="_blank" rel="noopener">管理 AVDs</a> 。</p>
<ol>
<li>在 Android 虚拟设备管理器中，在工具栏点击 <strong>Run</strong> 。模拟器启动和显示所选操作系统版本和设备的默认界面。</li>
<li>通过 <strong>flutter run</strong> 来启动你的应用，连接设备的名称是 <strong>Android SDK built for <platform></platform></strong> ，这里的 platform 是指设备 soc 芯片系列，比如 x86 。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/Android音视频点知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/Android音视频点知识/" itemprop="url">音视频点知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:23:15+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>视频是什么<br>&nbsp;&nbsp;&nbsp;&nbsp;静止的画面叫图像（picture）。连续的图像变化每秒超过24帧（frame）画面以上时，根椐视觉暂留原理，人眼无法辨别每付单独的静态画面，看上去是平滑连续的视觉效果。这样的连续画面叫视频。当连续图像变化每秒低于24帧画面时，人眼有不连续的感觉叫动画（cartoon）。</p>
</li>
<li><p>流媒体<br>&nbsp;&nbsp;&nbsp;&nbsp;指采用流式传输的方式在Internet / Intranet播放的媒体格式.流媒体的数据流随时传送随 时播放，只是在开始时有些延迟边下载边播入的流式传输方式不仅使启动延时大幅度地缩短，而且对系统缓存容量的需求也大大降低，极大地减少用户用在等待的时间。</p>
</li>
<li><p>分辨率<br>&nbsp;&nbsp;&nbsp;&nbsp;分辨率是一个表示平面图像精细程度的概念，通常它是以横向和纵向点的数量来衡量的，表示成水平点数垂直点数的形式，在计算机显示领域我们也表示成“每英寸像素”（ppi）.在一个固定的平面内，分辨率越高，意味着可使用的点数越多，图像越细致。</p>
</li>
<li><p>码率<br>&nbsp;&nbsp;&nbsp;&nbsp;数据传输时单位时间传送的数据位数,可以理解其为取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，如何用最低的码率达到最少的失真，一般我们用的单位是kbps即千位每秒。</p>
</li>
<li><p>帧率<br>&nbsp;&nbsp;&nbsp;&nbsp;帧/秒（frames per second）的缩写，也称为帧速率，测量用于保存、显示动态视频的信息数量。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。每秒钟帧数 （fps） 愈多，所显示的动作就会愈流畅，可理解为1秒钟时间里刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，也就是指每秒钟能够播放（或者录制）多少格画面。</p>
</li>
</ul>
<h3 id="多媒体的格式分类"><a href="#多媒体的格式分类" class="headerlink" title="多媒体的格式分类"></a>多媒体的格式分类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;封装格式(专业上讲叫容器,通俗的叫文件格式),视频编解码,音频编解码。</p>
<ul>
<li>常见的封装格式<ul>
<li>MPEG : 编码采用的容器，具有流的特性。里面又分为 PS，TS 等，PS 主要用于 DVD 存储，TS 主要用于 HDTV.</li>
<li>MPEG Audio Layer 3 :大名鼎鼎的 MP3，已经成为网络音频的主流格式，能在 128kbps 的码率接近 CD 音质</li>
<li>MPEG-4(Mp4) : 编码采用的容器，基于 QuickTime MOV 开发，具有许多先进特性;实际上是对Apple公司开发的MOV格式(也称Quicktime格式)的一种改进.</li>
<li>MKV: 它能把 Windows Media Video，RealVideo，MPEG-4 等视频音频融为一个文件，而且支持多音轨，支持章节字幕等;开源的容器格式</li>
<li>3GP : 3GPP视频采用的格式， 主要用于流媒体传送;3GP其实是MP4格式的一种简化版本,是手机视频格式的绝对主流.</li>
<li>MOV : QuickTime 的容器，恐怕也是现今最强大的容器，甚至支持虚拟现实技术，Java等，它的变种 MP4,3GP都没有这么厉害;广泛应用于Mac OS操作系统，在Windows操作系统上也可兼容，但是远比不上AVI格式流行</li>
<li>AVI : 最常见的音频视频容器,音频视频交错（Audio Video Interleaved）允许视频和音频交错在一起同步播放.</li>
<li>WAV : 一种音频容器，大家常说的 WAV 就是没有压缩的 PCM 编码，其实 WAV 里面还可以包括 MP3 等其他 ACM 压缩编码等等</li>
</ul>
</li>
</ul>
<h3 id="流媒体协议-RTP-RTCP-RTSP-RTMP-HLS"><a href="#流媒体协议-RTP-RTCP-RTSP-RTMP-HLS" class="headerlink" title="流媒体协议(RTP RTCP RTSP RTMP HLS)"></a>流媒体协议(RTP RTCP RTSP RTMP HLS)</h3><ul>
<li>RTP RTCP RTSP<ul>
<li>RTP :(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输层协议.RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的</li>
<li>RTCP:Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）实时传输控制协议,是实时传输协议（RTP）的一个姐妹协议，RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的</li>
<li>RTSP:（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议,RTSP提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用TCP或UDP来传送串流内容，比较能容忍网络延迟</li>
</ul>
</li>
</ul>
<p>RTP不像http和ftp可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。<br>RTSP与RTP最大的区别在于：RTSP是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP可基于RTP来传送数据，还可以选择TCP、UDP、组播UDP等通道来发送数据，具有很好的扩展性。它时一种类似与http协议的网络应用层协议</p>
<ul>
<li><p>RTMP<br>RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p>
</li>
<li><p>HLS<br>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备（如iPhone、iPad）提供音视频直播和点播方案。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p>
</li>
</ul>
<p>参考文献：<br>[1]. 基础知识 <a href="https://www.jianshu.com/p/8436c7353296" target="_blank" rel="noopener">https://www.jianshu.com/p/8436c7353296</a><br>[2]. android视频播放实现 <a href="https://blog.csdn.net/u011403718/article/details/53813713" target="_blank" rel="noopener">https://blog.csdn.net/u011403718/article/details/53813713</a><br>[3]. android种MediaCodeC编码 <a href="https://blog.csdn.net/mirkerson/article/details/38520175" target="_blank" rel="noopener">https://blog.csdn.net/mirkerson/article/details/38520175</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/MediaExtractor译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/MediaExtractor译文/" itemprop="url">MediaExtractor译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:20:26+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MediaExtractor"><a href="#MediaExtractor" class="headerlink" title="MediaExtractor"></a>MediaExtractor</h3><p>官网描述是：MediaExtractor facilitates extraction of demuxed, typically encoded, media data from a data source. added in API level 16。  public final class MediaExtractor<br>extends Object.<br>译文：MediaExtractor便于从数据源中提取复用的，典型编码的媒体数据。 在api 16时候加入到sdk的。<br>其一般的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor extractor = new MediaExtractor();</span><br><span class="line">extractor.setDataSource(...);</span><br><span class="line">int numTracks = extractor.getTrackCount();</span><br><span class="line">for (int i = 0; i &lt; numTracks; ++i) &#123;</span><br><span class="line">  MediaFormat format = extractor.getTrackFormat(i);</span><br><span class="line">  String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">  if (weAreInterestedInThisTrack) &#123;</span><br><span class="line">    extractor.selectTrack(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ByteBuffer inputBuffer = ByteBuffer.allocate(...)</span><br><span class="line">while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) &#123;</span><br><span class="line">  int trackIndex = extractor.getSampleTrackIndex();</span><br><span class="line">  long presentationTimeUs = extractor.getSampleTime();</span><br><span class="line">  ...</span><br><span class="line">  extractor.advance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extractor.release();</span><br><span class="line">extractor = null;</span><br></pre></td></tr></table></figure></p>
<p>在使用该类的时候可能需要使用到Manifest.permission.INTERNET权限，当数据源为网络数据时。   </p>
<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><ol>
<li>嵌套子类   </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MediaExtractor.CasInfo</td>
<td style="text-align:left">Describes the conditional access system used to scramble a track. （描述用于对轨道进行加扰的条件访问系统。）</td>
</tr>
<tr>
<td style="text-align:left">MediaExtractor.MetricsConstants</td>
<td style="text-align:left">度量标准常量</td>
</tr>
</tbody>
</table>
<ol>
<li>常量   </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">常量名</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SAMPLE_FLAG_ENCRYPTED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">The sample is (at least partially) encrypted（采样加密）, see also the documentation for MediaCodec.queueSecureInputBuffer(int, int, MediaCodec.CryptoInfo, long, int)</td>
<td style="text-align:left">2 (0x00000002)</td>
</tr>
<tr>
<td style="text-align:left">SAMPLE_FLAG_PARTIAL_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">This indicates that the buffer only contains part of a frame, and the decoder should batch the data until a buffer without this flag appears before decoding the frame.（这表明缓冲区只包含帧的一部分，并且解码器应该对数据进行批处理，直到没有该标志的缓冲区在解码帧之前出现。）</td>
<td style="text-align:left">4 (0x00000004)</td>
</tr>
<tr>
<td style="text-align:left">SAMPLE_FLAG_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">The sample is a sync sample (or in MediaCodec’s terminology it is a key frame.)（该示例是同步样本（或者在MediaCodec的术语中，它是一个关键帧）。）</td>
<td style="text-align:left">1 (0x00000001)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_CLOSEST_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to the sync sample closest to the specified time（如果可能的话，寻找最接近指定时间的同步采样）</td>
<td style="text-align:left">2 (0x00000002)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_NEXT_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to a sync sample at or after the specified time（如果可能的话，在指定的时间或之 <strong>后</strong> 寻找同步样本。）</td>
<td style="text-align:left">1 (0x00000001)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_PREVIOUS_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to a sync sample at or before the specified time（如果可能的话，在指定的时间或之 <strong>前</strong> 寻找同步样本。）</td>
<td style="text-align:left">0 (0x00000000)</td>
</tr>
</tbody>
</table>
<ol>
<li><p>公共构造器<br>MediaExtractor()  </p>
</li>
<li><p>公共方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">advance()</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Advance to the next sample.（前进到下一个采样）</td>
</tr>
<tr>
<td style="text-align:left">getAudioPresentations(int trackIndex)</td>
<td style="text-align:left">List<audiopresentation\></audiopresentation\></td>
<td style="text-align:left">Get the list of available audio presentations for the track.（获取该曲目的可用音频演示列表。）</td>
</tr>
<tr>
<td style="text-align:left">getCachedDuration()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns an estimate of how much data is presently cached in memory expressed in microseconds.（返回目前在内存中缓存的数据量，以微秒为单位表示。）</td>
</tr>
<tr>
<td style="text-align:left">getCasInfo(int index)</td>
<td style="text-align:left">MediaExtractor.CasInfo</td>
<td style="text-align:left">Retrieves the information about the conditional access system used to scramble a track.（检索有关用于加密曲目的条件访问系统的信息。）</td>
</tr>
<tr>
<td style="text-align:left">getDrmInitData()</td>
<td style="text-align:left">DrmInitData</td>
<td style="text-align:left">Extract DRM initialization data if it exists（提取DRM初始化数据（如果存在））</td>
</tr>
<tr>
<td style="text-align:left">getMetrics()</td>
<td style="text-align:left">PersistableBundle</td>
<td style="text-align:left">Return Metrics data about the current media container.(返回有关当前媒体容器的度量标准数据。)</td>
</tr>
<tr>
<td style="text-align:left">getPsshInfo()</td>
<td style="text-align:left">Map<uuid, byte[]\=""></uuid,></td>
<td style="text-align:left">Get the PSSH info if present.(获取PSSH信息，如果存在。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleCryptoInfo(MediaCodec.CryptoInfo info)</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">If the sample flags indicate that the current sample is at least partially encrypted, this call returns relevant information about the structure of the sample data required for decryption.(如果样本标志指示当前样本至少部分加密，则此调用返回有关解密所需的样本数据结构的相关信息。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleFlags()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Returns the current sample’s flags.(返回当前采样的标志。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleSize()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns the current sample’s presentation size</td>
</tr>
<tr>
<td style="text-align:left">getSampleTime()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns the current sample’s presentation time in microseconds.(以微秒为单位返回当前样本的呈现时间。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleTrackIndex()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Returns the track index the current sample originates from (or -1 if no more samples are available)(返回当前样本来源的轨道索引（如果没有更多样本可用，则返回-1）)</td>
</tr>
<tr>
<td style="text-align:left">getTrackCount()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Count the number of tracks found in the data source.(计算数据源中找到的曲目数量。)</td>
</tr>
<tr>
<td style="text-align:left">getTrackFormat(int index)</td>
<td style="text-align:left">MediaFormat</td>
<td style="text-align:left">Get the track format at the specified index.(获取指定索引处的曲目格式。)</td>
</tr>
<tr>
<td style="text-align:left">hasCacheReachedEndOfStream()</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Returns true iff we are caching data and the cache has reached the end of the data stream (for now, a future seek may of course restart the fetching of data).(如果我们正在缓存数据并且缓存已到达数据流的末尾（现在，未来的查找当然可能会重新开始提取数据），则返回true。)</td>
</tr>
<tr>
<td style="text-align:left">readSampleData(ByteBuffer byteBuf, int offset)</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Retrieve the current encoded sample and store it in the byte buffer starting at the given offset.(检索当前编码样本并将其存储在从给定偏移量开始的字节缓冲区中。)</td>
</tr>
<tr>
<td style="text-align:left">release()</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Make sure you call this when you’re done to free up any resources instead of relying on the garbage collector to do this for you at some point in the future.(确保你在完成任务时释放任何资源，而不是依赖垃圾回收器在将来的某个时刻为你做这件事。)</td>
</tr>
<tr>
<td style="text-align:left">seekTo(long timeUs, int mode)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">All selected tracks seek near the requested time according to the specified mode.(根据指定的模式，所有选定的曲目都会在请求的时间附近寻找。)</td>
</tr>
<tr>
<td style="text-align:left">selectTrack(int index)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Subsequent calls to readSampleData(ByteBuffer, int), getSampleTrackIndex() and getSampleTime() only retrieve information for the subset of tracks selected.(随后对readSampleData（ByteBuffer，int），getSampleTrackIndex（）和getSampleTime（）的调用仅检索所选轨道子集的信息。)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(AssetFileDescriptor afd)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (AssetFileDescriptor) to use.(设置要使用的数据源（AssetFileDescriptor）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(Context context, Uri uri, Map<string, string=""> headers)</string,></td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source as a content Uri.(将数据源设置为内容Uri。)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(FileDescriptor fd)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (FileDescriptor) to use.((设置要使用的数据源（FileDescriptor）))</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(MediaDataSource dataSource)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (MediaDataSource dataSource) to use.(设置要使用的数据源（MediaDataSource）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(FileDescriptor fd, long offset, long length)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (FileDescriptor) to use.(设置要使用的数据源（MediaDataSource）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(String path)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (file-path or http URL) to use.(设置要使用的数据源（文件路径或http URL）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(String path, Map<string, string=""> headers)</string,></td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (file-path or http URL) to use.(设置要使用的数据源（文件路径或http URL）)</td>
</tr>
<tr>
<td style="text-align:left">setMediaCas(MediaCas mediaCas)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the MediaCas instance to use.(设置要使用的MediaCas实例。)</td>
</tr>
<tr>
<td style="text-align:left">unselectTrack(int index)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Subsequent calls to readSampleData(ByteBuffer, int), getSampleTrackIndex() and getSampleTime() only retrieve information for the subset of tracks selected.(随后对readSampleData（ByteBuffer，int），getSampleTrackIndex（）和getSampleTime（）的调用仅检索所选轨道子集的信息。)</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/MediaCodec译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/MediaCodec译文/" itemprop="url">MediaCodec译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:17:28+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MediaCodec"><a href="#MediaCodec" class="headerlink" title="MediaCodec"></a>MediaCodec</h3><p>官方描述：MediaCodec class can be used to access low-level media codecs, i.e. encoder/decoder components. It is part of the Android low-level multimedia support infrastructure (normally used together with MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, and AudioTrack.)<br>译文：MediaCodec类可用于访问底层媒体编解码器，例如，编码器/解码器组件。 它是Android低级多媒体支持基础架构的一部分（通常与MediaExtractor，MediaSync，MediaMuxer，MediaCrypto，MediaDrm，Image，Surface和AudioTrack一起使用。）   </p>
<p><img src="/images/MediaCodeC_bufferflow.png" alt="MediaCodeC中缓存的处理">  </p>
<p>从广义上讲，编解码器就是处理输入数据来产生输出数据。MediaCode采用异步方式处理数据，并且使用了一组输入输出缓存（input and output buffers）。简单来讲，你请求或接收到一个空的输入缓存（input buffer），向其中填充满数据并将它传递给编解码器处理。编解码器处理完这些数据并将处理结果输出至一个空的输出缓存（output buffer）中。最终，你请求或接收到一个填充了结果数据的输出缓存（output buffer），使用完其中的数据，并将其释放给编解码器再次使用。</p>
<ol>
<li>数据类型（Data Types）</li>
</ol>
<p>　　编解码器可以处理三种类型的数据：压缩数据（即为经过H254. H265. 等编码的视频数据或AAC等编码的音频数据）、原始音频数据、原始视频数据。三种类型的数据均可以利用ByteBuffers进行处理，但是对于原始视频数据应提供一个Surface以提高编解码器的性能。Surface直接使用本地视频数据缓存（native video buffers），而没有映射或复制数据到ByteBuffers，因此，这种方式会更加高效。在使用Surface的时候，通常不能直接访问原始视频数据，但是可以使用ImageReader类来访问非安全的解码（原始）视频帧。这仍然比使用ByteBuffers更加高效，因为一些本地缓存（native buffer）可以被映射到 direct ByteBuffers。当使用ByteBuffer模式，你可以利用Image类和getInput/OutputImage(int)方法来访问到原始视频数据帧。</p>
<ol>
<li>压缩缓存（Compressed Buffers）</li>
</ol>
<p>　　输入缓存（对于解码器）和输出缓存（对编码器）中包含由多媒体格式类型决定的压缩数据。对于视频类型是单个压缩的视频帧。对于音频数据通常是单个可访问单元(一个编码的音频片段，通常包含几毫秒的遵循特定格式类型的音频数据)，但这种要求也不是十分严格，一个缓存内可能包含多个可访问的音频单元。在这两种情况下，缓存不会在任意的字节边界上开始或结束，而是在帧或可访问单元的边界上开始或结束。</p>
<ol>
<li>原始音频缓存（Raw Audio Buffers）</li>
</ol>
<p>　　原始的音频数据缓存包含完整的PCM（脉冲编码调制）音频数据帧，这是每一个通道按照通道顺序的一个样本。每一个样本是一个按照本机字节顺序的16位带符号整数（16-bit signed integer in native byte order）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">short[] getSamplesForChannel(MediaCodec codec, int bufferId, int channelIx) &#123;</span><br><span class="line">　　ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);</span><br><span class="line">　　MediaFormat format = codec.getOutputFormat(bufferId);</span><br><span class="line">　　ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();</span><br><span class="line">　　int numChannels = formet.getInteger(MediaFormat.KEY_CHANNEL_COUNT);</span><br><span class="line">　　if (channelIx &lt; 0 || channelIx &gt;= numChannels) &#123;</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br><span class="line">　　short[] res = new short[samples.remaining() / numChannels];</span><br><span class="line">　　for (int i = 0; i &lt; res.length; ++i) &#123;</span><br><span class="line">　　　　res[i] = samples.get(i * numChannels + channelIx);</span><br><span class="line">　　&#125;</span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>原始视频缓存（Raw Video Buffers）</li>
</ol>
<p>　　在ByteBuffer模式下，视频缓存（video buffers）根据它们的颜色格式（color format）进行展现。你可以通过调用getCodecInfo().getCapabilitiesForType(…).colorFormats方法获得编解码器支持的颜色格式数组。视频编解码器可以支持三种类型的颜色格式：  </p>
<ul>
<li>本地原始视频格式（native raw video format）：这种格式通过COLOR_FormatSurface标记，并可以与输入或输出Surface一起使用。</li>
<li>灵活的YUV缓存（flexible YUV buffers）(例如：COLOR_FormatYUV420Flexible)：利用一个输入或输出Surface，或在在ByteBuffer模式下，可以通过调用getInput/OutputImage(int)方法使用这些格式。</li>
<li>其他，特定的格式（other, specific formats）：通常只在ByteBuffer模式下被支持。有些颜色格式是特定供应商指定的。其他的一些被定义在 MediaCodecInfo.CodecCapabilities中。这些颜色格式同 flexible format相似，你仍然可以使用 getInput/OutputImage(int)方法。<br>　　从Android 5.1（LOLLIPOP_MR1）开始，所有的视频编解码器都支持灵活的YUV4:2:0缓存（flexible YUV 4:2:0 buffers）。</li>
</ul>
<ol>
<li>状态（States）  </li>
</ol>
<p>在编解码器的生命周期内有三种理论状态：停止态-Stopped、执行态-Executing、释放态-Released，停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。执行状态（Executing）在概念上会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）。<br><img src="/images/MediaCodec_states.png" alt="编码器的三种理论状态">     </p>
<ul>
<li>当你使用任意一种工厂方法（factory methods）创建了一个编解码器，此时编解码器处于未初始化状态（Uninitialized）。首先，你需要使用configure(…)方法对编解码器进行配置，这将使编解码器转为配置状态（Configured）。然后调用start()方法使其转入执行状态（Executing）。在这种状态下你可以通过上述的缓存队列操作处理数据。</li>
<li>执行状态（Executing）包含三个子状态： 刷新（Flushed）、运行（ Running） 以及流结束（End-of-Stream）。在调用start()方法后编解码器立即进入刷新子状态（Flushed），此时编解码器会拥有所有的缓存。一旦第一个输入缓存（input buffer）被移出队列，编解码器就转入运行子状态（Running），编解码器的大部分生命周期会在此状态下度过。当你将一个带有end-of-stream 标记的输入缓存入队列时，编解码器将转入流结束子状态（End-of-Stream）。在这种状态下，编解码器不再接收新的输入缓存，但它仍然产生输出缓存（output buffers）直到end-of- stream标记到达输出端。你可以在执行状态（Executing）下的任何时候通过调用flush()方法使编解码器重新返回到刷新子状态（Flushed）。</li>
<li>通过调用stop()方法使编解码器返回到未初始化状态（Uninitialized），此时这个编解码器可以再次重新配置 。当你使用完编解码器后，你必须调用release()方法释放其资源。</li>
<li>在极少情况下编解码器会遇到错误并进入错误状态（Error）。这个错误可能是在队列操作时返回一个错误的值或者有时候产生了一个异常导致的。通过调用 reset()方法使编解码器再次可用。你可以在任何状态调用reset()方法使编解码器返回到未初始化状态（Uninitialized）。否则，调用 release()方法进入最终的Released状态。</li>
</ul>
<ol>
<li>创建（Creation）  </li>
</ol>
<p>　　根据指定的MediaFormat使用MediaCodecList创建一个MediaCodec实例。在解码文件或数据流时，你可以通过调用MediaExtractor.getTrackFormat方法获得所期望的格式（media format）。并调用MediaFormat.setFeatureEnabled方法注入任何你想要添加的特定属性，然后调用MediaCodecList.findDecoderForFormat方法获得可以处理指定的媒体格式的编解码器的名字。最后，通过调用createByCodecName(String)方法创建一个编解码器。<br>　　注意：在Android 5.0 （LOLLIPOP）上，传递给MediaCodecList.findDecoder/EncoderForFormat的格式不能包含帧率-frame rate。通过调用format.setString(MediaFormat.KEY_FRAME_RATE, null)方法清除任何存在于当前格式中的帧率。<br>　　你也可以根据MIME类型利用createDecoder/EncoderByType(String)方法创建一个你期望的编解码器。然而，这种方式不能够给编解码器加入指定特性，而且创建的编解码器有可能不能处理你所期望的媒体格式。</p>
<ol>
<li>创建安全的解码器（Creating secure decoders<br>）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android 4.4（KITKAT_WATCH）及之前版本，安全的编解码器（secure codecs）没有被列在MediaCodecList中，但是仍然可以在系统中使用。安全编解码器只能够通过名字进行实例化，其名字是在常规编解码器的名字后附加.secure标识（所有安全编解码器的名字都必须以.secure结尾），调用createByCodecName(String)方法创建安全编解码器时，如果系统中不存在指定名字的编解码器就会抛出IOException异常。<br>&nbsp;&nbsp;&nbsp;&nbsp;从Android 5.0(LOLLIPOP）及之后版本，你可以在媒体格式中使用FEATURE_SecurePlayback属性来创建一个安全编解码器。</p>
<ol>
<li>初始化（Initialization）</li>
</ol>
<p>　　在创建了编解码器后，如果你想异步地处理数据，可以通过调用setCallback方法设置一个回调方法。然后，使用指定的媒体格式配置编解码器。这时你可以为视频原始数据产生者（例如视频解码器）指定输出Surface。此时你也可以为secure 编解码器设置解密参数（详见MediaCrypto） 。最后，因为编解码器可以工作于多种模式，你必须指定是该编码器是作为一个解码器（decoder）还是编码器（encoder）运行。</p>
<p>　　从API LOLLIPOP起，你可以在Configured 状态下查询输入和输出格式的结果。在开始编解码前你可以通过这个结果来验证配置的结果，例如，颜色格式。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你想将原始视频数据（raw video data）送视频消费者处理（将原始视频数据作为输入的编解码器，例如视频编码器），你可以在配置好视频消费者编解码器（encoder）后调用createInputSurface方法创建一个目的surface来存放输入数据，如此，调用视频生产者（decoder）的setInputSurface(Surface)方法将前面创建的目的Surface配置给视频生产者作为输出缓存位置。</p>
<ol>
<li>Codec-specific数据    </li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;有些格式，特别是ACC音频和MPEG4、H.264和H.265视频格式要求实际数据以若干个包含配置数据或编解码器指定数据的缓存为前缀。当处理这种压缩格式的数据时，这些数据必须在调用start()方法后且在处理任何帧数据之前提交给编解码器。这些数据必须在调用queueInputBuffer方法时使用BUFFER_FLAG_CODEC_CONFIG进行标记。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Codec-specific数据也可以被包含在传递给configure方法的格式信息（MediaFormat）中，在ByteBuffer条目中以”csd-0”, “csd-1”等key标记。这些keys一直包含在通过MediaExtractor获得的Audio Track or Video Track的MediaFormat中。一旦调用start()方法，MediaFormat中的Codec-specific数据会自动提交给编解码器；你不能显示的提交这些数据。如果MediaFormat中不包含编解码器指定的数据，你可以根据格式要求，按照正确的顺序使用指定数目的缓存来提交codec-specific数据。在H264 AVC编码格式下，你也可以连接所有的codec-specific数据并作为一个单独的codec-config buffer提交。</p>
<p>Android 使用下列的codec-specific data buffers。对于适当的MediaMuxer轨道配置，这些也要在轨道格式中进行设置。每一个参数集以及被标记为（*）的codec-specific-data段必须以”\x00\x00\x00\x01”字符开头。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Format</th>
<th style="text-align:left">CSD buffer #0</th>
<th style="text-align:left">CSD buffer #1</th>
<th style="text-align:left">CSD buffer #2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AAC</td>
<td style="text-align:left">Decoder-specific information from ESDS*</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">VORBIS</td>
<td style="text-align:left">Identification header</td>
<td style="text-align:left">Setup header</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">OPUS</td>
<td style="text-align:left">Identification header</td>
<td style="text-align:left">Pre-skip in nanosecs(unsigned 64-bit native-order integer.) This overrides the pre-skip value in the identification header.</td>
<td style="text-align:left">Seek Pre-roll in nanosecs(unsigned 64-bit native-order integer.)</td>
</tr>
<tr>
<td style="text-align:left">FLAC</td>
<td style="text-align:left">mandatory metadata block (called the STREAMINFO block),optionally followed by any number of other metadata blocks</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">MPEG-4</td>
<td style="text-align:left">Decoder-specific information from ESDS*</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">H.264 AVC</td>
<td style="text-align:left">SPS (Sequence Parameter Sets*)</td>
<td style="text-align:left">PPS (Picture Parameter Sets*)</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">H.265 HEVC</td>
<td style="text-align:left">VPS (Video Parameter Sets<em>) + SPS (Sequence Parameter Sets</em>) + PPS (Picture Parameter Sets*)</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">VP9</td>
<td style="text-align:left">VP9 CodecPrivate Data (optional)</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
</tbody>
</table>
<p>注意：当编解码器被立即刷新或start之后不久刷新，并且在任何输出buffer或输出格式变化被返回前需要特别地小心，因为编解码器的codec specific data可能会在flush过程中丢失。为保证编解码器的正常运行，你必须在刷新后使用标记为BUFFER_FLAG_CODEC_CONFIGbuffers的buffers再次提交这些数据。</p>
<p>　　 编码器（或者产生压缩数据的编解码器）将会在有效的输出缓存之前产生和返回编解码器指定的数据，这些数据会以codec-config flag进行标记。包含codec-specific-data的Buffers没有有意义的时间戳。</p>
<p>数据处理（Data Processing）<br>　　每一个编解码器都包含一组输入和输出缓存（input and output buffers），这些缓存在API调用中通过buffer-id进行引用。当成功调用start()方法后客户端将不会“拥有”输入或输出buffers。在同步模式下，通过调用dequeueInput/OutputBuffer(…) 方法从编解码器获得（取得所有权）一个输入或输出buffer。在异步模式下，你可以通过MediaCodec.Callback.onInput/OutputBufferAvailable(…)的回调方法自动地获得可用的buffers。</p>
<p>　　在获得一个输入buffe后，向其中填充数据，并利用queueInputBuffer方法将其提交给编解码器，若使用解密，则利用queueSecureInputBuffer方法提交。不要提交多个具有相同时间戳的输入buffers（除非它是也被同样标记的codec-specific data）。</p>
<p>　　在异步模式下通过onOutputBufferAvailable方法的回调或者在同步模式下响应dequeuOutputBuffer的调用，编解码器返回一个只读的output buffer。在这个output buffer被处理后，调用一个releaseOutputBuffer方法将这个buffer返回给编解码器。</p>
<p>　　当你不需要立即向编解码器重新提交或释放buffers时，保持对输入或输出buffers的所有权可使编解码器停止工作，当然这些行为依赖于设备情况。特别地，编解码器可能延迟产生输出buffers直到输出的buffers被释放或重新提交。因此，尽可能短时间地持有可用的buffers。</p>
<p>根据API版本情况，你有三种处理相关数据的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Processing Mode</th>
<th style="text-align:left">API version &lt;= 20 Jelly Bean/KitKat</th>
<th style="text-align:left">API version &gt;= 21  Lollipop and later</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Synchronous API using buffer arrays</td>
<td style="text-align:left">Supported</td>
<td style="text-align:left">Deprecated</td>
</tr>
<tr>
<td style="text-align:left">Synchronous API using buffers</td>
<td style="text-align:left">Not Available</td>
<td style="text-align:left">Supported</td>
</tr>
<tr>
<td style="text-align:left">Asynchronous API using buffers</td>
<td style="text-align:left">Not Available</td>
<td style="text-align:left">Supported</td>
</tr>
</tbody>
</table>
<ol>
<li>使用缓存的异步处理方式（Asynchronous Processing using Buffers）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从Android 5.0（LOLLIPOP）开始，首选的方法是调用configure之前通过设置回调异步地处理数据。异步模式稍微改变了状态转换方式，因为你必须在调用flush()方法后再调用start()方法才能使编解码器的状态转换为Running子状态并开始接收输入buffers。同样，初始调用start方法将编解码器的状态直接变化为Running 子状态并通过回调方法开始传递可用的输入buufers。<br><img src="/images/Asynchronous_buffer_flow.png" alt="异步模式处理"><br>　异步模式下，编解码器典型的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> MediaFormat mOutputFormat; // member variable</span><br><span class="line"> // 异步模式下需要在configure之前设置callback</span><br><span class="line"> codec.setCallback(new MediaCodec.Callback() &#123;</span><br><span class="line">   /**</span><br><span class="line">    * 在onInputBufferAvailable回调方法中，MediaCodec会通知什么时候input</span><br><span class="line">    * buffer有效，根据buffer id，调用getInputBuffer(id)可以获得这个buffer，</span><br><span class="line">    * 此时就可以向这个buffer中写入数据，最后调用queueInputBuffer(id, …)提交</span><br><span class="line">    * 给MediaCodec处理。</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123;</span><br><span class="line">     ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);</span><br><span class="line">     // fill inputBuffer with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">     * 在onOutputBufferAvailable回调方法中，MediaCodec会通知什么时候output</span><br><span class="line">     * buffer有效，根据buffer id，调用getOutputBuffer(id)可以获得这个buffer，</span><br><span class="line">     * 此时就可以读取这个buffer中的数据，最后调用releaseOutputBuffer(id, …)释放</span><br><span class="line">     * 给MediaCodec再次使用。</span><br><span class="line">     */</span><br><span class="line">   @Override</span><br><span class="line">   void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123;</span><br><span class="line">     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">     // bufferFormat is equivalent to mOutputFormat</span><br><span class="line">     // outputBuffer is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 当MediaCodec的output format发生变化是会回调该方法，一般在start之后都会首先回调该方法</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">     mOutputFormat = format; // option B</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">     * MediaCodec运行发生错误时会回调该方法</span><br><span class="line">     */</span><br><span class="line">   @Override</span><br><span class="line">   void onError(…) &#123;</span><br><span class="line">     …</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> mOutputFormat = codec.getOutputFormat(); // option B</span><br><span class="line"> codec.start();</span><br><span class="line"> // wait for processing to complete</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用缓存的同步处理方式（Synchronous Processing using Buffers） .<br>　　从Android5.0（LOLLIPOP）开始，即使在同步模式下使用编解码器你应该通过getInput/OutputBuffer(int) 和/或 getInput/OutputImage(int) 方法检索输入和输出buffers。这允许通过框架进行某些优化，例如，在处理动态内容过程中。如果你调用getInput/OutputBuffers()方法这种优化是不可用的。</li>
</ol>
<p>　　注意，不要同时混淆使用缓存和缓存数组的方法。特别地，仅仅在调用start()方法后或取出一个值为INFO_OUTPUT_FORMAT_CHANGED的输出buffer ID后你才可以直接调用getInput/OutputBuffers方法。</p>
<p>　　同步模式下MediaCodec的典型应用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> MediaFormat outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line"> codec.start();</span><br><span class="line"> /**</span><br><span class="line">  * 在一个无限循环中不断地请求Codec是否有可用的input buffer 或 output buffer</span><br><span class="line">  */</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(timeoutUs); // 请求是否有可用的input buffer</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     ByteBuffer inputBuffer = codec.getInputBuffer(…);</span><br><span class="line">     // fill inputBuffer with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);  // 提交数据给Codec</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">     // bufferFormat is identical to outputFormat</span><br><span class="line">     // outputBuffer is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);     // 释放output buffer供Codec再次使用</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">     outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>使用缓存数组的同步处理方式（Synchronous Processing using Buffer Arrays）– (deprecated)<br>　　在Android 4.4（KITKAT_WATCH）及之前版本，一组输入或输出buffers使用ByteBuffer[]数组表示。在成功调用了start()方法后，通过调用getInput/OutputBuffers()方法检索buffer数组。在这些数组中使用buffer的ID-s（非负数）作为索引，如下面的演示示例中，注意数组大小和系统使用的输入和输出buffers的数量之间并没有固定的关系，尽管这个数组提供了上限边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> codec.start();</span><br><span class="line"> ByteBuffer[] inputBuffers = codec.getInputBuffers();</span><br><span class="line"> ByteBuffer[] outputBuffers = codec.getOutputBuffers();</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(…);</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     // fill inputBuffers[inputBufferId] with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     // outputBuffers[outputBufferId] is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">     outputBuffers = codec.getOutputBuffers();</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     MediaFormat format = codec.getOutputFormat();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure>
</li>
<li><p>流结束处理（End-of-stream Handling）<br>　　当到达输入数据结尾时，你必须在调用queueInputBuffer方法中通过指定BUFFER_FLAG_END_OF_STREAM标记来通知编解码器。你可以在最后一个有效的输入buffer上做这些操作，或者提交一个额外的以end-of-stream标记的空的输入buffer。如果使用一个空的buffer，它的时间戳将被忽略。</p>
</li>
</ol>
<p>　　编解码器将会继续返回输出buffers，直到它发出输出流结束的信号，这是通过指定dequeueOutputBuffer方法中MediaCodec.BufferInfo的end-of-stream标记来实现的，或者是通过回调方法onOutputBufferAvailable来返回end-of-stream标记。可以在最后一个有效的输出buffer中设置或者在最后一个有效的输出buffer后添加一个空的buffer来设置，这种空的buffer的时间戳应该被忽略。</p>
<p>　　当通知输入流结束后不要再提交额外的输入buffers，除非编解码器被刷新或停止或重启。</p>
<ol>
<li>使用一个输出表面（Using an Output Surface）<br>　　使用一个输出Surface进行数据处理的方法与ByteBuffer模式几乎是相同的，然而，输出buffers不再可访问，而且被表示为null值。E.g.方法getOutputBuffer/Image(int)将返回null，方法getOutputBuffers()将返回仅包含null值的数组。</li>
</ol>
<p>　　当使用一个输出Surface时，你能够选择是否渲染surface上的每一个输出buffer，你有三种选择：</p>
<ul>
<li>不要渲染这个buffer（Do not render the buffer）：通过调用releaseOutputBuffer(bufferId, false)。</li>
<li>使用默认的时间戳渲染这个buffer（Render the buffer with the default timestamp）：调用releaseOutputBuffer(bufferId, true)。</li>
<li>使用指定的时间戳渲染这个buffer（Render the buffer with a specific timestamp）：调用 releaseOutputBuffer(bufferId, timestamp)。<br>　　从Android6.0(M)开始，默认的时间戳是buffer的presentation timestamp（转换为纳秒）。在此前的版本中这是没有被定义的。</li>
</ul>
<p>　　而且，从Android6.0(M)开始，你可以通过使用setOutputSurface方法动态地改变输出Surface。</p>
<ol>
<li>使用一个输入表面（Using an Input Surface）<br>　　当使用输入Surface时，将没有可访问的输入buffers,因为这些buffers将会从输入surface自动地向编解码器传输。调用dequeueInputBuffer时将抛出一个IllegalStateException异常，调用getInputBuffers()将要返回一个不能写入的伪ByteBuffer[]数组。</li>
</ol>
<p>　　调用signalEndOfInputStream()方法发送end-of-stream信号。调用这个方法后，输入surface将会立即停止向编解码器提交数据。</p>
<p>查询&amp;自适应播放支持（Seeking &amp; Adaptive Playback Support）<br>　　视频解码器（通常指处理压缩视频数据的编解码器）关于搜索-seek和格式转换（不管它们是否支持）表现不同，且被配置为adaptive playback。你可以通过调用CodecCapabilities.isFeatureSupported(String)方法来检查解码器是否支持adaptive playback 。支持Adaptive playback的解码器只有在编解码器被配置在Surface上解码时才被激活。</p>
<p>　　流域界与关键帧（Stream Boundary and Key Frames）</p>
<p>　　在调用start()或flush()方法后，输入数据在合适的流边界开始是非常重要的：其第一帧必须是关键帧（key-frame）。一个关键帧能够独立地完全解码（对于大多数编解码器它意味着I-frame），关键帧之后显示的帧不会引用关键帧之前的帧。</p>
<p>　　下面的表格针对不同的视频格式总结了合适的关键帧。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Format</th>
<th style="text-align:left">Suitable key frame</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">VP9/VP8</td>
<td style="text-align:left">a suitable intraframe where no subsequent frames refer to frames prior to this frame. (There is no specific name for such key frame.)</td>
</tr>
<tr>
<td style="text-align:left">H.265 HEVC</td>
<td style="text-align:left">IDR or CRA</td>
</tr>
<tr>
<td style="text-align:left">H.264 AVC</td>
<td style="text-align:left">IDR</td>
</tr>
<tr>
<td style="text-align:left">MPEG-4 H.263 MPEG-2</td>
<td style="text-align:left">a suitable I-frame where no subsequent frames refer to frames prior to this frame.(There is no specific name for such key frame.)</td>
</tr>
</tbody>
</table>
<p>对于不支持adaptive playback的解码器（包括解码到Surface上解码器）</p>
<p>　　为了开始解码与先前提交的数据（也就是seek后）不相邻的数据你必须刷新解码器。由于所有输出buffers会在flush的一刻立即撤销，你可能希望在调用flush方法前等待这些buffers首先被标记为end-of-stream。在调用flush方法后输入数据在一个合适的流边界或关键帧开始是非常重要的。</p>
<p>　　注意：flush后提交的数据的格式不能改变；flush()方法不支持格式的不连续性；为此，一个完整的stop()-configure(…)-start()的过程是必要的。</p>
<p>　　同时注意：如果你调用start()方法后过快地刷新编解码器，通常，在收到第一个输出buffer或输出format变化前，你需要向这个编解码器再次提交codec-specific-data。具体查看codec-specific-data部分以获得更多信息。</p>
<p>　　对于支持及被配置为adaptive playback的几码器</p>
<p>　　为了开始解码与先前提交的数据（也就是seek后）不相邻的数据，你没有必要刷新解码器；然而，在间断后传入的数据必须开始于一个合适的流边界或关键帧。</p>
<p>　　针对一些视频格式-也就是H.264、H.265、VP8和VP9，也可以修改图片大小或者配置mid-stream。为了做到这些你必须将整个新codec-specific配置数据与关键帧一起打包到一个单独的buffer中（包括所有的开始数据），并将它作为一个常规的输入数据提交。</p>
<p>　　在picture-size被改变后以及任意具有新大小的帧返回之前，你可以从dequeueOutputBuffer方法或onOutputFormatChanged回调中得到 INFO_OUTPUT_FORMAT_CHANGED的返回值。</p>
<p>　　注意：就像使用codec-specific data时的情况，在你修改图片大小后立即调用fush()方法时需要非常小心。如果你没有接收到图片大小改变的确认信息，你需要重试修改图片大小的请求。</p>
<ol>
<li>错误处理（Error handling）</li>
</ol>
<p>　　工厂方法createByCodecName以及createDecoder/EncoderByType会在创建codec失败时抛出一个IOException，你必须捕获异常或声明向上传递异常。在编解码器不允许使用该方法的状态下调用时，MediaCodec方法将会抛出IllegalStateException异常；这种情况一般是由于API接口的不正确调用引起的。涉及secure buffers的方法可能会抛出一个MediaCodec.CryptoException异常，可以调用getErrorCode()方法获得更多的异常信息。</p>
<p>　　内部的编解码器错误将导致MediaCodec.CodecException，这可能是由于media内容错误、硬件错误、资源枯竭等原因所致，即使你已经正确的使用了API。当接收到一个CodecException时，可以调用isRecoverable()和isTransient()两个方法来决定建议的行为。</p>
<p>可恢复错误（recoverable errors）：如果isRecoverable() 方法返回true,然后就可以调用stop(),configure(…),以及start()方法进行修复。<br>短暂错误（transient errors）：如果isTransient()方法返回true,资源短时间内不可用，这个方法可能会在一段时间之后重试。<br>致命错误（fatal errors）：如果isRecoverable()和isTransient()方法均返回fase，CodecException错误是致命的，此时就必须reset这个编解码器或调用released方法释放资源。<br>　　isRecoverable()和isTransient()方法不可能同时都返回true。</p>
<ol>
<li>嵌套类（Nested classes）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MediaCodec.BufferInfo</td>
<td style="text-align:left">class</td>
<td style="text-align:left">每一个缓存区的元数据都包含有一个偏移量offset和大小size用于指示相关编解码器（输出）缓存中有效数据的范围。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.Callback</td>
<td style="text-align:left">class</td>
<td style="text-align:left">MediaCodec回调接口</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CodecException</td>
<td style="text-align:left">class</td>
<td style="text-align:left">当发生内部的编解码器错误是抛出。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CryptoException</td>
<td style="text-align:left">class</td>
<td style="text-align:left">在入队列一个安全的输入缓存过程中发生加密错误时抛出。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CryptoInfo</td>
<td style="text-align:left">class</td>
<td style="text-align:left">描述（至少部分地）加密的输入样本的结构的元数据。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.OnFrameRenderedListener</td>
<td style="text-align:left">interface</td>
<td style="text-align:left">当一个输出帧在输出surface上呈现时，监听器被调用。</td>
</tr>
</tbody>
</table>
<ol>
<li>常量  </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BUFFER_FLAG_CODEC_CONFIG</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2（0x00000002）</td>
<td style="text-align:left">这表示带有此标记的缓存包含编解码器初始化或编解码器特定的数据而不是多媒体数据media data。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_END_OF_STREAM</td>
<td style="text-align:left">int</td>
<td style="text-align:left">4（0x00000004</td>
<td style="text-align:left">它表示流结束，该标志之后不会再有可用的buffer，除非接下来对Codec执行flush()方法。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_KEY_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">这表示带有此标记的（编码的）缓存包含关键帧数据。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_PARTIAL_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">8 (0x00000008)</td>
<td style="text-align:left">这表明缓冲区只包含帧的一部分，并且解码器应该对数据进行批处理，直到没有该标志的缓冲区在解码帧之前出现。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_SYNC_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">这个常量在API level 21中弃用，使用BUFFER_FLAG_KEY_FRAME代替。这表示带有此标记的（编码的）缓存包含关键帧数据。</td>
</tr>
<tr>
<td style="text-align:left">CONFIGURE_FLAG_ENCODE</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">如果编解码器被用作编码器，传递这个标志。</td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_AES_CBC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2（0x00000002）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_AES_CTR</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_UNENCRYPTED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">0（0x00000000）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INFO_OUTPUT_BUFFERS_CHANGED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-3 (0xfffffffd)</td>
<td style="text-align:left">此常数在API级别21中已弃用。由于getOutputBuffers（）已被弃用，此返回值可以被忽略。 每次出队时，客户端都应该使用get-buffer或get-image方法的on命令来请求当前缓冲区。输出缓冲区已更改，客户端必须从此处引用由getOutputBuffers（）返回的新输出缓冲区集合。此外，此事件表示视频缩放模式可能已重置为默认值。</td>
</tr>
<tr>
<td style="text-align:left">INFO_OUTPUT_FORMAT_CHANGED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-2 (0xfffffffe)</td>
<td style="text-align:left">输出格式已更改，后续数据将采用新格式。 getOutputFormat（）返回新的格式。 请注意，您也可以使用新的getOutputFormat（int）方法来获取特定输出缓冲区的格式。 这使您无需跟踪输出格式更改。</td>
</tr>
<tr>
<td style="text-align:left">INFO_TRY_AGAIN_LATER</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-1 (0xffffffff)</td>
<td style="text-align:left">如果在调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）时指定了非负超时，则表示该呼叫超时。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_REQUEST_SYNC_FRAME</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“request-sync”</td>
<td style="text-align:left">请求编码器“很快”产生一个同步帧。 提供值为0的整数。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_SUSPEND</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“drop-input-frames”</td>
<td style="text-align:left">暂时暂停/恢复输入数据的编码。虽然暂停输入数据被有效丢弃，而不是被馈送到编码器中。在“表面输入”模式下，这个参数只与编码器一起使用才是有意义的，因为在这种情况下，客户端代码对编码器的输入端没有控制。该值是一个整数对象，包含要挂起的值1或要恢复的值0。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_VIDEO_BITRATE</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“video-bitrate”</td>
<td style="text-align:left">立即改变视频编码器的目标比特率。该值是包含BPS中的新比特率的整数对象。</td>
</tr>
<tr>
<td style="text-align:left">VIDEO_SCALING_MODE_SCALE_TO_FIT</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1 (0x00000001)</td>
<td style="text-align:left">内容按比例缩放到表面尺寸。</td>
</tr>
<tr>
<td style="text-align:left">VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2 (0x00000002)</td>
<td style="text-align:left">内容是缩放，保持其纵横比，使用整个表面积，可以裁剪内容。这种模式只适用于1:1像素长宽比的内容，因为你不能为一个表面配置像素的长宽比。对于Build.VERSION_CODES.N版本，如果视频旋转90度或270度，则此模式可能无法工作。</td>
</tr>
</tbody>
</table>
<ol>
<li>公有方法</li>
</ol>
<h4 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h4><p>public void configure (MediaFormat format,Surface surface,MediaCrypto crypto,int flags)：Configures a component.（配置组件。）</p>
<ul>
<li><p>参数<br>format     -》 MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an an empty mediaformat.  （输入数据（解码器）的格式或输出数据（编码器）的所需格式。 以格式传递null相当于传递一个空的媒体格式。）<br>surface -》    Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for ByteBuffer output.（指定要渲染此解码器输出的表面。 如果编解码器不生成原始视频输出（例如，不是视频解码器），并且/或者如果要为ByteBuffer输出配置编解码器，则将null传递为曲面。）<br>crypto -》    MediaCrypto: Specify a crypto object to facilitate secure decryption of the media data. Pass null as crypto for non-secure codecs. （指定一个加密对象以促进媒体数据的安全解密。 传递null作为非安全编解码器的加密。）<br>flags -》    int: Specify CONFIGURE_FLAG_ENCODE to configure the component as an encoder.（指定CONFIGURE_FLAG_ENCODE将组件配置为编码器。）</p>
</li>
<li><p>异常<br>IllegalArgumentException -》    if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing CONFIGURE_FLAG_ENCODE for an encoder). （如果表面已被释放（或无效），或格式不可接受（例如，缺少必需的密钥），或者标记未正确设置（例如，编码器缺少CONFIGURE_FLAG_ENCODE）。）<br>IllegalStateException -》    if not in the Uninitialized state.（如果不是未初始化状态。）<br>MediaCodec.CryptoException -》    upon DRM error.（在DRM错误。）<br>MediaCodec.CodecException -》    upon codec error.（编解码器错误。）    </p>
</li>
</ul>
<h4 id="configure-1"><a href="#configure-1" class="headerlink" title="configure"></a>configure</h4><p>public void configure (MediaFormat format,Surface surface,int flags,MediaDescrambler descrambler)：Configure a component to be used with a descrambler.（配置要与解扰器一起使用的组件。）  </p>
<ul>
<li><p>参数<br>format     -》 MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an an empty mediaformat.  （输入数据（解码器）的格式或输出数据（编码器）的所需格式。 以格式传递null相当于传递一个空的媒体格式。）<br>surface -》    Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for ByteBuffer output.（指定要渲染此解码器输出的表面。 如果编解码器不生成原始视频输出（例如，不是视频解码器），并且/或者如果要为ByteBuffer输出配置编解码器，则将null传递为曲面。）<br>flags -》    int: Specify CONFIGURE_FLAG_ENCODE to configure the component as an encoder.（指定CONFIGURE_FLAG_ENCODE将组件配置为编码器。）<br>descrambler -》    MediaDescrambler: Specify a descrambler object to facilitate secure descrambling of the media data, or null for non-secure codecs.（指定解扰器对象以促进媒体数据的安全解扰，或者指定非安全编解码器为null。）  </p>
</li>
<li><p>异常<br>IllegalArgumentException -》    if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing CONFIGURE_FLAG_ENCODE for an encoder). （如果表面已被释放（或无效），或格式不可接受（例如，缺少必需的密钥），或者标记未正确设置（例如，编码器缺少CONFIGURE_FLAG_ENCODE）。）<br>IllegalStateException -》    if not in the Uninitialized state.（如果不是未初始化状态。）<br>MediaCodec.CryptoException -》    upon DRM error.（在DRM错误。）<br>MediaCodec.CodecException -》    upon codec error.（编解码器错误。）</p>
</li>
</ul>
<h4 id="createByCodecName"><a href="#createByCodecName" class="headerlink" title="createByCodecName"></a>createByCodecName</h4><p>public static MediaCodec createByCodecName (String name)：If you know the exact name of the component you want to instantiate use this method to instantiate it. Use with caution. Likely to be used with information obtained from MediaCodecList（如果您知道要实例化的组件的确切名称，请使用此方法将其实例化。 谨慎使用。 可能与从MediaCodecList获取的信息一起使用）  </p>
<ul>
<li><p>参数<br>name    -》String: The name of the codec to be instantiated.This value must never be null.（要实例化的编解码器的名称。此值绝不能为null。）</p>
</li>
<li><p>返回值<br>MediaCodec    -》 This value will never be null.（此值绝不能为null。）</p>
</li>
<li><p>异常<br>IOException -》    if the codec cannot be created.  （如果无法创建编解码器）<br>IllegalArgumentException -》    if name is not valid.（如果名称无效）<br>NullPointerException -》    if name is null.（如果名称为空）  </p>
</li>
</ul>
<h4 id="createDecoderByType"><a href="#createDecoderByType" class="headerlink" title="createDecoderByType"></a>createDecoderByType</h4><p>public static MediaCodec createDecoderByType (String type)：Instantiate the preferred decoder supporting input data of the given mime type. The following is a partial list of defined mime types and their semantics:（实例化支持给定MIME类型的输入数据的首选解码器。 以下是定义的MIME类型及其语义的部分列表：）</p>
<ul>
<li>“video/x-vnd.on2.vp8” - VP8 video (i.e. video in .webm)</li>
<li>“video/x-vnd.on2.vp9” - VP9 video (i.e. video in .webm)</li>
<li>“video/avc” - H.264/AVC video</li>
<li>“video/hevc” - H.265/HEVC video</li>
<li>“video/mp4v-es” - MPEG4 video</li>
<li>“video/3gpp” - H.263 video</li>
<li>“audio/3gpp” - AMR narrowband audio</li>
<li>“audio/amr-wb” - AMR wideband audio</li>
<li>“audio/mpeg” - MPEG1/2 audio layer III</li>
<li>“audio/mp4a-latm” - AAC audio (note, this is raw AAC packets, not packaged in LATM!)</li>
<li>“audio/vorbis” - vorbis audio</li>
<li>“audio/g711-alaw” - G.711 alaw audio</li>
<li>“audio/g711-mlaw” - G.711 ulaw audio<br>Note: It is preferred to use MediaCodecList.findDecoderForFormat(MediaFormat) and createByCodecName(String) to ensure that the resulting codec can handle a given format.（注意：最好使用MediaCodecList.findDecoderForFormat（MediaFormat）和createByCodecName（String）来确保生成的编解码器可以处理给定的格式。）</li>
</ul>
<ul>
<li><p>参数<br>type -》    String: The mime type of the input data.This value must never be null.（输入数据的mime类型。此值绝不能为null。）</p>
</li>
<li><p>异常<br>IOException     -》if the codec cannot be created.（如果无法创建编解码器）<br>IllegalArgumentException -》     if type is not a valid mime type.（如果type不是有效的mime类型）<br>NullPointerException -》    if type is null.（如果type为空）</p>
</li>
</ul>
<h4 id="createEncoderByType"><a href="#createEncoderByType" class="headerlink" title="createEncoderByType"></a>createEncoderByType</h4><p>public static MediaCodec createEncoderByType (String type)：Instantiate the preferred encoder supporting output data of the given mime type. Note: It is preferred to use MediaCodecList.findEncoderForFormat(MediaFormat) and createByCodecName(String) to ensure that the resulting codec can handle a given format.<br>（实例化支持给定MIME类型的输出数据的首选编码器。 注意：最好使用MediaCodecList.findEncoderForFormat（MediaFormat）和createByCodecName（String）来确保生成的编解码器可以处理给定的格式。）</p>
<ul>
<li><p>参数<br>type    -》String: The desired mime type of the output data.This value must never be null.（所需的MIME类型的输出数据。该值不能为空。）</p>
</li>
<li><p>返回值<br>MediaCodec    -》This value will never be null.（这个值永远不为空）。</p>
</li>
<li><p>异常<br>IOException -》 if the codec cannot be created. （如果编解码器不能被创建。）<br>IllegalArgumentException -》    if type is not a valid mime type.  （如果type不是有效的MIME类型。）<br>NullPointerException -》    if type is null.  （如果type为null。）</p>
</li>
</ul>
<h4 id="createInputSurface"><a href="#createInputSurface" class="headerlink" title="createInputSurface"></a>createInputSurface</h4><p>public Surface createInputSurface ()：Requests a Surface to use as the input to an encoder, in place of input buffers. This may only be called after configure(MediaFormat, Surface, MediaCrypto, int) and before start().The application is responsible for calling release() on the Surface when done.The Surface must be rendered with a hardware-accelerated API, such as OpenGL ES. Surface.lockCanvas(android.graphics.Rect) may fail or produce unexpected results.（请求Surface用作编码器的输入，以代替输入缓冲区。 这只能在configure（MediaFormat，Surface，MediaCrypto，int）和start（）之前调用。应用程序负责在完成时调用Surface上的release（）。Surface必须使用硬件加速API（如OpenGL ES）进行渲染。 Surface.lockCanvas（android.graphics.Rect）可能会失败或产生意想不到的结果。）</p>
<ul>
<li>返回值<br>Surface    -》 This value will never be null.（这个值永远不为空）</li>
<li>异常<br>IllegalStateException -》    if not in the Configured state.（如果不在配置状态）</li>
</ul>
<h4 id="createPersistentInputSurface"><a href="#createPersistentInputSurface" class="headerlink" title="createPersistentInputSurface"></a>createPersistentInputSurface</h4><p>public static Surface createPersistentInputSurface ()：Create a persistent input surface that can be used with codecs that normally have an input surface, such as video encoders. A persistent input can be reused by subsequent MediaCodec or MediaRecorder instances, but can only be used by at most one codec or recorder instance concurrently.The application is responsible for calling release() on the Surface when done.（创建可与通常具有输入表面的编解码器一起使用的持久输入表面，例如视频编码器。 持久性输入可以被后续MediaCodec或MediaRecorder实例重用，但最多只能同时使用一个编解码器或录制器实例。应用程序负责在完成时调用Surface上的release（）。）</p>
<ul>
<li>返回值<br>Surface    -》 an input surface that can be used with setInputSurface(Surface).This value will never be null.（一个可以与setInputSurface（Surface）一起使用的输入表面。该值永远不会为空）</li>
</ul>
<h4 id="dequeueInputBuffer"><a href="#dequeueInputBuffer" class="headerlink" title="dequeueInputBuffer"></a>dequeueInputBuffer</h4><p>public int dequeueInputBuffer (long timeoutUs)：Returns the index of an input buffer to be filled with valid data or -1 if no such buffer is currently available. This method will return immediately if timeoutUs == 0, wait indefinitely for the availability of an input buffer if timeoutUs &lt; 0 or wait up to “timeoutUs” microseconds if timeoutUs &gt; 0.（返回要用有效数据填充的输入缓冲区的索引，如果当前没有可用的缓冲区，则返回-1。 如果timeoutU == 0，此方法将立即返回，如果timeoutU <0，则无限期等待输入缓冲区的可用性;如果timeoutus> 0，则等待“timeoutUs”微秒。）</0，则无限期等待输入缓冲区的可用性;如果timeoutus></p>
<ul>
<li>参数<br>timeoutUs    -》 long: The timeout in microseconds, a negative timeout indicates “infinite”.（超时（微秒），负超时表示“无限”。<br>）</li>
<li>返回值<br>int -》 缓冲区索引id</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state, or codec is configured in asynchronous mode.（如果不处于执行状态，或编解码器配置为异步模式。）<br>MediaCodec.CodecException     -》 upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="dequeueOutputBuffer"><a href="#dequeueOutputBuffer" class="headerlink" title="dequeueOutputBuffer"></a>dequeueOutputBuffer</h4><p>public int dequeueOutputBuffer (MediaCodec.BufferInfo info, long timeoutUs)：Dequeue an output buffer, block at most “timeoutUs” microseconds. Returns the index of an output buffer that has been successfully decoded or one of the INFO<em>* constants.（出队输出缓冲区，最多阻止“timeoutUs”微秒。 返回已成功解码的输出缓冲区的索引或其中一个INFO</em> *常量。）</p>
<ul>
<li>参数<br>info -》    MediaCodec.BufferInfo: Will be filled with buffer meta data.This value must never be null.（将填充缓冲区元数据。该值不能为空）<br>timeoutUs     -》 long: The timeout in microseconds, a negative timeout indicates “infinite”.（超时（微秒），负超时表示“无限”。<br>）</li>
<li>返回值<br>int -》 缓冲区索引id</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state, or codec is configured in asynchronous mode.（如果不处于执行状态，或编解码器配置为异步模式。）<br>MediaCodec.CodecException     -》 upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><p>public void flush ()：Flush both input and output ports of the component.Upon return, all indices previously returned in calls to dequeueInputBuffer and dequeueOutputBuffer — or obtained via onInputBufferAvailable or onOutputBufferAvailable callbacks — become invalid, and all buffers are owned by the codec.If the codec is configured in asynchronous mode, call start() after flush has returned to resume codec operations. The codec will not request input buffers until this has happened. Note, however, that there may still be outstanding onOutputBufferAvailable callbacks that were not handled prior to calling flush. The indices returned via these callbacks also become invalid upon calling flush and should be discarded.If the codec is configured in synchronous mode, codec will resume automatically if it is configured with an input surface. Otherwise, it will resume when dequeueInputBuffer is called.（刷新组件的输入和输出端口。返回时，以前通过调用dequeueInputBuffer和dequeueOutputBuffer返回的所有索引 - 或通过onInputBufferAvailable或onOutputBufferAvailable回调获得 - 都变为无效，并且所有缓冲区都由编解码器拥有。如果编解码器配置为 异步模式，在刷新后调用start（）返回以恢复编解码器操作。 在这种情况发生之前，编解码器不会请求输入缓冲器。 但请注意，在调用刷新之前，可能仍有未完成的onOutputBufferAvailable回调。 通过这些回调返回的索引在调用flush时也会失效，应该丢弃。如果编解码器配置为同步模式，如果配置了输入表面，编解码器将自动恢复。 否则，它将在调用dequeueInputBuffer时继续。）</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getCodecInfo"><a href="#getCodecInfo" class="headerlink" title="getCodecInfo"></a>getCodecInfo</h4><p>public MediaCodecInfo getCodecInfo ()<br>Get the codec info. If the codec was created by createDecoderByType or createEncoderByType, what component is chosen is not known beforehand, and thus the caller does not have the MediaCodecInfo.（获取编解码器信息。 如果编解码器是由createDecoderByType或createEncoderByType创建的，则选择哪个组件并不是事先知道的，因此调用者没有MediaCodecInfo。）</p>
<ul>
<li>返回参数<br>MediaCodecInfo    -》 This value will never be null.（ 该值永远不会为空）</li>
<li>异常<br>IllegalStateException -》     if in the Released state.（如果处于Released状态。）</li>
</ul>
<h4 id="getInputBuffer"><a href="#getInputBuffer" class="headerlink" title="getInputBuffer"></a>getInputBuffer</h4><p>public ByteBuffer getInputBuffer (int index)：Returns a cleared, writable ByteBuffer object for a dequeued input buffer index to contain the input data. After calling this method any ByteBuffer or Image object previously returned for the same input index MUST no longer be used.（返回已清除的可写ByteBuffer对象，用于包含输入数据的出列输入缓冲区索引。 在调用这个方法之后，必须不再使用先前为相同输入索引返回的任何ByteBuffer或Image对象。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned from a call to dequeueInputBuffer(long), or received via an onInputBufferAvailable callback.（先前从调用dequeueInputBuffer（long）返回的客户机拥有的输入缓冲区的索引，或通过onInputBufferAvailable回调接收的索引。）   </li>
<li>返回值<br>ByteBuffer -》    the input buffer, or null if the index is not a dequeued input buffer, or if the codec is configured for surface input.（输入缓冲区;如果索引不是出列输入缓冲区，或者编解码器配置为表面输入，则为null。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getOutputFormat"><a href="#getOutputFormat" class="headerlink" title="getOutputFormat"></a>getOutputFormat</h4><p>public MediaFormat getOutputFormat (int index)：Returns the output format for a specific output buffer.（返回特定输出缓冲区的输出格式）  </p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned from a call to dequeueInputBuffer(long).（先前从调用dequeueInputBuffer（long）返回的客户机拥有的输入缓冲区的索引。）</li>
<li>返回值<br>MediaFormat    -》 the format for the output buffer, or null if the index is not a dequeued output buffer.（输出缓冲区的格式;如果索引不是出队输出缓冲区，则返回null。）</li>
</ul>
<h4 id="getOutputFormat-1"><a href="#getOutputFormat-1" class="headerlink" title="getOutputFormat"></a>getOutputFormat</h4><p>public MediaFormat getOutputFormat ()：Call this after dequeueOutputBuffer signals a format change by returning INFO_OUTPUT_FORMAT_CHANGED. You can also call this after configure(MediaFormat, Surface, MediaCrypto, int) returns successfully to get the output format initially configured for the codec. Do this to determine what optional configuration parameters were supported by the codec.（通过返回INFO_OUTPUT_FORMAT_CHANGED，dequeueOutputBuffer发出格式更改后调用此函数。 您也可以在configure（MediaFormat，Surface，MediaCrypto，int）成功返回后获取为编解码器初始配置的输出格式。 这样做可以确定编解码器支持哪些可选的配置参数。）</p>
<ul>
<li>返回值<br>MediaFormat    -》 This value will never be null.（该值永远不会为空）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getOutputImage"><a href="#getOutputImage" class="headerlink" title="getOutputImage"></a>getOutputImage</h4><p>public Image getOutputImage (int index)：Returns a read-only Image object for a dequeued output buffer index that contains the raw video frame. After calling this method, any ByteBuffer or Image object previously returned for the same output index MUST no longer be used.(返回包含原始视频帧的出列输出缓冲区索引的只读Image对象。 在调用这个方法之后，必须不再使用先前为相同输出索引返回的任何ByteBuffer或Image对象。)</p>
<ul>
<li>返回值<br>index -》    int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long), or received via an onOutputBufferAvailable callback.（先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）或通过onOutputBufferAvailable回调接收的客户端拥有的输出缓冲区的索引。）</li>
<li>返回值<br>Image -》    the output image, or null if the index is not a dequeued output buffer, not a raw video frame, or if the codec was configured with an output surface. （输出图像;如果索引不是出列输出缓冲区，不是原始视频帧，或者编解码器配置了输出表面，则为null。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="queueInputBuffer"><a href="#queueInputBuffer" class="headerlink" title="queueInputBuffer"></a>queueInputBuffer</h4><p>public void queueInputBuffer (int index,int offset, int size,long presentationTimeUs,int flags)：After filling a range of the input buffer at the specified index submit it to the component. Once an input buffer is queued to the codec, it MUST NOT be used until it is later retrieved by getInputBuffer(int) in response to a dequeueInputBuffer(long) return value or a MediaCodec.Callback.onInputBufferAvailable(MediaCodec, int) callback.Many decoders require the actual compressed data stream to be preceded by “codec specific data”, i.e. setup data used to initialize the codec such as PPS/SPS in the case of AVC video or code tables in the case of vorbis audio. The class MediaExtractor provides codec specific data as part of the returned track format in entries named “csd-0”, “csd-1” …  These buffers can be submitted directly after start() or flush() by specifying the flag BUFFER_FLAG_CODEC_CONFIG. However, if you configure the codec with a MediaFormat containing these keys, they will be automatically submitted by MediaCodec directly after start. Therefore, the use of BUFFER_FLAG_CODEC_CONFIG flag is discouraged and is recommended only for advanced users. To indicate that this is the final piece of input data (or rather that no more input data follows unless the decoder is subsequently flushed) specify the flag BUFFER_FLAG_END_OF_STREAM.（在指定索引处填充输入缓冲区的范围后，将其提交给组件。一旦输入缓冲区排队等待编解码器，它就不能被使用，直到它稍后被getInputBuffer（int）检索以响应dequeueInputBuffer（long）返回值或MediaCodec.Callback.onInputBufferAvailable（MediaCodec，int）回调。许多解码器要求实际压缩数据流在“编解码器特定数据”之前，即用于初始化编解码器的设置数据，例如在AVC视频情况下为PPS / SPS或在​​vorbis音频情况下为代码表。 MediaExtractor类在名为“csd-0”，“csd-1”的条目中提供特定于编解码器的数据作为返回轨道格式的一部分…可以通过指定标志BUFFER_FLAG_CODEC_CONFIG在start（）或flush（）后直接提交这些缓冲区。但是，如果使用包含这些密钥的MediaFormat配置编解码器，它们将在启动后直接由MediaCodec自动提交。因此，不鼓励使用BUFFER_FLAG_CODEC_CONFIG标志，并且建议仅限高级用户使用。为了表明这是最后一块输入数据（或者除非解码器随后被刷新，否则不会有更多的输入数据出现）指定标志BUFFER_FLAG_END_OF_STREAM。）<br>注意：在Build.VERSION_CODES.M之前，presentationTimeUs没有传播到（呈现的）表面输出缓冲区的帧时间戳，并且结果帧时间戳未定义。 使用releaseOutputBuffer（int，long）来确保设置了特定的帧时间戳。 同样，由于帧时间戳可以被目标表面用于渲染同步，因此必须注意使presentationTimeUs正常化，以便不会误认为系统时间。 （请参阅SurfaceView细节）。   </p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned in a call to dequeueInputBuffer(long).（先前在调用dequeueInputBuffer（long）时返回的客户机拥有的输入缓冲区的索引）<br>offset -》    int: The byte offset into the input buffer at which the data starts.（输入缓冲区中数据开始的字节偏移量）<br>size -》    int: The number of bytes of valid input data.（有效输入数据的字节数）<br>presentationTimeUs -》    long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered). When using an output surface, this will be propagated as the timestamp for the frame (after conversion to nanoseconds).（此缓冲区的呈现时间戳（以微秒为单位）。 这通常是介质缓冲区应呈现（呈现）的介质时间。 使用输出表面时，这将作为帧的时间戳（转换为纳秒后）传播。）<br>flags -》    int: A bitmask of flags BUFFER_FLAG_CODEC_CONFIG and BUFFER_FLAG_END_OF_STREAM. While not prohibited, most codecs do not use the BUFFER_FLAG_KEY_FRAME flag for input buffers.（标志BUFFER_FLAG_CODEC_CONFIG和BUFFER_FLAG_END_OF_STREAM的位掩码。 虽然不禁止，但大多数编解码器不会将BUFFER_FLAG_KEY_FRAME标志用于输入缓冲区。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）<br>MediaCodec.CryptoException     -》 if a crypto object has been specified in configure(MediaFormat, Surface, MediaCrypto, int)（如果在配置中指定了加密对象（MediaFormat，Surface，MediaCrypto，int）  </li>
</ul>
<h4 id="queueSecureInputBuffer"><a href="#queueSecureInputBuffer" class="headerlink" title="queueSecureInputBuffer"></a>queueSecureInputBuffer</h4><p>public void queueSecureInputBuffer (int index, int offset, 、MediaCodec.CryptoInfo info,long presentationTimeUs,int flags)：Similar to queueInputBuffer but submits a buffer that is potentially encrypted. Check out further notes at queueInputBuffer.（与queueInputBuffer类似，但提交可能加密的缓冲区。 在queueInputBuffer中查看进一步的注释。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned in a call to dequeueInputBuffer(long).（先前在调用dequeueInputBuffer（long）时返回的客户机拥有的输入缓冲区的索引。）<br>offset -》    int: The byte offset into the input buffer at which the data starts.输入缓冲区中数据开始的字节偏移量）<br>info -》    MediaCodec.CryptoInfo: Metadata required to facilitate decryption, the object can be reused immediately after this call returns.This value must never be null.（为便于解密而需要的元数据，该对象可在此调用返回后立即重用。此值绝不能为空。）<br>presentationTimeUs -》    long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered).（此缓冲区的呈现时间戳（以微秒为单位）。 这通常是介质缓冲区应呈现（呈现）的介质时间。）<br>flags    -》 int: A bitmask of flags BUFFER_FLAG_CODEC_CONFIG and BUFFER_FLAG_END_OF_STREAM. While not prohibited, most codecs do not use the BUFFER_FLAG_KEY_FRAME flag for input buffers.（标志BUFFER_FLAG_CODEC_CONFIG和BUFFER_FLAG_END_OF_STREAM的位掩码。 虽然不禁止，但大多数编解码器不会将BUFFER_FLAG_KEY_FRAME标志用于输入缓冲区。）<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）<br>MediaCodec.CryptoException     -》 if a crypto object has been specified in configure(MediaFormat, Surface, MediaCrypto, int)（如果在配置中指定了加密对象（MediaFormat，Surface，MediaCrypto，int）</li>
</ul>
</li>
</ul>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>public void release ()；Free up resources used by the codec instance. Make sure you call this when you’re done to free up any opened component instance instead of relying on the garbage collector to do this for you at some point in the future.（释放编解码器实例使用的资源。 确保在你完成释放任何打开的组件实例时调用它，而不是依赖垃圾回收器在将来的某个时刻为你做这件事。）</p>
<h4 id="releaseOutputBuffer"><a href="#releaseOutputBuffer" class="headerlink" title="releaseOutputBuffer"></a>releaseOutputBuffer</h4><p>public void releaseOutputBuffer (int index, boolean render)：If you are done with a buffer, use this call to return the buffer to the codec or to render it on the output surface. If you configured the codec with an output surface, setting render to true will first send the buffer to that output surface. The surface will release the buffer back to the codec once it is no longer used/displayed. Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by getOutputBuffer(int) in response to a dequeueOutputBuffer(MediaCodec.BufferInfo, long) return value or a MediaCodec.Callback.onOutputBufferAvailable(MediaCodec, int, MediaCodec.BufferInfo) callback.（如果完成了缓冲区，则使用此调用将缓冲区返回给编解码器或将其呈现在输出表面上。 如果您使用输出表面配置编解码器，将渲染设置为true将首先将缓冲区发送到该输出表面。 一旦不再使用/显示，表面就会将缓冲区释放回编解码器。 一旦输出缓冲区被释放到编解码器，它就不能被使用，直到之后被getOutputBuffer（int）检索以响应dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回值或MediaCodec.Callback.onOutputBufferAvailable（MediaCodec，int ，MediaCodec.BufferInfo）回调。）</p>
<ul>
<li>参数<br>index    -》 int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long).（先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回的客户端拥有的输出缓冲区的索引。）<br>render -》     boolean: If a valid surface was specified when configuring the codec, passing true renders this output buffer to the surface.（如果在配置编解码器时指定了有效曲面，则传递true会将此输出缓冲区渲染到曲面。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="releaseOutputBuffer-1"><a href="#releaseOutputBuffer-1" class="headerlink" title="releaseOutputBuffer"></a>releaseOutputBuffer</h4><p>public void releaseOutputBuffer (int index, long renderTimestampNs)：If you are done with a buffer, use this call to update its surface timestamp and return it to the codec to render it on the output surface. If you have not specified an output surface when configuring this video codec, this call will simply return the buffer to the codec.（如果已完成缓冲区，则使用此调用更新其表面时间戳并将其返回给编解码器以在输出表面上呈现它。 如果您在配置此视频编解码器时尚未指定输出界面，则此调用将简单地将缓冲区返回给编解码器。）<br>The timestamp may have special meaning depending on the destination surface.（时间戳根据目的地表面可能有特殊含义。）<br><strong>SurfaceView specifics</strong><br> If you render your buffer on a SurfaceView, you can use the timestamp to render the buffer at a specific time (at the VSYNC at or after the buffer timestamp). For this to work, the timestamp needs to be reasonably close to the current System.nanoTime(). Currently, this is set as within one (1) second. A few notes:（如果在SurfaceView上渲染缓冲区，则可以使用时间戳在特定时间渲染缓冲区（在缓冲区时间戳之后或之后的VSYNC处）。 为此，时间戳需要相当接近当前的System.nanoTime（）。 目前，这是在一（1）秒内设定的。 一些注意事项：）      </p>
<ul>
<li>the buffer will not be returned to the codec until the timestamp has passed and the buffer is no longer used by the Surface.（该缓冲区将不会返回到编解码器，直到时间戳已经过去并且该缓冲区不再被Surface使用。）</li>
<li>buffers are processed sequentially, so you may block subsequent buffers to be displayed on the Surface. This is important if you want to react to user action, e.g. stop the video or seek.（缓冲区会按顺序处理，因此您可能会阻止后续缓冲区显示在Surface上。 如果您想对用户操作做出反应，这很重要。 停止视频或寻求。）</li>
<li>if multiple buffers are sent to the Surface to be rendered at the same VSYNC, the last one will be shown, and the other ones will be dropped.（如果将多个缓冲区发送到要在同一个VSYNC上渲染的Surface，则会显示最后一个缓冲区，其他则会被放弃。）</li>
<li>if the timestamp is not “reasonably close” to the current system time, the Surface will ignore the timestamp, and display the buffer at the earliest feasible time. In this mode it will not drop frames.（如果时间戳不与当前系统时间“合理接近”，Surface将忽略时间戳，并在最早的可行时间显示缓冲区。 在这种模式下，它不会丢帧。）</li>
<li>for best performance and quality, call this method when you are about two VSYNCs’ time before the desired render time. For 60Hz displays, this is about 33 msec.（为获得最佳性能和质量，当您在所需渲染时间之前约两个VSYNC的时间时调用此方法。 对于60Hz的显示器，这是大约33毫秒。）</li>
</ul>
<p>Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by getOutputBuffer(int) in response to a dequeueOutputBuffer(MediaCodec.BufferInfo, long) return value or a MediaCodec.Callback.onOutputBufferAvailable(MediaCodec, int, MediaCodec.BufferInfo) callback.（一旦输出缓冲区被释放到编解码器，它就不能被使用，直到之后被getOutputBuffer（int）检索以响应dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回值或MediaCodec.Callback.onOutputBufferAvailable（MediaCodec，int ，MediaCodec.BufferInfo）回调。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long).（他先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回的客户端拥有的输出缓冲区的索引，）<br>renderTimestampNs -》     long: The timestamp to associate with this buffer when it is sent to the Surface.（发送到Surface时与此缓冲区关联的时间戳。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>public void reset ()：Returns the codec to its initial (Uninitialized) state. Call this if an unrecoverable error has occured to reset the codec to its initial state after creation.（将编解码器返回到其初始（未初始化）状态。 如果在创建后发生不可恢复的错误以将编解码器重置为其初始状态，请调用此函数。）</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="setCallback"><a href="#setCallback" class="headerlink" title="setCallback"></a>setCallback</h4><p>public void setCallback (MediaCodec.Callback cb,Handler handler)：Sets an asynchronous callback for actionable MediaCodec events. If the client intends to use the component in asynchronous mode, a valid callback should be provided before configure(MediaFormat, Surface, MediaCrypto, int) is called. When asynchronous callback is enabled, the client should not call getInputBuffers(), getOutputBuffers(), dequeueInputBuffer(long) or dequeueOutputBuffer(BufferInfo, long).<br>Also, flush() behaves differently in asynchronous mode. After calling flush, you must call start() to “resume” receiving input buffers, even if an input surface was created.（为可操作的MediaCodec事件设置异步回调。 如果客户端打算以异步模式使用组件，则应在调用configure（MediaFormat，Surface，MediaCrypto，int）之前提供有效的回调。 启用异步回调时，客户端不应调用getInputBuffers（），getOutputBuffers（），dequeueInputBuffer（long）或dequeueOutputBuffer（BufferInfo，long）。<br>另外，flush（）在异步模式下表现不同。 在调用flush之后，即使创建了输入曲面，也必须调用start（）来“继续”接收输入缓冲区。）</p>
<ul>
<li>参数<br>cb -》    MediaCodec.Callback: The callback that will run. Use null to clear a previously set callback (before configure is called and run in synchronous mode).（将运行的回调。 使用null清除先前设置的回调（在调用configure并在同步模式下运行之前）。）<br>handler    -》 Handler: Callbacks will happen on the handler’s thread. If null, callbacks are done on the default thread (the caller’s thread or the main thread.)（回调将在处理程序的线程上发生。 如果为null，则在默认线程（调用者线程或主线程）上完成回调。）</li>
</ul>
<h4 id="setCallback-1"><a href="#setCallback-1" class="headerlink" title="setCallback"></a>setCallback</h4><p>public void setCallback (MediaCodec.Callback cb)：Sets an asynchronous callback for actionable MediaCodec events on the default looper.Same as setCallback(Callback, Handler) with handler set to null.</p>
<h4 id="setInputSurface"><a href="#setInputSurface" class="headerlink" title="setInputSurface"></a>setInputSurface</h4><p>public void setInputSurface (Surface surface)：Configures the codec (e.g. encoder) to use a persistent input surface in place of input buffers. This may only be called after configure(MediaFormat, Surface, MediaCrypto, int) and before start(), in lieu of createInputSurface().（配置编解码器（例如编码器）以使用持久输入表面代替输入缓冲器。 这只能在configure（MediaFormat，Surface，MediaCrypto，int）和start（）之前调用，而不是createInputSurface（）。）</p>
<ul>
<li>参数<br>surface -》    Surface: a persistent input surface created by createPersistentInputSurface()，This value must never be null.（由createPersistentInputSurface（）创建的持久性输入表面，该值不能为空。）</li>
<li>异常<br>IllegalStateException  -》    if not in the Configured state or does not require an input surface.（如果不处于配置状态或不需要输入表面。）<br>IllegalArgumentException -》    if the surface was not created by createPersistentInputSurface(). （如果表面不是由createPersistentInputSurface（）创建的。）</li>
</ul>
<h4 id="setOnFrameRenderedListener"><a href="#setOnFrameRenderedListener" class="headerlink" title="setOnFrameRenderedListener"></a>setOnFrameRenderedListener</h4><p>public void setOnFrameRenderedListener (MediaCodec.OnFrameRenderedListener listener, Handler handler)：Registers a callback to be invoked when an output frame is rendered on the output surface.This method can be called in any codec state, but will only have an effect in the Executing state for codecs that render buffers to the output surface.<br>Note: This callback is for informational purposes only: to get precise render timing samples, and can be significantly delayed and batched. Some frames may have been rendered even if there was no callback generated.（注册在输出表面上呈现输出帧时调用的回调函数。可以在任何编解码器状态中调用此方法，但仅对于将缓冲区呈现到输出表面的编解码器在执行状态中起作用。<br>注意：此回调仅用于提供信息：获取精确的渲染时间采样，并且可以显着延迟和批处理。 即使没有生成回调，某些帧可能已经被渲染。）</p>
<ul>
<li>参数<br>listener     -》 MediaCodec.OnFrameRenderedListener: the callback that will be run，This value may be null.<br>handler -》    Handler: the callback will be run on the handler’s thread. If null, the callback will be run on the default thread, which is the looper from which the codec was created, or a new thread if there was none.</li>
</ul>
<h4 id="setOutputSurface"><a href="#setOutputSurface" class="headerlink" title="setOutputSurface"></a>setOutputSurface</h4><p>public void setOutputSurface (Surface surface)：Dynamically sets the output surface of a codec.This can only be used if the codec was configured with an output surface. The new output surface should have a compatible usage type to the original output surface. E.g. codecs may not support switching from a SurfaceTexture (GPU readable) output to ImageReader (software readable) output.（动态设置编解码器的输出表面。仅当编解码器配置有输出表面时才能使用此选项。 新的输出表面应与原始输出表面具有兼容的使用类型。 例如。 编解码器可能不支持从SurfaceTexture（GPU可读）输出切换到ImageReader（软件可读）输出。）</p>
<ul>
<li>参数<br>surface -》    Surface: the output surface to use. It must not be null.</li>
<li>异常<br>IllegalStateException -》    if the codec does not support setting the output surface in the current state.<br>IllegalArgumentException -》    if the new surface is not of a suitable type for the codec.</li>
</ul>
<h4 id="setParameters"><a href="#setParameters" class="headerlink" title="setParameters"></a>setParameters</h4><p>public void setParameters (Bundle params)：Communicate additional parameter changes to the component instance. Note: Some of these parameter changes may silently fail to apply.</p>
<ul>
<li>参数<br>params    -》Bundle: The bundle of parameters to set.This value may be null.</li>
<li>异常<br>IllegalStateException    if in the Released state.  </li>
</ul>
<h4 id="setVideoScalingMode"><a href="#setVideoScalingMode" class="headerlink" title="setVideoScalingMode"></a>setVideoScalingMode</h4><p>public void setVideoScalingMode (int mode)：If a surface has been specified in a previous call to configure(MediaFormat, Surface, MediaCrypto, int) specifies the scaling mode to use. The default is “scale to fit”.</p>
<p><strong> ⚠️ </strong> The scaling mode may be reset to the default each time an INFO_OUTPUT_BUFFERS_CHANGED event is received from the codec; therefore, the client must call this method after every buffer change event (and before the first output buffer is released for rendering) to ensure consistent scaling mode.<br><strong> ⚠️ </strong> Since the INFO_OUTPUT_BUFFERS_CHANGED event is deprecated, this can also be done after each INFO_OUTPUT_FORMAT_CHANGED event.</p>
<ul>
<li>参数<br>mode -》     int</li>
<li>异常<br>IllegalArgumentException -》    if mode is not recognized.<br>IllegalStateException -》    if in the Released state.</li>
</ul>
<h4 id="signalEndOfInputStream"><a href="#signalEndOfInputStream" class="headerlink" title="signalEndOfInputStream"></a>signalEndOfInputStream</h4><p>public void signalEndOfInputStream ()：Signals end-of-stream on input. Equivalent to submitting an empty buffer with BUFFER_FLAG_END_OF_STREAM set. This may only be used with encoders receiving input from a Surface created by createInputSurface().</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.<br>MediaCodec.CodecException    -》 upon codec error.</li>
</ul>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p>public void start ()：After successfully configuring the component, call start.Call start also if the codec is configured in asynchronous mode, and it has just been flushed, to resume requesting input buffers.</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Configured state or just after flush() for a codec that is configured in asynchronous mode.<br>MediaCodec.CodecException -》    upon codec error. Note that some codec errors for start may be attributed to future method calls.</li>
</ul>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>public void stop ()：Finish the decode/encode session, note that the codec instance remains active and ready to be start()ed again. To ensure that it is available to other client call release() and don’t just rely on garbage collection to eventually do this for you.</p>
<ul>
<li>异常<br>IllegalStateException -》    if in the Released state.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/02/Android音视频操作使用到的类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/Android音视频操作使用到的类/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T09:45:33+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>音视频处理涉及到的类api</p>
<h3 id="MediaFormat"><a href="#MediaFormat" class="headerlink" title="MediaFormat"></a>MediaFormat</h3><p>官方描述：Encapsulates the information describing the format of media data, be it audio or video. The format of the media data is specified as string/value pairs。added in API level 16。 public final class MediaFormat extends Object。<br>译文：封装描述媒体数据格式的信息，无论是音频还是视频。 媒体数据的格式被指定为字符串/值对。</p>
<h3 id="MediaMuxer"><a href="#MediaMuxer" class="headerlink" title="MediaMuxer"></a>MediaMuxer</h3><p>官方描述：MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4, Webm and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat. added in API level 18。public final class MediaMuxer extends Object。<br>译文：MediaMuxer有助于混合基本流。 目前MediaMuxer支持MP4，Webm和3GP文件作为输出。 自从Android Nougat以来，它还支持MP4中的M帧B帧。<br>其一般的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MediaMuxer muxer = new MediaMuxer(&quot;temp.mp4&quot;, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line">// More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat()</span><br><span class="line">// or MediaExtractor.getTrackFormat().</span><br><span class="line">MediaFormat audioFormat = new MediaFormat(...);</span><br><span class="line">MediaFormat videoFormat = new MediaFormat(...);</span><br><span class="line">int audioTrackIndex = muxer.addTrack(audioFormat);</span><br><span class="line">int videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line">ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);</span><br><span class="line">boolean finished = false;</span><br><span class="line">BufferInfo bufferInfo = new BufferInfo();</span><br><span class="line"></span><br><span class="line">muxer.start();</span><br><span class="line">while(!finished) &#123;</span><br><span class="line">  // getInputBuffer() will fill the inputBuffer with one frame of encoded</span><br><span class="line">  // sample from either MediaCodec or MediaExtractor, set isAudioSample to</span><br><span class="line">  // true when the sample is audio data, set up all the fields of bufferInfo,</span><br><span class="line">  // and return true if there are no more samples.</span><br><span class="line">  finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);</span><br><span class="line">  if (!finished) &#123;</span><br><span class="line">    int currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;</span><br><span class="line">    muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">muxer.stop();</span><br><span class="line">muxer.release();</span><br></pre></td></tr></table></figure></p>
<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>public class Surface extends Object implements Parcelable：Handle onto a raw buffer that is being managed by the screen compositor.A Surface is generally created by or from a consumer of image buffers (such as a SurfaceTexture, MediaRecorder, or Allocation), and is handed to some kind of producer (such as OpenGL, MediaPlayer, or CameraDevice) to draw into.</p>
<p>Note: A Surface acts like a weak reference to the consumer it is associated with. By itself it will not keep its parent consumer from being reclaimed.<br>（处理由屏幕合成器管理的原始缓冲区。surface通常由图像缓冲区（例如SurfaceTexture，MediaRecorder或Allocation）的使用者创建或从图像缓冲区的消费者创建，并被传递给某种生产者（例如OpenGL，MediaPlayer或CameraDevice）以进行绘制。<br>注意：Surface表示对与其关联的使用者的弱引用。 它本身不会让其父母消费者不被收回。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">the blog from a anroid coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
