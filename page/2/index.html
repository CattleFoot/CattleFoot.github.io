<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android, SpringBoot" />










<meta name="description" content="The blog from a Android coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/2/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="The blog from a Android coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="The blog from a Android coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/page/2/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/16/根据Uri获取文档的路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/根据Uri获取文档的路径/" itemprop="url">根据Uri获取文档的路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T14:11:33+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据Url获取文档的绝对路径，解决Android4.4以上版本Uri转换。<br>Android在4.4之后的版本(包括4.4)中，从相册中选取图片返回Uri进行了改动。所以无法通过该Uri来取得文件路径从而解码图片将其显示出来。<br><code>在4.3或以下可以直接用Intent.ACTION_GET_CONTENT打开相册;在4.4或以上,官方建议用ACTION_OPEN_DOCUMENT打开相册</code><br>在Android4.4之前得到的Uri为：</p>
<ul>
<li>content://media/external/images/media/8302  </li>
<li>content://media/external/video/media  </li>
<li>content://media/external/images/media  </li>
</ul>
<p>而在Android4.4后得到的可能是以下：</p>
<ul>
<li>content://com.android.providers.media.documents/document/image:8302</li>
<li>content://com.android.providers.downloads.documents/document/5</li>
</ul>
<p>以下为Android4.4之后的适配：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *</span><br><span class="line"> * 专为Android4.4设计的从Uri获取文件绝对路径</span><br><span class="line"> */</span><br><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public static String getPath(final Context context, final Uri uri) &#123;</span><br><span class="line">    final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line">    LogUtil.d(&quot;uri:&quot; + uri);</span><br><span class="line">    // DocumentProvider</span><br><span class="line">    if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">        // ExternalStorageProvider</span><br><span class="line">        if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1];</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO handle non-primary volumes</span><br><span class="line">        &#125;</span><br><span class="line">        // DownloadsProvider</span><br><span class="line">        else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">            final String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">            return getDataColumn(context, contentUri, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // MediaProvider</span><br><span class="line">        else if (isMediaDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            Uri contentUri = null;</span><br><span class="line">            if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String selection = &quot;_id=?&quot;;</span><br><span class="line">            final String[] selectionArgs = new String[]&#123;split[1]&#125;;</span><br><span class="line">            LogUtil.d(&quot;format uri:&quot; + contentUri);</span><br><span class="line">            return getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // MediaStore (and general)</span><br><span class="line">    else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return getDataColumn(context, uri, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // File</span><br><span class="line">    else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return uri.getPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the value of the data column for this Uri. This is useful for</span><br><span class="line"> * MediaStore Uris, and other file-based ContentProviders.</span><br><span class="line"> *</span><br><span class="line"> * @param context       The context.</span><br><span class="line"> * @param uri           The Uri to query.</span><br><span class="line"> * @param selection     (Optional) Filter used in the query.</span><br><span class="line"> * @param selectionArgs (Optional) Selection arguments used in the query.</span><br><span class="line"> * @return The value of the _data column, which is typically a file path.</span><br><span class="line"> */</span><br><span class="line">public static String getDataColumn(Context context, Uri uri, String selection,</span><br><span class="line">                                   String[] selectionArgs) &#123;</span><br><span class="line"></span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    final String column = &quot;_data&quot;;</span><br><span class="line">    final String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                null);</span><br><span class="line">        if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">            final int column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor != null)</span><br><span class="line">            cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is ExternalStorageProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is DownloadsProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is MediaProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看一个获取Mp3文档的Uri，其格式类似：content://com.android.providers.media.documents/document/audio%3A39，<br>然后我根据代码进一步分析，首先看判断条件：isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)，<br>这里判断了版本号和该Uri是否是文档类Uri，之所以要判断版本号是Uri的生成在Api19以后发送变化，通过官方文档DocumentsContract，我们也可以验证这点，DocumentsContract是在Api19加入的，其定义就是定义文档提供者与平台之间的协议，其主要作用就是关于文档Uri的一系列操作。<br>下面是其内部实现代码（代码都是在DocumentsContract类中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT = &quot;document&quot;;</span><br><span class="line">private static final String PATH_TREE = &quot;tree&quot;;</span><br><span class="line">public static final String PROVIDER_INTERFACE = &quot;android.content.action.DOCUMENTS_PROVIDER&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Test if the given URI represents a &#123;@link Document&#125; backed by a</span><br><span class="line">   * &#123;@link DocumentsProvider&#125;.</span><br><span class="line">   *</span><br><span class="line">   * @see #buildDocumentUri(String, String)</span><br><span class="line">   * @see #buildDocumentUriUsingTree(Uri, String)</span><br><span class="line">   */</span><br><span class="line">  public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">      if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">          final List&lt;String&gt; paths = uri.getPathSegments();</span><br><span class="line">          if (paths.size() == 2) &#123;</span><br><span class="line">              return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">          &#125; else if (paths.size() == 4) &#123;</span><br><span class="line">              return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  /** &#123;@hide&#125; */</span><br><span class="line">   public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">      // public static final String SCHEME_CONTENT = &quot;content&quot;;     !!add by custom</span><br><span class="line">       return uri != null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent = new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos = context.getPackageManager()</span><br><span class="line">            .queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看出，前提条件是判断是否是contentUri&amp;&amp;documentProvider，然后在进一步判断其pathSegments<br>是否是document/或者tree/document/开头。其中isDocumentsProvider方法不是特别理解，希望大神指点下。</p>
<p>参考地址：<br>[1] 解决Android4.4以上版本Uri转换  <a href="https://blog.csdn.net/q445697127/article/details/40537945" target="_blank" rel="noopener">https://blog.csdn.net/q445697127/article/details/40537945</a><br>[2] <a href="https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework" target="_blank" rel="noopener">https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/LinearLayout源码解读/" itemprop="url">LinearLayout源码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-12T10:01:49+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="LinearLayout基础"><a href="#LinearLayout基础" class="headerlink" title="LinearLayout基础"></a>LinearLayout基础</h3><p>LinearLayout所具有的属性：</p>
<ul>
<li>orientation：视图的布局方向，默认值：-1；</li>
<li>gravity：绘制起始点，默认值：-1；</li>
<li>baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true；</li>
<li>weightSum：子视图权重和，默认值：-1.0f；</li>
<li>baselineAlignedChildIndex：以第Index个子视图的基准线为对齐，该LinearLayout下的view以<br>某个继承TextView的View的基线对齐，默认值：-1；</li>
<li>measureWithLargestChild：以最大子视图宽高，为其子视图的宽高，<strong>其起作用前提是为true，且LinearLayout在该方向的宽或高为warp_content，且子视图具有权重</strong>。默认值：false；</li>
<li>divider：分割线；</li>
<li>showDividers：分割线显示样式（middle|end|beginning|non），默认值：SHOW_DIVIDER_NONE；</li>
<li><p>dividerPadding：分割线内边距，默认值：0；</p>
<p>解释：</p>
</li>
<li>基准线<br>其主要作用是在绘制字母的时候有个基线对齐，这个类似我们学习英语字母的时候用的四线谱：<br><img src="./images/baselineAligned_expand.png" alt="基线示意图"><br>其中红线就是基线（baseline），和下面我们书写英语字母的四线谱是不是很像，基线就是第三条。<br><img src="./images/baselineAligned_ch.png" alt="英语书写四线谱"></li>
</ul>
<ul>
<li>源码之垂直方向测量（void measureVertical(int widthMeasureSpec, int heightMeasureSpec)）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Measures the children when the orientation of this LinearLayout is set</span><br><span class="line">     * to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.</span><br><span class="line">     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.</span><br><span class="line">     *</span><br><span class="line">     * @see #getOrientation()</span><br><span class="line">     * @see #setOrientation(int)</span><br><span class="line">     * @see #onMeasure(int, int)</span><br><span class="line">     */</span><br><span class="line">    void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		// mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">		// maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">		// 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		* 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">		* 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">		* 否则，则跟maxWidth的计算方法一样</span><br><span class="line">		*/</span><br><span class="line">		// 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">		// 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">		// 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">		// 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">		// 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">		// 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">		// 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // See how tall everyone is. Also remember max width.</span><br><span class="line"></span><br><span class="line">		//查看每一个高，并记住最大宽度</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">			//首先获取子View</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">			//如果子View是null就继续测量下一个子View</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">				// 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">			//如果子View是GONE的也不算在总高度里面，这里也能看出GONE和INVISIBLE的区别</span><br><span class="line">            if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">				// 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line">			//有时候我们在代码里面通过Inflater服务，动态加载一个布局，然后去设置他的LayoutParams，</span><br><span class="line">			//如果不引用父容器的LayoutParams就会报一个强转错误，原因就在这个父容器在add,measure的时候都会</span><br><span class="line">			//把子View的LayoutParams强转成自己的类型</span><br><span class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">			//得到每个子控件的LayoutParams后，累加权重和,后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束,基本没有用到</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">			//这里就值得注意下了如果当前的LinearLayout是EXACTLY模式，且子view的高度为0，且权重大于0</span><br><span class="line">			//这个子view只有在LinearLayout高度有剩余的时候，才会根据权重的占比去平分剩余空间</span><br><span class="line">			//上文说的二次测量也就指的这部分</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // Optimization: don&apos;t bother measuring children who are going to use</span><br><span class="line">                // leftover space. These views will get measured again down below if</span><br><span class="line">                // there is any leftover space.</span><br><span class="line">				// 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0   	</span><br><span class="line"></span><br><span class="line">				// 如果LinearLayout的垂直方向测量模式是EXACTLY，即确定值，且子视图的高度为0，weight大于0，</span><br><span class="line">        //则先将总高度加上子视图的topMargin和bottomMargin，并设置skippedMeasure（暂时跳过测量标识）为true</span><br><span class="line"></span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法，此时需要记住view的topMargin和bottomMargin（对于方向为）</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">				// 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // heightMode is !!either UNSPECIFIED or AT_MOST!!, and this</span><br><span class="line">                    // child wanted to stretch to fill available space.</span><br><span class="line">                    // Translate that to WRAP_CONTENT so that it does not end up</span><br><span class="line">                    // with a height of 0</span><br><span class="line">					// 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line"></span><br><span class="line">					//这里其实官方的注释讲了也挺清楚的，到了这步，当前的LinearLayout的模式</span><br><span class="line">					//肯定是UNSPECIFIED或者MOST，因为EXACTLY模式会进入上一个判断</span><br><span class="line">					//然后把子View的高度赋值成-1(WRAP_CONTENT)</span><br><span class="line">					// 如果垂直方向测量模式为UNSPECIFIED或AT_MOST，同时子视图想要尽量获取可用的剩余空间，</span><br><span class="line">          //把子视图的高度改为WRAP_CONTENT，这样子视图的最终高度就不会是0</span><br><span class="line"></span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Determine how big this child would like to be. If this or</span><br><span class="line">                // previous children have given a weight, then we allow it to</span><br><span class="line">                // use all available space (and we will shrink things later</span><br><span class="line">                // if needed).</span><br><span class="line">				/**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line"></span><br><span class="line">				// 这个函数最后会调用child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</span><br><span class="line">        //测量出子视图要占用多大空间，并设置子视图的mMeasuredWidth和mMeasuredHeight</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">				// 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line"></span><br><span class="line">				// getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">				//加上子View的margin值</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">				// 重新设置最大子视图高度</span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * If applicable, compute the additional offset to the child&apos;s baseline</span><br><span class="line">             * we&apos;ll need later when asked &#123;@link #getBaseline&#125;.</span><br><span class="line">             */</span><br><span class="line">			// 计算子视图baseline的偏移量</span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // if we are trying to use a child index for our baseline, the above</span><br><span class="line">            // book keeping only works if there are no children above it with</span><br><span class="line">            // weight.  fail fast to aid the developer.</span><br><span class="line">			// 如果要为baseline指定子视图索引，只有在此子视图之上的视图没有设置weight属性时才有效</span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 下面开始测量宽度</span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // The width of the linear layout will scale, and at least one</span><br><span class="line">                // child said it wanted to match our width. Set a flag</span><br><span class="line">                // indicating that we need to remeasure at least that view when</span><br><span class="line">                // we know our width.</span><br><span class="line">				//如果LinearLayout宽度不是已确定的，如wrap_content,而子视图是MATCH_PARENT，  </span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 计算子视图总宽度（包含左右外边距）</span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">			// 合并子元素的测量状态</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">			// 子视图宽度是否都为MATCH_PARENT</span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Widths of weighted Views are bogus if we end up</span><br><span class="line">                 * remeasuring, so keep them separate.</span><br><span class="line">                 */</span><br><span class="line">				//如设置了weigh属性，则子视图的宽度需要在父视图确定后才能确定。这里并不是真实的宽度  </span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">		//for 循环结束</span><br><span class="line"></span><br><span class="line">		// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过</span><br><span class="line">        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">			// 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，</span><br><span class="line">      //重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                // Account for negative margins</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//在这两段代码之间还有些杂七杂八的处理，如果读者有兴趣可以自己阅读分析下</span><br><span class="line">		//当测量完子View的大小后，总高度会再加上padding的高度</span><br><span class="line">        // Add in our padding</span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        int heightSize = mTotalLength;</span><br><span class="line">		    //如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较</span><br><span class="line">        //然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值</span><br><span class="line">        // Check against our minimum height</span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        // Reconcile our calculated size with the heightMeasureSpe</span><br><span class="line">		// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，</span><br><span class="line">    //剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）</span><br><span class="line">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line">		//到了这里，会再对带weight属性的子View进行一次测绘</span><br><span class="line">        //首先计算剩余高度</span><br><span class="line"></span><br><span class="line">		//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的</span><br><span class="line">        // Either expand children with weight to take up available space or</span><br><span class="line">        // shrink them if they extend beyond our current bounds. If we skipped</span><br><span class="line">        // measurement on any children, we need to measure them now.</span><br><span class="line">        int delta = heightSize - mTotalLength;</span><br><span class="line">        if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123;</span><br><span class="line">			//如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦</span><br><span class="line">            float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = 0;</span><br><span class="line">			//这里的代码就和第一次测量很像了</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                float childExtra = lp.weight;</span><br><span class="line">                if (childExtra &gt; 0) &#123;</span><br><span class="line">					// 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure</span><br><span class="line">					//子控件的weight占比*剩余高度</span><br><span class="line">                    // Child said it could absorb extra space -- give him his share</span><br><span class="line">                    int share = (int) (childExtra * delta / weightSum);</span><br><span class="line">					// weightSum计余</span><br><span class="line">                    weightSum -= childExtra;</span><br><span class="line">					//剩余高度减去分配出去的高度</span><br><span class="line">                    delta -= share;</span><br><span class="line"></span><br><span class="line">                    final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight +</span><br><span class="line">                                    lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line">					//如果是当前LinearLayout的模式是EXACTLY</span><br><span class="line">                    //那么这个子View是没有被测量过的，就需要测量一次</span><br><span class="line">                    //如果不是EXACTLY的，在第一次循环里就被测量一些了</span><br><span class="line">                    // TODO: Use a field like lp.isMeasured to figure out if this</span><br><span class="line">                    // child has been previously measured</span><br><span class="line">                    if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        // child was measured once already above...</span><br><span class="line">                        // base new measurement on stored values</span><br><span class="line">						//如果是非EXACTLY模式下的子View就再加上</span><br><span class="line">                        //weight分配占比*剩余高度</span><br><span class="line">						// 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小</span><br><span class="line">                        int childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                        if (childHeight &lt; 0) &#123;</span><br><span class="line">                            childHeight = 0;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">						//重新测量一次，因为高度发生了变化</span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // child was skipped in the loop above.</span><br><span class="line">                        // Measure for this first time here  </span><br><span class="line"></span><br><span class="line">						//如果是EXACTLY模式下的</span><br><span class="line">                        //这里只会把weight占比所拥有的高度分配给你的子View</span><br><span class="line">						// 上面测量的时候被跳过，那么在这里进行测量    </span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Child may now not fit in vertical dimension.</span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里得到最终高度</span><br><span class="line">            // Add in our padding</span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            // TODO: Should we recompute the heightSpec based on the new total length?</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			 // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // We have no limit, so make all weighted views as tall as the largest child.</span><br><span class="line">            // Children will have already been measured once.</span><br><span class="line">			// 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次</span><br><span class="line">            if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                    if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    float childExtra = lp.weight;</span><br><span class="line">                    if (childExtra &gt; 0) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        // Check against our minimum width</span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">		// 设置测量完的宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        if (matchWidth) &#123;</span><br><span class="line">			// 使宽度一致</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在垂直绘制中主要执行逻辑在两大块代码，第一个for循环，第二个if判断中的for循环，接下来我们分块分析该函数源码：</p>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;      </span><br><span class="line">        // mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">        // maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">        // 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">         * 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">         * 否则，则跟maxWidth的计算方法一样</span><br><span class="line">         */</span><br><span class="line">        // 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">        // 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">        // 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">        // 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">        // 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        // 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        // 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // ...... 底下两个for循环</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在变量定义中，我们主要留意三个方面：</p>
<ul>
<li>mTotalLength：这个就是最终得到的整个LinearLayout的高度（子控件高度累加及自身padding）</li>
<li>三个跟width相关的变量</li>
<li>weight相关的变量</li>
</ul>
<h4 id="第一个for代码块和baselineChildIndex处理"><a href="#第一个for代码块和baselineChildIndex处理" class="headerlink" title="第一个for代码块和baselineChildIndex处理"></a>第一个for代码块和baselineChildIndex处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // ...上面的一大堆局部变量</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                // 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (child.getVisibility() == GONE) &#123;</span><br><span class="line">               // 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerWidth;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            // 得到每个子控件的LayoutParams后，累加权重和，后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            // 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0</span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">                // 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                // getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">        //... 底下第二个for循环</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">  在第一个for循环中，主要是if()&#123;&#125;else&#123;&#125;分支，判断是heightMode == MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">  lp.height == 0 &amp;&amp; lp.weight &gt; 0，这个主要是linearLayout测量模式为EXACTLY且子视图明确</span><br><span class="line"> 了是使用linearLayout的剩余空间，此时将其上下间距计入总高度并以之前的做对比去大值，并设置</span><br><span class="line"> skippedMeasure标志为true。而在else中则为复杂点，else中首先对lp.height == 0 &amp;&amp;</span><br><span class="line">  lp.weight &gt; 0的子视图的height做预处理使其为LayoutParams.WRAP_CONTENT（因为父类即</span><br><span class="line">  LinearLayout此时是wrap_content，或者mode为UNSPECIFIED），接着对子视图进行测量（</span><br><span class="line">  这个受总权重影响），并将其高度和上下间距计入到总高度中。之后对baselineChildIndex做处理，</span><br><span class="line">  计入总的基线高度并判定基线配置是否合理，不合理抛出异常，最后根据子视图设置最大宽度、</span><br><span class="line">  allFillParent、weightedMaxWidth或alternativeMaxWidth变量。</span><br><span class="line"></span><br><span class="line">#### 第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行前的处理 ####</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>// … 局部变量定义和第一个for循环<br>// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过<br>        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) {<br>            mTotalLength += mDividerHeight;<br>        }</p>
<pre><code>  if (useLargestChild &amp;&amp;
          (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
      mTotalLength = 0;

      // 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，
//重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸
      for (int i = 0; i &lt; count; ++i) {
          final View child = getVirtualChildAt(i);

          if (child == null) {
              mTotalLength += measureNullChild(i);
              continue;
          }

          if (child.getVisibility() == GONE) {
              i += getChildrenSkipCount(child, i);
              continue;
          }

          final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                  child.getLayoutParams();
          // Account for negative margins
          final int totalLength = mTotalLength;
          mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                  lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }
  }
  //... 第2个重要代码块
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里主要对useLargestChild属性处理，执行前提是设置了useLargestChild属性，且LinearLayout的垂直</span><br><span class="line">方向测量模式是AT_MOST或UNSPECIFIED，重新测量总高度，useLargestChild属性会使所有带weight属性的子视</span><br><span class="line">图具有最大子视图的最小尺寸</span><br><span class="line"></span><br><span class="line">第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行逻辑</span><br></pre></td></tr></table></figure>
<p>//当测量完子View的大小后，总高度会再加上padding的高度<br>        // Add in our padding<br>        mTotalLength += mPaddingTop + mPaddingBottom;</p>
<pre><code>int heightSize = mTotalLength;
//如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较
//然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值
// Check against our minimum height
heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

// Reconcile our calculated size with the heightMeasureSpe
// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）
int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;

//到了这里，会再对带weight属性的子View进行一次测绘
//首先计算剩余高度

//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的
// Either expand children with weight to take up available space or
// shrink them if they extend beyond our current bounds. If we skipped
// measurement on any children, we need to measure them now.
int delta = heightSize - mTotalLength;
if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) {
    //如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦
    float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;

    mTotalLength = 0;
    //这里的代码就和第一次测量很像了
    for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);

        if (child.getVisibility() == View.GONE) {
            continue;
        }

        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

        float childExtra = lp.weight;
        if (childExtra &gt; 0) {
            // 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure
            //子控件的weight占比*剩余高度
            // Child said it could absorb extra space -- give him his share
            int share = (int) (childExtra * delta / weightSum);
            // weightSum计余
            weightSum -= childExtra;
            //剩余高度减去分配出去的高度
            delta -= share;

            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                    mPaddingLeft + mPaddingRight +
                            lp.leftMargin + lp.rightMargin, lp.width);
            //如果是当前LinearLayout的模式是EXACTLY
            //那么这个子View是没有被测量过的，就需要测量一次
            //如果不是EXACTLY的，在第一次循环里就被测量一些了
            // TODO: Use a field like lp.isMeasured to figure out if this
            // child has been previously measured
            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                // child was measured once already above...
                // base new measurement on stored values
                //如果是非EXACTLY模式下的子View就再加上
                //weight分配占比*剩余高度
                // 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小
                int childHeight = child.getMeasuredHeight() + share;
                if (childHeight &lt; 0) {
                    childHeight = 0;
                }

                //重新测量一次，因为高度发生了变化
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
            } else {
                // child was skipped in the loop above.
                // Measure for this first time here  

                //如果是EXACTLY模式下的
                //这里只会把weight占比所拥有的高度分配给你的子View
                // 上面测量的时候被跳过，那么在这里进行测量    
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,
                                MeasureSpec.EXACTLY));
            }

            // Child may now not fit in vertical dimension.
            childState = combineMeasuredStates(childState, child.getMeasuredState()
                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
        }

        final int margin =  lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);

        boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;
                lp.width == LayoutParams.MATCH_PARENT;

        alternativeMaxWidth = Math.max(alternativeMaxWidth,
                matchWidthLocally ? margin : measuredWidth);

        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
    }
    // 这里得到最终高度
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
} else {
     // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略
    alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);


    // We have no limit, so make all weighted views as tall as the largest child.
    // Children will have already been measured once.
    // 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次
    if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) {
        for (int i = 0; i &lt; count; i++) {
            final View child = getVirtualChildAt(i);

            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            float childExtra = lp.weight;
            if (childExtra &gt; 0) {
                child.measure(
                        MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(largestChildHeight,
                                MeasureSpec.EXACTLY));
            }
        }
    }
}
</code></pre><p>```<br>在进入ifelse分支前，先计算视图的总高度，并与测量模式进行比较（resolveSizeAndState）得到最终高度，<br>在减去总高度，得到最终还剩多高（也就是可以分配给带权重的视图的高）；<br>ifelse首先判断（skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f），</p>
<ul>
<li><p>如果该条件为true，先将总高度置为0再进入for循环，此处根据子视图的权重，再次判定(lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)</p>
<ul>
<li>true：子视图再次测量 则计算子视图可以得到多少高（有可能为负，也就是子视图要吐出一定高度出来），然后子视图测量高度和分配的高度相加，小于0，则重置为0，最后在测量一次。</li>
<li><p>false：直接测量子视图，这个是之前被跳过没有测量的子视图；<br>最后再次测量视图的宽和总高度。</p>
</li>
<li><p>如果该条件为false：看useLargestChild参数，如果都无相关，那就走layout流程了，<br>我们可以看到这里直接判断是useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY，如果条件成立的话，遍历子视图，再次判断子视图是否含有权重，如果有则直接将子视图高度都是largestChildHeight。如果条件不成立，则啥也不做。</p>
</li>
</ul>
</li>
</ul>
<p>最后就是视图maxWidth计算，并setMeasuredDimension（这个是一定要的），自此垂直方向已经测量完毕。</p>
<p><strong>总结</strong><br>这里大篇幅讲解measureVertical()的流程，事实上对于LinearLayout来说，其最大的特性也正是两个<br>方向的排布以及weight的计算方式。回过头来看测量过程，我们可以看出设计者的测量计算思路，就是将有weight<br>和不含有weight的测量分开处理，再利用height跟0比较来更加的细分每一种情况。<br>最后我们在理下其测量不同情况和原理：</p>
<ul>
<li>父控件为match_parent（或者精确值），子控件拥有weight，并且高度给定为0，也即子控件明确表示使用剩余空间：<ul>
<li>子控件的高度比例将会跟我们分配的layout_weight一致，原因在于weight二次测量时走了else分支，传入的是计算出来的share值；</li>
</ul>
</li>
<li>父控件是match_parent（或者精确值），子控件拥有weight，但高度给定为match_parent（或者精确值），子控件使用自己的高度或者父控件的高度，但在父控件空间不足时，其大小可以调整：<ul>
<li>子控件高度比例将会跟我们分配的layout_weight相反，原因在于在此之前子控件测量过一次，同时子控件的测量高度为父控件的高度，在计算剩余空间的时候得出一个负值，加上自身的测量高度的时候反而更小；</li>
</ul>
</li>
<li>父控件是wrap_content，子控件拥有weight：<ul>
<li>子控件的高度将会强行置为其wrap_content给的值并以wrap_content模式进行测量</li>
</ul>
</li>
<li>父控件是wrap_content，子控件没有weight：<ul>
<li>子控件的高度跟其他的viewgroup一致</li>
</ul>
</li>
</ul>
<p>自此，LinearLayout在垂直方向的测量分析已经结束。</p>
<p>参考地址：<br>[1]. baselineAligned解析 <a href="http://www.bubuko.com/infodetail-612730.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-612730.html</a><br>[2]. measureWithLargestChild使用解析 <a href="https://blog.csdn.net/a87b01c14/article/details/49420449" target="_blank" rel="noopener">https://blog.csdn.net/a87b01c14/article/details/49420449</a><br>[3]. LinearLayout垂直测量分析 <a href="https://www.jianshu.com/p/aea27bac7c8e" target="_blank" rel="noopener">https://www.jianshu.com/p/aea27bac7c8e</a><br>[4]. view和LinearLayout源码分析 <a href="https://www.jianshu.com/p/f9b9f05222a8" target="_blank" rel="noopener">https://www.jianshu.com/p/f9b9f05222a8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/22/android-camera2预览拍照录制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/android-camera2预览拍照录制/" itemprop="url">android-camera2预览拍照录制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T10:06:52+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android 5.0(Lollipop)增加了Camera2 API，并将原有的Camera API标记为废弃。对于原有的Camera API来说，Camera2重新定义了相机的API，也重构了相机API的架构。在Camera2中其主要思想是基于会话模式和事件驱动与相机实现交互，对于预览、拍照、录制等操作都是在会话的基础下请求某种类型的会话操作。</p>
<p>比如一次拍照的操作：<br><img src="&quot;./images/take-picture.png&quot;" alt="拍照">    </p>
<p>下面一起看下camera2的操作：</p>
<ol>
<li>相机初始化<br>我们知道要使用相机，首先我们需要获得相关的权限，主要是在manifest中定义，其次在Android6.0还需要动态获取权限。</li>
</ol>
<ul>
<li>在manifest中定义需要的权限<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果要保存照片、录制视频，还需要两个权限：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>相机功能：相机特性，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera.autofocus"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>动态权限申请<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] VIDEO_PERMISSIONS = &#123;</span><br><span class="line">           Manifest.permission.CAMERA,</span><br><span class="line">           Manifest.permission.RECORD_AUDIO,</span><br><span class="line">           Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">           Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">   <span class="keyword">if</span> (!hasPermissionsGranted(getApplicationContext(), VIDEO_PERMISSIONS)) &#123;</span><br><span class="line">               requestPermissions(VIDEO_PERMISSIONS, <span class="number">1</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">hasPermissionsGranted(Context context, String[] permissions) &#123;</span><br><span class="line">       <span class="keyword">for</span> (String permission : permissions) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(context, permission)</span><br><span class="line">                   != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上基础工作好了基本可以开始对相机操作了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化相机设备</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设备管理类</span></span><br><span class="line">       cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取相机设备特征类，通过该类可以获取相机的一些特性，如相机的方向</span></span><br><span class="line">           CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraManager.getCameraIdList()[<span class="number">0</span>]);</span><br><span class="line">           mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">           Log.e(TAG, <span class="string">"sensor_orientation is :"</span> + mSensorOrientation);</span><br><span class="line">           StreamConfigurationMap streamConfigurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);</span><br><span class="line">           <span class="comment">//获取录制视屏时的宽高，这个通过MediaRecorder类获取系统支持的录制视频的宽高，主要是防止配置录制适配配置时失败</span></span><br><span class="line">           mVideoSize = chooseVideoSize(streamConfigurationMap.getOutputSizes(MediaRecorder.class));</span><br><span class="line">           <span class="comment">//根据录制视频支持的宽高和SurfaceTexture支持的宽高，以及当前视图的宽高设置预览视图的宽高</span></span><br><span class="line">           mPreviewSize = chooseOptimalSize(streamConfigurationMap.getOutputSizes(SurfaceTexture.class), surfaceView.getWidth(), surfaceView.getHeight(), mVideoSize);</span><br><span class="line">           <span class="comment">//imageReader初始化，用于获取拍照信息</span></span><br><span class="line">           imageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(), ImageFormat.JPEG, <span class="number">2</span>);</span><br><span class="line">           imageReader.setOnImageAvailableListener(<span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">                   imageView.setVisibility(View.VISIBLE);</span><br><span class="line">                   <span class="comment">// 拿到拍照照片数据</span></span><br><span class="line">                   Image image = reader.acquireNextImage();</span><br><span class="line">                   ByteBuffer buffer = image.getPlanes()[<span class="number">0</span>].getBuffer();</span><br><span class="line">                   <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                   buffer.get(bytes);<span class="comment">//由缓冲区存入字节数组</span></span><br><span class="line">                   <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">                   <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       imageView.setImageBitmap(bitmap);</span><br><span class="line">                   &#125;</span><br><span class="line">                   updatePreView();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, mainHandler);</span><br><span class="line">           <span class="comment">//打开摄像头，stateCallback为相机的状态监听回调</span></span><br><span class="line">           cameraManager.openCamera(cameraManager.getCameraIdList()[<span class="number">0</span>], stateCallback, mainHandler);</span><br><span class="line">           mMediaRecorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line">           Log.d(TAG, <span class="string">"open camera"</span>);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的</span></span><br><span class="line">     <span class="keyword">private</span> CameraDevice.StateCallback stateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">             Log.d(TAG, <span class="string">"camera open"</span>);</span><br><span class="line">             mCameraDevice = cameraDevice;</span><br><span class="line">             takePreview();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">             Log.d(TAG, <span class="string">"camera onDisconnected"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">null</span> != mCameraDevice) &#123;</span><br><span class="line">                 mCameraDevice.close();</span><br><span class="line">                 mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice cameraDevice, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">             Log.d(TAG, <span class="string">"camera onError"</span>);</span><br><span class="line">             cameraDevice.close();</span><br><span class="line">             mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">             Toast.makeText(ImageShowActivity.<span class="keyword">this</span>, <span class="string">"摄像头开启失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>开启相机预览</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 开始预览,此处创建一个捕获视频信息的请求，以此来获取一个会话session，在获取会话时监听其配置状态，一旦成功，则此时通过会话构建一个重复预览的请求；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          closePreviewSession();</span><br><span class="line">          SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">          surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">          Log.e(TAG, <span class="string">"preview SurfaceTexture buffer size is width:"</span> + mPreviewSize.getWidth() + <span class="string">" height :"</span> + mPreviewSize.getHeight());</span><br><span class="line">          Surface previewSurface = <span class="keyword">new</span> Surface(surfaceTexture);</span><br><span class="line">          List&lt;Surface&gt; surfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          surfaces.add(previewSurface);</span><br><span class="line">          surfaces.add(imageReader.getSurface());</span><br><span class="line">          <span class="comment">// 创建CameraCaptureSession，该对象负责管理处理预览请求和拍照请求</span></span><br><span class="line">          mCameraDevice.createCaptureSession(surfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() <span class="comment">//</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                  Log.d(<span class="string">"onConfigured"</span>, <span class="string">"onConfigured"</span>);</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice) <span class="keyword">return</span>;</span><br><span class="line">                  <span class="comment">// 当摄像头已经准备好时，开始显示预览</span></span><br><span class="line">                  mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                  updatePreView();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                  Log.d(<span class="string">"onConfigureFailed"</span>, <span class="string">"onConfigureFailed"</span>);</span><br><span class="line"></span><br><span class="line">                  Toast.makeText(ImageShowActivity.<span class="keyword">this</span>, <span class="string">"配置失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, childHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新预览视图，构建一个TEMPLATE_PREVIEW捕获请求，此时是对会话进行设置！！！setRepeatingRequest！！！</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePreView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 创建预览需要的CaptureRequest.Builder</span></span><br><span class="line">           CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">           <span class="comment">// 将SurfaceView的surface作为CaptureRequest.Builder的目标</span></span><br><span class="line">           SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">           Log.e(TAG, <span class="string">"update preview SurfaceTexture buffer size is width:"</span> + mPreviewSize.getWidth() + <span class="string">" height :"</span> + mPreviewSize.getHeight());</span><br><span class="line">           surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">           Surface previewSurface = <span class="keyword">new</span> Surface(surfaceTexture);</span><br><span class="line"></span><br><span class="line">           mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">           mPreviewBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">           mCameraCaptureSession.setRepeatingRequest(mPreviewBuilder.build(), <span class="keyword">null</span>, childHandler);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拍照</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拍照，构建一个TEMPLATE_STILL_CAPTURE静态的相机信息捕获请求，需要注意的是需要获取ImageReader的surface并将其作为捕获去请求的目标输出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mCameraDevice == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 创建拍照需要的CaptureRequest.Builder</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">          <span class="comment">// 将surfaceHolder的surface作为CaptureRequest.Builder的目标</span></span><br><span class="line">          captureRequestBuilder.addTarget(imageReader.getSurface());</span><br><span class="line">          <span class="comment">// 自动对焦</span></span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">          <span class="comment">// 自动曝光</span></span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);</span><br><span class="line">          <span class="comment">// 获取手机方向，手机竖屏和平板的方向是不同的，需要调整。</span></span><br><span class="line">          <span class="keyword">int</span> rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">          <span class="comment">// 根据设备方向计算设置照片的方向</span></span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line">          <span class="comment">//拍照</span></span><br><span class="line">          CaptureRequest mCaptureRequest = captureRequestBuilder.build();</span><br><span class="line">          mCameraCaptureSession.capture(mCaptureRequest, <span class="keyword">null</span>, childHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieves the JPEG orientation from the specified screen rotation.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> rotation The screen rotation.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The JPEG orientation (one of 0, 90, 270, and 360)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getOrientation</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)</span></span><br><span class="line">       <span class="comment">// We have to take that into account and rotate JPEG properly.</span></span><br><span class="line">       <span class="comment">// For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.</span></span><br><span class="line">       <span class="comment">// For devices with orientation of 270, we need to rotate the JPEG 180 degrees.</span></span><br><span class="line">       <span class="keyword">return</span> (ORIENTATIONS.get(rotation) + mSensorOrientation + <span class="number">270</span>) % <span class="number">360</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>录制视频</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 视屏录制，比较上层api是直接通过Recorder类来实现录制，通过这个不需要自己对视屏数据进行处理，只需要指定具体编码格式即可，同时注意这里是重启一个会话。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecordingVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关闭预览会话</span></span><br><span class="line">        closePreviewSession();</span><br><span class="line">        <span class="comment">//对Recoder类进行设置</span></span><br><span class="line">        setUpMediaRecorder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建录制的session会话中的请求</span></span><br><span class="line">            CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">            <span class="comment">//向CaptureRequest添加surface</span></span><br><span class="line">            SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">            Log.e(TAG, <span class="string">"video SurfaceTexture  buffer size is width:"</span> + mVideoSize.getWidth() + <span class="string">" height :"</span> + mVideoSize.getHeight());</span><br><span class="line">            surfaceTexture.setDefaultBufferSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">            Surface previewSurface = <span class="keyword">new</span> Surface(surfaceTexture);</span><br><span class="line">            mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">            <span class="comment">//向CaptureRequest添加surface</span></span><br><span class="line">            mPreviewBuilder.addTarget(mMediaRecorder.getSurface());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            mCameraDevice.createCaptureSession(Arrays.asList(previewSurface, mMediaRecorder.getSurface()), <span class="keyword">new</span></span><br><span class="line">                    CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                            mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                            updatePreView();</span><br><span class="line">                            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    mMediaRecorder.start();</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                            Log.d(<span class="string">"onConfigureFailed"</span>, <span class="string">"onConfigureFailed"</span>);</span><br><span class="line"></span><br><span class="line">                            Toast.makeText(ImageShowActivity.<span class="keyword">this</span>, <span class="string">"RecordingVideo 配置失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, childHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Recorder类进行设置，主要包括音频、视频源、视频输出格式、输出路径、编码频率、视频帧频率、视频宽高、视频编码格式、音频编码格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpMediaRecorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">        mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">        <span class="comment">//!!!这里需要设置路径，要不获取surface时会为空。context.getExternalFilesDir(null);</span></span><br><span class="line">        mMediaRecorder.setOutputFile(Environment</span><br><span class="line">                .getExternalStorageDirectory() + <span class="string">"/"</span> + System.currentTimeMillis() + <span class="string">".mp4"</span>);</span><br><span class="line">        mMediaRecorder.setVideoEncodingBitRate(<span class="number">10000000</span>);</span><br><span class="line">        mMediaRecorder.setVideoFrameRate(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 设置视频录制的分辨率。必须放在设置编码和格式的后面，否则报错!!!!!!需要小心设置，同时需要根据Recorder类来遴选出当前设备支持的分辨率，如果不恰当，则录制视频的时候会显示配置失败</span></span><br><span class="line">        Log.e(TAG, <span class="string">"video size is width:"</span> + mVideoSize.getWidth() + <span class="string">" height :"</span> + mVideoSize.getHeight());</span><br><span class="line">        mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line"></span><br><span class="line">        mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">        mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">        <span class="keyword">int</span> rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        <span class="comment">//调整视频的方向</span></span><br><span class="line">        <span class="keyword">switch</span> (mSensorOrientation) &#123;</span><br><span class="line">            <span class="keyword">case</span> SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMediaRecorder.prepare();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>手机支持的一些分辨率：<br>width:4608 height:3456<br>width:4608 height:2304<br>width:3456 height:3456<br>width:3840 height:2160<br>width:3280 height:2448<br>width:3264 height:2448<br>width:3264 height:1840<br>width:3264 height:1632<br>width:2448 height:2448<br>width:2592 height:1952<br>width:2048 height:1536<br>width:1920 height:1080<br>width:1440 height:1080<br>width:1536 height:864<br>width:1456 height:1456<br>width:1920 height:960<br>width:1440 height:720<br>width:1280 height:960<br>width:1280 height:720<br>width:960 height:720</p>
<p>参考地址：<br>[1].官网示例 <a href="https://github.com/googlesamples/android-Camera2Basic" target="_blank" rel="noopener">https://github.com/googlesamples/android-Camera2Basic</a><br>[2]. <a href="https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/17/http之head解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/17/http之head解析/" itemprop="url">http之head解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T11:31:15+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th style="text-align:left">Header</th>
<th style="text-align:left">Header 解释</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">表明服务器是否支持指定范围请求及那种类型的分段请求</td>
<td style="text-align:left">Accept-Ranges: bytes</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td style="text-align:left">Age：12</td>
</tr>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">对某网络资源的有效请求行为，不允许则返回405</td>
<td style="text-align:left">Allow：GET，HEAD</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">告诉所有的缓存机制是否可以缓存及那种类型</td>
<td style="text-align:left">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">web服务器支持的返回内容压缩编码类型</td>
<td style="text-align:left">Content-Encoding:gzip</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">响应体的语言</td>
<td style="text-align:left">Content-Language: en,zh</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">响应体的长度</td>
<td style="text-align:left">Content-Length:348</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">请求资源可替代的备用的另一个地址</td>
<td style="text-align:left">Content-Location: /index.htm</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">返回资源的MD5校验值</td>
<td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">在整个返回体中本部分的字节位置</td>
<td style="text-align:left">Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td style="text-align:left">Content-type</td>
<td style="text-align:left">返回内容的MIME类型</td>
<td style="text-align:left">Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">原始服务器消息发出的时间</td>
<td style="text-align:left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">请求变量的实体标签的当前值</td>
<td style="text-align:left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">响应过期的日期和时间</td>
<td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">请求资源的最后修改时间</td>
<td style="text-align:left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">用来重定向接收方到非请求URL的位置来完成请求和标识新的资源</td>
<td style="text-align:left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td style="text-align:left">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">它指出认证方案和可应用到代理的该URL上的参数</td>
<td style="text-align:left">Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td style="text-align:left">refresh</td>
<td style="text-align:left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td style="text-align:left">Refresh: 5; url=</td>
</tr>
</tbody>
</table>
<p><a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a> |<br>| Retry-After | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试  | Retry-After: 120 |<br>| Server | web服务器软件名称 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) |<br>| Set-Cookie | 设置Http Cookie | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 |<br>| Trailer | 指出头域在分块传输编码的尾部存在 | Trailer: Max-Forwards |<br>| Transfet-Encoding | 文件传输编码 | Transfer-Encoding:chunked |<br>| Vary | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: * |<br>| Via | 告诉代理客户端响应是通过哪里发送的 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) |<br>| Warning | 警告实体可能存在的问题 | Warning: 199 Miscellaneous warning |<br>| WWW-Authenticate | 表明客户端请求实体应该使用的授权方案  | WWW-Authenticate: Basic |</p>
<h3 id="HTTP-Request的Header信息"><a href="#HTTP-Request的Header信息" class="headerlink" title="HTTP Request的Header信息"></a>HTTP Request的Header信息</h3><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文。请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：<br>POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1<br>一个简单的请求头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1</span><br><span class="line">Host	adash.m.taobao.com</span><br><span class="line">Content-Type	multipart/form-data; boundary=--iphone_BOUNDARY--</span><br><span class="line">Connection	keep-alive</span><br><span class="line">Accept	*/*</span><br><span class="line">User-Agent	%E9%92%89%E9%92%89/400 CFNetwork/901.1 Darwin/17.6.0 (x86_64)</span><br><span class="line">Accept-Language	zh-cn</span><br><span class="line">Accept-Encoding	gzip</span><br><span class="line">Content-Length	702</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HTTP请求方式</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">向Web服务器请求一个文件</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">向Web服务器发送数据让Web服务器进行处理</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">向Web服务器发送数据并存储在Web服务器内部</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">检查一个对象是否存在</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">从Web服务器上删除一个文件</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">对通道提供支持</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">跟踪到服务器的路径</td>
</tr>
<tr>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">查询Web服务器的性能</td>
</tr>
</tbody>
</table>
<p>说明：<br>主要使用到“GET”和“POST”。</p>
<p>实例：<br>POST /test/tupian/cm HTTP/1.1<br>分成三部分：</p>
<ul>
<li><p>POST：HTTP请求方式</p>
</li>
<li><p>/test/tupian/cm：请求Web服务器的目录地址（或者指令）</p>
</li>
<li><p>HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本</p>
</li>
</ul>
<p><strong>备注：</strong>  在Ajax中，对应method属性设置。</p>
<ol>
<li>Host</li>
</ol>
<p>说明：<br>请求的web服务器域名地址</p>
<p>实例：<br>例如web请求URL：<a href="http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm" target="_blank" rel="noopener">http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm</a> ，Host就为zjm-forum-test10.zjm.baidu.com:8088</p>
<ol>
<li>User-Agent</li>
</ol>
<p>说明：<br>HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。</p>
<p>实例：<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11</p>
<ol>
<li>Accept</li>
</ol>
<p>说明：<br>指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。</p>
<p>实例：<br>Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,<em>/</em>;q=0.5</p>
<p>备注：<br>在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/javascript, text/html, application/xml, text/xml, <em>/</em>”。这是因为Ajax默认获取服务器返回的Json数据模式。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。</p>
<ol>
<li>Accept-Language</li>
</ol>
<p>说明：<br>指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。</p>
<p>实例：<br>Accept-Language: zh-cn,zh;q=0.5   ,这里默认为中文。</p>
<ol>
<li>Accept-Encoding</li>
</ol>
<p>说明：<br>指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。</p>
<p>实例：<br>Accept-Encoding: gzip,deflate</p>
<p><strong>备注：</strong>  其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。</p>
<p>另外有关deflate压缩介绍：<a href="http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html" target="_blank" rel="noopener">http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html</a></p>
<ol>
<li>Accept-Charset</li>
</ol>
<p>说明：<br>浏览器可以接受的字符编码集。</p>
<p>实例：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7</p>
<ol>
<li>Content-Type</li>
</ol>
<p>说明：  显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。</p>
<p>实例：  Content-type: application/x-www-form-urlencoded;charset:UTF-8</p>
<p>有关Content-Type属性值可以如下两种编码类型：  </p>
<ul>
<li>“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。</li>
<li>“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。  </li>
</ul>
<p>当提交为表单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。</p>
<p>在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。 一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。</p>
<ol>
<li>Connection</li>
</ol>
<p>说明： 表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。</p>
<p>实例： Connection: keep-alive</p>
<ol>
<li>Keep-Alive</li>
</ol>
<p>说明：显示此HTTP连接的Keep-Alive时间。使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<p>以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。</p>
<p>实例： Keep-Alive: 300</p>
<ol>
<li>cookie</li>
</ol>
<p>说明：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p>
<ol>
<li>Referer</li>
</ol>
<p>说明：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</p>
<h3 id="服务器端返回HTTP头部信息"><a href="#服务器端返回HTTP头部信息" class="headerlink" title="服务器端返回HTTP头部信息"></a>服务器端返回HTTP头部信息</h3><p>简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type	text/plain</span><br><span class="line">Content-Length	8</span><br><span class="line">Last-Modified	Mon, 15 May 2017 18:04:40 GMT</span><br><span class="line">ETag	&quot;ae780585f49b94ce1444eb7d28906123&quot;</span><br><span class="line">Accept-Ranges	bytes</span><br><span class="line">Server	AmazonS3</span><br><span class="line">X-Amz-Cf-Id	jodC9tJqDu4my9HVAend7hMtgKNcrlV4SUHJOKveUP-hHSIJ6ewkig==</span><br><span class="line">Cache-Control	no-cache, no-store, must-revalidate</span><br><span class="line">Date	Tue, 17 Jul 2018 02:28:52 GMT</span><br><span class="line">Proxy-Connection	Keep-alive</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Content-Length</li>
</ol>
<p>说明：表示web服务器返回消息正文的长度</p>
<ol>
<li>Content-Type:</li>
</ol>
<p>说明：返回数据的类型（例如text/html文本类型）和字符编码格式。</p>
<p>实例： Content-Type: text/html;charset=utf-8</p>
<ol>
<li>Date<br>说明：显示当前的时间</li>
</ol>
<p>本文根据RFC2616(HTTP/1.1规范),参考</p>
<p><a href="http://www.w3.org/Protocols/rfc2068/rfc2068" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2068/rfc2068</a></p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616</a></p>
<p><a href="http://www.ietf.org/rfc/rfc3229.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3229.txt</a></p>
<p><a href="https://blog.csdn.net/u012359618/article/details/50240617" target="_blank" rel="noopener">https://blog.csdn.net/u012359618/article/details/50240617</a>  </p>
<p><a href="https://www.cnblogs.com/wenqiang/p/5698772.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenqiang/p/5698772.html</a></p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可 选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域 值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/17/okhttp使用记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/17/okhttp使用记录/" itemprop="url">okhttp使用记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T09:27:19+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Applicaion Interceptor和NetworkInterceptor区别<br>Application interceptors：</li>
</ol>
<ul>
<li>Don’t need to worry about intermediate responses like redirects and retries.（不必担心重定向和重试等中间响应，因为它处于第一个拦截器，会获取到最终的响应 response 。）</li>
<li>Are always invoked once, even if the HTTP response is served from the cache.（即使从缓存提供HTTP响应，也始终调用一次）</li>
<li>Observe the application’s original intent. Unconcerned with OkHttp-injected headers like If-None-Match.（观察应用程序的原始意图。 不去关注OkHttp注入的头信息，如If-None-Match。）</li>
<li>Permitted to short-circuit and not call Chain.proceed().（允许短路而不调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有权决定了是否要调用其他拦截，也就是 Chain.proceed() 方法是否要被执行。）</li>
<li>Permitted to retry and make multiple calls to Chain.proceed().（允许重试并多次调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有可以多次调用 Chain.proceed() 方法，其实也就是相当与重新请求的作用了。）</li>
</ul>
<p>Network Interceptors  </p>
<ul>
<li>Able to operate on intermediate responses like redirects and retries.（能够对重定向和重试等中间响应进行操作，因为 NetworkInterceptor 是排在第 6 个拦截器中，因此可以操作经过 RetryAndFollowup 进行失败重试或者重定向之后得到的resposne）</li>
<li>Not invoked for cached responses that short-circuit the network.（未调用使网络短路的缓存响应，对于从缓存获取的 response 则不会去触发 NetworkInterceptor 。因为响应直接从 CacheInterceptor 返回了）</li>
<li>Observe the data just as it will be transmitted over the network.（观察数据，就像它将通过网络传输一样）</li>
<li>Access to the Connection that carries the request.（访问带有请求的Connection）</li>
</ul>
<p>参考地址：<br>[1]. 官网 <a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki/Interceptors</a><br>[2]. 简书 <a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d04b463806c8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/13/Android开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/13/Android开发记录/" itemprop="url">Android开发记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-13T13:45:40+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="Android-studio中如何修改运行环境中最低版本和目标版本"><a href="#Android-studio中如何修改运行环境中最低版本和目标版本" class="headerlink" title="Android studio中如何修改运行环境中最低版本和目标版本"></a>Android studio中如何修改运行环境中最低版本和目标版本</h4><p>最近发现使用Android Studio创建的项目中，最低版本和目标版本已经不在AndroidManifest.xml中显示了。那我们应该去那里需改呢？</p>
<p>原来放到了File -&gt; Project Structure中了。直接上图吧，一目了然。<br><a href="&quot;images/AndroidDownBuildVersion.jpg&quot;">修改最低版本和目标版本</a></p>
<p>参考地址：   </p>
<ul>
<li><a href="https://blog.csdn.net/kingroc/article/details/50947143" target="_blank" rel="noopener">https://blog.csdn.net/kingroc/article/details/50947143</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/Flutter编写第一个应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/Flutter编写第一个应用/" itemprop="url">编写第一个Flutter应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T19:07:44+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="&quot;images/startup-namer-app.gif&quot;">Animated GIF of the app that you will be building.</a><br>这篇教程将指导你创建第一个 Flutter 应用程序。如果你熟悉面向对象程序设计和基本的编程概念（如变量，循环和条件），即可完成本教程。无需具有使用 Dart 语言或移动编程的相关经验。</p>
<ul>
<li>第1步：创建初始Flutter应用</li>
<li>第2步：使用外部 package</li>
<li>第3步：添加有状态的widget</li>
<li>第4步：创建一个无限滚动的 ListView</li>
<li>第5步：添加可交互性</li>
<li>第6步：导航到新页面</li>
<li>第7步：使用主题更改UI</li>
<li>干得漂亮！<h3 id="你需要做什么"><a href="#你需要做什么" class="headerlink" title="你需要做什么"></a>你需要做什么</h3></li>
</ul>
<p>完成一个简单的移动应用程序，为一家创业公司进行命名推荐。用户可以选择和取消选择名称，并保存最好的一个。代码一次生成十个名称。当用户滚动时，会新生成一批名称。用户可以点击应用栏右上方的列表图标，跳转到仅显示已被收藏的名称的列表页面。</p>
<p>这个GIF动画可以显示出该应用是如何工作的。</p>
<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会学到</strong>:<br>- Flutter 应用程序的基本结构 。<br>- 查找和使用 package 来扩展功能。<br>- 使用热加载加快开发效率。<br>- 如何实现一个有状态的 widget 。<br>- 如何创建一个无限长度的延迟加载列表。<br>- 如何创建并导航到第二个页面。<br>- 如何使用主题更改应用程序的外观。<br></td></tr></table>

<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会用到</strong>:<br><br>需要安装以下工具:<br><br>- Flutter SDK<br>Flutter SDK 包括 Flutter 的引擎，框架，控件，工具和 Dart SDK 。这个 codelab 需要 v0.1.4 或更高版本。<br><br>-  Android Studio IDE<br>这个 codelab 基于 Android Studio IDE 构建，但也可以使用其他 IDE ，或者从命令行运行。<br><br>- 安装 IDE 插件<br>插件必须为您的编译器单独安装 Flutter 和 Dart 插件。除了Android Studio，Flutter和Dart插件也可用于 <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">VS Code</a> 和 <a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">IntelliJ IDE</a>。<br><br>有关如何设置环境的信息，<a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">请参阅 Flutter安装和配置</a>。<br></td></tr></table>

<h3 id="第1步：创建初始Flutter应用"><a href="#第1步：创建初始Flutter应用" class="headerlink" title="第1步：创建初始Flutter应用"></a>第1步：创建初始Flutter应用</h3><p>使用<a href="http://doc.flutter-dev.cn/get-started/test-drive/#create-app" target="_blank" rel="noopener">第一个入门 Flutter 应用</a>中的说明创建一个简单的模板化 Flutter 应用。将项目命名为 <strong>startup_namer</strong>（而不是myapp）。你将修改这个应用并最终完成它。</p>
<p>在这个 codelab 中，将主要编辑 Dart 代码所在的 lib / main.dart。</p>
<table><tr><td bgcolor="#f0f0f0"><br> 小贴士： 将代码粘贴到应用程序中时，缩进可能会错位。你可以使用 Flutter 工具自动修复此问题：<br><br>1. Android Studio / IntelliJ IDEA: 右键单击 dart 代码，然后选择 <strong>Reformat Code with dartfmt</strong>。<br>2. VS Code: 单击右键，选择 <strong>Format Document</strong>.<br>3. 命令行: 运行 flutter format <filename>.<br></filename></td></tr></table>

<ol>
<li><p>替换 lib / main.dart 。<br>删除 lib / main.dart 中的所有代码。替换为下面的代码，它在屏幕中心显示 “Hello World” 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Text(&apos;Hello World&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行应用程序。现在应该可以看到下面的页面。<br><a href="hello-world-screenshot.png">screenshot of hello world app</a></p>
<p>小结</p>
<ul>
<li><p>本示例创建了一个 Material app 。 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material</a> 设计语言是一套移动设备和网页上的视觉设计标准。Flutter 提供了一套丰富的 Material Widgets 。</p>
</li>
<li><p>main 方法采用了 fat arrow (=&gt;) 表示法，这是一种用于单行函数或方法的简写。</p>
</li>
<li><p>该 app 继承了使它本身成为一个 widget 的 StatelessWidget 类。在 Flutter 中，大多数时候一切都可以看作 widget , 包括 alignment，padding 和 layout 。</p>
</li>
<li><p>Material 库中的 Scaffold widget 提供了默认的应用栏 (app bar)，标题和构成主页面 widget 树结构的 body 属性。 widget 的子树可以非常复杂。</p>
</li>
<li><p>widget 的主要工作是提供一个build()方法，描述如何根据其他更低层级的 widget，来对这个 widget 进行展示。</p>
</li>
<li><p>本示例的 widget 树由包含了 Text child widget 的 Center widget 组成。Center widget 可将它的所有子树对齐到屏幕中心。</p>
</li>
</ul>
<h3 id="第2步：使用外部-package"><a href="#第2步：使用外部-package" class="headerlink" title="第2步：使用外部 package"></a>第2步：使用外部 package</h3><p>在这一步，将开始使用名为 <strong>english_words</strong> 的开源软件包 ，其中包含数千个最常用的英文单词以及一些实用功能。</p>
<p>可以在 <a href="https://pub.dartlang.org/flutter/" target="_blank" rel="noopener">pub.dartlang.org</a> 上找到 <a href="https://pub.dartlang.org/packages/english_words" target="_blank" rel="noopener">english_words</a> 软件包以及其他许多开源软件包。</p>
<ol>
<li><p>pubspec 文件管理着 Flutter 应用程序的静态资源文件(assets)。 在 <strong>pubspec.yaml</strong> 文件中， 将 <strong>english_words</strong>（3.1.0或更高版本）添加到依赖列表。新的一行高亮如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  cupertino_icons: ^0.1.0</span><br><span class="line">  english_words: ^3.1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Android Studio 的 editor 视图中查看 pubspec 时, 点击右上角的 <strong>Packages get</strong> ，将把 package 拉取到项目中。现在应该可以在控制台中看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br><span class="line">Running &quot;flutter packages get&quot; in startup_namer...</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <strong>lib/main.dart</strong> 中，为 english_words 添加导入，如高亮的行所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br></pre></td></tr></table></figure>
<p>在键入该行时， Android Studio 会提供有关库导入的建议。然后将导入字符串显示为灰色，让你知道导入的库尚未使用（到目前为止）。</p>
</li>
<li><p>改用英文单词的 package 来生成文本，而不是字符串 “Hello World” 。</p>
<table><tr><td bgcolor="#f0f0f0"><br>小贴士： “Pascal case”（也被称为“大骆驼拼写法”），意味着字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，“uppercamelcase” 变成 “UpperCamelCase” 。<br></td></tr></table>

</li>
</ol>
<p>对代码进行以下更改，如!!!所示：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final wordPair = new WordPair.random();   //!!!!</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          //child: new Text(&apos;Hello World&apos;), // Replace the highlighted text...</span><br><span class="line">          child: new Text(wordPair.asPascalCase),  // With this highlighted text. !!!</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果应用正在运行，请使用 Flutter Hot Reload (热重载)按钮 (lightning bolt icon)更新应用程序。每次单击按钮或保存项目时，都会看到随机的词组文本，这是因为配对的词组是在 build 方法内部生成的，每次应用需要渲染时，或在 Flutter Inspector 中切换 Platform 时都会运行  </li>
</ol>
<p><a href="&quot;images/step2-screenshot.png&quot;">screenshot at completion of second step</a>  </p>
<h4 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h4><p>如果应用程序运行不正常，请检查拼写错误。如有需要，可使用以下链接中的代码使项目恢复正常</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/pubspec.yaml" target="_blank" rel="noopener">pubspec.yaml</a> (pubspec.yaml文件不会再更改。)</li>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/main.dart" target="_blank" rel="noopener">lib/main.dart</a>   </li>
</ul>
<h3 id="第3步：添加有状态的widget"><a href="#第3步：添加有状态的widget" class="headerlink" title="第3步：添加有状态的widget"></a>第3步：添加有状态的widget</h3><p>Stateless widgets 是不可改变的，这意味着它们的属性不能改变——所有的值都是 final 的。</p>
<p>Statefulwidget 在其 <strong>生命周期</strong> 保持的状态可能会变化，<strong>实现一个有状态的 widget 至少需要两个类</strong>：StatefulWidgets类和State类，其中StatefulWidgets类创建了一个State类的实例。StatefulWidget类本身是不可变的，但State类可存在于Widget的整个生命周期中。</p>
<p>在这一步，将添加一个有状态的 RandomWords widget ，它可以创建其 State 类 RandomWordsState 。 State 类会为 widget 保存被推荐和被收藏的词组。  </p>
<ol>
<li><p>将有状态的 RandomWords widget 添加到 main.dart 。它可以在 MyApp 类之外的任何位置使用，但当前将把它放在文件底部。 RandomWords widget 除了创建 State 类之外几乎没有任何其他代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class RandomWords extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  createState() =&gt; new RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 RandomWordsState 类。这个类保存了 RandomWords widget 的状态，该应用程序的大部分代码都放在该类中。这个类将保存随着用户的滑动操作而生成的无限增长的词组，以及保存用户收藏的词组，用户通过触发心形图标来添加或删除收藏的词组列表。  </p>
</li>
</ol>
<p>你可以一点点建立这个类。首先，通过以下!!!代码，创建一个最简的类：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  class RandomWordsState extends State&lt;RandomWords&gt; &#123; //!!!</span><br><span class="line">  &#125;</span><br><span class="line">  ```   </span><br><span class="line"></span><br><span class="line">3. 添加这个 state 类之后，IDE 会提示该类缺少 build 方法。接下来，需要添加一个基本的 build 方法，并将生成单词的代码行从 MyApp 类移动到 RandomWordsState 类的 build 方法中，生成词组。  </span><br><span class="line">将 build 方法添加到 RandomWordState 中，如!!!代码所示：</span><br></pre></td></tr></table></figure>
<p>  class RandomWordsState extends State<randomwords> {<br>    @override     //-!!!<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();<br>      return new Text(wordPair.asPascalCase);<br>    }  //-!!!<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 根据!!!部分的更改，从 MyApp 中删除生成单词的代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();  // !!! Delete this line</p>
<pre><code>  return new MaterialApp(
    title: &apos;Welcome to Flutter&apos;,
    home: new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Welcome to Flutter&apos;),
     ),
      body: new Center(
        //child: new Text(wordPair.asPascalCase), // !!!Change the highlighted text to...
        child: new RandomWords(), // !!!... this highlighted text
      ),
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启应用。如果尝试热重载，则可能会看到警告:</span><br></pre></td></tr></table></figure></p>
<p>  Reloading…<br>  Not all changed program elements ran during view reassembly; consider<br>  restarting.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这可能是一个误报，但可以考虑重启应用，以确保更改能正常反映在应用的 UI 界面中。</span><br><span class="line"></span><br><span class="line">应用程序应该像之前一样运行，每次热重载或保存应用程序时都会显示一个词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of third step](step3-screenshot.png)   </span><br><span class="line">#### 有问题吗? ####</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](lib/main.dart)</span><br><span class="line"></span><br><span class="line">### 第4步：创建一个无限滚动的 ListView ###</span><br><span class="line">在这一步，可以扩展 RandomWordsState 类，生成并展示词组列表。当用户滑动列表，ListView widget 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许按需建立一个延迟加载的列表 view 。</span><br><span class="line"></span><br><span class="line">1. \_suggestions 变量向 RandomWordsState 类中添加一个数组列表，用来保存推荐词组。 该变量以下划线(\_)开头，在 Dart 语言中使用下划线前缀表示强制私有。   </span><br><span class="line">此外，添加一个 biggerFont 变量来增大字体。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_buildSuggestions() 函数，用于构建一个显示词组的 ListView 。   </span><br><span class="line">ListView 类提供了一个 itemBuilder 属性，这是一个工厂 builder 并作为匿名函数进行回调。它有两个传入参数— BuildContext 上下文和行迭代器 i 。对于每个推荐词组都会执行一次函数调用，迭代器从 0 开始，每调用一次函数就累加 1 。这个模块允许推荐列表在用户滑动时无限增长。  </span><br><span class="line">添加如下代码行：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …<br>    Widget _buildSuggestions() {<br>      return new ListView.builder(<br>        padding: const EdgeInsets.all(16.0),<br>        // The itemBuilder callback is called once per suggested word pairing,<br>        // and places each suggestion into a ListTile row.<br>        // For even rows, the function adds a ListTile row for the word pairing.<br>        // For odd rows, the function adds a Divider widget to visually<br>        // separate the entries. Note that the divider may be difficult<br>        // to see on smaller devices.<br>        itemBuilder: (context, i) {<br>          // Add a one-pixel-high divider widget before each row in theListView.<br>          if (i.isOdd) return new Divider();</randomwords></p>
<pre><code>      // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.
      // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
      // This calculates the actual number of word pairings in the ListView,
      // minus the divider widgets.
      final index = i ~/ 2;
      // If you&apos;ve reached the end of the available word pairings...
      if (index &gt;= _suggestions.length) {
        // ...then generate 10 more and add them to the suggestions list.
        _suggestions.addAll(generateWordPairs().take(10));
      }
      return _buildRow(_suggestions[index]);
    }
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.  函数都调用一次 \_buildRow 函数。这个函数每次会在一个 ListTile widget 中展示一条新词组，这将在下一步操作中，使一行数据更有表现力。    </span><br><span class="line">  添加 \_buildRow 函数到 RandomWordsState 类中：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …</randomwords></p>
<pre><code>Widget _buildRow(WordPair pair) {
  return new ListTile(
    title: new Text(
      pair.asPascalCase,
      style: _biggerFont,
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 更新 RandomWordsState 类的 build 方法来使用 \_buildSuggestions() 函数，而不是直接调用单词生成库。对部分进行修改：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    final wordPair = new WordPair.random(); // Delete these two lines.<br>    Return new Text(wordPair.asPascalCase);<br>    return new Scaffold (<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>      ),<br>    body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 更新 MyApp 类的 build 方法。从 MyApp 中删除 Scaffold 和 AppBar 实例。这些将由 RandomWordsState 类进行统一管理，这样在下一步操作中，可以使用户从一个页面导航到另一页面时，更方便的更改应用栏中的页面名称。</span><br><span class="line"></span><br><span class="line">  用下面高亮的 build 方法替换原始代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      return new MaterialApp(<br>        title: ‘Startup Name Generator’,<br>        home: new RandomWords(),<br>      );<br>    }<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重启应用程序，将可以看到一个词组清单。尽量向下滑动，将继续看到新的词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of fourth step](step4-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/d6f9460a04d3a429eb6ac0b0f07da564/raw/34fe240f4122435c871bb737708ee0357741801c/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第5步：添加可交互性 ###</span><br><span class="line">在这一步，将为每一行添加可点击的心形图标。当用户点击列表中的条目，切换其“收藏”状态，词组就会添加到收藏栏，或从已保存词组的收藏栏中删除。</span><br><span class="line"></span><br><span class="line">1. 添加一个 Set 集合 \_saved 到 RandomWordsState 类。保存用户收藏的词组。Set 集合比 List 更适用于此，因为它不允许重复元素。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _saved = new Set<wordpair>();</wordpair></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 在 \_buildRow 函数中，添加 alreadySaved 标志检查来确保一个词组还没有被添加到收藏。</span><br></pre></td></tr></table></figure></p>
<p>Widget _buildRow(WordPair pair) {<br>  final alreadySaved = _saved.contains(pair);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3. 在 \_buildRow() 的 ListTiles widget 中，添加一个心形图标来使用收藏功能，随后将添加与心形图标进行交互的功能。  </span><br><span class="line"></span><br><span class="line">  添加以下高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4. 重启应用。现在应该可以在每一行看到心形图标，但还没有交互功能。</span><br><span class="line"></span><br><span class="line">5. 在 \_buildRow 函数中使心形可点击。如果词条已经被加入收藏，再次点击它将从收藏中删除。当心形图标被点击，函数将调用 setState() 通知应用框架state已经改变。</span><br><span class="line"></span><br><span class="line">  添加高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>      onTap: () {<br>        setState(() {<br>          if (alreadySaved) {<br>            _saved.remove(pair);<br>          } else {<br>            _saved.add(pair);<br>          }<br>        });<br>      },<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f0f0f0&gt;</span><br><span class="line">  小贴士： 在 Flutter 的响应式风格框架中，调用 setState() ，将为 State 对象触发 build() 方法的调用，从而实现对UI的更新。</span><br><span class="line">  &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">热重载应用。可以点击任意一行来收藏或取消收藏条目。 请注意，点击一行可以产生从心形图标展开的泼墨动画效果。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 5th step](step5-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/936ce0059029a8c6e88aaa826a3789cd/raw/a3065d5c681a81eff32f75a9cd5f4d9a5b24f9ff/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第6步：导航到新页面 ###</span><br><span class="line">在这一步，将添加一个显示收藏夹的新页面(在 Flutter 中称为 route(路由))。你将学习如何在主路由和新路由之间导航。</span><br><span class="line"></span><br><span class="line">在 Flutter 中， Navigator 管理着包含了应用程序所有路由的一个堆栈。将一个路由push到 Navigator 的堆栈，将显示更新为新页面路由。将一个路由 pull 出 Navigator 的堆栈，显示将返回到前一个页面路由。</span><br><span class="line"></span><br><span class="line">1. 在 RandomWordsState 类的 build 方法中，向 AppBar 添加一个列表图标。当用户点击列表图标时，包含了已收藏条目的新路由将被 push 到 Navigator 堆栈并显示新页面。</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f1f1f1&gt;</span><br><span class="line"> 小贴士： 某些 widget 属性使用独立 widget(child) 和其他属性例如 action 组成一个子 widget 数组(children)，用方括号([])表示。</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">将该图标及其相应的 action 操作添加到 build 方法中：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    return new Scaffold(<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>        actions: <widget>[<br>          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),<br>        ],<br>      ),<br>      body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_pushSaved() 函数。</span><br></pre></td></tr></table></figure></widget></randomwords></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  void _pushSaved() {<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重新加载应用程序。列表图标将出现在应用栏中。点击它不会有任何响应，因为 \_pushSaved 这个函数还未实现功能。</span><br><span class="line"></span><br><span class="line">3. 当用户点击应用栏中的列表图标时，将建立一个新路由并 push 到 Navigator 的路由堆栈中，这个操作将改变界面显示，展示新的路由页面。   </span><br><span class="line"></span><br><span class="line">  新页面的内容使用匿名函数在 MaterialPageRoute widget的builder属性中创建。</span><br><span class="line"></span><br><span class="line">  将函数调用添加到 Navigator.push 中作为参数,如高亮代码所示，将路由 push 到 Navigator 的堆栈中。</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  void _pushSaved() {<br>    Navigator.of(context).push(<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 添加 MaterialPageRoute widget 及其 builder 属性。先添加生成 ListTile widget 的代码。其中 ListTile 的 divideTiles() 方法为每个 ListTile widget 之间添加水平间距。divided变量保存最终生成的所有行，并用 toList() 函数转换为列表。</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();<br>      },<br>    ),<br>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. builder 属性返回一个 Scaffold widget ，其中包含了应用栏标题名为 “Saved Suggestions” 的新路由页面。新页面的body属性由包含多个 ListTile widget 的 ListView 组成。</span><br><span class="line"></span><br><span class="line">  添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();</p>
<pre><code>    return new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Saved Suggestions&apos;),
      ),
      body: new ListView(children: divided),
    );
  },
),
</code></pre><p>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6. 热重载应用程序。对一些条目点击收藏，然后点击应用栏右侧的列表图标。显示出包含收藏夹列表的新页面。注意，Navigator 会在应用栏左侧添加一个“返回”按钮。不必再显式实现 Navigator.pop 。点击返回按钮会返回到主页面。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 6th stepsecond route](step6a-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.github.com/Sfshaza/bc5547e112e4dc3a1aa87afdf917caeb)</span><br><span class="line"></span><br><span class="line">### 第7步：使用主题更改UI ##</span><br><span class="line">在最后一步中，将使用该应用的主题。 theme 控制的是应用程序的观感。可以使用默认主题，该主题取决于使用的模拟器或真机，也可以自定义主题以反映你的品牌。</span><br><span class="line"></span><br><span class="line">可以通过配置 ThemeData 类轻松更改应用程序的主题。应用程序目前使用默认主题，现在将更改主要颜色为白色。</span><br><span class="line"></span><br><span class="line">1. 将高亮代码添加到 MyApp 类中，可以把应用程序的主题更改为白色：</span><br></pre></td></tr></table></figure></p>
<p>class MyApp extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return new MaterialApp(<br>      title: ‘Startup Name Generator’,<br>      theme: new ThemeData(<br>        primaryColor: Colors.white,<br>      ),<br>      home: new RandomWords(),<br>    );<br>  }<br>}<br>```</p>
<ol>
<li><p>热重载应用程序。请注意，整个背景都是白色的，甚至包括应用栏。</p>
</li>
<li><p>作为读者的练习，可使用 <a href="https://docs.flutter.io/flutter/material/ThemeData-class.html" target="_blank" rel="noopener">ThemeData</a> 来改变用户界面的其他方面。 Material 库中的 <a href="https://docs.flutter.io/flutter/material/Colors-class.html" target="_blank" rel="noopener">Colors</a> 类提供了多种可以使用的颜色常量，而热重载使用户界面的修改变得简单快捷。<br><a href="step7-themes.png">screenshot at completion of 7th step</a><br>有问题吗?</p>
</li>
</ol>
<p>如果又不能正常运行了，请使用以下链接中的代码查看最终应用的代码。</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/c07c91a4061fce4b5eacaaf4d82e4993/raw/4001a72c0133b97c8e16bdeb3195ca03525696bd/main.dart" target="_blank" rel="noopener">lib/main.dart</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter初体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter初体验/" itemprop="url">flutter初体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T16:44:17+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在这篇文档中你将了解如何在 Flutter 开发中进行调试和修改：从我们提供的项目模板创建一个 Flutter 应用程序，运行然后学习如何使用热重载来修改程序。</p>
<p>Flutter 是一个扩展性极强的工具集，因此你可以选择你钟爱的开发工具或者平台来写代码，编译以及运行 Flutter 应用程序。</p>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p>Android Studio: 一个完整的，高度集成的 Flutter 开发编辑器。</p>
<h4 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>依次选择 <strong>File&gt;New Flutter Project</strong></li>
<li>选择 <strong>Flutter application</strong> 作为项目类型，然后点击下一步</li>
<li>输入项目名称（例如：myapp），然后点击下一步</li>
<li>点击 Finish</li>
<li>等待 Android Studio 安装好 SDK 和创建好这个项目。<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <strong><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a></strong> 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序"><a href="#运行这个程序" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>找到 Android Studio 的主工具栏：<br><a href="&quot;images/main-toolbar.png&quot;">IntelliJ 的主工具栏</a></li>
<li>在 <strong>target selector</strong> 中，选择一个已连接的 Android 设备来运行这个程序。如果列表中没有可用的设备， 那么依次选择 <strong>Tools&gt;Android&gt;AVD Manager</strong> 创建一个可用的模拟器。了解更多，请查看 管理 AVDs。</li>
<li>点击工具栏中的 <strong>Run icon</strong>，或者在菜单栏中一次选择 <strong>Run &gt; Run</strong>。</li>
<li>如果一切正常，那么你现在就可以在你的手机或者模拟器上看到程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载"><a href="#尝试一下热重载" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p><strong>VS Code</strong>: 包含了运行和调试 Flutter 应用程序的轻量级编辑器。</p>
<h4 id="创建应用程序-1"><a href="#创建应用程序-1" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>启动 VS Code</li>
<li>依次执行 View&gt;Command Palette…</li>
<li>输入 ‘flutter’，选择 ‘Flutter: New Project’ 命令</li>
<li>输入项目名称（例如：myapp），回车</li>
<li>找到一个用于保存项目的目录，然后点击蓝色的确认按钮</li>
<li>项目会自动进行创建，创建完毕之后，main.dart 文件会被自动打开<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 Material 组件 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序-1"><a href="#运行这个程序-1" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>确保在 VS Code 的右下角能看到目标设备的名称</li>
<li>使用键盘上的 F5 按钮，或者依次执行 Debug&gt;Start Debugging</li>
<li>等待应用程序启动</li>
<li>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载-1"><a href="#尝试一下热重载-1" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="控制台-文本编辑器"><a href="#控制台-文本编辑器" class="headerlink" title="控制台 + 文本编辑器"></a>控制台 + 文本编辑器</h3><p>控制台 + 文本编辑器 你自己选择的代码编辑器加上 Flutter 提供的命令行工具来运行和构建 Flutter 应用程序。</p>
<p>创建应用程序</p>
<ol>
<li>使用 flutter create 命令来创建一个新的应用程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create myapp</span><br><span class="line">$ cd myapp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a> 的项目。</p>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 lib/main.dart 中。</p>
<h4 id="运行这个程序-2"><a href="#运行这个程序-2" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ul>
<li><p>确保 Android 设备当前处于运行状态。如果没有发现在运行的设备，查看 <a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">安装</a> 页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter devices</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 flutter run 命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></p>
</li>
</ul>
<h4 id="尝试一下热重载-2"><a href="#尝试一下热重载-2" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-开发记录/" itemprop="url">flutter-开发记录（错误或技巧）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T15:04:29+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ol>
<li>flutter doctor 显示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方案一：<br>根据提示运行flutter doctor –android-licenses 一路y就好了。</p>
<ol>
<li>Row中包含TextField时在弹出软键盘时会overflow（TextField inside of Row causes layout exception: Unable to calculate size）</li>
</ol>
<p>解决：在TextField外层在包一个Flexible组件即可；</p>
<p>参考：<a href="https://stackoverflow.com/questions/45986093/textfield-inside-of-row-causes-layout-exception-unable-to-calculate-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/45986093/textfield-inside-of-row-causes-layout-exception-unable-to-calculate-size</a> （译文：（假设您正在使用Row，因为您希望将来在TextField旁边放置其他小部件。）Row小部件想要确定其非灵活子节点的内在大小，以便它知道它为灵活子节点留下了多少空间。 但是，TextField没有固有宽度; 它只知道如何将自身大小调整到其父容器的整个宽度。 尝试将其包装在Flexible或Expanded中，告诉Row您希望TextField占用剩余空间：）</p>
<ol>
<li>Keyboard overflows TextField creating yellow/black stripes<br>文本域获取焦点时，弹出软键盘，导致overflowed错误，<br>修正：通过设置Scaffold的属性resizeToAvoidBottomPadding: false即可，</li>
</ol>
<p>原因：猜测（可能键盘的弹出导致，内容视图的高度+键盘的高度超出了一个屏幕的高度从而产生了overflowed）。</p>
<p>参考网址：<a href="https://github.com/flutter/flutter/issues/13339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13339</a> （译文：当你点击文本字段键盘显示白色内容溢出整个脚手架区域时，是的还有同样的问题。 使用resizeToAvoidBottomPadding它确实有效但我认为禁用此选项键盘不会尊重焦点文本字段，也不会将内容滚动到适当的焦点框<br>）</p>
<ol>
<li>使用cipher时报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The parameter &apos;m&apos; of the method &apos;BigIntegerV8::modPowInt&apos; has type bignum::BigIntegerV8, which does not match the corresponding type in the overridden method (dynamic).</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时我在使用依赖cipher: ^0.7.1时遇到的，后来查看Dart版本，和cipher的发布日志发现，cipher: ^0.7.1只使用与Dart 1，而开发当前用的时Dart 2，因此出现该错误，加密/解密依赖目前开发用的是 <a href="https://pub.dartlang.org/packages/crypto#-readme-tab-" target="_blank" rel="noopener">crypto</a>.</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>!!! 谨记：Flutter 中是基于数据驱动，Java中是基于事件驱动。</p>
<ol>
<li>Dart中字符串转换为字节数组或列表（How do I convert a UTF-8 String into an array of bytes in Dart?）</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:convert&apos;;</span><br><span class="line">List&lt;int&gt; bytes = utf8.encode(&quot;Some data&quot;);   //UTF8 is deprecated sind Dart 2. But it was just renamed to utf8: List&lt;int&gt; bytes = utf8.encode(&quot;Some data&quot;);</span><br><span class="line">print(bytes) //[115, 111, 109, 101, 32, 100, 97, 116, 97]</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://stackoverflow.com/questions/10404147/how-do-i-convert-a-utf-8-string-into-an-array-of-bytes-in-dart" target="_blank" rel="noopener">https://stackoverflow.com/questions/10404147/how-do-i-convert-a-utf-8-string-into-an-array-of-bytes-in-dart</a></p>
<ol>
<li>Dart json操作：<br>在Dart中json的构建和将对象转换为json字符很简单，麻烦在将json转换为一个对象,关于json的操作依赖于dart:convert；</li>
</ol>
<ul>
<li><p>构建一个json字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Smith&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;john@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对象转换为一个字符串</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json = json.encode(user);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>序列化json对象：</p>
<ul>
<li><p>序列化JSON内联  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, dynamic&gt; user = json.decode(json);</span><br><span class="line">print(&apos;Howdy, $&#123;user[&apos;name&apos;]&#125;!&apos;);</span><br><span class="line">print(&apos;We sent the verification link to $&#123;user[&apos;email&apos;]&#125;.&apos;);</span><br></pre></td></tr></table></figure>
<p>通过上面我们知道，json.decode（）只返回一个Map <string，dynamic>，这意味着我们直到运行时才知道值的类型。 使用这种方法，我们失去了大多数静态类型语言功能：类型安全，自动完成以及最重要的编译时异常。 我们的代码可能会立即变得更容易出错。<br>例如，每当我们访问名称或电子邮件字段时，我们都会很快引入拼写错误。 由于我们的整个JSON仅存在于地图结构中，因此我们的编译器不知道这是一个错字。</string，dynamic></p>
</li>
<li><p>在模型类中序列化JSON</p>
<p>我们可以通过引入一个普通的模型类来解决前面提到的问题，我们称之为User。 在User类中，我们有：<br> User.fromJson构造函数，用于从地图结构构造新的User实例<br>一个toJson方法，它将User实例转换为map。<br>这样，调用代码现在可以具有类型安全性，名称和电子邮件字段的自动完成以及编译时异常。 如果我们使用拼写错误或将字段视为int而不是字符串，我们的应用程序甚至不会编译，而不是在运行时崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final String email;</span><br><span class="line"></span><br><span class="line">  User(this.name, this.email);</span><br><span class="line"></span><br><span class="line">  User.fromJson(Map&lt;String, dynamic&gt; json)</span><br><span class="line">      : name = json[&apos;name&apos;],</span><br><span class="line">        email = json[&apos;email&apos;];</span><br><span class="line"></span><br><span class="line">  Map&lt;String, dynamic&gt; toJson() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      &apos;name&apos;: name,</span><br><span class="line">      &apos;email&apos;: email,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，序列化逻辑的责任在模型本身内部移动。 通过这种新方法，我们可以非常轻松地反序列化用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map userMap = json.decode(json);</span><br><span class="line">var user = new User.fromJson(userMap);</span><br><span class="line"></span><br><span class="line">print(&apos;Howdy, $&#123;user.name&#125;!&apos;);</span><br><span class="line">print(&apos;We sent the verification link to $&#123;user.email&#125;.&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>参考地址：  </p>
<ul>
<li><a href="https://flutter.io/json/" target="_blank" rel="noopener">https://flutter.io/json/</a></li>
</ul>
<ol>
<li>Flutter中获取设备信息：</li>
</ol>
<p>依赖于 import ‘dart:io’;和 device_info : ^0.2.0；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DeviceInfoPlugin deviceInfo = new DeviceInfoPlugin();</span><br><span class="line">if(Platform.isIOS)&#123;</span><br><span class="line">  IosDeviceInfo iosInfo = await deviceInfo.iosInfo;</span><br><span class="line">  print(&apos;Running on $&#123;iosInfo.utsname.machine&#125;&apos;);  // e.g. &quot;iPod7,1&quot;</span><br><span class="line">      //ios相关代码</span><br><span class="line">    &#125;else if(Platform.isAndroid)&#123;</span><br><span class="line">      AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;</span><br><span class="line">      print(&apos;Running on $&#123;androidInfo.model&#125;&apos;);  // e.g. &quot;Moto G (4)&quot;</span><br><span class="line">      //android相关代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考地址：  </p>
<ul>
<li>官网参考：<a href="https://github.com/flutter/plugins/tree/master/packages/device_info" target="_blank" rel="noopener">https://github.com/flutter/plugins/tree/master/packages/device_info</a></li>
<li><a href="https://segmentfault.com/a/1190000014913010?utm_source=index-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014913010?utm_source=index-hottest</a></li>
<li>网络请求简单示例 <a href="https://segmentfault.com/a/1190000013712168" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013712168</a></li>
<li>列表操作 list、map、set <a href="https://blog.csdn.net/hekaiyou/article/details/51374093" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/51374093</a></li>
<li>下拉刷新、加载更多  <a href="https://www.jianshu.com/p/0a64d84b0937" target="_blank" rel="noopener">https://www.jianshu.com/p/0a64d84b0937</a></li>
<li>flutter导航 <a href="https://blog.csdn.net/hekaiyou/article/details/72853738" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/72853738</a></li>
</ul>
<ol>
<li>Flutter加载本地资源</li>
</ol>
<p>通过异步加载本地Json资源，需要先在pubspec.yaml文件添加资源文件，然后再通过异步加载资源文件，以下为实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">flutter:</span><br><span class="line">  uses-material-design: true</span><br><span class="line">  assets:</span><br><span class="line">    - assets/config.json     //资源所在位置</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:convert&apos;;</span><br><span class="line">import &apos;dart:async&apos; show Future;</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:flutter/services.dart&apos; show rootBundle;</span><br><span class="line">Future&lt;String&gt; loadAsset() async &#123;</span><br><span class="line">  return await rootBundle.loadString(&apos;assets/config.json&apos;);</span><br><span class="line">&#125;</span><br><span class="line">void _loadJson() &#123;</span><br><span class="line">  loadAsset().then((value)&#123;</span><br><span class="line">    JsonDecoder decoder = new JsonDecoder();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; json = decoder.convert(value);</span><br><span class="line">    print(&apos;姓名：&apos;+json[0][0]+&apos;，年龄：&apos;+json[0][1]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考地址：  </p>
<ul>
<li><a href="https://blog.csdn.net/hekaiyou/article/details/54602103" target="_blank" rel="noopener">https://blog.csdn.net/hekaiyou/article/details/54602103</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-配置编辑器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-配置编辑器/" itemprop="url">flutter-配置编辑器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T14:52:32+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你可以使用任意一款文本编辑器结合我们提供的命令行工具来构建 Flutter 应用程序。当然，我们更推荐的是使用我们开发的文本编辑器插件之一，来优化开发的使用体验。安装好编辑器插件之后，你会获得代码自动补全，关键词高亮，组件编辑助手，运行&amp;调试的支持等一系列实用的功能。</p>
<p>请跟随下面的步骤来为你的编辑器添加这些插件，我们支持 Android Studio, IntelliJ 以及 VS Code。如果你使用的是另外的编辑器，也没有问题，跳过这一步，直接进入 <a href="http://doc.flutter-dev.cn/get-started/test-drive/" target="_blank" rel="noopener">下一步：创建并运行你的第一个应用程序</a>。</p>
<h3 id="Android-Studio-配置"><a href="#Android-Studio-配置" class="headerlink" title="Android Studio 配置"></a>Android Studio 配置</h3><p>Android Studio: 一个完整的，高度集成的 Flutter 开发编辑器。</p>
<h4 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h4><ul>
<li>Android Studio, 3.0 或者更高的版本。</li>
</ul>
<p>当然，你也可以选择使用 IntelliJ：</p>
<ul>
<li>IntelliJ IDEA 社区版, 2017.1 或者更高的版本。</li>
<li>IntelliJ IDEA 高级版, 2017.1 或者更高的版本。</li>
</ul>
<h4 id="安装-Flutter-和-Dart-插件"><a href="#安装-Flutter-和-Dart-插件" class="headerlink" title="安装 Flutter 和 Dart 插件"></a>安装 Flutter 和 Dart 插件</h4><p>Flutter 的开发支持需要安装 2 个插件：</p>
<ul>
<li>Flutter 插件可以提高 Flutter 在开发过程中的开发效率（运行，调试，热重载等等）。</li>
<li>Dart 插件提提升了代码层面的开发效率（在你敲代码的同时进行代码校验，代码自动补全等等）。</li>
</ul>
<p>安装步骤：</p>
<ol>
<li>启动 Android Studio。</li>
<li>打开插件设置（在 macOS 上路径为<br><strong>Preferences&gt;Plugins</strong>，在 Windows 和 Linux 上路径为 <strong>File&gt;Settings&gt;Plugins</strong>）。</li>
<li>选择 <strong>Browse repositories…</strong>，找到或者在搜索栏输入 Flutter，然后点击 install。</li>
<li>当弹出对话框提示要安装 Dart 插件的时候，点击 Yes 接受。</li>
<li>如果弹出 <strong>Restart</strong> 需要重启编辑器的时候，点击 Yes 接受。</li>
</ol>
<h3 id="Visual-Studio-Code-VS-Code-配置"><a href="#Visual-Studio-Code-VS-Code-配置" class="headerlink" title="Visual Studio Code (VS Code) 配置"></a>Visual Studio Code (VS Code) 配置</h3><p><strong>VS Code</strong>: 包含了运行和调试 Flutter 应用程序的轻量级编辑器。</p>
<h4 id="安装-VS-Code"><a href="#安装-VS-Code" class="headerlink" title="安装 VS Code"></a>安装 VS Code</h4><ul>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a>,   <ol>
<li>20.1 或更高版本。</li>
</ol>
</li>
</ul>
<h4 id="安装-Dart-Code-插件"><a href="#安装-Dart-Code-插件" class="headerlink" title="安装 Dart Code 插件"></a>安装 Dart Code 插件</h4><ol>
<li>启动 VS Code</li>
<li>依次执行 View&gt;Command Palette…</li>
<li>在扩展插件安装面板的输入框输入 dart code 关键词，在显示的列表中选择 ‘Dart Code’ 插件，然后点击 Install</li>
<li>点击 ‘OK’ 重新加载 VS Code</li>
</ol>
<h4 id="使用-Flutter-Doctor-来验证你的配置"><a href="#使用-Flutter-Doctor-来验证你的配置" class="headerlink" title="使用 Flutter Doctor 来验证你的配置"></a>使用 Flutter Doctor 来验证你的配置</h4><ol>
<li>依次执行 View&gt;Command Palette…</li>
<li>输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ 命令</li>
<li>在日志打印窗口的 ‘OUTPUT’ 标签中查看打印出的日志信息，看看有没有报错</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">The blog from a Android coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
