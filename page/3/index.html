<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android, SpringBoot" />










<meta name="description" content="The blog from a Android coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/3/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="The blog from a Android coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="The blog from a Android coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/page/3/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/12/flutter-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/flutter-install/" itemprop="url">Flutter_install</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T09:06:17+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章目录：  </p>
<ul>
<li>系统要求</li>
<li>获取Flutter Sdk<ul>
<li>克隆仓库</li>
<li>运行flutter doctor</li>
<li>更新系统路径</li>
</ul>
</li>
<li>编译器设置</li>
<li>平台设置</li>
<li>IOS设置<ul>
<li>安装Xcode</li>
<li>设置IOS模拟器</li>
<li>部署到IOS设备</li>
</ul>
</li>
<li>Android设置<ul>
<li>安装Android Studio</li>
<li>设置Android设备</li>
<li>设置Android模拟器</li>
</ul>
</li>
</ul>
<h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>安装并运行 Flutter ，你的开发环境必须满足这些最低要求：  </p>
<ul>
<li><strong>操作系统</strong>：macOS （64-bit）。</li>
<li><strong>磁盘空间</strong>： 700 MB （不包括 Xcode 和 Android Studio 的磁盘空间）。</li>
<li><strong>工具</strong>：Flutter 依赖你环境中可用的这些命令行工具。<ul>
<li>bash， mkdir，rm，git， curl，unzip，which   </li>
</ul>
</li>
</ul>
<h3 id="获取-Flutter-SDK"><a href="#获取-Flutter-SDK" class="headerlink" title="获取 Flutter SDK"></a>获取 Flutter SDK</h3><p>获取 Flutter ，你可使用 <strong>git</strong> 去克隆 Flutter 的仓库然后添加 <strong>flutter</strong> 工具到你的路径，运行 flutter doctor 显示你可能要安装的依赖。</p>
<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>如果你是第一次在你机器上安装 Flutter ，克隆 <strong>beta</strong> 分支的仓库然后添加 <strong>flutter</strong> 工具到你的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b beta https://github.com/flutter/flutter.git</span><br><span class="line">$ export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p>上面的命令会在当前的终端窗口暂时设置 PATH 变量，要永久添加 Flutter 到你的路径，请参阅 <a href="http://doc.flutter-dev.cn/setup-macos/#update-your-path" target="_blank" rel="noopener">更新你的路径</a>。</p>
<p>要更新一个现有版本的 Flutter ，请参阅<a href="http://doc.flutter-dev.cn/upgrading/" target="_blank" rel="noopener">更新 Flutter</a> 。</p>
<h4 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h4><p>运行以下命令可以看到你是否需要安装任何依赖来完成安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter doctor</span><br></pre></td></tr></table></figure></p>
<p>这个命令会检查你的环境并显示一份报告在终端窗口，Dart SDK 已和 Flutter 捆绑在一起，所以你不需要额外安装 Dart 。仔细检查输出信息是否需要安装其他软件或者执行其他任务（以 <strong>粗体</strong> 字显示）。</p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-] Android toolchain - develop for Android devices</span><br><span class="line">    • Android SDK at /Users/obiwan/Library/Android/sdk</span><br><span class="line">    ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</span><br><span class="line">    • Try re-installing or updating your Android SDK,</span><br><span class="line">      visit https://flutter.io/setup/#android-setup for detailed instructions.</span><br></pre></td></tr></table></figure></p>
<p>这是你第一次去运行 flutter 命令（比如 <strong>flutter doctor</strong> ），它会下载依赖库，并且自行编译。后续运行这条命令就会更加快了。</p>
<p>接下来的章节就是描述怎么执行这些任务和完成设置过程。你会看到 <strong>flutter doctor</strong> 输出了,假如你是用了 IDE ，就会显示 IntelliJ IDEA ， Android Studio 和 VS Code 这些编译器的可用插件。请参阅<a href="http://doc.flutter-dev.cn/get-started/editor/" target="_blank" rel="noopener">编译器设置</a>根据步骤去安装 Flutter 和 Dart 插件。</p>
<p>当你安装好了所有缺失的依赖库，运行 <strong>flutter doctor</strong> 命令去验证你的设置是否正确。</p>
<p>这个 <strong>flutter</strong> 工具使用了 Google Analytics 匿名分析 报告功能，使用情况信息和基本崩溃报告。这些数据用于帮助改进 Flutter 工具。并且这个分析报告是不会在第一次运行或者任何涉及到 <strong>flutter config</strong> 的设置运行时发送，因此你可以在任何分析之前退出分析。要禁用分析的话，输入 <strong>flutter config –no-analytics</strong> ，要显示当前配置的话输入 <strong>flutter config</strong> 。详情请参阅 Google 的隐私政策：www.google.com/intl/en/policies/privacy。</p>
<h4 id="更新你的路径"><a href="#更新你的路径" class="headerlink" title="更新你的路径"></a>更新你的路径</h4><p>你只能在命令行中更新你当前会话窗口的 PATH 变量，如<a href="http://doc.flutter-dev.cn/setup-macos/#clone-the-repo" target="_blank" rel="noopener">克隆 Flutter</a> 库所示。当永久更新这个变量，这样子你就可以在任意终端会话中运行 flutter 命令了。</p>
<p>对于计算机来说，永久给全部终端会话修改这个变量这些操作都是不同的。通常，你会打开新窗口时将命令输入。举个例子：</p>
<ol>
<li>确定好放置 Flutter SDK 的目录，你会在步骤 3 用到它。</li>
<li>打开（或者创建） <strong>$HOME/.bash_profile</strong> 这个文件或者文件名可能不同于你计算机的。</li>
<li><p>添加下面命令行并将 <strong>[PATH_TO_FLUTTER_GIT_DIRECTORY]</strong> 改为你克隆 Flutter 仓库的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <strong>source $HOME/.bash_profile</strong> 刷新当前窗口。</p>
</li>
<li>验证 <strong>flutter/bin</strong> 是否在你的路径上：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多的细节，可以参阅<a href="https://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path" target="_blank" rel="noopener">StackExchange 上的问题</a>。</p>
<h3 id="编译器设置"><a href="#编译器设置" class="headerlink" title="编译器设置"></a>编译器设置</h3><p>使用 <strong>flutter</strong> 命令行工具，你可以使用任何编辑器去开发 Flutter 应用。在命令提示符窗口输入 flutter help 可以显示可用的操作。</p>
<p>我推荐使用我们的插件来获取<a href="http://doc.flutter-dev.cn/using-ide/" target="_blank" rel="noopener">丰富的 IDE 体验</a> ，支持编辑，运行和调试 Flutter 应用。参阅<a href="http://doc.flutter-dev.cn/get-started/editor/" target="_blank" rel="noopener">编译器设置</a>了解详细步骤。</p>
<h3 id="平台设置"><a href="#平台设置" class="headerlink" title="平台设置"></a>平台设置</h3><p>macOS 支持为 iOS 和 Android 开发 Flutter 应用程序。现在只要在两个系统平台中的一个完成设置，就可以构建运行你的第一个 Flutter 应用程序了。</p>
<h3 id="iOS-设置"><a href="#iOS-设置" class="headerlink" title="iOS 设置"></a>iOS 设置</h3><h4 id="安装-Xcode"><a href="#安装-Xcode" class="headerlink" title="安装 Xcode"></a>安装 Xcode</h4><p>为 iOS 开发 Flutter 应用，你需要一台安装了 Xcode 7.2 或者更新版本的 Mac 。</p>
<ol>
<li>安装 Xcode 7.2 或者更新版本（通过<a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">网页下载</a>或者 <a href="https://itunes.apple.com/us/app/xcode/id497799835" target="_blank" rel="noopener">App Store</a> 安装）。</li>
<li>通过在在命令行运行 <strong>sudo xcode-select –switch /Applications/Xcode.app/Contents/Developer</strong> 来配置 Xcode 命令行工具来使用安装好的最新版本 Xcode 。</li>
</ol>
<p>大多数情况下，这是安装最新版 Xcode 的正确的路径。如果你想使用不同的版本，请改为指定的路径。</p>
<p>3.确保 Xcode 许可协议是通过打开一次 Xcode 或者从命令行中运行 <strong>sudo xcodebuild -license</strong> 来签署的。<br>使用 Xcode ，你就可以在你的 iOS 设备或者在模拟器上运行 Flutter 应用。</p>
<h4 id="设置-iOS-模拟器"><a href="#设置-iOS-模拟器" class="headerlink" title="设置 iOS 模拟器"></a>设置 iOS 模拟器</h4><p>准备在 iOS 模拟器上运行并测试你的 Flutter 应用，根据以下步骤：</p>
<p>在你的 Mac 上，可以通过 Spotlight 或者使用以下命令找到模拟器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open -a Simulator</span><br></pre></td></tr></table></figure></p>
<ol>
<li>通过检查模拟器的 <strong>Hardware &gt; Device</strong> 设置，确保你的模拟器运行 64 位的设备（iPhone 5s 或者更高版本）。</li>
<li>根据你开发设备的屏幕尺寸，模拟高屏幕密度的 iOS 设备可能会溢出你的屏幕，在模拟器的 <strong>Window &gt; Scale</strong> 菜单设置设备的比例。</li>
<li>运行 <strong>flutter run</strong> 来启动你的应用</li>
</ol>
<h4 id="部署到-iOS-设备"><a href="#部署到-iOS-设备" class="headerlink" title="部署到 iOS 设备"></a>部署到 iOS 设备</h4><p>部署你的 Flutter 应用程序到物理的 iOS 设备，你需要一些额外的工具和一个 Apple 账号。你还需要在 Xcode 中设置物理设备的部署。</p>
<ol>
<li>安装 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a>。</li>
<li>打开终端运行这些命令来安装部署 Flutter 应用程序到 iOS 设备的工具<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install --HEAD libimobiledevice</span><br><span class="line">$ brew install ideviceinstaller ios-deploy cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果这些命令中的任何一个命令失败出现错误，运行 <strong>brew doctor</strong> 并根据说明解决问题。</p>
<ol>
<li><p>遵循 Xcode 的签名流程来配置你的项目：</p>
<ol>
<li>打开默认的 Xcode 工作空间，找到你的 Flutter 项目目录并打开终端运行 <strong>open ios/Runner.xcworkspace</strong> 。</li>
<li>在 Xcode 左边的导航面板，选择 <strong>Runner</strong> 项目。</li>
<li><p>在 <strong>Runner</strong> 目标设置界面，确保在 <strong>General &gt; Signing &gt; Team</strong> 选择了你的开发团队，当你选择了开发团队，Xcode 创建和下载一个开发证书，向你的设备注册你的账户，并创建和下载配置文件（如果你需要的话）。</p>
<ul>
<li>要开始你的第一个 iOS 开发项目，你可能需要在 Xcode 上注册你的 Apple ID。<br>Xcode account add<br>任意的 Apple ID 都支持开发和测试。需要注册 Apple 开发者计划才能分发你的应用到 App Store 。请参阅 <a href="https://developer.apple.com/support/compare-memberships/" target="_blank" rel="noopener">Apple 会员类型之间的差异</a>。</li>
<li>你第一次用物理设备开发 iOS 时，你需要同时信任该设备上的 Mac 和开发证书。 当你的 iOS 设备第一次连接到你的 Mac 时，在对话框提示中选择 <strong>Trust</strong>。<br><a href="&quot;images/trust-computer.png&quot;">Trust Mac</a><br>然后，打开 iOS 设备上的设置，选择 <strong>常规 &gt; 设备管理</strong> 然后信任你的证书。<br>如果 Xcode 的自动签名失败，验证项目的 <strong>General &gt; Identity &gt; Bundle Identifier</strong> 是否唯一。<br><a href="&quot;xcode-unique-bundle-id.png&quot;">Check the app’s Bundle ID</a><br>运行flutter run 启动你的应用程序。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Android设置"><a href="#Android设置" class="headerlink" title="Android设置"></a>Android设置</h3><h4 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h4><p>为 Android 开发 Flutter 应用，你可以使用 Mac ，Windows 或者是 Linux（64 位）机器。</p>
<p>Flutter 要求安装和配置 Android Studio：</p>
<ol>
<li><p>下载并安装 <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>。</p>
</li>
<li><p>启动 Android Studio，并执行 Android Studio 安装向导。这将会安装 Flutter 为 Android 开发所需的最新的 Android SDK ，Android SDK 平台工具和 Android SDK 构建工具。</p>
</li>
</ol>
<h4 id="设置你的-Android-设备"><a href="#设置你的-Android-设备" class="headerlink" title="设置你的 Android 设备"></a>设置你的 Android 设备</h4><p>为了在 Android 设备上运行和测试你的 Flutter 应用，你需要一台运行 Android 4.1（ API 级别 16 ）或者更高版本的 Android 设备。</p>
<ol>
<li>在你的设备上启动 <strong>开发者选项</strong> 和 <strong>USB 调试</strong>，详情说明可在 <a href="https://developer.android.com/studio/debug/dev-options.html" target="_blank" rel="noopener">Android 文档</a>中找到。</li>
<li>使用 USB 线将设备插入电脑。如果在设备上出现提示，请授权你的电脑访问你的设备。</li>
<li>在终端运行 flutter devices 命令来验证 Flutter 识别到你连接的 Android 设备。</li>
<li>运行 flutter run 来启动的你的应用。<br>通常情况下， Flutter 使用了 adb 工具所基于的 Android SDK 版本，如果你要安装使用不同的 Android SDK 版本，就必须设置 ANDROID_HOME 环境变量设置为安装目录。</li>
</ol>
<h4 id="设置-Android-模拟器"><a href="#设置-Android-模拟器" class="headerlink" title="设置 Android 模拟器"></a>设置 Android 模拟器</h4><p>准备在 Android 模拟器上运行和测试你的 Flutter 应用，需要按照以下几个步骤来操作：</p>
<ol>
<li>在你的电脑上启动 <a href="https://developer.android.com/studio/run/emulator-acceleration.html" target="_blank" rel="noopener">VM 加速</a>。<ol>
<li>启动 <strong>Android Studio &gt; Tools &gt; Android &gt; AVD Manager</strong> 和选择 <strong>Create Virtual Device</strong> 。</li>
<li>选择一个设备的定义和选择 <strong>Next</strong> 。</li>
<li>为你的模拟器 Android 版本选择一个或者多个系统镜像，和选择 <strong>Next</strong> 。推荐使用 x86 or x86_64 镜像。</li>
<li>为了提高模拟器性能，选择 <strong>Hardware - GLES 2.0</strong> 来启动<a href="https://developer.android.com/studio/run/emulator-acceleration.html" target="_blank" rel="noopener">硬件加速</a>。</li>
<li>验证 AVD 的配置是否正确，然后选择 Finish 。</li>
</ol>
</li>
</ol>
<p>有关上述步骤的详细信息,请查阅<a href="https://developer.android.com/studio/run/managing-avds.html" target="_blank" rel="noopener">管理 AVDs</a> 。</p>
<ol>
<li>在 Android 虚拟设备管理器中，在工具栏点击 <strong>Run</strong> 。模拟器启动和显示所选操作系统版本和设备的默认界面。</li>
<li>通过 <strong>flutter run</strong> 来启动你的应用，连接设备的名称是 <strong>Android SDK built for <platform></platform></strong> ，这里的 platform 是指设备 soc 芯片系列，比如 x86 。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/Android音视频点知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/Android音视频点知识/" itemprop="url">音视频点知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:23:15+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>视频是什么<br>&nbsp;&nbsp;&nbsp;&nbsp;静止的画面叫图像（picture）。连续的图像变化每秒超过24帧（frame）画面以上时，根椐视觉暂留原理，人眼无法辨别每付单独的静态画面，看上去是平滑连续的视觉效果。这样的连续画面叫视频。当连续图像变化每秒低于24帧画面时，人眼有不连续的感觉叫动画（cartoon）。</p>
</li>
<li><p>流媒体<br>&nbsp;&nbsp;&nbsp;&nbsp;指采用流式传输的方式在Internet / Intranet播放的媒体格式.流媒体的数据流随时传送随 时播放，只是在开始时有些延迟边下载边播入的流式传输方式不仅使启动延时大幅度地缩短，而且对系统缓存容量的需求也大大降低，极大地减少用户用在等待的时间。</p>
</li>
<li><p>分辨率<br>&nbsp;&nbsp;&nbsp;&nbsp;分辨率是一个表示平面图像精细程度的概念，通常它是以横向和纵向点的数量来衡量的，表示成水平点数垂直点数的形式，在计算机显示领域我们也表示成“每英寸像素”（ppi）.在一个固定的平面内，分辨率越高，意味着可使用的点数越多，图像越细致。</p>
</li>
<li><p>码率<br>&nbsp;&nbsp;&nbsp;&nbsp;数据传输时单位时间传送的数据位数,可以理解其为取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，如何用最低的码率达到最少的失真，一般我们用的单位是kbps即千位每秒。</p>
</li>
<li><p>帧率<br>&nbsp;&nbsp;&nbsp;&nbsp;帧/秒（frames per second）的缩写，也称为帧速率，测量用于保存、显示动态视频的信息数量。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。每秒钟帧数 （fps） 愈多，所显示的动作就会愈流畅，可理解为1秒钟时间里刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，也就是指每秒钟能够播放（或者录制）多少格画面。</p>
</li>
</ul>
<h3 id="多媒体的格式分类"><a href="#多媒体的格式分类" class="headerlink" title="多媒体的格式分类"></a>多媒体的格式分类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;封装格式(专业上讲叫容器,通俗的叫文件格式),视频编解码,音频编解码。</p>
<ul>
<li>常见的封装格式<ul>
<li>MPEG : 编码采用的容器，具有流的特性。里面又分为 PS，TS 等，PS 主要用于 DVD 存储，TS 主要用于 HDTV.</li>
<li>MPEG Audio Layer 3 :大名鼎鼎的 MP3，已经成为网络音频的主流格式，能在 128kbps 的码率接近 CD 音质</li>
<li>MPEG-4(Mp4) : 编码采用的容器，基于 QuickTime MOV 开发，具有许多先进特性;实际上是对Apple公司开发的MOV格式(也称Quicktime格式)的一种改进.</li>
<li>MKV: 它能把 Windows Media Video，RealVideo，MPEG-4 等视频音频融为一个文件，而且支持多音轨，支持章节字幕等;开源的容器格式</li>
<li>3GP : 3GPP视频采用的格式， 主要用于流媒体传送;3GP其实是MP4格式的一种简化版本,是手机视频格式的绝对主流.</li>
<li>MOV : QuickTime 的容器，恐怕也是现今最强大的容器，甚至支持虚拟现实技术，Java等，它的变种 MP4,3GP都没有这么厉害;广泛应用于Mac OS操作系统，在Windows操作系统上也可兼容，但是远比不上AVI格式流行</li>
<li>AVI : 最常见的音频视频容器,音频视频交错（Audio Video Interleaved）允许视频和音频交错在一起同步播放.</li>
<li>WAV : 一种音频容器，大家常说的 WAV 就是没有压缩的 PCM 编码，其实 WAV 里面还可以包括 MP3 等其他 ACM 压缩编码等等</li>
</ul>
</li>
</ul>
<h3 id="流媒体协议-RTP-RTCP-RTSP-RTMP-HLS"><a href="#流媒体协议-RTP-RTCP-RTSP-RTMP-HLS" class="headerlink" title="流媒体协议(RTP RTCP RTSP RTMP HLS)"></a>流媒体协议(RTP RTCP RTSP RTMP HLS)</h3><ul>
<li>RTP RTCP RTSP<ul>
<li>RTP :(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输层协议.RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的</li>
<li>RTCP:Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）实时传输控制协议,是实时传输协议（RTP）的一个姐妹协议，RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的</li>
<li>RTSP:（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议,RTSP提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用TCP或UDP来传送串流内容，比较能容忍网络延迟</li>
</ul>
</li>
</ul>
<p>RTP不像http和ftp可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。<br>RTSP与RTP最大的区别在于：RTSP是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP可基于RTP来传送数据，还可以选择TCP、UDP、组播UDP等通道来发送数据，具有很好的扩展性。它时一种类似与http协议的网络应用层协议</p>
<ul>
<li><p>RTMP<br>RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p>
</li>
<li><p>HLS<br>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备（如iPhone、iPad）提供音视频直播和点播方案。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p>
</li>
</ul>
<p>参考文献：<br>[1]. 基础知识 <a href="https://www.jianshu.com/p/8436c7353296" target="_blank" rel="noopener">https://www.jianshu.com/p/8436c7353296</a><br>[2]. android视频播放实现 <a href="https://blog.csdn.net/u011403718/article/details/53813713" target="_blank" rel="noopener">https://blog.csdn.net/u011403718/article/details/53813713</a><br>[3]. android种MediaCodeC编码 <a href="https://blog.csdn.net/mirkerson/article/details/38520175" target="_blank" rel="noopener">https://blog.csdn.net/mirkerson/article/details/38520175</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/MediaExtractor译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/MediaExtractor译文/" itemprop="url">MediaExtractor译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:20:26+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MediaExtractor"><a href="#MediaExtractor" class="headerlink" title="MediaExtractor"></a>MediaExtractor</h3><p>官网描述是：MediaExtractor facilitates extraction of demuxed, typically encoded, media data from a data source. added in API level 16。  public final class MediaExtractor<br>extends Object.<br>译文：MediaExtractor便于从数据源中提取复用的，典型编码的媒体数据。 在api 16时候加入到sdk的。<br>其一般的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor extractor = new MediaExtractor();</span><br><span class="line">extractor.setDataSource(...);</span><br><span class="line">int numTracks = extractor.getTrackCount();</span><br><span class="line">for (int i = 0; i &lt; numTracks; ++i) &#123;</span><br><span class="line">  MediaFormat format = extractor.getTrackFormat(i);</span><br><span class="line">  String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">  if (weAreInterestedInThisTrack) &#123;</span><br><span class="line">    extractor.selectTrack(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ByteBuffer inputBuffer = ByteBuffer.allocate(...)</span><br><span class="line">while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) &#123;</span><br><span class="line">  int trackIndex = extractor.getSampleTrackIndex();</span><br><span class="line">  long presentationTimeUs = extractor.getSampleTime();</span><br><span class="line">  ...</span><br><span class="line">  extractor.advance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extractor.release();</span><br><span class="line">extractor = null;</span><br></pre></td></tr></table></figure></p>
<p>在使用该类的时候可能需要使用到Manifest.permission.INTERNET权限，当数据源为网络数据时。   </p>
<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><ol>
<li>嵌套子类   </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MediaExtractor.CasInfo</td>
<td style="text-align:left">Describes the conditional access system used to scramble a track. （描述用于对轨道进行加扰的条件访问系统。）</td>
</tr>
<tr>
<td style="text-align:left">MediaExtractor.MetricsConstants</td>
<td style="text-align:left">度量标准常量</td>
</tr>
</tbody>
</table>
<ol>
<li>常量   </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">常量名</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SAMPLE_FLAG_ENCRYPTED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">The sample is (at least partially) encrypted（采样加密）, see also the documentation for MediaCodec.queueSecureInputBuffer(int, int, MediaCodec.CryptoInfo, long, int)</td>
<td style="text-align:left">2 (0x00000002)</td>
</tr>
<tr>
<td style="text-align:left">SAMPLE_FLAG_PARTIAL_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">This indicates that the buffer only contains part of a frame, and the decoder should batch the data until a buffer without this flag appears before decoding the frame.（这表明缓冲区只包含帧的一部分，并且解码器应该对数据进行批处理，直到没有该标志的缓冲区在解码帧之前出现。）</td>
<td style="text-align:left">4 (0x00000004)</td>
</tr>
<tr>
<td style="text-align:left">SAMPLE_FLAG_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">The sample is a sync sample (or in MediaCodec’s terminology it is a key frame.)（该示例是同步样本（或者在MediaCodec的术语中，它是一个关键帧）。）</td>
<td style="text-align:left">1 (0x00000001)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_CLOSEST_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to the sync sample closest to the specified time（如果可能的话，寻找最接近指定时间的同步采样）</td>
<td style="text-align:left">2 (0x00000002)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_NEXT_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to a sync sample at or after the specified time（如果可能的话，在指定的时间或之 <strong>后</strong> 寻找同步样本。）</td>
<td style="text-align:left">1 (0x00000001)</td>
</tr>
<tr>
<td style="text-align:left">SEEK_TO_PREVIOUS_SYNC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">If possible, seek to a sync sample at or before the specified time（如果可能的话，在指定的时间或之 <strong>前</strong> 寻找同步样本。）</td>
<td style="text-align:left">0 (0x00000000)</td>
</tr>
</tbody>
</table>
<ol>
<li><p>公共构造器<br>MediaExtractor()  </p>
</li>
<li><p>公共方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">advance()</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Advance to the next sample.（前进到下一个采样）</td>
</tr>
<tr>
<td style="text-align:left">getAudioPresentations(int trackIndex)</td>
<td style="text-align:left">List<audiopresentation\></audiopresentation\></td>
<td style="text-align:left">Get the list of available audio presentations for the track.（获取该曲目的可用音频演示列表。）</td>
</tr>
<tr>
<td style="text-align:left">getCachedDuration()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns an estimate of how much data is presently cached in memory expressed in microseconds.（返回目前在内存中缓存的数据量，以微秒为单位表示。）</td>
</tr>
<tr>
<td style="text-align:left">getCasInfo(int index)</td>
<td style="text-align:left">MediaExtractor.CasInfo</td>
<td style="text-align:left">Retrieves the information about the conditional access system used to scramble a track.（检索有关用于加密曲目的条件访问系统的信息。）</td>
</tr>
<tr>
<td style="text-align:left">getDrmInitData()</td>
<td style="text-align:left">DrmInitData</td>
<td style="text-align:left">Extract DRM initialization data if it exists（提取DRM初始化数据（如果存在））</td>
</tr>
<tr>
<td style="text-align:left">getMetrics()</td>
<td style="text-align:left">PersistableBundle</td>
<td style="text-align:left">Return Metrics data about the current media container.(返回有关当前媒体容器的度量标准数据。)</td>
</tr>
<tr>
<td style="text-align:left">getPsshInfo()</td>
<td style="text-align:left">Map<uuid, byte[]\=""></uuid,></td>
<td style="text-align:left">Get the PSSH info if present.(获取PSSH信息，如果存在。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleCryptoInfo(MediaCodec.CryptoInfo info)</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">If the sample flags indicate that the current sample is at least partially encrypted, this call returns relevant information about the structure of the sample data required for decryption.(如果样本标志指示当前样本至少部分加密，则此调用返回有关解密所需的样本数据结构的相关信息。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleFlags()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Returns the current sample’s flags.(返回当前采样的标志。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleSize()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns the current sample’s presentation size</td>
</tr>
<tr>
<td style="text-align:left">getSampleTime()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">Returns the current sample’s presentation time in microseconds.(以微秒为单位返回当前样本的呈现时间。)</td>
</tr>
<tr>
<td style="text-align:left">getSampleTrackIndex()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Returns the track index the current sample originates from (or -1 if no more samples are available)(返回当前样本来源的轨道索引（如果没有更多样本可用，则返回-1）)</td>
</tr>
<tr>
<td style="text-align:left">getTrackCount()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Count the number of tracks found in the data source.(计算数据源中找到的曲目数量。)</td>
</tr>
<tr>
<td style="text-align:left">getTrackFormat(int index)</td>
<td style="text-align:left">MediaFormat</td>
<td style="text-align:left">Get the track format at the specified index.(获取指定索引处的曲目格式。)</td>
</tr>
<tr>
<td style="text-align:left">hasCacheReachedEndOfStream()</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Returns true iff we are caching data and the cache has reached the end of the data stream (for now, a future seek may of course restart the fetching of data).(如果我们正在缓存数据并且缓存已到达数据流的末尾（现在，未来的查找当然可能会重新开始提取数据），则返回true。)</td>
</tr>
<tr>
<td style="text-align:left">readSampleData(ByteBuffer byteBuf, int offset)</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Retrieve the current encoded sample and store it in the byte buffer starting at the given offset.(检索当前编码样本并将其存储在从给定偏移量开始的字节缓冲区中。)</td>
</tr>
<tr>
<td style="text-align:left">release()</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Make sure you call this when you’re done to free up any resources instead of relying on the garbage collector to do this for you at some point in the future.(确保你在完成任务时释放任何资源，而不是依赖垃圾回收器在将来的某个时刻为你做这件事。)</td>
</tr>
<tr>
<td style="text-align:left">seekTo(long timeUs, int mode)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">All selected tracks seek near the requested time according to the specified mode.(根据指定的模式，所有选定的曲目都会在请求的时间附近寻找。)</td>
</tr>
<tr>
<td style="text-align:left">selectTrack(int index)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Subsequent calls to readSampleData(ByteBuffer, int), getSampleTrackIndex() and getSampleTime() only retrieve information for the subset of tracks selected.(随后对readSampleData（ByteBuffer，int），getSampleTrackIndex（）和getSampleTime（）的调用仅检索所选轨道子集的信息。)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(AssetFileDescriptor afd)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (AssetFileDescriptor) to use.(设置要使用的数据源（AssetFileDescriptor）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(Context context, Uri uri, Map<string, string=""> headers)</string,></td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source as a content Uri.(将数据源设置为内容Uri。)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(FileDescriptor fd)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (FileDescriptor) to use.((设置要使用的数据源（FileDescriptor）))</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(MediaDataSource dataSource)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (MediaDataSource dataSource) to use.(设置要使用的数据源（MediaDataSource）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(FileDescriptor fd, long offset, long length)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (FileDescriptor) to use.(设置要使用的数据源（MediaDataSource）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(String path)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (file-path or http URL) to use.(设置要使用的数据源（文件路径或http URL）)</td>
</tr>
<tr>
<td style="text-align:left">setDataSource(String path, Map<string, string=""> headers)</string,></td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the data source (file-path or http URL) to use.(设置要使用的数据源（文件路径或http URL）)</td>
</tr>
<tr>
<td style="text-align:left">setMediaCas(MediaCas mediaCas)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Sets the MediaCas instance to use.(设置要使用的MediaCas实例。)</td>
</tr>
<tr>
<td style="text-align:left">unselectTrack(int index)</td>
<td style="text-align:left">void</td>
<td style="text-align:left">Subsequent calls to readSampleData(ByteBuffer, int), getSampleTrackIndex() and getSampleTime() only retrieve information for the subset of tracks selected.(随后对readSampleData（ByteBuffer，int），getSampleTrackIndex（）和getSampleTime（）的调用仅检索所选轨道子集的信息。)</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/05/MediaCodec译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/MediaCodec译文/" itemprop="url">MediaCodec译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T19:17:28+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MediaCodec"><a href="#MediaCodec" class="headerlink" title="MediaCodec"></a>MediaCodec</h3><p>官方描述：MediaCodec class can be used to access low-level media codecs, i.e. encoder/decoder components. It is part of the Android low-level multimedia support infrastructure (normally used together with MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, and AudioTrack.)<br>译文：MediaCodec类可用于访问底层媒体编解码器，例如，编码器/解码器组件。 它是Android低级多媒体支持基础架构的一部分（通常与MediaExtractor，MediaSync，MediaMuxer，MediaCrypto，MediaDrm，Image，Surface和AudioTrack一起使用。）   </p>
<p><img src="/images/MediaCodeC_bufferflow.png" alt="MediaCodeC中缓存的处理">  </p>
<p>从广义上讲，编解码器就是处理输入数据来产生输出数据。MediaCode采用异步方式处理数据，并且使用了一组输入输出缓存（input and output buffers）。简单来讲，你请求或接收到一个空的输入缓存（input buffer），向其中填充满数据并将它传递给编解码器处理。编解码器处理完这些数据并将处理结果输出至一个空的输出缓存（output buffer）中。最终，你请求或接收到一个填充了结果数据的输出缓存（output buffer），使用完其中的数据，并将其释放给编解码器再次使用。</p>
<ol>
<li>数据类型（Data Types）</li>
</ol>
<p>　　编解码器可以处理三种类型的数据：压缩数据（即为经过H254. H265. 等编码的视频数据或AAC等编码的音频数据）、原始音频数据、原始视频数据。三种类型的数据均可以利用ByteBuffers进行处理，但是对于原始视频数据应提供一个Surface以提高编解码器的性能。Surface直接使用本地视频数据缓存（native video buffers），而没有映射或复制数据到ByteBuffers，因此，这种方式会更加高效。在使用Surface的时候，通常不能直接访问原始视频数据，但是可以使用ImageReader类来访问非安全的解码（原始）视频帧。这仍然比使用ByteBuffers更加高效，因为一些本地缓存（native buffer）可以被映射到 direct ByteBuffers。当使用ByteBuffer模式，你可以利用Image类和getInput/OutputImage(int)方法来访问到原始视频数据帧。</p>
<ol>
<li>压缩缓存（Compressed Buffers）</li>
</ol>
<p>　　输入缓存（对于解码器）和输出缓存（对编码器）中包含由多媒体格式类型决定的压缩数据。对于视频类型是单个压缩的视频帧。对于音频数据通常是单个可访问单元(一个编码的音频片段，通常包含几毫秒的遵循特定格式类型的音频数据)，但这种要求也不是十分严格，一个缓存内可能包含多个可访问的音频单元。在这两种情况下，缓存不会在任意的字节边界上开始或结束，而是在帧或可访问单元的边界上开始或结束。</p>
<ol>
<li>原始音频缓存（Raw Audio Buffers）</li>
</ol>
<p>　　原始的音频数据缓存包含完整的PCM（脉冲编码调制）音频数据帧，这是每一个通道按照通道顺序的一个样本。每一个样本是一个按照本机字节顺序的16位带符号整数（16-bit signed integer in native byte order）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">short[] getSamplesForChannel(MediaCodec codec, int bufferId, int channelIx) &#123;</span><br><span class="line">　　ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);</span><br><span class="line">　　MediaFormat format = codec.getOutputFormat(bufferId);</span><br><span class="line">　　ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();</span><br><span class="line">　　int numChannels = formet.getInteger(MediaFormat.KEY_CHANNEL_COUNT);</span><br><span class="line">　　if (channelIx &lt; 0 || channelIx &gt;= numChannels) &#123;</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br><span class="line">　　short[] res = new short[samples.remaining() / numChannels];</span><br><span class="line">　　for (int i = 0; i &lt; res.length; ++i) &#123;</span><br><span class="line">　　　　res[i] = samples.get(i * numChannels + channelIx);</span><br><span class="line">　　&#125;</span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>原始视频缓存（Raw Video Buffers）</li>
</ol>
<p>　　在ByteBuffer模式下，视频缓存（video buffers）根据它们的颜色格式（color format）进行展现。你可以通过调用getCodecInfo().getCapabilitiesForType(…).colorFormats方法获得编解码器支持的颜色格式数组。视频编解码器可以支持三种类型的颜色格式：  </p>
<ul>
<li>本地原始视频格式（native raw video format）：这种格式通过COLOR_FormatSurface标记，并可以与输入或输出Surface一起使用。</li>
<li>灵活的YUV缓存（flexible YUV buffers）(例如：COLOR_FormatYUV420Flexible)：利用一个输入或输出Surface，或在在ByteBuffer模式下，可以通过调用getInput/OutputImage(int)方法使用这些格式。</li>
<li>其他，特定的格式（other, specific formats）：通常只在ByteBuffer模式下被支持。有些颜色格式是特定供应商指定的。其他的一些被定义在 MediaCodecInfo.CodecCapabilities中。这些颜色格式同 flexible format相似，你仍然可以使用 getInput/OutputImage(int)方法。<br>　　从Android 5.1（LOLLIPOP_MR1）开始，所有的视频编解码器都支持灵活的YUV4:2:0缓存（flexible YUV 4:2:0 buffers）。</li>
</ul>
<ol>
<li>状态（States）  </li>
</ol>
<p>在编解码器的生命周期内有三种理论状态：停止态-Stopped、执行态-Executing、释放态-Released，停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。执行状态（Executing）在概念上会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）。<br><img src="/images/MediaCodec_states.png" alt="编码器的三种理论状态">     </p>
<ul>
<li>当你使用任意一种工厂方法（factory methods）创建了一个编解码器，此时编解码器处于未初始化状态（Uninitialized）。首先，你需要使用configure(…)方法对编解码器进行配置，这将使编解码器转为配置状态（Configured）。然后调用start()方法使其转入执行状态（Executing）。在这种状态下你可以通过上述的缓存队列操作处理数据。</li>
<li>执行状态（Executing）包含三个子状态： 刷新（Flushed）、运行（ Running） 以及流结束（End-of-Stream）。在调用start()方法后编解码器立即进入刷新子状态（Flushed），此时编解码器会拥有所有的缓存。一旦第一个输入缓存（input buffer）被移出队列，编解码器就转入运行子状态（Running），编解码器的大部分生命周期会在此状态下度过。当你将一个带有end-of-stream 标记的输入缓存入队列时，编解码器将转入流结束子状态（End-of-Stream）。在这种状态下，编解码器不再接收新的输入缓存，但它仍然产生输出缓存（output buffers）直到end-of- stream标记到达输出端。你可以在执行状态（Executing）下的任何时候通过调用flush()方法使编解码器重新返回到刷新子状态（Flushed）。</li>
<li>通过调用stop()方法使编解码器返回到未初始化状态（Uninitialized），此时这个编解码器可以再次重新配置 。当你使用完编解码器后，你必须调用release()方法释放其资源。</li>
<li>在极少情况下编解码器会遇到错误并进入错误状态（Error）。这个错误可能是在队列操作时返回一个错误的值或者有时候产生了一个异常导致的。通过调用 reset()方法使编解码器再次可用。你可以在任何状态调用reset()方法使编解码器返回到未初始化状态（Uninitialized）。否则，调用 release()方法进入最终的Released状态。</li>
</ul>
<ol>
<li>创建（Creation）  </li>
</ol>
<p>　　根据指定的MediaFormat使用MediaCodecList创建一个MediaCodec实例。在解码文件或数据流时，你可以通过调用MediaExtractor.getTrackFormat方法获得所期望的格式（media format）。并调用MediaFormat.setFeatureEnabled方法注入任何你想要添加的特定属性，然后调用MediaCodecList.findDecoderForFormat方法获得可以处理指定的媒体格式的编解码器的名字。最后，通过调用createByCodecName(String)方法创建一个编解码器。<br>　　注意：在Android 5.0 （LOLLIPOP）上，传递给MediaCodecList.findDecoder/EncoderForFormat的格式不能包含帧率-frame rate。通过调用format.setString(MediaFormat.KEY_FRAME_RATE, null)方法清除任何存在于当前格式中的帧率。<br>　　你也可以根据MIME类型利用createDecoder/EncoderByType(String)方法创建一个你期望的编解码器。然而，这种方式不能够给编解码器加入指定特性，而且创建的编解码器有可能不能处理你所期望的媒体格式。</p>
<ol>
<li>创建安全的解码器（Creating secure decoders<br>）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android 4.4（KITKAT_WATCH）及之前版本，安全的编解码器（secure codecs）没有被列在MediaCodecList中，但是仍然可以在系统中使用。安全编解码器只能够通过名字进行实例化，其名字是在常规编解码器的名字后附加.secure标识（所有安全编解码器的名字都必须以.secure结尾），调用createByCodecName(String)方法创建安全编解码器时，如果系统中不存在指定名字的编解码器就会抛出IOException异常。<br>&nbsp;&nbsp;&nbsp;&nbsp;从Android 5.0(LOLLIPOP）及之后版本，你可以在媒体格式中使用FEATURE_SecurePlayback属性来创建一个安全编解码器。</p>
<ol>
<li>初始化（Initialization）</li>
</ol>
<p>　　在创建了编解码器后，如果你想异步地处理数据，可以通过调用setCallback方法设置一个回调方法。然后，使用指定的媒体格式配置编解码器。这时你可以为视频原始数据产生者（例如视频解码器）指定输出Surface。此时你也可以为secure 编解码器设置解密参数（详见MediaCrypto） 。最后，因为编解码器可以工作于多种模式，你必须指定是该编码器是作为一个解码器（decoder）还是编码器（encoder）运行。</p>
<p>　　从API LOLLIPOP起，你可以在Configured 状态下查询输入和输出格式的结果。在开始编解码前你可以通过这个结果来验证配置的结果，例如，颜色格式。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你想将原始视频数据（raw video data）送视频消费者处理（将原始视频数据作为输入的编解码器，例如视频编码器），你可以在配置好视频消费者编解码器（encoder）后调用createInputSurface方法创建一个目的surface来存放输入数据，如此，调用视频生产者（decoder）的setInputSurface(Surface)方法将前面创建的目的Surface配置给视频生产者作为输出缓存位置。</p>
<ol>
<li>Codec-specific数据    </li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;有些格式，特别是ACC音频和MPEG4、H.264和H.265视频格式要求实际数据以若干个包含配置数据或编解码器指定数据的缓存为前缀。当处理这种压缩格式的数据时，这些数据必须在调用start()方法后且在处理任何帧数据之前提交给编解码器。这些数据必须在调用queueInputBuffer方法时使用BUFFER_FLAG_CODEC_CONFIG进行标记。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Codec-specific数据也可以被包含在传递给configure方法的格式信息（MediaFormat）中，在ByteBuffer条目中以”csd-0”, “csd-1”等key标记。这些keys一直包含在通过MediaExtractor获得的Audio Track or Video Track的MediaFormat中。一旦调用start()方法，MediaFormat中的Codec-specific数据会自动提交给编解码器；你不能显示的提交这些数据。如果MediaFormat中不包含编解码器指定的数据，你可以根据格式要求，按照正确的顺序使用指定数目的缓存来提交codec-specific数据。在H264 AVC编码格式下，你也可以连接所有的codec-specific数据并作为一个单独的codec-config buffer提交。</p>
<p>Android 使用下列的codec-specific data buffers。对于适当的MediaMuxer轨道配置，这些也要在轨道格式中进行设置。每一个参数集以及被标记为（*）的codec-specific-data段必须以”\x00\x00\x00\x01”字符开头。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Format</th>
<th style="text-align:left">CSD buffer #0</th>
<th style="text-align:left">CSD buffer #1</th>
<th style="text-align:left">CSD buffer #2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AAC</td>
<td style="text-align:left">Decoder-specific information from ESDS*</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">VORBIS</td>
<td style="text-align:left">Identification header</td>
<td style="text-align:left">Setup header</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">OPUS</td>
<td style="text-align:left">Identification header</td>
<td style="text-align:left">Pre-skip in nanosecs(unsigned 64-bit native-order integer.) This overrides the pre-skip value in the identification header.</td>
<td style="text-align:left">Seek Pre-roll in nanosecs(unsigned 64-bit native-order integer.)</td>
</tr>
<tr>
<td style="text-align:left">FLAC</td>
<td style="text-align:left">mandatory metadata block (called the STREAMINFO block),optionally followed by any number of other metadata blocks</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">MPEG-4</td>
<td style="text-align:left">Decoder-specific information from ESDS*</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">H.264 AVC</td>
<td style="text-align:left">SPS (Sequence Parameter Sets*)</td>
<td style="text-align:left">PPS (Picture Parameter Sets*)</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">H.265 HEVC</td>
<td style="text-align:left">VPS (Video Parameter Sets<em>) + SPS (Sequence Parameter Sets</em>) + PPS (Picture Parameter Sets*)</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
<tr>
<td style="text-align:left">VP9</td>
<td style="text-align:left">VP9 CodecPrivate Data (optional)</td>
<td style="text-align:left">Not Used</td>
<td style="text-align:left">Not Used</td>
</tr>
</tbody>
</table>
<p>注意：当编解码器被立即刷新或start之后不久刷新，并且在任何输出buffer或输出格式变化被返回前需要特别地小心，因为编解码器的codec specific data可能会在flush过程中丢失。为保证编解码器的正常运行，你必须在刷新后使用标记为BUFFER_FLAG_CODEC_CONFIGbuffers的buffers再次提交这些数据。</p>
<p>　　 编码器（或者产生压缩数据的编解码器）将会在有效的输出缓存之前产生和返回编解码器指定的数据，这些数据会以codec-config flag进行标记。包含codec-specific-data的Buffers没有有意义的时间戳。</p>
<p>数据处理（Data Processing）<br>　　每一个编解码器都包含一组输入和输出缓存（input and output buffers），这些缓存在API调用中通过buffer-id进行引用。当成功调用start()方法后客户端将不会“拥有”输入或输出buffers。在同步模式下，通过调用dequeueInput/OutputBuffer(…) 方法从编解码器获得（取得所有权）一个输入或输出buffer。在异步模式下，你可以通过MediaCodec.Callback.onInput/OutputBufferAvailable(…)的回调方法自动地获得可用的buffers。</p>
<p>　　在获得一个输入buffe后，向其中填充数据，并利用queueInputBuffer方法将其提交给编解码器，若使用解密，则利用queueSecureInputBuffer方法提交。不要提交多个具有相同时间戳的输入buffers（除非它是也被同样标记的codec-specific data）。</p>
<p>　　在异步模式下通过onOutputBufferAvailable方法的回调或者在同步模式下响应dequeuOutputBuffer的调用，编解码器返回一个只读的output buffer。在这个output buffer被处理后，调用一个releaseOutputBuffer方法将这个buffer返回给编解码器。</p>
<p>　　当你不需要立即向编解码器重新提交或释放buffers时，保持对输入或输出buffers的所有权可使编解码器停止工作，当然这些行为依赖于设备情况。特别地，编解码器可能延迟产生输出buffers直到输出的buffers被释放或重新提交。因此，尽可能短时间地持有可用的buffers。</p>
<p>根据API版本情况，你有三种处理相关数据的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Processing Mode</th>
<th style="text-align:left">API version &lt;= 20 Jelly Bean/KitKat</th>
<th style="text-align:left">API version &gt;= 21  Lollipop and later</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Synchronous API using buffer arrays</td>
<td style="text-align:left">Supported</td>
<td style="text-align:left">Deprecated</td>
</tr>
<tr>
<td style="text-align:left">Synchronous API using buffers</td>
<td style="text-align:left">Not Available</td>
<td style="text-align:left">Supported</td>
</tr>
<tr>
<td style="text-align:left">Asynchronous API using buffers</td>
<td style="text-align:left">Not Available</td>
<td style="text-align:left">Supported</td>
</tr>
</tbody>
</table>
<ol>
<li>使用缓存的异步处理方式（Asynchronous Processing using Buffers）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从Android 5.0（LOLLIPOP）开始，首选的方法是调用configure之前通过设置回调异步地处理数据。异步模式稍微改变了状态转换方式，因为你必须在调用flush()方法后再调用start()方法才能使编解码器的状态转换为Running子状态并开始接收输入buffers。同样，初始调用start方法将编解码器的状态直接变化为Running 子状态并通过回调方法开始传递可用的输入buufers。<br><img src="/images/Asynchronous_buffer_flow.png" alt="异步模式处理"><br>　异步模式下，编解码器典型的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> MediaFormat mOutputFormat; // member variable</span><br><span class="line"> // 异步模式下需要在configure之前设置callback</span><br><span class="line"> codec.setCallback(new MediaCodec.Callback() &#123;</span><br><span class="line">   /**</span><br><span class="line">    * 在onInputBufferAvailable回调方法中，MediaCodec会通知什么时候input</span><br><span class="line">    * buffer有效，根据buffer id，调用getInputBuffer(id)可以获得这个buffer，</span><br><span class="line">    * 此时就可以向这个buffer中写入数据，最后调用queueInputBuffer(id, …)提交</span><br><span class="line">    * 给MediaCodec处理。</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123;</span><br><span class="line">     ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);</span><br><span class="line">     // fill inputBuffer with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">     * 在onOutputBufferAvailable回调方法中，MediaCodec会通知什么时候output</span><br><span class="line">     * buffer有效，根据buffer id，调用getOutputBuffer(id)可以获得这个buffer，</span><br><span class="line">     * 此时就可以读取这个buffer中的数据，最后调用releaseOutputBuffer(id, …)释放</span><br><span class="line">     * 给MediaCodec再次使用。</span><br><span class="line">     */</span><br><span class="line">   @Override</span><br><span class="line">   void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123;</span><br><span class="line">     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">     // bufferFormat is equivalent to mOutputFormat</span><br><span class="line">     // outputBuffer is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 当MediaCodec的output format发生变化是会回调该方法，一般在start之后都会首先回调该方法</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">     mOutputFormat = format; // option B</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">     * MediaCodec运行发生错误时会回调该方法</span><br><span class="line">     */</span><br><span class="line">   @Override</span><br><span class="line">   void onError(…) &#123;</span><br><span class="line">     …</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> mOutputFormat = codec.getOutputFormat(); // option B</span><br><span class="line"> codec.start();</span><br><span class="line"> // wait for processing to complete</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用缓存的同步处理方式（Synchronous Processing using Buffers） .<br>　　从Android5.0（LOLLIPOP）开始，即使在同步模式下使用编解码器你应该通过getInput/OutputBuffer(int) 和/或 getInput/OutputImage(int) 方法检索输入和输出buffers。这允许通过框架进行某些优化，例如，在处理动态内容过程中。如果你调用getInput/OutputBuffers()方法这种优化是不可用的。</li>
</ol>
<p>　　注意，不要同时混淆使用缓存和缓存数组的方法。特别地，仅仅在调用start()方法后或取出一个值为INFO_OUTPUT_FORMAT_CHANGED的输出buffer ID后你才可以直接调用getInput/OutputBuffers方法。</p>
<p>　　同步模式下MediaCodec的典型应用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> MediaFormat outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line"> codec.start();</span><br><span class="line"> /**</span><br><span class="line">  * 在一个无限循环中不断地请求Codec是否有可用的input buffer 或 output buffer</span><br><span class="line">  */</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(timeoutUs); // 请求是否有可用的input buffer</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     ByteBuffer inputBuffer = codec.getInputBuffer(…);</span><br><span class="line">     // fill inputBuffer with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);  // 提交数据给Codec</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">     // bufferFormat is identical to outputFormat</span><br><span class="line">     // outputBuffer is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);     // 释放output buffer供Codec再次使用</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">     outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>使用缓存数组的同步处理方式（Synchronous Processing using Buffer Arrays）– (deprecated)<br>　　在Android 4.4（KITKAT_WATCH）及之前版本，一组输入或输出buffers使用ByteBuffer[]数组表示。在成功调用了start()方法后，通过调用getInput/OutputBuffers()方法检索buffer数组。在这些数组中使用buffer的ID-s（非负数）作为索引，如下面的演示示例中，注意数组大小和系统使用的输入和输出buffers的数量之间并没有固定的关系，尽管这个数组提供了上限边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> codec.start();</span><br><span class="line"> ByteBuffer[] inputBuffers = codec.getInputBuffers();</span><br><span class="line"> ByteBuffer[] outputBuffers = codec.getOutputBuffers();</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(…);</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     // fill inputBuffers[inputBufferId] with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     // outputBuffers[outputBufferId] is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">     outputBuffers = codec.getOutputBuffers();</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     MediaFormat format = codec.getOutputFormat();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure>
</li>
<li><p>流结束处理（End-of-stream Handling）<br>　　当到达输入数据结尾时，你必须在调用queueInputBuffer方法中通过指定BUFFER_FLAG_END_OF_STREAM标记来通知编解码器。你可以在最后一个有效的输入buffer上做这些操作，或者提交一个额外的以end-of-stream标记的空的输入buffer。如果使用一个空的buffer，它的时间戳将被忽略。</p>
</li>
</ol>
<p>　　编解码器将会继续返回输出buffers，直到它发出输出流结束的信号，这是通过指定dequeueOutputBuffer方法中MediaCodec.BufferInfo的end-of-stream标记来实现的，或者是通过回调方法onOutputBufferAvailable来返回end-of-stream标记。可以在最后一个有效的输出buffer中设置或者在最后一个有效的输出buffer后添加一个空的buffer来设置，这种空的buffer的时间戳应该被忽略。</p>
<p>　　当通知输入流结束后不要再提交额外的输入buffers，除非编解码器被刷新或停止或重启。</p>
<ol>
<li>使用一个输出表面（Using an Output Surface）<br>　　使用一个输出Surface进行数据处理的方法与ByteBuffer模式几乎是相同的，然而，输出buffers不再可访问，而且被表示为null值。E.g.方法getOutputBuffer/Image(int)将返回null，方法getOutputBuffers()将返回仅包含null值的数组。</li>
</ol>
<p>　　当使用一个输出Surface时，你能够选择是否渲染surface上的每一个输出buffer，你有三种选择：</p>
<ul>
<li>不要渲染这个buffer（Do not render the buffer）：通过调用releaseOutputBuffer(bufferId, false)。</li>
<li>使用默认的时间戳渲染这个buffer（Render the buffer with the default timestamp）：调用releaseOutputBuffer(bufferId, true)。</li>
<li>使用指定的时间戳渲染这个buffer（Render the buffer with a specific timestamp）：调用 releaseOutputBuffer(bufferId, timestamp)。<br>　　从Android6.0(M)开始，默认的时间戳是buffer的presentation timestamp（转换为纳秒）。在此前的版本中这是没有被定义的。</li>
</ul>
<p>　　而且，从Android6.0(M)开始，你可以通过使用setOutputSurface方法动态地改变输出Surface。</p>
<ol>
<li>使用一个输入表面（Using an Input Surface）<br>　　当使用输入Surface时，将没有可访问的输入buffers,因为这些buffers将会从输入surface自动地向编解码器传输。调用dequeueInputBuffer时将抛出一个IllegalStateException异常，调用getInputBuffers()将要返回一个不能写入的伪ByteBuffer[]数组。</li>
</ol>
<p>　　调用signalEndOfInputStream()方法发送end-of-stream信号。调用这个方法后，输入surface将会立即停止向编解码器提交数据。</p>
<p>查询&amp;自适应播放支持（Seeking &amp; Adaptive Playback Support）<br>　　视频解码器（通常指处理压缩视频数据的编解码器）关于搜索-seek和格式转换（不管它们是否支持）表现不同，且被配置为adaptive playback。你可以通过调用CodecCapabilities.isFeatureSupported(String)方法来检查解码器是否支持adaptive playback 。支持Adaptive playback的解码器只有在编解码器被配置在Surface上解码时才被激活。</p>
<p>　　流域界与关键帧（Stream Boundary and Key Frames）</p>
<p>　　在调用start()或flush()方法后，输入数据在合适的流边界开始是非常重要的：其第一帧必须是关键帧（key-frame）。一个关键帧能够独立地完全解码（对于大多数编解码器它意味着I-frame），关键帧之后显示的帧不会引用关键帧之前的帧。</p>
<p>　　下面的表格针对不同的视频格式总结了合适的关键帧。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Format</th>
<th style="text-align:left">Suitable key frame</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">VP9/VP8</td>
<td style="text-align:left">a suitable intraframe where no subsequent frames refer to frames prior to this frame. (There is no specific name for such key frame.)</td>
</tr>
<tr>
<td style="text-align:left">H.265 HEVC</td>
<td style="text-align:left">IDR or CRA</td>
</tr>
<tr>
<td style="text-align:left">H.264 AVC</td>
<td style="text-align:left">IDR</td>
</tr>
<tr>
<td style="text-align:left">MPEG-4 H.263 MPEG-2</td>
<td style="text-align:left">a suitable I-frame where no subsequent frames refer to frames prior to this frame.(There is no specific name for such key frame.)</td>
</tr>
</tbody>
</table>
<p>对于不支持adaptive playback的解码器（包括解码到Surface上解码器）</p>
<p>　　为了开始解码与先前提交的数据（也就是seek后）不相邻的数据你必须刷新解码器。由于所有输出buffers会在flush的一刻立即撤销，你可能希望在调用flush方法前等待这些buffers首先被标记为end-of-stream。在调用flush方法后输入数据在一个合适的流边界或关键帧开始是非常重要的。</p>
<p>　　注意：flush后提交的数据的格式不能改变；flush()方法不支持格式的不连续性；为此，一个完整的stop()-configure(…)-start()的过程是必要的。</p>
<p>　　同时注意：如果你调用start()方法后过快地刷新编解码器，通常，在收到第一个输出buffer或输出format变化前，你需要向这个编解码器再次提交codec-specific-data。具体查看codec-specific-data部分以获得更多信息。</p>
<p>　　对于支持及被配置为adaptive playback的几码器</p>
<p>　　为了开始解码与先前提交的数据（也就是seek后）不相邻的数据，你没有必要刷新解码器；然而，在间断后传入的数据必须开始于一个合适的流边界或关键帧。</p>
<p>　　针对一些视频格式-也就是H.264、H.265、VP8和VP9，也可以修改图片大小或者配置mid-stream。为了做到这些你必须将整个新codec-specific配置数据与关键帧一起打包到一个单独的buffer中（包括所有的开始数据），并将它作为一个常规的输入数据提交。</p>
<p>　　在picture-size被改变后以及任意具有新大小的帧返回之前，你可以从dequeueOutputBuffer方法或onOutputFormatChanged回调中得到 INFO_OUTPUT_FORMAT_CHANGED的返回值。</p>
<p>　　注意：就像使用codec-specific data时的情况，在你修改图片大小后立即调用fush()方法时需要非常小心。如果你没有接收到图片大小改变的确认信息，你需要重试修改图片大小的请求。</p>
<ol>
<li>错误处理（Error handling）</li>
</ol>
<p>　　工厂方法createByCodecName以及createDecoder/EncoderByType会在创建codec失败时抛出一个IOException，你必须捕获异常或声明向上传递异常。在编解码器不允许使用该方法的状态下调用时，MediaCodec方法将会抛出IllegalStateException异常；这种情况一般是由于API接口的不正确调用引起的。涉及secure buffers的方法可能会抛出一个MediaCodec.CryptoException异常，可以调用getErrorCode()方法获得更多的异常信息。</p>
<p>　　内部的编解码器错误将导致MediaCodec.CodecException，这可能是由于media内容错误、硬件错误、资源枯竭等原因所致，即使你已经正确的使用了API。当接收到一个CodecException时，可以调用isRecoverable()和isTransient()两个方法来决定建议的行为。</p>
<p>可恢复错误（recoverable errors）：如果isRecoverable() 方法返回true,然后就可以调用stop(),configure(…),以及start()方法进行修复。<br>短暂错误（transient errors）：如果isTransient()方法返回true,资源短时间内不可用，这个方法可能会在一段时间之后重试。<br>致命错误（fatal errors）：如果isRecoverable()和isTransient()方法均返回fase，CodecException错误是致命的，此时就必须reset这个编解码器或调用released方法释放资源。<br>　　isRecoverable()和isTransient()方法不可能同时都返回true。</p>
<ol>
<li>嵌套类（Nested classes）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MediaCodec.BufferInfo</td>
<td style="text-align:left">class</td>
<td style="text-align:left">每一个缓存区的元数据都包含有一个偏移量offset和大小size用于指示相关编解码器（输出）缓存中有效数据的范围。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.Callback</td>
<td style="text-align:left">class</td>
<td style="text-align:left">MediaCodec回调接口</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CodecException</td>
<td style="text-align:left">class</td>
<td style="text-align:left">当发生内部的编解码器错误是抛出。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CryptoException</td>
<td style="text-align:left">class</td>
<td style="text-align:left">在入队列一个安全的输入缓存过程中发生加密错误时抛出。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.CryptoInfo</td>
<td style="text-align:left">class</td>
<td style="text-align:left">描述（至少部分地）加密的输入样本的结构的元数据。</td>
</tr>
<tr>
<td style="text-align:left">MediaCodec.OnFrameRenderedListener</td>
<td style="text-align:left">interface</td>
<td style="text-align:left">当一个输出帧在输出surface上呈现时，监听器被调用。</td>
</tr>
</tbody>
</table>
<ol>
<li>常量  </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BUFFER_FLAG_CODEC_CONFIG</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2（0x00000002）</td>
<td style="text-align:left">这表示带有此标记的缓存包含编解码器初始化或编解码器特定的数据而不是多媒体数据media data。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_END_OF_STREAM</td>
<td style="text-align:left">int</td>
<td style="text-align:left">4（0x00000004</td>
<td style="text-align:left">它表示流结束，该标志之后不会再有可用的buffer，除非接下来对Codec执行flush()方法。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_KEY_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">这表示带有此标记的（编码的）缓存包含关键帧数据。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_PARTIAL_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">8 (0x00000008)</td>
<td style="text-align:left">这表明缓冲区只包含帧的一部分，并且解码器应该对数据进行批处理，直到没有该标志的缓冲区在解码帧之前出现。</td>
</tr>
<tr>
<td style="text-align:left">BUFFER_FLAG_SYNC_FRAME</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">这个常量在API level 21中弃用，使用BUFFER_FLAG_KEY_FRAME代替。这表示带有此标记的（编码的）缓存包含关键帧数据。</td>
</tr>
<tr>
<td style="text-align:left">CONFIGURE_FLAG_ENCODE</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left">如果编解码器被用作编码器，传递这个标志。</td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_AES_CBC</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2（0x00000002）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_AES_CTR</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1（0x00000001）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CRYPTO_MODE_UNENCRYPTED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">0（0x00000000）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INFO_OUTPUT_BUFFERS_CHANGED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-3 (0xfffffffd)</td>
<td style="text-align:left">此常数在API级别21中已弃用。由于getOutputBuffers（）已被弃用，此返回值可以被忽略。 每次出队时，客户端都应该使用get-buffer或get-image方法的on命令来请求当前缓冲区。输出缓冲区已更改，客户端必须从此处引用由getOutputBuffers（）返回的新输出缓冲区集合。此外，此事件表示视频缩放模式可能已重置为默认值。</td>
</tr>
<tr>
<td style="text-align:left">INFO_OUTPUT_FORMAT_CHANGED</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-2 (0xfffffffe)</td>
<td style="text-align:left">输出格式已更改，后续数据将采用新格式。 getOutputFormat（）返回新的格式。 请注意，您也可以使用新的getOutputFormat（int）方法来获取特定输出缓冲区的格式。 这使您无需跟踪输出格式更改。</td>
</tr>
<tr>
<td style="text-align:left">INFO_TRY_AGAIN_LATER</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-1 (0xffffffff)</td>
<td style="text-align:left">如果在调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）时指定了非负超时，则表示该呼叫超时。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_REQUEST_SYNC_FRAME</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“request-sync”</td>
<td style="text-align:left">请求编码器“很快”产生一个同步帧。 提供值为0的整数。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_SUSPEND</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“drop-input-frames”</td>
<td style="text-align:left">暂时暂停/恢复输入数据的编码。虽然暂停输入数据被有效丢弃，而不是被馈送到编码器中。在“表面输入”模式下，这个参数只与编码器一起使用才是有意义的，因为在这种情况下，客户端代码对编码器的输入端没有控制。该值是一个整数对象，包含要挂起的值1或要恢复的值0。</td>
</tr>
<tr>
<td style="text-align:left">PARAMETER_KEY_VIDEO_BITRATE</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“video-bitrate”</td>
<td style="text-align:left">立即改变视频编码器的目标比特率。该值是包含BPS中的新比特率的整数对象。</td>
</tr>
<tr>
<td style="text-align:left">VIDEO_SCALING_MODE_SCALE_TO_FIT</td>
<td style="text-align:left">int</td>
<td style="text-align:left">1 (0x00000001)</td>
<td style="text-align:left">内容按比例缩放到表面尺寸。</td>
</tr>
<tr>
<td style="text-align:left">VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING</td>
<td style="text-align:left">int</td>
<td style="text-align:left">2 (0x00000002)</td>
<td style="text-align:left">内容是缩放，保持其纵横比，使用整个表面积，可以裁剪内容。这种模式只适用于1:1像素长宽比的内容，因为你不能为一个表面配置像素的长宽比。对于Build.VERSION_CODES.N版本，如果视频旋转90度或270度，则此模式可能无法工作。</td>
</tr>
</tbody>
</table>
<ol>
<li>公有方法</li>
</ol>
<h4 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h4><p>public void configure (MediaFormat format,Surface surface,MediaCrypto crypto,int flags)：Configures a component.（配置组件。）</p>
<ul>
<li><p>参数<br>format     -》 MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an an empty mediaformat.  （输入数据（解码器）的格式或输出数据（编码器）的所需格式。 以格式传递null相当于传递一个空的媒体格式。）<br>surface -》    Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for ByteBuffer output.（指定要渲染此解码器输出的表面。 如果编解码器不生成原始视频输出（例如，不是视频解码器），并且/或者如果要为ByteBuffer输出配置编解码器，则将null传递为曲面。）<br>crypto -》    MediaCrypto: Specify a crypto object to facilitate secure decryption of the media data. Pass null as crypto for non-secure codecs. （指定一个加密对象以促进媒体数据的安全解密。 传递null作为非安全编解码器的加密。）<br>flags -》    int: Specify CONFIGURE_FLAG_ENCODE to configure the component as an encoder.（指定CONFIGURE_FLAG_ENCODE将组件配置为编码器。）</p>
</li>
<li><p>异常<br>IllegalArgumentException -》    if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing CONFIGURE_FLAG_ENCODE for an encoder). （如果表面已被释放（或无效），或格式不可接受（例如，缺少必需的密钥），或者标记未正确设置（例如，编码器缺少CONFIGURE_FLAG_ENCODE）。）<br>IllegalStateException -》    if not in the Uninitialized state.（如果不是未初始化状态。）<br>MediaCodec.CryptoException -》    upon DRM error.（在DRM错误。）<br>MediaCodec.CodecException -》    upon codec error.（编解码器错误。）    </p>
</li>
</ul>
<h4 id="configure-1"><a href="#configure-1" class="headerlink" title="configure"></a>configure</h4><p>public void configure (MediaFormat format,Surface surface,int flags,MediaDescrambler descrambler)：Configure a component to be used with a descrambler.（配置要与解扰器一起使用的组件。）  </p>
<ul>
<li><p>参数<br>format     -》 MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an an empty mediaformat.  （输入数据（解码器）的格式或输出数据（编码器）的所需格式。 以格式传递null相当于传递一个空的媒体格式。）<br>surface -》    Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for ByteBuffer output.（指定要渲染此解码器输出的表面。 如果编解码器不生成原始视频输出（例如，不是视频解码器），并且/或者如果要为ByteBuffer输出配置编解码器，则将null传递为曲面。）<br>flags -》    int: Specify CONFIGURE_FLAG_ENCODE to configure the component as an encoder.（指定CONFIGURE_FLAG_ENCODE将组件配置为编码器。）<br>descrambler -》    MediaDescrambler: Specify a descrambler object to facilitate secure descrambling of the media data, or null for non-secure codecs.（指定解扰器对象以促进媒体数据的安全解扰，或者指定非安全编解码器为null。）  </p>
</li>
<li><p>异常<br>IllegalArgumentException -》    if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing CONFIGURE_FLAG_ENCODE for an encoder). （如果表面已被释放（或无效），或格式不可接受（例如，缺少必需的密钥），或者标记未正确设置（例如，编码器缺少CONFIGURE_FLAG_ENCODE）。）<br>IllegalStateException -》    if not in the Uninitialized state.（如果不是未初始化状态。）<br>MediaCodec.CryptoException -》    upon DRM error.（在DRM错误。）<br>MediaCodec.CodecException -》    upon codec error.（编解码器错误。）</p>
</li>
</ul>
<h4 id="createByCodecName"><a href="#createByCodecName" class="headerlink" title="createByCodecName"></a>createByCodecName</h4><p>public static MediaCodec createByCodecName (String name)：If you know the exact name of the component you want to instantiate use this method to instantiate it. Use with caution. Likely to be used with information obtained from MediaCodecList（如果您知道要实例化的组件的确切名称，请使用此方法将其实例化。 谨慎使用。 可能与从MediaCodecList获取的信息一起使用）  </p>
<ul>
<li><p>参数<br>name    -》String: The name of the codec to be instantiated.This value must never be null.（要实例化的编解码器的名称。此值绝不能为null。）</p>
</li>
<li><p>返回值<br>MediaCodec    -》 This value will never be null.（此值绝不能为null。）</p>
</li>
<li><p>异常<br>IOException -》    if the codec cannot be created.  （如果无法创建编解码器）<br>IllegalArgumentException -》    if name is not valid.（如果名称无效）<br>NullPointerException -》    if name is null.（如果名称为空）  </p>
</li>
</ul>
<h4 id="createDecoderByType"><a href="#createDecoderByType" class="headerlink" title="createDecoderByType"></a>createDecoderByType</h4><p>public static MediaCodec createDecoderByType (String type)：Instantiate the preferred decoder supporting input data of the given mime type. The following is a partial list of defined mime types and their semantics:（实例化支持给定MIME类型的输入数据的首选解码器。 以下是定义的MIME类型及其语义的部分列表：）</p>
<ul>
<li>“video/x-vnd.on2.vp8” - VP8 video (i.e. video in .webm)</li>
<li>“video/x-vnd.on2.vp9” - VP9 video (i.e. video in .webm)</li>
<li>“video/avc” - H.264/AVC video</li>
<li>“video/hevc” - H.265/HEVC video</li>
<li>“video/mp4v-es” - MPEG4 video</li>
<li>“video/3gpp” - H.263 video</li>
<li>“audio/3gpp” - AMR narrowband audio</li>
<li>“audio/amr-wb” - AMR wideband audio</li>
<li>“audio/mpeg” - MPEG1/2 audio layer III</li>
<li>“audio/mp4a-latm” - AAC audio (note, this is raw AAC packets, not packaged in LATM!)</li>
<li>“audio/vorbis” - vorbis audio</li>
<li>“audio/g711-alaw” - G.711 alaw audio</li>
<li>“audio/g711-mlaw” - G.711 ulaw audio<br>Note: It is preferred to use MediaCodecList.findDecoderForFormat(MediaFormat) and createByCodecName(String) to ensure that the resulting codec can handle a given format.（注意：最好使用MediaCodecList.findDecoderForFormat（MediaFormat）和createByCodecName（String）来确保生成的编解码器可以处理给定的格式。）</li>
</ul>
<ul>
<li><p>参数<br>type -》    String: The mime type of the input data.This value must never be null.（输入数据的mime类型。此值绝不能为null。）</p>
</li>
<li><p>异常<br>IOException     -》if the codec cannot be created.（如果无法创建编解码器）<br>IllegalArgumentException -》     if type is not a valid mime type.（如果type不是有效的mime类型）<br>NullPointerException -》    if type is null.（如果type为空）</p>
</li>
</ul>
<h4 id="createEncoderByType"><a href="#createEncoderByType" class="headerlink" title="createEncoderByType"></a>createEncoderByType</h4><p>public static MediaCodec createEncoderByType (String type)：Instantiate the preferred encoder supporting output data of the given mime type. Note: It is preferred to use MediaCodecList.findEncoderForFormat(MediaFormat) and createByCodecName(String) to ensure that the resulting codec can handle a given format.<br>（实例化支持给定MIME类型的输出数据的首选编码器。 注意：最好使用MediaCodecList.findEncoderForFormat（MediaFormat）和createByCodecName（String）来确保生成的编解码器可以处理给定的格式。）</p>
<ul>
<li><p>参数<br>type    -》String: The desired mime type of the output data.This value must never be null.（所需的MIME类型的输出数据。该值不能为空。）</p>
</li>
<li><p>返回值<br>MediaCodec    -》This value will never be null.（这个值永远不为空）。</p>
</li>
<li><p>异常<br>IOException -》 if the codec cannot be created. （如果编解码器不能被创建。）<br>IllegalArgumentException -》    if type is not a valid mime type.  （如果type不是有效的MIME类型。）<br>NullPointerException -》    if type is null.  （如果type为null。）</p>
</li>
</ul>
<h4 id="createInputSurface"><a href="#createInputSurface" class="headerlink" title="createInputSurface"></a>createInputSurface</h4><p>public Surface createInputSurface ()：Requests a Surface to use as the input to an encoder, in place of input buffers. This may only be called after configure(MediaFormat, Surface, MediaCrypto, int) and before start().The application is responsible for calling release() on the Surface when done.The Surface must be rendered with a hardware-accelerated API, such as OpenGL ES. Surface.lockCanvas(android.graphics.Rect) may fail or produce unexpected results.（请求Surface用作编码器的输入，以代替输入缓冲区。 这只能在configure（MediaFormat，Surface，MediaCrypto，int）和start（）之前调用。应用程序负责在完成时调用Surface上的release（）。Surface必须使用硬件加速API（如OpenGL ES）进行渲染。 Surface.lockCanvas（android.graphics.Rect）可能会失败或产生意想不到的结果。）</p>
<ul>
<li>返回值<br>Surface    -》 This value will never be null.（这个值永远不为空）</li>
<li>异常<br>IllegalStateException -》    if not in the Configured state.（如果不在配置状态）</li>
</ul>
<h4 id="createPersistentInputSurface"><a href="#createPersistentInputSurface" class="headerlink" title="createPersistentInputSurface"></a>createPersistentInputSurface</h4><p>public static Surface createPersistentInputSurface ()：Create a persistent input surface that can be used with codecs that normally have an input surface, such as video encoders. A persistent input can be reused by subsequent MediaCodec or MediaRecorder instances, but can only be used by at most one codec or recorder instance concurrently.The application is responsible for calling release() on the Surface when done.（创建可与通常具有输入表面的编解码器一起使用的持久输入表面，例如视频编码器。 持久性输入可以被后续MediaCodec或MediaRecorder实例重用，但最多只能同时使用一个编解码器或录制器实例。应用程序负责在完成时调用Surface上的release（）。）</p>
<ul>
<li>返回值<br>Surface    -》 an input surface that can be used with setInputSurface(Surface).This value will never be null.（一个可以与setInputSurface（Surface）一起使用的输入表面。该值永远不会为空）</li>
</ul>
<h4 id="dequeueInputBuffer"><a href="#dequeueInputBuffer" class="headerlink" title="dequeueInputBuffer"></a>dequeueInputBuffer</h4><p>public int dequeueInputBuffer (long timeoutUs)：Returns the index of an input buffer to be filled with valid data or -1 if no such buffer is currently available. This method will return immediately if timeoutUs == 0, wait indefinitely for the availability of an input buffer if timeoutUs &lt; 0 or wait up to “timeoutUs” microseconds if timeoutUs &gt; 0.（返回要用有效数据填充的输入缓冲区的索引，如果当前没有可用的缓冲区，则返回-1。 如果timeoutU == 0，此方法将立即返回，如果timeoutU <0，则无限期等待输入缓冲区的可用性;如果timeoutus> 0，则等待“timeoutUs”微秒。）</0，则无限期等待输入缓冲区的可用性;如果timeoutus></p>
<ul>
<li>参数<br>timeoutUs    -》 long: The timeout in microseconds, a negative timeout indicates “infinite”.（超时（微秒），负超时表示“无限”。<br>）</li>
<li>返回值<br>int -》 缓冲区索引id</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state, or codec is configured in asynchronous mode.（如果不处于执行状态，或编解码器配置为异步模式。）<br>MediaCodec.CodecException     -》 upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="dequeueOutputBuffer"><a href="#dequeueOutputBuffer" class="headerlink" title="dequeueOutputBuffer"></a>dequeueOutputBuffer</h4><p>public int dequeueOutputBuffer (MediaCodec.BufferInfo info, long timeoutUs)：Dequeue an output buffer, block at most “timeoutUs” microseconds. Returns the index of an output buffer that has been successfully decoded or one of the INFO<em>* constants.（出队输出缓冲区，最多阻止“timeoutUs”微秒。 返回已成功解码的输出缓冲区的索引或其中一个INFO</em> *常量。）</p>
<ul>
<li>参数<br>info -》    MediaCodec.BufferInfo: Will be filled with buffer meta data.This value must never be null.（将填充缓冲区元数据。该值不能为空）<br>timeoutUs     -》 long: The timeout in microseconds, a negative timeout indicates “infinite”.（超时（微秒），负超时表示“无限”。<br>）</li>
<li>返回值<br>int -》 缓冲区索引id</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state, or codec is configured in asynchronous mode.（如果不处于执行状态，或编解码器配置为异步模式。）<br>MediaCodec.CodecException     -》 upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><p>public void flush ()：Flush both input and output ports of the component.Upon return, all indices previously returned in calls to dequeueInputBuffer and dequeueOutputBuffer — or obtained via onInputBufferAvailable or onOutputBufferAvailable callbacks — become invalid, and all buffers are owned by the codec.If the codec is configured in asynchronous mode, call start() after flush has returned to resume codec operations. The codec will not request input buffers until this has happened. Note, however, that there may still be outstanding onOutputBufferAvailable callbacks that were not handled prior to calling flush. The indices returned via these callbacks also become invalid upon calling flush and should be discarded.If the codec is configured in synchronous mode, codec will resume automatically if it is configured with an input surface. Otherwise, it will resume when dequeueInputBuffer is called.（刷新组件的输入和输出端口。返回时，以前通过调用dequeueInputBuffer和dequeueOutputBuffer返回的所有索引 - 或通过onInputBufferAvailable或onOutputBufferAvailable回调获得 - 都变为无效，并且所有缓冲区都由编解码器拥有。如果编解码器配置为 异步模式，在刷新后调用start（）返回以恢复编解码器操作。 在这种情况发生之前，编解码器不会请求输入缓冲器。 但请注意，在调用刷新之前，可能仍有未完成的onOutputBufferAvailable回调。 通过这些回调返回的索引在调用flush时也会失效，应该丢弃。如果编解码器配置为同步模式，如果配置了输入表面，编解码器将自动恢复。 否则，它将在调用dequeueInputBuffer时继续。）</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getCodecInfo"><a href="#getCodecInfo" class="headerlink" title="getCodecInfo"></a>getCodecInfo</h4><p>public MediaCodecInfo getCodecInfo ()<br>Get the codec info. If the codec was created by createDecoderByType or createEncoderByType, what component is chosen is not known beforehand, and thus the caller does not have the MediaCodecInfo.（获取编解码器信息。 如果编解码器是由createDecoderByType或createEncoderByType创建的，则选择哪个组件并不是事先知道的，因此调用者没有MediaCodecInfo。）</p>
<ul>
<li>返回参数<br>MediaCodecInfo    -》 This value will never be null.（ 该值永远不会为空）</li>
<li>异常<br>IllegalStateException -》     if in the Released state.（如果处于Released状态。）</li>
</ul>
<h4 id="getInputBuffer"><a href="#getInputBuffer" class="headerlink" title="getInputBuffer"></a>getInputBuffer</h4><p>public ByteBuffer getInputBuffer (int index)：Returns a cleared, writable ByteBuffer object for a dequeued input buffer index to contain the input data. After calling this method any ByteBuffer or Image object previously returned for the same input index MUST no longer be used.（返回已清除的可写ByteBuffer对象，用于包含输入数据的出列输入缓冲区索引。 在调用这个方法之后，必须不再使用先前为相同输入索引返回的任何ByteBuffer或Image对象。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned from a call to dequeueInputBuffer(long), or received via an onInputBufferAvailable callback.（先前从调用dequeueInputBuffer（long）返回的客户机拥有的输入缓冲区的索引，或通过onInputBufferAvailable回调接收的索引。）   </li>
<li>返回值<br>ByteBuffer -》    the input buffer, or null if the index is not a dequeued input buffer, or if the codec is configured for surface input.（输入缓冲区;如果索引不是出列输入缓冲区，或者编解码器配置为表面输入，则为null。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getOutputFormat"><a href="#getOutputFormat" class="headerlink" title="getOutputFormat"></a>getOutputFormat</h4><p>public MediaFormat getOutputFormat (int index)：Returns the output format for a specific output buffer.（返回特定输出缓冲区的输出格式）  </p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned from a call to dequeueInputBuffer(long).（先前从调用dequeueInputBuffer（long）返回的客户机拥有的输入缓冲区的索引。）</li>
<li>返回值<br>MediaFormat    -》 the format for the output buffer, or null if the index is not a dequeued output buffer.（输出缓冲区的格式;如果索引不是出队输出缓冲区，则返回null。）</li>
</ul>
<h4 id="getOutputFormat-1"><a href="#getOutputFormat-1" class="headerlink" title="getOutputFormat"></a>getOutputFormat</h4><p>public MediaFormat getOutputFormat ()：Call this after dequeueOutputBuffer signals a format change by returning INFO_OUTPUT_FORMAT_CHANGED. You can also call this after configure(MediaFormat, Surface, MediaCrypto, int) returns successfully to get the output format initially configured for the codec. Do this to determine what optional configuration parameters were supported by the codec.（通过返回INFO_OUTPUT_FORMAT_CHANGED，dequeueOutputBuffer发出格式更改后调用此函数。 您也可以在configure（MediaFormat，Surface，MediaCrypto，int）成功返回后获取为编解码器初始配置的输出格式。 这样做可以确定编解码器支持哪些可选的配置参数。）</p>
<ul>
<li>返回值<br>MediaFormat    -》 This value will never be null.（该值永远不会为空）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="getOutputImage"><a href="#getOutputImage" class="headerlink" title="getOutputImage"></a>getOutputImage</h4><p>public Image getOutputImage (int index)：Returns a read-only Image object for a dequeued output buffer index that contains the raw video frame. After calling this method, any ByteBuffer or Image object previously returned for the same output index MUST no longer be used.(返回包含原始视频帧的出列输出缓冲区索引的只读Image对象。 在调用这个方法之后，必须不再使用先前为相同输出索引返回的任何ByteBuffer或Image对象。)</p>
<ul>
<li>返回值<br>index -》    int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long), or received via an onOutputBufferAvailable callback.（先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）或通过onOutputBufferAvailable回调接收的客户端拥有的输出缓冲区的索引。）</li>
<li>返回值<br>Image -》    the output image, or null if the index is not a dequeued output buffer, not a raw video frame, or if the codec was configured with an output surface. （输出图像;如果索引不是出列输出缓冲区，不是原始视频帧，或者编解码器配置了输出表面，则为null。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="queueInputBuffer"><a href="#queueInputBuffer" class="headerlink" title="queueInputBuffer"></a>queueInputBuffer</h4><p>public void queueInputBuffer (int index,int offset, int size,long presentationTimeUs,int flags)：After filling a range of the input buffer at the specified index submit it to the component. Once an input buffer is queued to the codec, it MUST NOT be used until it is later retrieved by getInputBuffer(int) in response to a dequeueInputBuffer(long) return value or a MediaCodec.Callback.onInputBufferAvailable(MediaCodec, int) callback.Many decoders require the actual compressed data stream to be preceded by “codec specific data”, i.e. setup data used to initialize the codec such as PPS/SPS in the case of AVC video or code tables in the case of vorbis audio. The class MediaExtractor provides codec specific data as part of the returned track format in entries named “csd-0”, “csd-1” …  These buffers can be submitted directly after start() or flush() by specifying the flag BUFFER_FLAG_CODEC_CONFIG. However, if you configure the codec with a MediaFormat containing these keys, they will be automatically submitted by MediaCodec directly after start. Therefore, the use of BUFFER_FLAG_CODEC_CONFIG flag is discouraged and is recommended only for advanced users. To indicate that this is the final piece of input data (or rather that no more input data follows unless the decoder is subsequently flushed) specify the flag BUFFER_FLAG_END_OF_STREAM.（在指定索引处填充输入缓冲区的范围后，将其提交给组件。一旦输入缓冲区排队等待编解码器，它就不能被使用，直到它稍后被getInputBuffer（int）检索以响应dequeueInputBuffer（long）返回值或MediaCodec.Callback.onInputBufferAvailable（MediaCodec，int）回调。许多解码器要求实际压缩数据流在“编解码器特定数据”之前，即用于初始化编解码器的设置数据，例如在AVC视频情况下为PPS / SPS或在​​vorbis音频情况下为代码表。 MediaExtractor类在名为“csd-0”，“csd-1”的条目中提供特定于编解码器的数据作为返回轨道格式的一部分…可以通过指定标志BUFFER_FLAG_CODEC_CONFIG在start（）或flush（）后直接提交这些缓冲区。但是，如果使用包含这些密钥的MediaFormat配置编解码器，它们将在启动后直接由MediaCodec自动提交。因此，不鼓励使用BUFFER_FLAG_CODEC_CONFIG标志，并且建议仅限高级用户使用。为了表明这是最后一块输入数据（或者除非解码器随后被刷新，否则不会有更多的输入数据出现）指定标志BUFFER_FLAG_END_OF_STREAM。）<br>注意：在Build.VERSION_CODES.M之前，presentationTimeUs没有传播到（呈现的）表面输出缓冲区的帧时间戳，并且结果帧时间戳未定义。 使用releaseOutputBuffer（int，long）来确保设置了特定的帧时间戳。 同样，由于帧时间戳可以被目标表面用于渲染同步，因此必须注意使presentationTimeUs正常化，以便不会误认为系统时间。 （请参阅SurfaceView细节）。   </p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned in a call to dequeueInputBuffer(long).（先前在调用dequeueInputBuffer（long）时返回的客户机拥有的输入缓冲区的索引）<br>offset -》    int: The byte offset into the input buffer at which the data starts.（输入缓冲区中数据开始的字节偏移量）<br>size -》    int: The number of bytes of valid input data.（有效输入数据的字节数）<br>presentationTimeUs -》    long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered). When using an output surface, this will be propagated as the timestamp for the frame (after conversion to nanoseconds).（此缓冲区的呈现时间戳（以微秒为单位）。 这通常是介质缓冲区应呈现（呈现）的介质时间。 使用输出表面时，这将作为帧的时间戳（转换为纳秒后）传播。）<br>flags -》    int: A bitmask of flags BUFFER_FLAG_CODEC_CONFIG and BUFFER_FLAG_END_OF_STREAM. While not prohibited, most codecs do not use the BUFFER_FLAG_KEY_FRAME flag for input buffers.（标志BUFFER_FLAG_CODEC_CONFIG和BUFFER_FLAG_END_OF_STREAM的位掩码。 虽然不禁止，但大多数编解码器不会将BUFFER_FLAG_KEY_FRAME标志用于输入缓冲区。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）<br>MediaCodec.CryptoException     -》 if a crypto object has been specified in configure(MediaFormat, Surface, MediaCrypto, int)（如果在配置中指定了加密对象（MediaFormat，Surface，MediaCrypto，int）  </li>
</ul>
<h4 id="queueSecureInputBuffer"><a href="#queueSecureInputBuffer" class="headerlink" title="queueSecureInputBuffer"></a>queueSecureInputBuffer</h4><p>public void queueSecureInputBuffer (int index, int offset, 、MediaCodec.CryptoInfo info,long presentationTimeUs,int flags)：Similar to queueInputBuffer but submits a buffer that is potentially encrypted. Check out further notes at queueInputBuffer.（与queueInputBuffer类似，但提交可能加密的缓冲区。 在queueInputBuffer中查看进一步的注释。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned input buffer previously returned in a call to dequeueInputBuffer(long).（先前在调用dequeueInputBuffer（long）时返回的客户机拥有的输入缓冲区的索引。）<br>offset -》    int: The byte offset into the input buffer at which the data starts.输入缓冲区中数据开始的字节偏移量）<br>info -》    MediaCodec.CryptoInfo: Metadata required to facilitate decryption, the object can be reused immediately after this call returns.This value must never be null.（为便于解密而需要的元数据，该对象可在此调用返回后立即重用。此值绝不能为空。）<br>presentationTimeUs -》    long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered).（此缓冲区的呈现时间戳（以微秒为单位）。 这通常是介质缓冲区应呈现（呈现）的介质时间。）<br>flags    -》 int: A bitmask of flags BUFFER_FLAG_CODEC_CONFIG and BUFFER_FLAG_END_OF_STREAM. While not prohibited, most codecs do not use the BUFFER_FLAG_KEY_FRAME flag for input buffers.（标志BUFFER_FLAG_CODEC_CONFIG和BUFFER_FLAG_END_OF_STREAM的位掩码。 虽然不禁止，但大多数编解码器不会将BUFFER_FLAG_KEY_FRAME标志用于输入缓冲区。）<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）<br>MediaCodec.CryptoException     -》 if a crypto object has been specified in configure(MediaFormat, Surface, MediaCrypto, int)（如果在配置中指定了加密对象（MediaFormat，Surface，MediaCrypto，int）</li>
</ul>
</li>
</ul>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>public void release ()；Free up resources used by the codec instance. Make sure you call this when you’re done to free up any opened component instance instead of relying on the garbage collector to do this for you at some point in the future.（释放编解码器实例使用的资源。 确保在你完成释放任何打开的组件实例时调用它，而不是依赖垃圾回收器在将来的某个时刻为你做这件事。）</p>
<h4 id="releaseOutputBuffer"><a href="#releaseOutputBuffer" class="headerlink" title="releaseOutputBuffer"></a>releaseOutputBuffer</h4><p>public void releaseOutputBuffer (int index, boolean render)：If you are done with a buffer, use this call to return the buffer to the codec or to render it on the output surface. If you configured the codec with an output surface, setting render to true will first send the buffer to that output surface. The surface will release the buffer back to the codec once it is no longer used/displayed. Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by getOutputBuffer(int) in response to a dequeueOutputBuffer(MediaCodec.BufferInfo, long) return value or a MediaCodec.Callback.onOutputBufferAvailable(MediaCodec, int, MediaCodec.BufferInfo) callback.（如果完成了缓冲区，则使用此调用将缓冲区返回给编解码器或将其呈现在输出表面上。 如果您使用输出表面配置编解码器，将渲染设置为true将首先将缓冲区发送到该输出表面。 一旦不再使用/显示，表面就会将缓冲区释放回编解码器。 一旦输出缓冲区被释放到编解码器，它就不能被使用，直到之后被getOutputBuffer（int）检索以响应dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回值或MediaCodec.Callback.onOutputBufferAvailable（MediaCodec，int ，MediaCodec.BufferInfo）回调。）</p>
<ul>
<li>参数<br>index    -》 int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long).（先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回的客户端拥有的输出缓冲区的索引。）<br>render -》     boolean: If a valid surface was specified when configuring the codec, passing true renders this output buffer to the surface.（如果在配置编解码器时指定了有效曲面，则传递true会将此输出缓冲区渲染到曲面。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="releaseOutputBuffer-1"><a href="#releaseOutputBuffer-1" class="headerlink" title="releaseOutputBuffer"></a>releaseOutputBuffer</h4><p>public void releaseOutputBuffer (int index, long renderTimestampNs)：If you are done with a buffer, use this call to update its surface timestamp and return it to the codec to render it on the output surface. If you have not specified an output surface when configuring this video codec, this call will simply return the buffer to the codec.（如果已完成缓冲区，则使用此调用更新其表面时间戳并将其返回给编解码器以在输出表面上呈现它。 如果您在配置此视频编解码器时尚未指定输出界面，则此调用将简单地将缓冲区返回给编解码器。）<br>The timestamp may have special meaning depending on the destination surface.（时间戳根据目的地表面可能有特殊含义。）<br><strong>SurfaceView specifics</strong><br> If you render your buffer on a SurfaceView, you can use the timestamp to render the buffer at a specific time (at the VSYNC at or after the buffer timestamp). For this to work, the timestamp needs to be reasonably close to the current System.nanoTime(). Currently, this is set as within one (1) second. A few notes:（如果在SurfaceView上渲染缓冲区，则可以使用时间戳在特定时间渲染缓冲区（在缓冲区时间戳之后或之后的VSYNC处）。 为此，时间戳需要相当接近当前的System.nanoTime（）。 目前，这是在一（1）秒内设定的。 一些注意事项：）      </p>
<ul>
<li>the buffer will not be returned to the codec until the timestamp has passed and the buffer is no longer used by the Surface.（该缓冲区将不会返回到编解码器，直到时间戳已经过去并且该缓冲区不再被Surface使用。）</li>
<li>buffers are processed sequentially, so you may block subsequent buffers to be displayed on the Surface. This is important if you want to react to user action, e.g. stop the video or seek.（缓冲区会按顺序处理，因此您可能会阻止后续缓冲区显示在Surface上。 如果您想对用户操作做出反应，这很重要。 停止视频或寻求。）</li>
<li>if multiple buffers are sent to the Surface to be rendered at the same VSYNC, the last one will be shown, and the other ones will be dropped.（如果将多个缓冲区发送到要在同一个VSYNC上渲染的Surface，则会显示最后一个缓冲区，其他则会被放弃。）</li>
<li>if the timestamp is not “reasonably close” to the current system time, the Surface will ignore the timestamp, and display the buffer at the earliest feasible time. In this mode it will not drop frames.（如果时间戳不与当前系统时间“合理接近”，Surface将忽略时间戳，并在最早的可行时间显示缓冲区。 在这种模式下，它不会丢帧。）</li>
<li>for best performance and quality, call this method when you are about two VSYNCs’ time before the desired render time. For 60Hz displays, this is about 33 msec.（为获得最佳性能和质量，当您在所需渲染时间之前约两个VSYNC的时间时调用此方法。 对于60Hz的显示器，这是大约33毫秒。）</li>
</ul>
<p>Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by getOutputBuffer(int) in response to a dequeueOutputBuffer(MediaCodec.BufferInfo, long) return value or a MediaCodec.Callback.onOutputBufferAvailable(MediaCodec, int, MediaCodec.BufferInfo) callback.（一旦输出缓冲区被释放到编解码器，它就不能被使用，直到之后被getOutputBuffer（int）检索以响应dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回值或MediaCodec.Callback.onOutputBufferAvailable（MediaCodec，int ，MediaCodec.BufferInfo）回调。）</p>
<ul>
<li>参数<br>index -》    int: The index of a client-owned output buffer previously returned from a call to dequeueOutputBuffer(MediaCodec.BufferInfo, long).（他先前从调用dequeueOutputBuffer（MediaCodec.BufferInfo，long）返回的客户端拥有的输出缓冲区的索引，）<br>renderTimestampNs -》     long: The timestamp to associate with this buffer when it is sent to the Surface.（发送到Surface时与此缓冲区关联的时间戳。）</li>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>public void reset ()：Returns the codec to its initial (Uninitialized) state. Call this if an unrecoverable error has occured to reset the codec to its initial state after creation.（将编解码器返回到其初始（未初始化）状态。 如果在创建后发生不可恢复的错误以将编解码器重置为其初始状态，请调用此函数。）</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.（如果不处于执行状态）<br>MediaCodec.CodecException  -》     upon codec error.（编解码器错误。）</li>
</ul>
<h4 id="setCallback"><a href="#setCallback" class="headerlink" title="setCallback"></a>setCallback</h4><p>public void setCallback (MediaCodec.Callback cb,Handler handler)：Sets an asynchronous callback for actionable MediaCodec events. If the client intends to use the component in asynchronous mode, a valid callback should be provided before configure(MediaFormat, Surface, MediaCrypto, int) is called. When asynchronous callback is enabled, the client should not call getInputBuffers(), getOutputBuffers(), dequeueInputBuffer(long) or dequeueOutputBuffer(BufferInfo, long).<br>Also, flush() behaves differently in asynchronous mode. After calling flush, you must call start() to “resume” receiving input buffers, even if an input surface was created.（为可操作的MediaCodec事件设置异步回调。 如果客户端打算以异步模式使用组件，则应在调用configure（MediaFormat，Surface，MediaCrypto，int）之前提供有效的回调。 启用异步回调时，客户端不应调用getInputBuffers（），getOutputBuffers（），dequeueInputBuffer（long）或dequeueOutputBuffer（BufferInfo，long）。<br>另外，flush（）在异步模式下表现不同。 在调用flush之后，即使创建了输入曲面，也必须调用start（）来“继续”接收输入缓冲区。）</p>
<ul>
<li>参数<br>cb -》    MediaCodec.Callback: The callback that will run. Use null to clear a previously set callback (before configure is called and run in synchronous mode).（将运行的回调。 使用null清除先前设置的回调（在调用configure并在同步模式下运行之前）。）<br>handler    -》 Handler: Callbacks will happen on the handler’s thread. If null, callbacks are done on the default thread (the caller’s thread or the main thread.)（回调将在处理程序的线程上发生。 如果为null，则在默认线程（调用者线程或主线程）上完成回调。）</li>
</ul>
<h4 id="setCallback-1"><a href="#setCallback-1" class="headerlink" title="setCallback"></a>setCallback</h4><p>public void setCallback (MediaCodec.Callback cb)：Sets an asynchronous callback for actionable MediaCodec events on the default looper.Same as setCallback(Callback, Handler) with handler set to null.</p>
<h4 id="setInputSurface"><a href="#setInputSurface" class="headerlink" title="setInputSurface"></a>setInputSurface</h4><p>public void setInputSurface (Surface surface)：Configures the codec (e.g. encoder) to use a persistent input surface in place of input buffers. This may only be called after configure(MediaFormat, Surface, MediaCrypto, int) and before start(), in lieu of createInputSurface().（配置编解码器（例如编码器）以使用持久输入表面代替输入缓冲器。 这只能在configure（MediaFormat，Surface，MediaCrypto，int）和start（）之前调用，而不是createInputSurface（）。）</p>
<ul>
<li>参数<br>surface -》    Surface: a persistent input surface created by createPersistentInputSurface()，This value must never be null.（由createPersistentInputSurface（）创建的持久性输入表面，该值不能为空。）</li>
<li>异常<br>IllegalStateException  -》    if not in the Configured state or does not require an input surface.（如果不处于配置状态或不需要输入表面。）<br>IllegalArgumentException -》    if the surface was not created by createPersistentInputSurface(). （如果表面不是由createPersistentInputSurface（）创建的。）</li>
</ul>
<h4 id="setOnFrameRenderedListener"><a href="#setOnFrameRenderedListener" class="headerlink" title="setOnFrameRenderedListener"></a>setOnFrameRenderedListener</h4><p>public void setOnFrameRenderedListener (MediaCodec.OnFrameRenderedListener listener, Handler handler)：Registers a callback to be invoked when an output frame is rendered on the output surface.This method can be called in any codec state, but will only have an effect in the Executing state for codecs that render buffers to the output surface.<br>Note: This callback is for informational purposes only: to get precise render timing samples, and can be significantly delayed and batched. Some frames may have been rendered even if there was no callback generated.（注册在输出表面上呈现输出帧时调用的回调函数。可以在任何编解码器状态中调用此方法，但仅对于将缓冲区呈现到输出表面的编解码器在执行状态中起作用。<br>注意：此回调仅用于提供信息：获取精确的渲染时间采样，并且可以显着延迟和批处理。 即使没有生成回调，某些帧可能已经被渲染。）</p>
<ul>
<li>参数<br>listener     -》 MediaCodec.OnFrameRenderedListener: the callback that will be run，This value may be null.<br>handler -》    Handler: the callback will be run on the handler’s thread. If null, the callback will be run on the default thread, which is the looper from which the codec was created, or a new thread if there was none.</li>
</ul>
<h4 id="setOutputSurface"><a href="#setOutputSurface" class="headerlink" title="setOutputSurface"></a>setOutputSurface</h4><p>public void setOutputSurface (Surface surface)：Dynamically sets the output surface of a codec.This can only be used if the codec was configured with an output surface. The new output surface should have a compatible usage type to the original output surface. E.g. codecs may not support switching from a SurfaceTexture (GPU readable) output to ImageReader (software readable) output.（动态设置编解码器的输出表面。仅当编解码器配置有输出表面时才能使用此选项。 新的输出表面应与原始输出表面具有兼容的使用类型。 例如。 编解码器可能不支持从SurfaceTexture（GPU可读）输出切换到ImageReader（软件可读）输出。）</p>
<ul>
<li>参数<br>surface -》    Surface: the output surface to use. It must not be null.</li>
<li>异常<br>IllegalStateException -》    if the codec does not support setting the output surface in the current state.<br>IllegalArgumentException -》    if the new surface is not of a suitable type for the codec.</li>
</ul>
<h4 id="setParameters"><a href="#setParameters" class="headerlink" title="setParameters"></a>setParameters</h4><p>public void setParameters (Bundle params)：Communicate additional parameter changes to the component instance. Note: Some of these parameter changes may silently fail to apply.</p>
<ul>
<li>参数<br>params    -》Bundle: The bundle of parameters to set.This value may be null.</li>
<li>异常<br>IllegalStateException    if in the Released state.  </li>
</ul>
<h4 id="setVideoScalingMode"><a href="#setVideoScalingMode" class="headerlink" title="setVideoScalingMode"></a>setVideoScalingMode</h4><p>public void setVideoScalingMode (int mode)：If a surface has been specified in a previous call to configure(MediaFormat, Surface, MediaCrypto, int) specifies the scaling mode to use. The default is “scale to fit”.</p>
<p><strong> ⚠️ </strong> The scaling mode may be reset to the default each time an INFO_OUTPUT_BUFFERS_CHANGED event is received from the codec; therefore, the client must call this method after every buffer change event (and before the first output buffer is released for rendering) to ensure consistent scaling mode.<br><strong> ⚠️ </strong> Since the INFO_OUTPUT_BUFFERS_CHANGED event is deprecated, this can also be done after each INFO_OUTPUT_FORMAT_CHANGED event.</p>
<ul>
<li>参数<br>mode -》     int</li>
<li>异常<br>IllegalArgumentException -》    if mode is not recognized.<br>IllegalStateException -》    if in the Released state.</li>
</ul>
<h4 id="signalEndOfInputStream"><a href="#signalEndOfInputStream" class="headerlink" title="signalEndOfInputStream"></a>signalEndOfInputStream</h4><p>public void signalEndOfInputStream ()：Signals end-of-stream on input. Equivalent to submitting an empty buffer with BUFFER_FLAG_END_OF_STREAM set. This may only be used with encoders receiving input from a Surface created by createInputSurface().</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Executing state.<br>MediaCodec.CodecException    -》 upon codec error.</li>
</ul>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p>public void start ()：After successfully configuring the component, call start.Call start also if the codec is configured in asynchronous mode, and it has just been flushed, to resume requesting input buffers.</p>
<ul>
<li>异常<br>IllegalStateException -》    if not in the Configured state or just after flush() for a codec that is configured in asynchronous mode.<br>MediaCodec.CodecException -》    upon codec error. Note that some codec errors for start may be attributed to future method calls.</li>
</ul>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>public void stop ()：Finish the decode/encode session, note that the codec instance remains active and ready to be start()ed again. To ensure that it is available to other client call release() and don’t just rely on garbage collection to eventually do this for you.</p>
<ul>
<li>异常<br>IllegalStateException -》    if in the Released state.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/02/Android音视频操作使用到的类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/Android音视频操作使用到的类/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T09:45:33+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>音视频处理涉及到的类api</p>
<h3 id="MediaFormat"><a href="#MediaFormat" class="headerlink" title="MediaFormat"></a>MediaFormat</h3><p>官方描述：Encapsulates the information describing the format of media data, be it audio or video. The format of the media data is specified as string/value pairs。added in API level 16。 public final class MediaFormat extends Object。<br>译文：封装描述媒体数据格式的信息，无论是音频还是视频。 媒体数据的格式被指定为字符串/值对。</p>
<h3 id="MediaMuxer"><a href="#MediaMuxer" class="headerlink" title="MediaMuxer"></a>MediaMuxer</h3><p>官方描述：MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4, Webm and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat. added in API level 18。public final class MediaMuxer extends Object。<br>译文：MediaMuxer有助于混合基本流。 目前MediaMuxer支持MP4，Webm和3GP文件作为输出。 自从Android Nougat以来，它还支持MP4中的M帧B帧。<br>其一般的用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MediaMuxer muxer = <span class="keyword">new</span> MediaMuxer(<span class="string">"temp.mp4"</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"><span class="comment">// More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat()</span></span><br><span class="line"><span class="comment">// or MediaExtractor.getTrackFormat().</span></span><br><span class="line">MediaFormat audioFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line">MediaFormat videoFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"><span class="keyword">int</span> audioTrackIndex = muxer.addTrack(audioFormat);</span><br><span class="line"><span class="keyword">int</span> videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line">ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);</span><br><span class="line"><span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">BufferInfo bufferInfo = <span class="keyword">new</span> BufferInfo();</span><br><span class="line"></span><br><span class="line">muxer.start();</span><br><span class="line"><span class="keyword">while</span>(!finished) &#123;</span><br><span class="line">  <span class="comment">// getInputBuffer() will fill the inputBuffer with one frame of encoded</span></span><br><span class="line">  <span class="comment">// sample from either MediaCodec or MediaExtractor, set isAudioSample to</span></span><br><span class="line">  <span class="comment">// true when the sample is audio data, set up all the fields of bufferInfo,</span></span><br><span class="line">  <span class="comment">// and return true if there are no more samples.</span></span><br><span class="line">  finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);</span><br><span class="line">  <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">    <span class="keyword">int</span> currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;</span><br><span class="line">    muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">muxer.stop();</span><br><span class="line">muxer.release();</span><br></pre></td></tr></table></figure></p>
<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>public class Surface extends Object implements Parcelable：Handle onto a raw buffer that is being managed by the screen compositor.A Surface is generally created by or from a consumer of image buffers (such as a SurfaceTexture, MediaRecorder, or Allocation), and is handed to some kind of producer (such as OpenGL, MediaPlayer, or CameraDevice) to draw into.</p>
<p>Note: A Surface acts like a weak reference to the consumer it is associated with. By itself it will not keep its parent consumer from being reclaimed.<br>（处理由屏幕合成器管理的原始缓冲区。surface通常由图像缓冲区（例如SurfaceTexture，MediaRecorder或Allocation）的使用者创建或从图像缓冲区的消费者创建，并被传递给某种生产者（例如OpenGL，MediaPlayer或CameraDevice）以进行绘制。<br>注意：Surface表示对与其关联的使用者的弱引用。 它本身不会让其父母消费者不被收回。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/28/Android音视频处理之MediaExtractor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/Android音视频处理之MediaExtractor/" itemprop="url">Android音视频处理之MediaExtractor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:29:55+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android提供了一个MediaExtractor类，可以用来分离容器中的视频track和音频track，下面的例子展示了使用MediaExtractor和MediaMuxer来实现视频的换音：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">muxingAudioAndVideo</span><span class="params">(String videoPath, String audioPath, String outputPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        MediaMuxer mediaMuxer = <span class="keyword">new</span> MediaMuxer(outputPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//视频的MediaExtractor</span></span><br><span class="line">        MediaExtractor videoExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">        videoExtractor.setDataSource(videoPath);</span><br><span class="line">        <span class="keyword">int</span> videoTrackIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; videoExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">            MediaFormat format = videoExtractor.getTrackFormat(i);</span><br><span class="line">            <span class="keyword">if</span> (format.getString(MediaFormat.KEY_MIME).startsWith(<span class="string">"video"</span>)) &#123;</span><br><span class="line">                videoExtractor.selectTrack(i);</span><br><span class="line">                videoTrackIndex = mediaMuxer.addTrack(format);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//音频的MediaExtractor</span></span><br><span class="line">        MediaExtractor audioExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">        audioExtractor.setDataSource(audioPath);</span><br><span class="line">        <span class="keyword">int</span> audioTrackIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; audioExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">            MediaFormat format = audioExtractor.getTrackFormat(i);</span><br><span class="line">            <span class="keyword">if</span> (format.getString(MediaFormat.KEY_MIME).startsWith(<span class="string">"audio"</span>)) &#123;</span><br><span class="line">                audioExtractor.selectTrack(i);</span><br><span class="line">                audioTrackIndex = mediaMuxer.addTrack(format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加完所有轨道后start</span></span><br><span class="line">        mediaMuxer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装视频track</span></span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> != videoTrackIndex) &#123;</span><br><span class="line">            MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">            info.presentationTimeUs = <span class="number">0</span>;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sampleSize = videoExtractor.readSampleData(buffer, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                info.offset = <span class="number">0</span>;</span><br><span class="line">                info.size = sampleSize;</span><br><span class="line">                info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;</span><br><span class="line">                info.presentationTimeUs = videoExtractor.getSampleTime();</span><br><span class="line">                mediaMuxer.writeSampleData(videoTrackIndex, buffer, info);</span><br><span class="line"></span><br><span class="line">                videoExtractor.advance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装音频track</span></span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> != audioTrackIndex) &#123;</span><br><span class="line">            MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">            info.presentationTimeUs = <span class="number">0</span>;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span> * <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sampleSize = audioExtractor.readSampleData(buffer, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                info.offset = <span class="number">0</span>;</span><br><span class="line">                info.size = sampleSize;</span><br><span class="line">                info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;</span><br><span class="line">                info.presentationTimeUs = audioExtractor.getSampleTime();</span><br><span class="line">                mediaMuxer.writeSampleData(audioTrackIndex, buffer, info);</span><br><span class="line"></span><br><span class="line">                audioExtractor.advance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放MediaExtractor</span></span><br><span class="line">        videoExtractor.release();</span><br><span class="line">        audioExtractor.release();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放MediaMuxer</span></span><br><span class="line">        mediaMuxer.stop();</span><br><span class="line">        mediaMuxer.release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MediaExtractor的接口比较简单，首先通过 <strong>setDataSource()设置数据源</strong>，数据源可以是本地文件地址，也可以是网络地址：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor mVideoExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">mVideoExtractor.setDataSource(mVideoPath);</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过getTrackFormat(int index)来获取各个track的 <strong>MediaFormat，通过MediaFormat来获取track的详细信息</strong>，如：<strong>MimeType、分辨率、采样频率、帧率</strong> 等等,其内部就是一个map对象，通过key获取对应的信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVideoExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">    MediaFormat format = mVideoExtractor.getTrackFormat(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取到track的详细信息后，通过selectTrack(int index)选择指定的通道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (format.getString(MediaFormat.KEY_MIME).startsWith(<span class="string">"video/"</span>)) &#123;</span><br><span class="line">    mVideoExtractor.selectTrack(i);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指定通道之后就可以从MediaExtractor中读取数据了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> sampleSize = mVideoExtractor.readSampleData(buffer, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mVideoExtractor.advance(); <span class="comment">// 移动到下一帧</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在读取结束之后，记得释放资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mVideoExtractor.release();</span><br></pre></td></tr></table></figure></p>
<p>问题：  </p>
<ol>
<li>Android MediaExtractor readSampleData IllegalArgumentException<br>视频采样的时候报的错误，主要视频的采用buffer设置的可能小了，开始设置的是100K，后来提到1M就没有问题；<br>参考地址：<a href="https://stackoverflow.com/questions/33148629/android-mediaextractor-readsampledata-illegalargumentexception" target="_blank" rel="noopener">https://stackoverflow.com/questions/33148629/android-mediaextractor-readsampledata-illegalargumentexception</a>  </li>
<li>MPEG4Writer: Unsupported mime ‘audio/mpeg’<br>一开始使用的是mp3音频，显示不支持，后来换成m4a就没有问题，后期在看下MPEG4Writer支持什么音频格式！！！<br>参考地址： <a href="http://www.cnblogs.com/rockylearnstodevelop/p/5353717.html" target="_blank" rel="noopener">http://www.cnblogs.com/rockylearnstodevelop/p/5353717.html</a></li>
</ol>
<p>拓展：</p>
<ol>
<li><p>关于Android读取assert下的资源文件<br>Android 中资源分为两种,一种是res下可编译的资源文件, 这种资源文件系统会在R.java里面自动生成该资源文件的ID，访问也很简单,只需要调用R.XXX.id即可;第二种就是放在assets文件夹下面的原生资源文件,assets文件夹里面的文件都是保持原始的文件格式,放在这个文件夹下面的文件不会被R文件编译,所以不能像第一种那样直接使用.Android提供了一个工具类,方便我们操作获取assets文件下的文件:AssetManager,需要用AssetManager以字节流的形式读取文件。其主要步骤是：</p>
<ul>
<li>获取Context然后调用getAssets()来获取AssetManager引用。</li>
<li>再用AssetManager的open（String fileName,int accessMode）方法并指定要读取的文件名称以及访<br>问模式来获取输入流InputStream。</li>
<li>用InputStream读取文件，读取完后需要InputStream.close();</li>
<li>最后调用AssetManager的close（）方法关闭AssetManager。</li>
</ul>
</li>
<li><p>AssetManager提供了如下方法用于处理assets：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] list(String path);<span class="comment">//列出该目录下的下级文件和文件夹名称</span></span><br><span class="line"></span><br><span class="line">   <span class="function">InputStream <span class="title">open</span><span class="params">(String fileName)</span></span>;<span class="comment">//以顺序读取模式打开文件，默认模式为ACCESS_STREAMING</span></span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">open</span><span class="params">(String fileName, <span class="keyword">int</span> accessMode)</span></span>;<span class="comment">//以指定模式打开文件。读取模式有以下几种：</span></span><br><span class="line">                                       <span class="comment">//ACCESS_UNKNOWN : 未指定具体的读取模式</span></span><br><span class="line">                                       <span class="comment">//ACCESS_RANDOM : 随机读取</span></span><br><span class="line">                                       <span class="comment">//ACCESS_STREAMING : 顺序读取</span></span><br><span class="line">                                       <span class="comment">//ACCESS_BUFFER : 缓存读取</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span><span class="comment">//关闭AssetManager实例</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br>assets目录下主要存放四种文件：文本文件、图像文件、网页文件（包括html中引用的js/ccs/jpg等资源）、音频视频文件,下面通过具体的案例分别来说下怎么获取</p>
<ul>
<li>加载assets目录下的网页<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(<span class="string">"file:///android_asset/html/index.htmll"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>说明：这种方式可以加载assets目录下的网页，并且与网页有关的css，js，图片等文件也会的加载。</p>
<ul>
<li><p>加载assets目录下的图片资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getAssets().open(fileName);  </span><br><span class="line">bitmap = BitmapFactory.decodeStream(is);</span><br><span class="line">ivImg.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载assets目录下文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getAssets().open(fileName);  </span><br><span class="line"><span class="keyword">int</span> lenght = is.available();  </span><br><span class="line"><span class="keyword">byte</span>[]  buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[lenght];  </span><br><span class="line">is.read(buffer);  </span><br><span class="line">String result = = <span class="keyword">new</span> String(buffer, <span class="string">"utf8"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载assets目录下音乐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开指定音乐文件,获取assets目录下指定文件的AssetFileDescriptor对象  </span></span><br><span class="line">AssetFileDescriptor afd = am.openFd(music);  </span><br><span class="line">mPlayer.reset();  </span><br><span class="line"><span class="comment">// 使用MediaPlayer加载指定的声音文件。  </span></span><br><span class="line">mPlayer.setDataSource(afd.getFileDescriptor(),  </span><br><span class="line">    afd.getStartOffset(), afd.getLength());  </span><br><span class="line"><span class="comment">// 准备声音  </span></span><br><span class="line">mPlayer.prepare();  </span><br><span class="line"><span class="comment">// 播放  </span></span><br><span class="line">mPlayer.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>补充下:Android中还有另外一个文件夹raw,和assets差不多,也不会被R文件编译,但是raw下不能在建文件夹,assets文件下是可以在建文件夹的,下面是获取raw文件夹下资源的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getResources().openRawResource(R.id.filename);</span><br></pre></td></tr></table></figure></p>
<p>将assets下的文件复制到SD卡中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  从assets目录中复制整个文件夹内容  </span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  context  Context 使用CopyFiles类的Activity</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  oldPath  String  原文件路径  如：/aa  </span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  newPath  String  复制后路径  如：xx:/bb/cc  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFilesFassets</span><span class="params">(Context context,String oldPath,String newPath)</span> </span>&#123;                      </span><br><span class="line">         <span class="keyword">try</span> &#123;  </span><br><span class="line">        String fileNames[] = context.getAssets().list(oldPath);<span class="comment">//获取assets目录下的所有文件及目录名  </span></span><br><span class="line">        <span class="keyword">if</span> (fileNames.length &gt; <span class="number">0</span>) &#123;<span class="comment">//如果是目录  </span></span><br><span class="line">            File file = <span class="keyword">new</span> File(newPath);  </span><br><span class="line">            file.mkdirs();<span class="comment">//如果文件夹不存在，则递归  </span></span><br><span class="line">            <span class="keyword">for</span> (String fileName : fileNames) &#123;  </span><br><span class="line">               copyFilesFassets(context,oldPath + <span class="string">"/"</span> + fileName,newPath+<span class="string">"/"</span>+fileName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是文件  </span></span><br><span class="line">            InputStream is = context.getAssets().open(oldPath);  </span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(newPath));  </span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">            <span class="keyword">int</span> byteCount=<span class="number">0</span>;                 </span><br><span class="line">            <span class="keyword">while</span>((byteCount=is.read(buffer))!=-<span class="number">1</span>) &#123;<span class="comment">//循环从输入流读取 buffer字节          </span></span><br><span class="line">                fos.write(buffer, <span class="number">0</span>, byteCount);<span class="comment">//将读取的输入流写入到输出流  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            fos.flush();<span class="comment">//刷新缓冲区  </span></span><br><span class="line">            is.close();  </span><br><span class="line">            fos.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">        <span class="comment">//如果捕捉到错误则通知UI线程  </span></span><br><span class="line">                   MainActivity.handler.sendEmptyMessage(COPY_FALSE);  </span><br><span class="line">    &#125;                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>补充</strong>：Android获取assets或者raw目录的视频文件路径播放视频<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String mp4FilePath = <span class="string">"file:///android_asset/Kotlin与ava共存.mp4"</span>;</span><br><span class="line">mVideoView = (VideoView) findViewById(R.id.mVideoView);</span><br><span class="line">mVideoView.setVideoPath(mp4FilePath);</span><br><span class="line">mVideoView.start();</span><br></pre></td></tr></table></figure></p>
<p>会提示播放失败。因为通过assets目录构造URI，不能用来播放视频，也不能播放音频。在raw目录下的文件构造URI可以播放音频，也能播放视频。 .<br>正确的是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String uri = <span class="string">"android.resource://"</span> + getPackageName() + <span class="string">"/"</span> + R.raw.video;</span><br><span class="line">mVideoView = (VideoView) findViewById(R.id.mVideoView);</span><br><span class="line">mVideoView.setVideoPath(uri);</span><br><span class="line"><span class="comment">//mVideoView.setVideoPath(uri);</span></span><br><span class="line">mVideoView.setVideoURI(Uri.parse(uri));</span><br><span class="line">mVideoView.start();</span><br></pre></td></tr></table></figure></p>
<p>参考：<br>[1] Android中读取assets目录下的文件详细介绍 <a href="https://blog.csdn.net/greathfs/article/details/52123984" target="_blank" rel="noopener">https://blog.csdn.net/greathfs/article/details/52123984</a><br>[2] assets文件读取 <a href="https://www.cnblogs.com/wgscd/p/6738818.html" target="_blank" rel="noopener">https://www.cnblogs.com/wgscd/p/6738818.html</a><br>[3] asset视频播放 <a href="https://blog.csdn.net/e_inch_photo/article/details/78306785?utm_source=debugrun&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/e_inch_photo/article/details/78306785?utm_source=debugrun&amp;utm_medium=referral</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/27/Android_o_notification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/Android_o_notification/" itemprop="url">Android o 中Notification使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T10:43:05+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;随着Android 8.0的发布，google更新了Notification内容，新增了通知渠道这个概念，用来对通知进行分类管理，以提高用户体验。关于Android 8.0中NotificationChannel的管理在《设置》-》《应用管理》-》《具体应用》-》《通知》或者 《设置》-》《通知》（具体应手机不同可能略有差异）就可以看到应用已经设置的通知渠道，这里可以对不同渠道通知管理。</p>
<h3 id="创建NotificationChannl"><a href="#创建NotificationChannl" class="headerlink" title="创建NotificationChannl"></a>创建NotificationChannl</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过NotificationManager的createNotificationChannel方法来创建NotificationChannel：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">(String id, String name, <span class="keyword">int</span> importance, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mNotificationManager.getNotificationChannel(id) != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        NotificationChannel notificationChannel = <span class="keyword">new</span> NotificationChannel(id, name, importance);</span><br><span class="line">        notificationChannel.enableLights(<span class="keyword">true</span>);</span><br><span class="line">        notificationChannel.enableVibration(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        notificationChannel.setLightColor(Color.RED);</span><br><span class="line">        notificationChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);</span><br><span class="line">        notificationChannel.setShowBadge(<span class="keyword">true</span>);</span><br><span class="line">        notificationChannel.setBypassDnd(<span class="keyword">true</span>);</span><br><span class="line">        notificationChannel.setVibrationPattern(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;);</span><br><span class="line">        notificationChannel.setDescription(desc);</span><br><span class="line"></span><br><span class="line">        mNotificationManager.createNotificationChannel(notificationChannel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>NotificationChannel 的方法列表：</p>
<ul>
<li>getId() — 获取 ChannleId</li>
<li>enableLights() — 开启指示灯，如果设备有的话。</li>
<li>setLightColor() — 设置指示灯颜色</li>
<li>enableVibration() — 开启震动</li>
<li>setVibrationPattern() — 设置震动频率</li>
<li>setImportance() — 设置频道重要性</li>
<li>getImportance() — 获取频道重要性</li>
<li>setSound() — 设置声音</li>
<li>getSound() — 获取声音</li>
<li>setGroup() — 设置 ChannleGroup</li>
<li>getGroup() — 得到 ChannleGroup</li>
<li>setBypassDnd() — 设置绕过免打扰模式</li>
<li>canBypassDnd() — 检测是否绕过免打扰模式</li>
<li>getName() — 获取名称</li>
<li>setLockScreenVisibility() — 设置是否应在锁定屏幕上显示此频道的通知</li>
<li>getLockscreenVisibility() — 检测是否应在锁定屏幕上显示此频道的通知</li>
<li>setShowBadge() 设置是否显示角标</li>
<li>canShowBadge() — 检测是否显示角标</li>
</ul>
<p>以上属性表示了隶属这个渠道的通知显示效果。</p>
<h4 id="setImportance-重要程度"><a href="#setImportance-重要程度" class="headerlink" title="setImportance 重要程度"></a>setImportance 重要程度</h4><p>越高，提示权限就越高，最高的支持发出声音&amp;悬浮通知。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_DEFAULT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_HIGH = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_LOW = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_MAX = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_MIN = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_NONE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_UNSPECIFIED = -<span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除-NotificationChannel"><a href="#删除-NotificationChannel" class="headerlink" title="删除 NotificationChannel"></a>删除 NotificationChannel</h4><p>通过 NotificationManager 的 deleteNotificationChannel 方法来删除 NotificationChannel。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.deleteNotificationChannel(chatChannelId);</span><br></pre></td></tr></table></figure></p>
<h4 id="发出通知"><a href="#发出通知" class="headerlink" title="发出通知"></a>发出通知</h4><p>只需要设置一个 ChannelId 即可发布到对应的 Channel 上，需要注意的是 NotificationChannel 一定要先创建才行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>, chatChannelId);</span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentTitle(<span class="string">"Gavin"</span>)</span><br><span class="line">        .setContentText(<span class="string">"Today released Android 8.0 version of its name is Oreo"</span>)</span><br><span class="line">        .setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Intent resultIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">TaskStackBuilder stackBuilder = TaskStackBuilder.create(<span class="keyword">this</span>);</span><br><span class="line">stackBuilder.addParentStack(MainActivity.class);</span><br><span class="line">stackBuilder.addNextIntent(resultIntent);</span><br><span class="line">PendingIntent resultPendingIntent = stackBuilder.getPendingIntent(<span class="number">0</span>, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">builder.setContentIntent(resultPendingIntent);</span><br><span class="line"></span><br><span class="line">mNotificationManager.notify((<span class="keyword">int</span>) System.currentTimeMillis(), builder.build());</span><br></pre></td></tr></table></figure></p>
<h4 id="角标管理"><a href="#角标管理" class="headerlink" title="角标管理"></a>角标管理</h4><p>首先要开启允许使用通知圆点，这个是用户可以取消的，如果要显示一定要代码中保证是开启状态。</p>
<ol>
<li><p>NotificationChannel 开启角标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notificationChannel.setShowBadge(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Notification 设置角标样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(this, chatChannelId).setBadgeIconType(BADGE_ICON_SMALL)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Notification 设置角标计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(this, chatChannelId).setNumber(1)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="跳转设置"><a href="#跳转设置" class="headerlink" title="跳转设置"></a>跳转设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">intent.putExtra(Settings.EXTRA_CHANNEL_ID, chatChannelId);</span><br><span class="line">intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<h3 id="使用-NotificationChannleGroup"><a href="#使用-NotificationChannleGroup" class="headerlink" title="使用 NotificationChannleGroup"></a>使用 NotificationChannleGroup</h3><p>如果你的通知渠道比较多，那么久可以考虑使用 NotificationChannleGroup 来管理一下  。</p>
<h4 id="创建-NotificationChannleGroup"><a href="#创建-NotificationChannleGroup" class="headerlink" title="创建 NotificationChannleGroup"></a>创建 NotificationChannleGroup</h4><p>和创建 NotificationChannle 类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.createNotificationChannelGroup(new NotificationChannelGroup(groupId, groupName));</span><br></pre></td></tr></table></figure></p>
<h4 id="NotificationChannle-绑定-groupId"><a href="#NotificationChannle-绑定-groupId" class="headerlink" title="NotificationChannle 绑定 groupId"></a>NotificationChannle 绑定 groupId</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notificationChannel.setGroup(groupId);</span><br></pre></td></tr></table></figure>
<h4 id="删除-NotificationChannleGroup"><a href="#删除-NotificationChannleGroup" class="headerlink" title="删除 NotificationChannleGroup"></a>删除 NotificationChannleGroup</h4><p>可以批量删除该 Group 下的所有 Channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.deleteNotificationChannelGroup(groupId2);</span><br></pre></td></tr></table></figure>
<p>参考地址：<br>[1]. NotificationChannl运用 <a href="http://gavinliu.cn/2017/08/22/Android-%E5%90%83%E5%A5%A5%E5%88%A9%E5%A5%A5%E7%B3%BB%E5%88%97-1-Notification/" target="_blank" rel="noopener">http://gavinliu.cn/2017/08/22/Android-%E5%90%83%E5%A5%A5%E5%88%A9%E5%A5%A5%E7%B3%BB%E5%88%97-1-Notification/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/22/androidCamera2使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/androidCamera2使用/" itemprop="url">androidCamera2使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T13:39:38+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Camera2-介绍"><a href="#Camera2-介绍" class="headerlink" title="Camera2 介绍"></a>Camera2 介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从android5.0开始对相机的API进行了全新的设计，这些API都在android.hardware.camera2包下，也是为了区分之前的API，新API不仅大幅提高了Android系统拍照等功能，还支持RAW照片输出，甚至允许程序调整相机的对焦模式、曝光模式、快门等。官网给出的说明如下：<br>Camera2 API  </p>
<ul>
<li>Supports 30fps full resolution with burst mode<br>支持30fps的全高清连拍</li>
<li>Supports change on manual camera settings between frame capture<br>支持帧之间的手动设置</li>
<li>Supports RAW image capture<br>支持RAW格式的图片拍摄</li>
<li>Supports Zero Shutter Lag &amp; Movie Snapshot<br>支持快门0延迟以及电影速拍</li>
<li>Supports setting other manual camera device controls including level of Noise Cancelling<br>支持相机其他方面的手动控制包括噪音消除的级别</li>
</ul>
<ol>
<li><p>Camera2工作流程示意图：<br><img src="/images/Camera2Flow.png" alt="camera2流程示意图"><br>&nbsp;&nbsp;&nbsp;&nbsp;Google采用了pipeline（管道）的概念，将Camera Device相机设备和Android Device安卓设备连接起来， Android Device通过管道发送CaptureRequest拍照请求给Camera Device，Camera Device通过管道返回CameraMetadata数据给Android Device，这一切建立在一个叫作CameraCaptureSession的会话中。  </p>
</li>
<li><p>Camera2类图：<br><img src="/images/Camera2Classes.png" alt="camera2类图"><br>&nbsp;&nbsp;&nbsp;&nbsp;其中CameraManager是所有相机设备（CameraDevice）的管理者，而每个CameraDevice自己会负责建立CameraCaptureSession以及建立CaptureRequest。CameraCharacteristics是CameraDevice的属性描述类，在CameraCharacteristics中可以进行相机设备功能的详细设定（当然了，首先你得确定你的相机设备支持这些功能才行）类图中有着三个重要的callback，其中CameraCaptureSession.CaptureCallback将处理预览和拍照图片的工作，需要重点对待。</p>
</li>
</ol>
<p>以上的类是如何相互配合的？下面是拍照的流程图：<br><img src="/images/Camera2Step.png" alt="camera2类图">       </p>
<ol>
<li>调用openCamera方法后会回调CameraDevice.StateCallback方法，该方法重写onPened函数；</li>
<li>在onOpened方法中调用createCaptureSession方法，该方法又回调CameraCaptureSession.StateCallback方法。</li>
<li>在CameraCaptureSession.StateCallback中重写onConfigured方法，设置setRepeatingRequest方法（也即开启预览）；</li>
<li>在setRepeatingRequest又会回调CameraCaptureSession.CaptureCallback方法；</li>
<li>重写CameraCaptureSession.CaptureCallback中的onCaptureCompleted方法，result就是未经过处理的元数据；  </li>
</ol>
<p>其中onCaptureProgressed方法很明显是在Capture过程中的，也就是在onCaptureCompleted之前，所以，在这之前相对图像干什么就看你的了，像美颜等操作就可以在这个方法中实现了。  </p>
<p>由此也可以看出Camera2相机使用还是简单的，其实就是3个Callback函数的回调，先说一下：setRepeatingRequest和capture方法其实都是向相机设备发送获取图像的请求，但是capture就获取那么一次，而setRepeatingRequest就是不停的获取图像数据，所以呢，使用capture就想拍照一样，图像就停在那里了，但是setRepeatingRequest一直在发送和获取，所以需要连拍的时候就调用它，然后在onCaptureCompleted中保存图像就行了。（注意了，图像的预览也是用的setRepeatingRequest，只要不处理数据就行了），从上面我们也了解到Camera2运用主要用到这些类：CameraManager、CameraDevice、CameraCharacteristics、CameraRequest与CameraRequest.Builder、CameraCaptureSession以及CaptureResult。  </p>
<ol>
<li><p>CameraManager：位于android.hardware.camera2.CameraManager下，也是Android 21(5.0)添加的，和其他系统服务一样通过 Context.getSystemService(CameraManager.class ) 或者Context.getSystemService(Context.CAMERA_SERVICE) 来完成初始化，主要用于管理系统摄像头：</p>
<ul>
<li>通过getCameraIdList()方法获取Android设备的摄像头列表，如今手机基本都有前后摄像头，有的手机则更多；  </li>
<li>通过getCameraIdList()方法获取Android设备的摄像头列表；  </li>
<li>openCamera(String cameraId, CameraDevice.StateCallback callback, Handler handler)打开指定Id的摄像头；  </li>
</ul>
</li>
<li><p>CameraDevice：CameraDevice是Camera2中抽象出来的一个对象，直接与系统硬件摄像头相联系。因为不可能所有的摄像头都会支持高级功能（即摄像头功能可被分为limit 和full 两个级别），当摄像头处于limited 级别时候，此时Camera2和早期的Camera功能差不多，除此之外在Camera2架构中，CameraDevice还承担其他两项重要任务：</p>
<ul>
<li>通过CameraDevice.StateCallback监听摄像头的状态（主要包括onOpened、onClosed、onDisconnected、onErro四种状态）；</li>
<li>管理CameraCaptureSession，通过方法createCaptureSession(List<surface> outputs, CameraCaptureSession.StateCallback callback, Handler handler)方法和createReprocessableCaptureSession(InputConfiguration inputConfig, List<surface> outputs, CameraCaptureSession.StateCallback callback, Handler handler)方法创建会话 （其中第三个参数： The handler on which the callback should be invoked, or null to use the current thread’s looper.），通常会在CameraDevice.StateCallback中调用对应方法创建预览会话。</surface></surface></li>
<li>管理CaptureRequest，主要包括通过createCaptureRequest（int templateType）创建捕获请求，在需要预览、拍照、再次预览的时候都需要通过创建请求来完成；</li>
</ul>
</li>
<li><p>CameraCaptureSession：系统向摄像头发送 Capture 请求，而摄像头会返回 CameraMetadata，这一切都是在由对应的 <strong>CameraDevice创建的CameraCaptureSession 会话</strong> 完成，当程序需要预览、拍照、再次预览时，都需要先通过会话。（A configured capture session for a CameraDevice, used for capturing images from the camera or reprocessing images captured from the camera in the same session previously.A CameraCaptureSession is created by providing a set of target output surfaces to createCaptureSession, or by providing an InputConfiguration and a set of target output surfaces to createReprocessableCaptureSession for a reprocessable capture session. Once created, the session is active until a new session is created by the camera device, or the camera device is closed.）CameraCaptureSession一旦被创建，直到对应的CameraDevice关闭才会死掉。虽然CameraCaptureSession会话用于从摄像头中捕获图像，但是 <strong>只有同一个会话才能再次从同一摄像头中捕获图像</strong>。另外，创建会话是一项耗时的异步操作，可能需要几百毫秒，因为它需要配置相机设备的内部管道并分配内存缓冲区以将图像发送到所需的目标，因而createCaptureSession和createReprocessableCaptureSession会将随时可用的CameraCaptureSession发送到提供的监听器的onConfigured回调中。如果无法完成配置，则触发onConfigureFailed回调，并且会话将不会变为活动状态。最后需要注意的是，<strong>如果摄像头设备创建了一个新的会话，那么上一个会话是被关闭的，并且会回调与其关联的onClosed</strong>，如果不处理好，当会话关闭之后再次调用会话的对应方法那么所有方法将会跑出IllegalStateException异常。关闭的会话清除任何重复的请求（和调用了stopRepeating()方法类似），但是在新创建的会话接管并重新配置摄像机设备之前，关闭的会话仍然会正常完成所有正在进行的捕获请求。简而言之，在Camera2中CameraCaptureSession承担很重要的角色：</p>
<ul>
<li>管理CameraCaptureSession.StateCallback状态回调，用于接收有关CameraCaptureSession状态的更新的回调对象，主要回调方法有两个当CameraDevice 完成配置，对应的会话开始处理捕获请求时触发onConfigured(CameraCaptureSession session)方法，反之配置失败时候触发onConfigureFailed(CameraCaptureSession session)方法；  </li>
<li>管理CameraCaptureSession.CaptureCallback捕获回调，用于接收捕获请求状态的回调，当请求触发捕获已启动时；捕获完成时；在捕获图像时发生错误的情况下；都会触发该回调对应的方法；  </li>
<li>通过调用方法capture(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)提交捕获图像请求（Submit a request for an image to be captured by the camera device.）即拍照，其中该请求定义了捕获单个图像的所有参数，包括传感器，镜头，闪光灯和后处理参数，每一次请求的结果将产生一个CaptureResult，可以为一个或多个Surface生成新的帧，然后 <strong>通过CaptureRequest.Builder的addTarget(Surface)方法附着到对应的Surface上显示</strong>，而且这个参数Surface必须是会话创建时候的一个子集，会话一次可以处理多个常规和重新处理请求。但如果只有常规请求或重新处理请求在进行，则以先进先出的顺序处理它们；如果两者都在进行中则分别以各自的先进先出顺序处理他们；然而，处理常规请求和重新处理请求的顺序并不是特定的，换言之，一个常规请求在下一个常规请求提交前被处理，同理重新处理请求也一样，但是一个常规请求不一定是在下一个重新处理请求提交之前被处理。通过capture方法提交的请求处理优先级比通过其他方式（ setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) 或者setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)）提交的请求的处理优先级高，一旦当前的repeat / repeatBurst处理完成，就会被处理。最后一点，所有CaptureSession可用于从相机捕获图像，但只有由createReprocessableCaptureSession创建的会话才可以提交重新处理捕获请求，<br>将重新处理请求提交到常规捕获会话将导致IllegalArgumentException；</li>
<li>通过调用方法setRepeatingRequest(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)请求不断重复捕获图像，即实现预览；  </li>
<li>通过方法调用stopRepeating()实现停止捕获图像，即停止预览；  </li>
</ul>
<ol>
<li><p>CameraCharacteristics：描述Cameradevice属性的对象，可以使用CameraManager通过getCameraCharacteristics（String cameraId）进行查询；</p>
</li>
<li><p>CameraRequest和CameraRequest.Builder：CameraRequest代表了一次捕获请求，而 <strong>CameraRequest.Builder用于描述捕获图片的各种参数设置，包含捕获硬件（传感器，镜头，闪存），对焦模式、曝光模式，处理流水线，控制算法和输出缓冲区的配置</strong>。，然后传递到对应的会话中进行设置，CameraRequest.Builder则负责生成CameraRequest对象。当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数。CameraRequest可以通过CameraRequest.Builder来进行初始化，通过调用createCaptureRequest来获得；</p>
</li>
<li><p>CaptureResult：CaptureRequest描述是从图像传感器捕获单个图像的结果的子集的对象。（CaptureResults are produced by a CameraDevice after processing a CaptureRequest）当CaptureRequest被处理之后由CameraDevice生成；</p>
</li>
<li><p>Camera2 主要角色之间的联系：<strong>CameraManager</strong>处于顶层管理位置<strong>负责检测获取所有摄像头及其特性和传入指定的CameraDevice.StateCallback回调打开指定摄像头</strong>，<strong>CameraDevice</strong> 是负责管理抽象对象，包括 <strong>监听Camera 的状态回调CameraDevice.StateCallback、创建CameraCaptureSession和CameraRequest，CameraCaptureSession</strong> 用于描述一次图像捕获操作，主要负责 <strong>监听自己会话的状态回调CameraCaptureSession.StateCallback和CameraCaptureSession.CaptureCallback捕获回调</strong>，还有发送处理 <strong>CameraRequest；CameraRequest</strong> 则可以看成是一个”JavaBean”的作用用于描述希望什么样的配置来处理这次请求；最后三个回调用于监听对应的状态。</p>
</li>
</ol>
</li>
</ol>
<h3 id="Camera2-使用"><a href="#Camera2-使用" class="headerlink" title="Camera2 使用"></a>Camera2 使用</h3><ol>
<li>权限配置：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//相机权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">//保存照片需要的权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">//录制视频需要的权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在6.0之后还需要在使用相机时动态判断是否具备权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private String[] permission = new String[]&#123;</span><br><span class="line">            Manifest.permission.CAMERA&#125;;</span><br><span class="line">if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                   requestPermissions(permission, 101);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>打开相机并实时预览：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread=new HandlerThread(&quot;Camera2&quot;);</span><br><span class="line">handlerThread.start();</span><br><span class="line">Handler childHandler=new Handler(handlerThread.getLooper());</span><br><span class="line">handler mainHandler=new Handler(getMainLooper());</span><br><span class="line"></span><br><span class="line">private void initCamera() &#123;</span><br><span class="line"></span><br><span class="line">  CameraManager cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">  try &#123;</span><br><span class="line">      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //打开摄像头</span><br><span class="line">      cameraManager.openCamera(CameraCharacteristics.LENS_FACING_BACK + &quot;&quot;, stateCallback, mainHandler);</span><br><span class="line">  &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相机状态监听回调</span><br><span class="line">private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onOpened(CameraDevice camera) &#123;//打开摄像头</span><br><span class="line">        mCameraDevice = camera;</span><br><span class="line">        //开启预览</span><br><span class="line">        takePreview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDisconnected(CameraDevice camera) &#123;//关闭摄像头</span><br><span class="line">        if (null != mCameraDevice) &#123;</span><br><span class="line">            mCameraDevice.close();</span><br><span class="line">            MainActivity.this.mCameraDevice = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(CameraDevice camera, int error) &#123;//发生错误</span><br><span class="line">        Toast.makeText(MainActivity.this, &quot;摄像头开启失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开始预览</span><br><span class="line"> */</span><br><span class="line">private void takePreview() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建预览需要的CaptureRequest.Builder</span><br><span class="line">        final CaptureRequest.Builder previewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        // 将SurfaceView的surface作为CaptureRequest.Builder的目标</span><br><span class="line">        previewRequestBuilder.addTarget(surfaceHolder.getSurface());</span><br><span class="line">        // 创建CameraCaptureSession，该对象负责管理处理预览请求和拍照请求</span><br><span class="line">        mCameraDevice.createCaptureSession(Arrays.asList(surfaceHolder.getSurface(), mImageReader.getSurface()), new CameraCaptureSession.StateCallback() // ③</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onConfigured(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                if (null == mCameraDevice) return;</span><br><span class="line">                // 当摄像头已经准备好时，开始显示预览</span><br><span class="line">                mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 自动对焦</span><br><span class="line">                    previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                    // 打开闪光灯</span><br><span class="line">                    previewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);</span><br><span class="line">                    // 显示预览</span><br><span class="line">                    CaptureRequest previewRequest = previewRequestBuilder.build();</span><br><span class="line">                    mCameraCaptureSession.setRepeatingRequest(previewRequest, null, childHandler);</span><br><span class="line">                &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onConfigureFailed(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, childHandler);</span><br><span class="line">    &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用相机拍照</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//设置Surface旋转角</span><br><span class="line">    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();</span><br><span class="line">    static &#123;</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_0,90);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_90,0);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_180,270);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_270,180);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //imageReader初始化,！！！这个在初始化摄像头时赋值。</span><br><span class="line">    mImageReader = ImageReader.newInstance(mPreviewSize.getWidth(),</span><br><span class="line">    mPreviewSize.getHeight(),</span><br><span class="line">    ImageFormat.JPEG,</span><br><span class="line">    2 );                   </span><br><span class="line">     mImageReader.setOnImageAvailableListener(onImageAvailableListener , mBackgroundHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void takePicture()&#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);  </span><br><span class="line">        // 将imageReader的surface作为CaptureRequest.Builder的目标  </span><br><span class="line">        captureRequestBuilder.addTarget(imageReader.getSurface());  </span><br><span class="line">        // 自动对焦  </span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);  </span><br><span class="line">        // 获取手机方向  </span><br><span class="line">        int rotation = getWindowManager().getDefaultDisplay().getRotation();  </span><br><span class="line">        // 根据设备方向计算设置照片的方向  </span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATIONS.get(rotation));  </span><br><span class="line">        //拍照  </span><br><span class="line">        CaptureRequest mCaptureRequest = captureRequestBuilder.build();  </span><br><span class="line">        mSession.stopRepeating();  </span><br><span class="line">        mSession.capture(mCaptureRequest, null, mHandler);  </span><br><span class="line">    &#125; catch (CameraAccessException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**监听拍照的图片*/</span><br><span class="line">   private ImageReader.OnImageAvailableListener imageAvailableListener= new ImageReader.OnImageAvailableListener()</span><br><span class="line">   &#123;</span><br><span class="line">       // 当照片数据可用时激发该方法</span><br><span class="line">       @Override</span><br><span class="line">       public void onImageAvailable(ImageReader reader) &#123;</span><br><span class="line"></span><br><span class="line">           //先验证手机是否有sdcard</span><br><span class="line">           String status = Environment.getExternalStorageState();</span><br><span class="line">           if (!status.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">               Toast.makeText(getApplicationContext(), &quot;你的sd卡不可用。&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           // 获取捕获的照片数据</span><br><span class="line">           Image image = reader.acquireNextImage();</span><br><span class="line">           ByteBuffer buffer = image.getPlanes()[0].getBuffer();</span><br><span class="line">           byte[] data = new byte[buffer.remaining()];</span><br><span class="line">           buffer.get(data);</span><br><span class="line"></span><br><span class="line">           //手机拍照都是存到这个路径</span><br><span class="line">           String filePath = Environment.getExternalStorageDirectory().getPath() + &quot;/DCIM/Camera/&quot;;</span><br><span class="line">           String picturePath = System.currentTimeMillis() + &quot;.jpg&quot;;</span><br><span class="line">           File file = new File(filePath, picturePath);</span><br><span class="line">           try &#123;</span><br><span class="line">               //存到本地相册</span><br><span class="line">               FileOutputStream fileOutputStream = new FileOutputStream(file);</span><br><span class="line">               fileOutputStream.write(data);</span><br><span class="line">               fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">               //显示图片</span><br><span class="line">               BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">               options.inSampleSize = 2;</span><br><span class="line">               Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, options);</span><br><span class="line">               iv.setImageBitmap(bitmap);</span><br><span class="line">           &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               image.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用相机录像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//设置MediaRecoder属性</span><br><span class="line">private void setUpMediaRecorder() throws IOException &#123;</span><br><span class="line">       //设置音频源</span><br><span class="line">       mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">       //设置视频源</span><br><span class="line">       mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">       mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">       //存储路径</span><br><span class="line">       if (mNextVideoAbsolutePath == null || mNextVideoAbsolutePath.isEmpty()) &#123;</span><br><span class="line">           mNextVideoAbsolutePath = getVideoFilePath(getApplicationContext());</span><br><span class="line">       &#125;</span><br><span class="line">       mMediaRecorder.setOutputFile(mNextVideoAbsolutePath);</span><br><span class="line">       mMediaRecorder.setVideoEncodingBitRate(10000000);</span><br><span class="line">       mMediaRecorder.setVideoFrameRate(30);</span><br><span class="line">       //视屏宽高</span><br><span class="line">       mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">       //视屏编码格式</span><br><span class="line">       mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">       //音频编码格式</span><br><span class="line">       mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">       int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">       switch (mSensorOrientation) &#123;</span><br><span class="line">           case SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">               mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">               break;</span><br><span class="line">           case SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">               mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       mMediaRecorder.prepare();</span><br><span class="line">   &#125;</span><br><span class="line">   //视频录制</span><br><span class="line">private void startRecordingVideo() &#123;</span><br><span class="line">        if (null == mCameraDevice || !textureView.isAvailable() || null == mPreviewSize) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            closePreviewSession();</span><br><span class="line">            setUpMediaRecorder();</span><br><span class="line">            SurfaceTexture texture = textureView.getSurfaceTexture();</span><br><span class="line">            assert texture != null;</span><br><span class="line">            texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">            mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">            List&lt;Surface&gt; surfaces = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            // Set up Surface for the camera preview</span><br><span class="line">            Surface previewSurface = new Surface(texture);</span><br><span class="line">            surfaces.add(previewSurface);</span><br><span class="line">            mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line"></span><br><span class="line">            // Set up Surface for the MediaRecorder</span><br><span class="line">            Surface recorderSurface = mMediaRecorder.getSurface();</span><br><span class="line">            surfaces.add(recorderSurface);</span><br><span class="line">            mPreviewBuilder.addTarget(recorderSurface);</span><br><span class="line"></span><br><span class="line">            // Start a capture session</span><br><span class="line">            // Once the session starts, we can update the UI and start recording</span><br><span class="line">            mCameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                    mPreviewSession = cameraCaptureSession;</span><br><span class="line">                    updatePreview();</span><br><span class="line">                    runOnUiThread(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            // UI</span><br><span class="line">                            button.setText(&quot;stop&quot;);</span><br><span class="line">                            mIsRecordingVideo = true;</span><br><span class="line"></span><br><span class="line">                            // Start recording</span><br><span class="line">                            mMediaRecorder.start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;Failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, mBackgroundHandler);</span><br><span class="line">        &#125; catch (CameraAccessException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>录像主要时通过TextureView实现实时预览，同时使用MediaRecorder录制视屏。</p>
<p>参考：<br>[1]. Camera2完全解析 <a href="https://www.jianshu.com/p/d83161e77e90" target="_blank" rel="noopener">https://www.jianshu.com/p/d83161e77e90</a><br>[2]. Camera2介绍 <a href="https://blog.csdn.net/vinicolor/article/details/50992692" target="_blank" rel="noopener">https://blog.csdn.net/vinicolor/article/details/50992692</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/22/Activity启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/Activity启动模式/" itemprop="url">android启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T13:39:38+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>任务<br>任务是指执行特定作业时与用户交互的一系列Activity，这些Activity按照各自的打开顺序排列在堆栈<br>（即“返回栈”）中。google为了记录用户开启了那些Activity，引入了 <strong>任务栈（task stack）</strong> 的概念，<br>用于记录activity开启的先后顺序，帮助维护好的用户体验。<strong>栈的特性是：先进后出</strong>。</li>
<li>如何查看当前系统的任务栈  <ul>
<li>手机中，长按 <strong>home或者多任务键</strong> 会进入到概览屏幕的一个界面；</li>
<li>命令行中，adb shell dumpsys activity；</li>
</ul>
</li>
<li><p>Activity启动模式<br>Activity启动模式在AndroidMainifest.xml文件里面的activity标签设置，属性名为android:launchMode，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.FirstActivity&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:label=&quot;This is FirstActivity&quot; &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>standard:标准模式，也是系统默认的，每次都会创建新的Activity覆盖在原Activity上。<br><img src="/images/ActivityStandard.jpg" alt="标准模式示意图">    </li>
<li>singleTop：栈顶复用模式，首先判断栈顶Activity是否是要启动的Activity，如果是则不创建新的<br>Activity而直接引用这个Activity；如果不是则创建新的Activity。<br><img src="/images/ActivitySingleTop.jpg" alt="栈顶复用模式示意图">  </li>
<li>singleTask：栈内复用模式，检测整个Activity栈中是否存在当前需要启动的Activity，如果存在<br>则将该Activity置于栈顶，并销毁其上所有Activity，如果不存在则创建新的Activity置于栈顶。<br><img src="/images/ActivitySingleTask.jpg" alt="栈内复用模式示意图">   </li>
<li>singleInstance：单实例模式，创建新的任务栈，且该任务栈仅有一个Activity。<br><img src="/images/ActivitySingleInstance.png" alt="单实例模式示意图">     </li>
</ul>
</li>
<li><p>其他   </p>
<ul>
<li>为Activity设置新的任务栈<br>taskAffinity，任务相关性。xml中的一个属性，标识了一个Activity所需要的任务栈的名字。默认是包名。如果设置了其他的名字如com.test.task1，那启动它的时候就会新建一个名为com.test.task1的任务栈。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.test.task0.MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">andorid:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">andorid:name</span>=<span class="string">"com.test.SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.test.task1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">andorid:name</span>=<span class="string">"com.test.ThirdActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.test.task1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span>/&gt;</span></span><br><span class="line"> ```  </span><br><span class="line"> 如果从MainActivity启动SecondActivity，然后再启动ThirdActivity，那么任务栈如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Blockquotes com.test.task0 MainActivity<br>Blockquotes com.test.task1 SecondActivity ThirdActivity<br>若再从ThirdActivity启动MainActivity，那么任务栈如下：<br>com.test.task0 MainActivity<br>com.test.task1 SecondActivity ThirdActivity MainActivit<br>总结：通过设置 TaskAffinity 属性更改任务栈属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 回退栈和通知  </span><br><span class="line">通过通知进入Activity存在的问题，默认情况下，从通知启动一个Activity，按返回键会回到主屏幕。但某些时候有按返回键仍然留在当前应用的需求。从通知打开的某个深层次Activity。在此Acitivity中点回退，若不做处理，将会直接返回到AndroidLaunch界面。这是因为在Notification中的PendingIntent会默认开启新的任务栈。当回退的时候此任务栈没有其他新的Activity，默认在PendingIntent 的Activity是任务栈中唯一的 Activity.</span><br></pre></td></tr></table></figure>
<p>举例： HomeActiy=&gt;Step1Activity=&gt;Step2Acitity<br>某个通知 默认在PendingIntent 指定了Step2Acitity。通过通知栏进入到Step2Acitity。点回退。正常的顺序为：<br>Step2Activity=&gt;Step1Acitivity=&gt;HomeActivity但是如果通过通知栏这样进入Step2Activity 点回退 会直接退回到Android 桌面。就是因为 PendingIntent会默认开启新的任务栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：通过TaskStackBuilder设置具体的回退路径,在 AndroidManifest.xml定义Acitivity从属关系。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Android 4.0.3 及更早版本</p>
<p><activity android:name=".ResultActivity"><br>    <meta-data android:name="android.support.PARENT_ACTIVITY" android:value=".MainActivity"><br></meta-data></activity><br>Android 4.1 及更高版本</p>
<p><activity android:name=".ResultActivity" android:parentactivityname=".MainActivity"><br></activity><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在代码中做如下处理：</span><br><span class="line">```java</span><br><span class="line">Intent intent = new Intent(MainActivity.this, ResultActivity.class);</span><br><span class="line">TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(this);</span><br><span class="line">taskStackBuilder.addParentStack(ResultActivity.class);</span><br><span class="line">taskStackBuilder.addNextIntent(intent);</span><br><span class="line">PendingIntent pendingIntent = taskStackBuilder.getPendingIntent(1, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this);</span><br><span class="line">notificationBuilder.setContentIntent(pendingIntent);</span><br></pre></td></tr></table></figure></p>
<p>这样从Notification进入到指定的ResultActivity中。回退到正常的MainActivity中。<br><strong>TaskStackBuilder 扩展应用</strong><br>也可以单独使用TaskStackBuilder，让某个二级Acitivity启动的时候启动它的一级Acitity.<br>在 AndroidManifest.xml定义Acitivity从属关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.example.app.ChildActivity</span><br><span class="line">    android:parentActivityName=&quot;com.example.app.ParentActivity&quot;&gt;</span><br><span class="line">    &lt;!-- 下面这段用来兼容API 16之前的版本 --&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.PARENT_ACTIVITY&quot;</span><br><span class="line">        android:value=&quot;com.example.app.MainActivity&quot;/&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ChildActivity.class);</span><br><span class="line">TaskStackBuilder.create(<span class="keyword">this</span>)</span><br><span class="line">                .addNextIntentWithParentStack(intent)</span><br><span class="line">                .startActivities();</span><br></pre></td></tr></table></figure>
<p>通过启动一个无任何层级关系的Acitity 激活应用（目前Lianlian3.0应用采用此方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLaunchAppActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// Now finish, which will drop the user in to the activity that was at the top</span></span><br><span class="line">        <span class="comment">//  of the task stack</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理：若通过Notification打开Acitivity后此Acitivy会位于要启动的App的栈顶。自动finish()后，app恢复到切换到后台之前的状态。SimpleLaunchAppActivity不得设置android:taskAffinity。taskAffinity和默认App的包名一致就不会新建任务栈。若设置了taskAffinity为新的任务栈，点回退后 将会回到android launch页面。<br>联连wifi的解决方案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过启动一个无任何层级关系的TransparentSwitchActivity 激活应用**</span><br><span class="line">目前存在的问题是TransparentSwitchActivity里面会根据参数判断 通过通知进入后还有部分逻辑不太人性化和完善。需要提高用户体验。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于系统默认的清空返回栈<br>如何用户将任务切换到后台之后过了很长一段时间，系统会将这个任务中除了最底层的那个Activity之外的其它所有Activity全部清除掉。当用户重新回到这个任务的时候，最底层的那个Activity将得到恢复。这个是系统默认的行为，因为既然过了这么长的一段时间，用户很有可能早就忘记了当时正在做什么，那么重新回到这个任务的时候，基本上应该是要去做点新的事情了。当然，既然说是默认的行为，那就说明我们肯定是有办法来改变的，在Manifest中 元素中设置以下几种属性就可以改变系统这一默认行为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alwaysRetainTaskState   </span><br><span class="line">如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。</span><br><span class="line">clearTaskOnLaunch   </span><br><span class="line">如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。</span><br><span class="line">finishOnTaskLaunch   </span><br><span class="line">这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：<br>[1]. Activity启动模式 <a href="https://blog.csdn.net/lixiaodaoaaa/article/details/51700981" target="_blank" rel="noopener">https://blog.csdn.net/lixiaodaoaaa/article/details/51700981</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/15/webpack4安装使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/webpack4安装使用/" itemprop="url">webpack4安装使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T16:07:35+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node/" itemprop="url" rel="index">
                    <span itemprop="name">node</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;官网手册为<a href="https://webpack.js.org/guides/getting-started/，但是在最后一步会出现npx" target="_blank" rel="noopener">https://webpack.js.org/guides/getting-started/，但是在最后一步会出现npx</a> webpack可能会出现错误，官网说是npx是在node 8.2或更高版本才行，但我的已经是v8.11.3。</p>
<p>其中dist为最终文件输出目录，src为需要编译打包的源文件；</p>
<ol>
<li><p>webpack安装：<br>webpack安装分两种模式：</p>
<ul>
<li>全局安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global webpack</span><br><span class="line">npm install --global webpack-cli</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面主要安装了webpakc基础库和webpack控制台（主要作用是命令行处理），通过上面那安装后在终端<br>运行webpack -v会显示webpack版本号，如果没有安装webpack-cli，此时会有提示让安装webpack-cli或者webpack-command两个中的一个,如果两个都安装了此时会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have installed webpack-cli and webpack-command together. To work with the &quot;webpack&quot; command you need only one CLI package, please remove one of them or use them directly via their binary.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时需要移除其中一个即可，执行npm remove  webpack-cli 或者 npm remove webpack-command移除当前项目的， 全局的话使用npm remove –global webpack-cli。  </p>
<ul>
<li>安装到你的项目目录：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>!!! 全局安装了webpack后在npm脚本配置时，需要在当前目录安装npm install  –save-dev webpack-command，否则会报错误显示找不到webpack的module。</p>
<ol>
<li><p>项目包结构：<br><img src="images/webpack_package_struct.png" alt="包结构"><br>其中dist为webpack <strong>默认</strong> 的打包后最终输出的文件所在目录，src为webpack <strong>默认</strong> 的编写的js所在目录，main.js为webpack将src下的js打包集成的 <strong>默认</strong> 文件。<br>此时package.json中的依赖应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.12.0&quot;,</span><br><span class="line">    &quot;webpack-command&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.9.7&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack配置：<br>webpack配置的文件名称 <strong>默认</strong> 为：webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry:  &quot;./src/index.js&quot;, //入口文件,使用相对路径</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: __dirname + &quot;/dist&quot;,   //打包后的文件存放的地方，使用绝对路径</span><br><span class="line">      filename: &quot;bundle.js&quot;   //打包后输出文件的文件名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时打包命令为：webpack –config webpack.config.js，也可以不加config参数。</p>
<ol>
<li>npm脚本化：<br>通过npm实现打包编译则需要对package.json文件处理：主要是在scripts下添加build属性：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;   //脚本化的命令和执行者</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^2.0.9&quot;,</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.5&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后打包命令则为 <strong>npm run build</strong>。</p>
<p>参考地址：<br>[1].  官网 <a href="https://webpack.js.org/guides/getting-started/" target="_blank" rel="noopener">https://webpack.js.org/guides/getting-started/</a><br>[2].  webpack入门 <a href="https://segmentfault.com/a/1190000006178770" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006178770</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">The blog from a Android coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
