<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="the blog from a anroid coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/3/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="the blog from a anroid coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="the blog from a anroid coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/page/3/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/28/Android音视频处理之MediaExtractor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/Android音视频处理之MediaExtractor/" itemprop="url">Android音视频处理之MediaExtractor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:29:55+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android提供了一个MediaExtractor类，可以用来分离容器中的视频track和音频track，下面的例子展示了使用MediaExtractor和MediaMuxer来实现视频的换音：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private void muxingAudioAndVideo(String videoPath, String audioPath, String outputPath) throws IOException &#123;</span><br><span class="line">        MediaMuxer mediaMuxer = new MediaMuxer(outputPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"></span><br><span class="line">        //视频的MediaExtractor</span><br><span class="line">        MediaExtractor videoExtractor = new MediaExtractor();</span><br><span class="line">        videoExtractor.setDataSource(videoPath);</span><br><span class="line">        int videoTrackIndex = -1;</span><br><span class="line">        for (int i = 0; i &lt; videoExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">            MediaFormat format = videoExtractor.getTrackFormat(i);</span><br><span class="line">            if (format.getString(MediaFormat.KEY_MIME).startsWith(&quot;video&quot;)) &#123;</span><br><span class="line">                videoExtractor.selectTrack(i);</span><br><span class="line">                videoTrackIndex = mediaMuxer.addTrack(format);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //音频的MediaExtractor</span><br><span class="line">        MediaExtractor audioExtractor = new MediaExtractor();</span><br><span class="line">        audioExtractor.setDataSource(audioPath);</span><br><span class="line">        int audioTrackIndex = -1;</span><br><span class="line">        for (int i = 0; i &lt; audioExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">            MediaFormat format = audioExtractor.getTrackFormat(i);</span><br><span class="line">            if (format.getString(MediaFormat.KEY_MIME).startsWith(&quot;audio&quot;)) &#123;</span><br><span class="line">                audioExtractor.selectTrack(i);</span><br><span class="line">                audioTrackIndex = mediaMuxer.addTrack(format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加完所有轨道后start</span><br><span class="line">        mediaMuxer.start();</span><br><span class="line"></span><br><span class="line">        // 封装视频track</span><br><span class="line">        if (-1 != videoTrackIndex) &#123;</span><br><span class="line">            MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();</span><br><span class="line">            info.presentationTimeUs = 0;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int sampleSize = videoExtractor.readSampleData(buffer, 0);</span><br><span class="line">                if (sampleSize &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                info.offset = 0;</span><br><span class="line">                info.size = sampleSize;</span><br><span class="line">                info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;</span><br><span class="line">                info.presentationTimeUs = videoExtractor.getSampleTime();</span><br><span class="line">                mediaMuxer.writeSampleData(videoTrackIndex, buffer, info);</span><br><span class="line"></span><br><span class="line">                videoExtractor.advance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 封装音频track</span><br><span class="line">        if (-1 != audioTrackIndex) &#123;</span><br><span class="line">            MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();</span><br><span class="line">            info.presentationTimeUs = 0;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(100 * 1024);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int sampleSize = audioExtractor.readSampleData(buffer, 0);</span><br><span class="line">                if (sampleSize &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                info.offset = 0;</span><br><span class="line">                info.size = sampleSize;</span><br><span class="line">                info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME;</span><br><span class="line">                info.presentationTimeUs = audioExtractor.getSampleTime();</span><br><span class="line">                mediaMuxer.writeSampleData(audioTrackIndex, buffer, info);</span><br><span class="line"></span><br><span class="line">                audioExtractor.advance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 释放MediaExtractor</span><br><span class="line">        videoExtractor.release();</span><br><span class="line">        audioExtractor.release();</span><br><span class="line"></span><br><span class="line">        // 释放MediaMuxer</span><br><span class="line">        mediaMuxer.stop();</span><br><span class="line">        mediaMuxer.release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MediaExtractor的接口比较简单，首先通过 <strong>setDataSource()设置数据源</strong>，数据源可以是本地文件地址，也可以是网络地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor mVideoExtractor = new MediaExtractor();</span><br><span class="line">mVideoExtractor.setDataSource(mVideoPath);</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过getTrackFormat(int index)来获取各个track的 <strong>MediaFormat，通过MediaFormat来获取track的详细信息</strong>，如：<strong>MimeType、分辨率、采样频率、帧率</strong> 等等,其内部就是一个map对象，通过key获取对应的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; mVideoExtractor.getTrackCount(); i++) &#123;</span><br><span class="line">    MediaFormat format = mVideoExtractor.getTrackFormat(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取到track的详细信息后，通过selectTrack(int index)选择指定的通道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (format.getString(MediaFormat.KEY_MIME).startsWith(&quot;video/&quot;)) &#123;</span><br><span class="line">    mVideoExtractor.selectTrack(i);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指定通道之后就可以从MediaExtractor中读取数据了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  int sampleSize = mVideoExtractor.readSampleData(buffer, 0);</span><br><span class="line">  if (sampleSize &lt; 0) &#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    // do something</span><br><span class="line">    mVideoExtractor.advance(); // 移动到下一帧</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在读取结束之后，记得释放资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mVideoExtractor.release();</span><br></pre></td></tr></table></figure></p>
<p>问题：  </p>
<ol>
<li>Android MediaExtractor readSampleData IllegalArgumentException<br>视频采样的时候报的错误，主要视频的采用buffer设置的可能小了，开始设置的是100K，后来提到1M就没有问题；<br>参考地址：<a href="https://stackoverflow.com/questions/33148629/android-mediaextractor-readsampledata-illegalargumentexception" target="_blank" rel="noopener">https://stackoverflow.com/questions/33148629/android-mediaextractor-readsampledata-illegalargumentexception</a>  </li>
<li>MPEG4Writer: Unsupported mime ‘audio/mpeg’<br>一开始使用的是mp3音频，显示不支持，后来换成m4a就没有问题，后期在看下MPEG4Writer支持什么音频格式！！！<br>参考地址： <a href="http://www.cnblogs.com/rockylearnstodevelop/p/5353717.html" target="_blank" rel="noopener">http://www.cnblogs.com/rockylearnstodevelop/p/5353717.html</a></li>
</ol>
<p>拓展：</p>
<ol>
<li><p>关于Android读取assert下的资源文件<br>Android 中资源分为两种,一种是res下可编译的资源文件, 这种资源文件系统会在R.java里面自动生成该资源文件的ID，访问也很简单,只需要调用R.XXX.id即可;第二种就是放在assets文件夹下面的原生资源文件,assets文件夹里面的文件都是保持原始的文件格式,放在这个文件夹下面的文件不会被R文件编译,所以不能像第一种那样直接使用.Android提供了一个工具类,方便我们操作获取assets文件下的文件:AssetManager,需要用AssetManager以字节流的形式读取文件。其主要步骤是：</p>
<ul>
<li>获取Context然后调用getAssets()来获取AssetManager引用。</li>
<li>再用AssetManager的open（String fileName,int accessMode）方法并指定要读取的文件名称以及访<br>问模式来获取输入流InputStream。</li>
<li>用InputStream读取文件，读取完后需要InputStream.close();</li>
<li>最后调用AssetManager的close（）方法关闭AssetManager。</li>
</ul>
</li>
<li><p>AssetManager提供了如下方法用于处理assets：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] list(String path);//列出该目录下的下级文件和文件夹名称</span><br><span class="line"></span><br><span class="line">   InputStream open(String fileName);//以顺序读取模式打开文件，默认模式为ACCESS_STREAMING</span><br><span class="line"></span><br><span class="line">    InputStream open(String fileName, int accessMode);//以指定模式打开文件。读取模式有以下几种：</span><br><span class="line">                                       //ACCESS_UNKNOWN : 未指定具体的读取模式</span><br><span class="line">                                       //ACCESS_RANDOM : 随机读取</span><br><span class="line">                                       //ACCESS_STREAMING : 顺序读取</span><br><span class="line">                                       //ACCESS_BUFFER : 缓存读取</span><br><span class="line">   void close()//关闭AssetManager实例</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br>assets目录下主要存放四种文件：文本文件、图像文件、网页文件（包括html中引用的js/ccs/jpg等资源）、音频视频文件,下面通过具体的案例分别来说下怎么获取</p>
<ul>
<li>加载assets目录下的网页<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(&quot;file:///android_asset/html/index.htmll&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>说明：这种方式可以加载assets目录下的网页，并且与网页有关的css，js，图片等文件也会的加载。</p>
<ul>
<li><p>加载assets目录下的图片资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getAssets().open(fileName);  </span><br><span class="line">bitmap = BitmapFactory.decodeStream(is);</span><br><span class="line">ivImg.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载assets目录下文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getAssets().open(fileName);  </span><br><span class="line">int lenght = is.available();  </span><br><span class="line">byte[]  buffer = new byte[lenght];  </span><br><span class="line">is.read(buffer);  </span><br><span class="line">String result = = new String(buffer, &quot;utf8&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载assets目录下音乐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 打开指定音乐文件,获取assets目录下指定文件的AssetFileDescriptor对象  </span><br><span class="line">AssetFileDescriptor afd = am.openFd(music);  </span><br><span class="line">mPlayer.reset();  </span><br><span class="line">// 使用MediaPlayer加载指定的声音文件。  </span><br><span class="line">mPlayer.setDataSource(afd.getFileDescriptor(),  </span><br><span class="line">    afd.getStartOffset(), afd.getLength());  </span><br><span class="line">// 准备声音  </span><br><span class="line">mPlayer.prepare();  </span><br><span class="line">// 播放  </span><br><span class="line">mPlayer.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>补充下:Android中还有另外一个文件夹raw,和assets差不多,也不会被R文件编译,但是raw下不能在建文件夹,assets文件下是可以在建文件夹的,下面是获取raw文件夹下资源的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = getResources().openRawResource(R.id.filename);</span><br></pre></td></tr></table></figure></p>
<p>将assets下的文件复制到SD卡中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> *  从assets目录中复制整个文件夹内容  </span><br><span class="line"> *  @param  context  Context 使用CopyFiles类的Activity</span><br><span class="line"> *  @param  oldPath  String  原文件路径  如：/aa  </span><br><span class="line"> *  @param  newPath  String  复制后路径  如：xx:/bb/cc  </span><br><span class="line"> */   </span><br><span class="line">public void copyFilesFassets(Context context,String oldPath,String newPath) &#123;                      </span><br><span class="line">         try &#123;  </span><br><span class="line">        String fileNames[] = context.getAssets().list(oldPath);//获取assets目录下的所有文件及目录名  </span><br><span class="line">        if (fileNames.length &gt; 0) &#123;//如果是目录  </span><br><span class="line">            File file = new File(newPath);  </span><br><span class="line">            file.mkdirs();//如果文件夹不存在，则递归  </span><br><span class="line">            for (String fileName : fileNames) &#123;  </span><br><span class="line">               copyFilesFassets(context,oldPath + &quot;/&quot; + fileName,newPath+&quot;/&quot;+fileName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;//如果是文件  </span><br><span class="line">            InputStream is = context.getAssets().open(oldPath);  </span><br><span class="line">            FileOutputStream fos = new FileOutputStream(new File(newPath));  </span><br><span class="line">            byte[] buffer = new byte[1024];  </span><br><span class="line">            int byteCount=0;                 </span><br><span class="line">            while((byteCount=is.read(buffer))!=-1) &#123;//循环从输入流读取 buffer字节          </span><br><span class="line">                fos.write(buffer, 0, byteCount);//将读取的输入流写入到输出流  </span><br><span class="line">            &#125;  </span><br><span class="line">            fos.flush();//刷新缓冲区  </span><br><span class="line">            is.close();  </span><br><span class="line">            fos.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; catch (Exception e) &#123;  </span><br><span class="line">        // TODO Auto-generated catch block  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">        //如果捕捉到错误则通知UI线程  </span><br><span class="line">                   MainActivity.handler.sendEmptyMessage(COPY_FALSE);  </span><br><span class="line">    &#125;                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>补充</strong>：Android获取assets或者raw目录的视频文件路径播放视频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String mp4FilePath = &quot;file:///android_asset/Kotlin与ava共存.mp4&quot;;</span><br><span class="line">mVideoView = (VideoView) findViewById(R.id.mVideoView);</span><br><span class="line">mVideoView.setVideoPath(mp4FilePath);</span><br><span class="line">mVideoView.start();</span><br></pre></td></tr></table></figure></p>
<p>会提示播放失败。因为通过assets目录构造URI，不能用来播放视频，也不能播放音频。在raw目录下的文件构造URI可以播放音频，也能播放视频。 .<br>正确的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String uri = &quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video;</span><br><span class="line">mVideoView = (VideoView) findViewById(R.id.mVideoView);</span><br><span class="line">mVideoView.setVideoPath(uri);</span><br><span class="line">//mVideoView.setVideoPath(uri);</span><br><span class="line">mVideoView.setVideoURI(Uri.parse(uri));</span><br><span class="line">mVideoView.start();</span><br></pre></td></tr></table></figure></p>
<p>参考：<br>[1] Android中读取assets目录下的文件详细介绍 <a href="https://blog.csdn.net/greathfs/article/details/52123984" target="_blank" rel="noopener">https://blog.csdn.net/greathfs/article/details/52123984</a><br>[2] assets文件读取 <a href="https://www.cnblogs.com/wgscd/p/6738818.html" target="_blank" rel="noopener">https://www.cnblogs.com/wgscd/p/6738818.html</a><br>[3] asset视频播放 <a href="https://blog.csdn.net/e_inch_photo/article/details/78306785?utm_source=debugrun&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/e_inch_photo/article/details/78306785?utm_source=debugrun&amp;utm_medium=referral</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/27/Android_o_notification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/Android_o_notification/" itemprop="url">Android o 中Notification使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T10:43:05+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;随着Android 8.0的发布，google更新了Notification内容，新增了通知渠道这个概念，用来对通知进行分类管理，以提高用户体验。关于Android 8.0中NotificationChannel的管理在《设置》-》《应用管理》-》《具体应用》-》《通知》或者 《设置》-》《通知》（具体应手机不同可能略有差异）就可以看到应用已经设置的通知渠道，这里可以对不同渠道通知管理。</p>
<h3 id="创建NotificationChannl"><a href="#创建NotificationChannl" class="headerlink" title="创建NotificationChannl"></a>创建NotificationChannl</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过NotificationManager的createNotificationChannel方法来创建NotificationChannel：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void createNotificationChannel(String id, String name, int importance, String desc) &#123;</span><br><span class="line">        if (mNotificationManager.getNotificationChannel(id) != null) return;</span><br><span class="line"></span><br><span class="line">        NotificationChannel notificationChannel = new NotificationChannel(id, name, importance);</span><br><span class="line">        notificationChannel.enableLights(true);</span><br><span class="line">        notificationChannel.enableVibration(true);</span><br><span class="line"></span><br><span class="line">        notificationChannel.setLightColor(Color.RED);</span><br><span class="line">        notificationChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);</span><br><span class="line">        notificationChannel.setShowBadge(true);</span><br><span class="line">        notificationChannel.setBypassDnd(true);</span><br><span class="line">        notificationChannel.setVibrationPattern(new long[]&#123;100, 200, 300, 400&#125;);</span><br><span class="line">        notificationChannel.setDescription(desc);</span><br><span class="line"></span><br><span class="line">        mNotificationManager.createNotificationChannel(notificationChannel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>NotificationChannel 的方法列表：</p>
<ul>
<li>getId() — 获取 ChannleId</li>
<li>enableLights() — 开启指示灯，如果设备有的话。</li>
<li>setLightColor() — 设置指示灯颜色</li>
<li>enableVibration() — 开启震动</li>
<li>setVibrationPattern() — 设置震动频率</li>
<li>setImportance() — 设置频道重要性</li>
<li>getImportance() — 获取频道重要性</li>
<li>setSound() — 设置声音</li>
<li>getSound() — 获取声音</li>
<li>setGroup() — 设置 ChannleGroup</li>
<li>getGroup() — 得到 ChannleGroup</li>
<li>setBypassDnd() — 设置绕过免打扰模式</li>
<li>canBypassDnd() — 检测是否绕过免打扰模式</li>
<li>getName() — 获取名称</li>
<li>setLockScreenVisibility() — 设置是否应在锁定屏幕上显示此频道的通知</li>
<li>getLockscreenVisibility() — 检测是否应在锁定屏幕上显示此频道的通知</li>
<li>setShowBadge() 设置是否显示角标</li>
<li>canShowBadge() — 检测是否显示角标</li>
</ul>
<p>以上属性表示了隶属这个渠道的通知显示效果。</p>
<h4 id="setImportance-重要程度"><a href="#setImportance-重要程度" class="headerlink" title="setImportance 重要程度"></a>setImportance 重要程度</h4><p>越高，提示权限就越高，最高的支持发出声音&amp;悬浮通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final int IMPORTANCE_DEFAULT = 3;</span><br><span class="line">public static final int IMPORTANCE_HIGH = 4;</span><br><span class="line">public static final int IMPORTANCE_LOW = 2;</span><br><span class="line">public static final int IMPORTANCE_MAX = 5;</span><br><span class="line">public static final int IMPORTANCE_MIN = 1;</span><br><span class="line">public static final int IMPORTANCE_NONE = 0;</span><br><span class="line">public static final int IMPORTANCE_UNSPECIFIED = -1000;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除-NotificationChannel"><a href="#删除-NotificationChannel" class="headerlink" title="删除 NotificationChannel"></a>删除 NotificationChannel</h4><p>通过 NotificationManager 的 deleteNotificationChannel 方法来删除 NotificationChannel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.deleteNotificationChannel(chatChannelId);</span><br></pre></td></tr></table></figure></p>
<h4 id="发出通知"><a href="#发出通知" class="headerlink" title="发出通知"></a>发出通知</h4><p>只需要设置一个 ChannelId 即可发布到对应的 Channel 上，需要注意的是 NotificationChannel 一定要先创建才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Notification.Builder builder = new Notification.Builder(this, chatChannelId);</span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentTitle(&quot;Gavin&quot;)</span><br><span class="line">        .setContentText(&quot;Today released Android 8.0 version of its name is Oreo&quot;)</span><br><span class="line">        .setAutoCancel(true);</span><br><span class="line"></span><br><span class="line">Intent resultIntent = new Intent(this, MainActivity.class);</span><br><span class="line">TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);</span><br><span class="line">stackBuilder.addParentStack(MainActivity.class);</span><br><span class="line">stackBuilder.addNextIntent(resultIntent);</span><br><span class="line">PendingIntent resultPendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">builder.setContentIntent(resultPendingIntent);</span><br><span class="line"></span><br><span class="line">mNotificationManager.notify((int) System.currentTimeMillis(), builder.build());</span><br></pre></td></tr></table></figure></p>
<h4 id="角标管理"><a href="#角标管理" class="headerlink" title="角标管理"></a>角标管理</h4><p>首先要开启允许使用通知圆点，这个是用户可以取消的，如果要显示一定要代码中保证是开启状态。</p>
<ol>
<li><p>NotificationChannel 开启角标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notificationChannel.setShowBadge(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Notification 设置角标样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(this, chatChannelId).setBadgeIconType(BADGE_ICON_SMALL)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Notification 设置角标计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(this, chatChannelId).setNumber(1)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="跳转设置"><a href="#跳转设置" class="headerlink" title="跳转设置"></a>跳转设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">intent.putExtra(Settings.EXTRA_CHANNEL_ID, chatChannelId);</span><br><span class="line">intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<h3 id="使用-NotificationChannleGroup"><a href="#使用-NotificationChannleGroup" class="headerlink" title="使用 NotificationChannleGroup"></a>使用 NotificationChannleGroup</h3><p>如果你的通知渠道比较多，那么久可以考虑使用 NotificationChannleGroup 来管理一下  。</p>
<h4 id="创建-NotificationChannleGroup"><a href="#创建-NotificationChannleGroup" class="headerlink" title="创建 NotificationChannleGroup"></a>创建 NotificationChannleGroup</h4><p>和创建 NotificationChannle 类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.createNotificationChannelGroup(new NotificationChannelGroup(groupId, groupName));</span><br></pre></td></tr></table></figure></p>
<h4 id="NotificationChannle-绑定-groupId"><a href="#NotificationChannle-绑定-groupId" class="headerlink" title="NotificationChannle 绑定 groupId"></a>NotificationChannle 绑定 groupId</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notificationChannel.setGroup(groupId);</span><br></pre></td></tr></table></figure>
<h4 id="删除-NotificationChannleGroup"><a href="#删除-NotificationChannleGroup" class="headerlink" title="删除 NotificationChannleGroup"></a>删除 NotificationChannleGroup</h4><p>可以批量删除该 Group 下的所有 Channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mNotificationManager.deleteNotificationChannelGroup(groupId2);</span><br></pre></td></tr></table></figure>
<p>参考地址：<br>[1]. NotificationChannl运用 <a href="http://gavinliu.cn/2017/08/22/Android-%E5%90%83%E5%A5%A5%E5%88%A9%E5%A5%A5%E7%B3%BB%E5%88%97-1-Notification/" target="_blank" rel="noopener">http://gavinliu.cn/2017/08/22/Android-%E5%90%83%E5%A5%A5%E5%88%A9%E5%A5%A5%E7%B3%BB%E5%88%97-1-Notification/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/22/Activity启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/Activity启动模式/" itemprop="url">android启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T13:39:38+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>任务<br>任务是指执行特定作业时与用户交互的一系列Activity，这些Activity按照各自的打开顺序排列在堆栈<br>（即“返回栈”）中。google为了记录用户开启了那些Activity，引入了 <strong>任务栈（task stack）</strong> 的概念，<br>用于记录activity开启的先后顺序，帮助维护好的用户体验。<strong>栈的特性是：先进后出</strong>。</li>
<li>如何查看当前系统的任务栈  <ul>
<li>手机中，长按 <strong>home或者多任务键</strong> 会进入到概览屏幕的一个界面；</li>
<li>命令行中，adb shell dumpsys activity；</li>
</ul>
</li>
<li><p>Activity启动模式<br>Activity启动模式在AndroidMainifest.xml文件里面的activity标签设置，属性名为android:launchMode，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.FirstActivity&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:label=&quot;This is FirstActivity&quot; &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>standard:标准模式，也是系统默认的，每次都会创建新的Activity覆盖在原Activity上。<br><img src="/images/ActivityStandard.jpg" alt="标准模式示意图">    </li>
<li>singleTop：栈顶复用模式，首先判断栈顶Activity是否是要启动的Activity，如果是则不创建新的<br>Activity而直接引用这个Activity；如果不是则创建新的Activity。<br><img src="/images/ActivitySingleTop.jpg" alt="栈顶复用模式示意图">  </li>
<li>singleTask：栈内复用模式，检测整个Activity栈中是否存在当前需要启动的Activity，如果存在<br>则将该Activity置于栈顶，并销毁其上所有Activity，如果不存在则创建新的Activity置于栈顶。<br><img src="/images/ActivitySingleTask.jpg" alt="栈内复用模式示意图">   </li>
<li>singleInstance：单实例模式，创建新的任务栈，且该任务栈仅有一个Activity。<br><img src="/images/ActivitySingleInstance.png" alt="单实例模式示意图">     </li>
</ul>
</li>
<li><p>其他   </p>
<ul>
<li>为Activity设置新的任务栈<br>taskAffinity，任务相关性。xml中的一个属性，标识了一个Activity所需要的任务栈的名字。默认是包名。如果设置了其他的名字如com.test.task1，那启动它的时候就会新建一个名为com.test.task1的任务栈。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.test.task0.MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">andorid:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">andorid:name</span>=<span class="string">"com.test.SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.test.task1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">andorid:name</span>=<span class="string">"com.test.ThirdActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.test.task1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span>/&gt;</span></span><br><span class="line"> ```  </span><br><span class="line"> 如果从MainActivity启动SecondActivity，然后再启动ThirdActivity，那么任务栈如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Blockquotes com.test.task0 MainActivity<br>Blockquotes com.test.task1 SecondActivity ThirdActivity<br>若再从ThirdActivity启动MainActivity，那么任务栈如下：<br>com.test.task0 MainActivity<br>com.test.task1 SecondActivity ThirdActivity MainActivit<br>总结：通过设置 TaskAffinity 属性更改任务栈属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 回退栈和通知  </span><br><span class="line">通过通知进入Activity存在的问题，默认情况下，从通知启动一个Activity，按返回键会回到主屏幕。但某些时候有按返回键仍然留在当前应用的需求。从通知打开的某个深层次Activity。在此Acitivity中点回退，若不做处理，将会直接返回到AndroidLaunch界面。这是因为在Notification中的PendingIntent会默认开启新的任务栈。当回退的时候此任务栈没有其他新的Activity，默认在PendingIntent 的Activity是任务栈中唯一的 Activity.</span><br></pre></td></tr></table></figure>
<p>举例： HomeActiy=&gt;Step1Activity=&gt;Step2Acitity<br>某个通知 默认在PendingIntent 指定了Step2Acitity。通过通知栏进入到Step2Acitity。点回退。正常的顺序为：<br>Step2Activity=&gt;Step1Acitivity=&gt;HomeActivity但是如果通过通知栏这样进入Step2Activity 点回退 会直接退回到Android 桌面。就是因为 PendingIntent会默认开启新的任务栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：通过TaskStackBuilder设置具体的回退路径,在 AndroidManifest.xml定义Acitivity从属关系。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Android 4.0.3 及更早版本</p>
<p><activity android:name=".ResultActivity"><br>    <meta-data android:name="android.support.PARENT_ACTIVITY" android:value=".MainActivity"><br></meta-data></activity><br>Android 4.1 及更高版本</p>
<p><activity android:name=".ResultActivity" android:parentactivityname=".MainActivity"><br></activity><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码中做如下处理：</span><br></pre></td></tr></table></figure></p>
<p>Intent intent = new Intent(MainActivity.this, ResultActivity.class);<br>TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(this);<br>taskStackBuilder.addParentStack(ResultActivity.class);<br>taskStackBuilder.addNextIntent(intent);<br>PendingIntent pendingIntent = taskStackBuilder.getPendingIntent(1, PendingIntent.FLAG_UPDATE_CURRENT);<br>NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this);<br>notificationBuilder.setContentIntent(pendingIntent);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这样从Notification进入到指定的ResultActivity中。回退到正常的MainActivity中。   </span><br><span class="line">**TaskStackBuilder 扩展应用**  </span><br><span class="line">也可以单独使用TaskStackBuilder，让某个二级Acitivity启动的时候启动它的一级Acitity.</span><br><span class="line">在 AndroidManifest.xml定义Acitivity从属关系。</span><br></pre></td></tr></table></figure></p>
<p>&lt;activity<br>    android:name=”com.example.app.ChildActivity<br>    android:parentActivityName=”com.example.app.ParentActivity” &gt;<br>    <!-- 下面这段用来兼容API 16之前的版本 --><br>    <meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.app.MainActivity"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码中申明：</span><br></pre></td></tr></table></figure></meta-data></p>
<p>Intent intent = new Intent(this, ChildActivity.class);<br>TaskStackBuilder.create(this)<br>                .addNextIntentWithParentStack(intent)<br>                .startActivities();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过启动一个无任何层级关系的Acitity 激活应用（目前Lianlian3.0应用采用此方法）</span><br></pre></td></tr></table></figure></p>
<p>public class SimpleLaunchAppActivity extends Activity {<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        // Now finish, which will drop the user in to the activity that was at the top<br>        //  of the task stack<br>        finish();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原理：若通过Notification打开Acitivity后此Acitivy会位于要启动的App的栈顶。自动finish()后，app恢复到切换到后台之前的状态。SimpleLaunchAppActivity不得设置android:taskAffinity。taskAffinity和默认App的包名一致就不会新建任务栈。若设置了taskAffinity为新的任务栈，点回退后 将会回到android launch页面。  </span><br><span class="line">联连wifi的解决方案:</span><br></pre></td></tr></table></figure></p>
<p>过启动一个无任何层级关系的TransparentSwitchActivity 激活应用**<br>目前存在的问题是TransparentSwitchActivity里面会根据参数判断 通过通知进入后还有部分逻辑不太人性化和完善。需要提高用户体验。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 关于系统默认的清空返回栈  </span><br><span class="line">如何用户将任务切换到后台之后过了很长一段时间，系统会将这个任务中除了最底层的那个Activity之外的其它所有Activity全部清除掉。当用户重新回到这个任务的时候，最底层的那个Activity将得到恢复。这个是系统默认的行为，因为既然过了这么长的一段时间，用户很有可能早就忘记了当时正在做什么，那么重新回到这个任务的时候，基本上应该是要去做点新的事情了。当然，既然说是默认的行为，那就说明我们肯定是有办法来改变的，在Manifest中 元素中设置以下几种属性就可以改变系统这一默认行为：</span><br></pre></td></tr></table></figure></p>
<p>alwaysRetainTaskState<br>如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。<br>clearTaskOnLaunch<br>如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。<br>finishOnTaskLaunch<br>这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。<br> ```</p>
<p>参考：<br>[1]. Activity启动模式 <a href="https://blog.csdn.net/lixiaodaoaaa/article/details/51700981" target="_blank" rel="noopener">https://blog.csdn.net/lixiaodaoaaa/article/details/51700981</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/22/androidCamera2使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/androidCamera2使用/" itemprop="url">androidCamera2使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T13:39:38+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Camera2-介绍"><a href="#Camera2-介绍" class="headerlink" title="Camera2 介绍"></a>Camera2 介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从android5.0开始对相机的API进行了全新的设计，这些API都在android.hardware.camera2包下，也是为了区分之前的API，新API不仅大幅提高了Android系统拍照等功能，还支持RAW照片输出，甚至允许程序调整相机的对焦模式、曝光模式、快门等。官网给出的说明如下：<br>Camera2 API  </p>
<ul>
<li>Supports 30fps full resolution with burst mode<br>支持30fps的全高清连拍</li>
<li>Supports change on manual camera settings between frame capture<br>支持帧之间的手动设置</li>
<li>Supports RAW image capture<br>支持RAW格式的图片拍摄</li>
<li>Supports Zero Shutter Lag &amp; Movie Snapshot<br>支持快门0延迟以及电影速拍</li>
<li>Supports setting other manual camera device controls including level of Noise Cancelling<br>支持相机其他方面的手动控制包括噪音消除的级别</li>
</ul>
<ol>
<li><p>Camera2工作流程示意图：<br><img src="/images/Camera2Flow.png" alt="camera2流程示意图"><br>&nbsp;&nbsp;&nbsp;&nbsp;Google采用了pipeline（管道）的概念，将Camera Device相机设备和Android Device安卓设备连接起来， Android Device通过管道发送CaptureRequest拍照请求给Camera Device，Camera Device通过管道返回CameraMetadata数据给Android Device，这一切建立在一个叫作CameraCaptureSession的会话中。  </p>
</li>
<li><p>Camera2类图：<br><img src="/images/Camera2Classes.png" alt="camera2类图"><br>&nbsp;&nbsp;&nbsp;&nbsp;其中CameraManager是所有相机设备（CameraDevice）的管理者，而每个CameraDevice自己会负责建立CameraCaptureSession以及建立CaptureRequest。CameraCharacteristics是CameraDevice的属性描述类，在CameraCharacteristics中可以进行相机设备功能的详细设定（当然了，首先你得确定你的相机设备支持这些功能才行）类图中有着三个重要的callback，其中CameraCaptureSession.CaptureCallback将处理预览和拍照图片的工作，需要重点对待。</p>
</li>
</ol>
<p>以上的类是如何相互配合的？下面是拍照的流程图：<br><img src="/images/Camera2Step.png" alt="camera2类图">       </p>
<ol>
<li>调用openCamera方法后会回调CameraDevice.StateCallback方法，该方法重写onPened函数；</li>
<li>在onOpened方法中调用createCaptureSession方法，该方法又回调CameraCaptureSession.StateCallback方法。</li>
<li>在CameraCaptureSession.StateCallback中重写onConfigured方法，设置setRepeatingRequest方法（也即开启预览）；</li>
<li>在setRepeatingRequest又会回调CameraCaptureSession.CaptureCallback方法；</li>
<li>重写CameraCaptureSession.CaptureCallback中的onCaptureCompleted方法，result就是未经过处理的元数据；  </li>
</ol>
<p>其中onCaptureProgressed方法很明显是在Capture过程中的，也就是在onCaptureCompleted之前，所以，在这之前相对图像干什么就看你的了，像美颜等操作就可以在这个方法中实现了。  </p>
<p>由此也可以看出Camera2相机使用还是简单的，其实就是3个Callback函数的回调，先说一下：setRepeatingRequest和capture方法其实都是向相机设备发送获取图像的请求，但是capture就获取那么一次，而setRepeatingRequest就是不停的获取图像数据，所以呢，使用capture就想拍照一样，图像就停在那里了，但是setRepeatingRequest一直在发送和获取，所以需要连拍的时候就调用它，然后在onCaptureCompleted中保存图像就行了。（注意了，图像的预览也是用的setRepeatingRequest，只要不处理数据就行了），从上面我们也了解到Camera2运用主要用到这些类：CameraManager、CameraDevice、CameraCharacteristics、CameraRequest与CameraRequest.Builder、CameraCaptureSession以及CaptureResult。  </p>
<ol>
<li><p>CameraManager：位于android.hardware.camera2.CameraManager下，也是Android 21(5.0)添加的，和其他系统服务一样通过 Context.getSystemService(CameraManager.class ) 或者Context.getSystemService(Context.CAMERA_SERVICE) 来完成初始化，主要用于管理系统摄像头：</p>
<ul>
<li>通过getCameraIdList()方法获取Android设备的摄像头列表，如今手机基本都有前后摄像头，有的手机则更多；  </li>
<li>通过getCameraIdList()方法获取Android设备的摄像头列表；  </li>
<li>openCamera(String cameraId, CameraDevice.StateCallback callback, Handler handler)打开指定Id的摄像头；  </li>
</ul>
</li>
<li><p>CameraDevice：CameraDevice是Camera2中抽象出来的一个对象，直接与系统硬件摄像头相联系。因为不可能所有的摄像头都会支持高级功能（即摄像头功能可被分为limit 和full 两个级别），当摄像头处于limited 级别时候，此时Camera2和早期的Camera功能差不多，除此之外在Camera2架构中，CameraDevice还承担其他两项重要任务：</p>
<ul>
<li>通过CameraDevice.StateCallback监听摄像头的状态（主要包括onOpened、onClosed、onDisconnected、onErro四种状态）；</li>
<li>管理CameraCaptureSession，通过方法createCaptureSession(List<surface> outputs, CameraCaptureSession.StateCallback callback, Handler handler)方法和createReprocessableCaptureSession(InputConfiguration inputConfig, List<surface> outputs, CameraCaptureSession.StateCallback callback, Handler handler)方法创建会话 （其中第三个参数： The handler on which the callback should be invoked, or null to use the current thread’s looper.），通常会在CameraDevice.StateCallback中调用对应方法创建预览会话。</surface></surface></li>
<li>管理CaptureRequest，主要包括通过createCaptureRequest（int templateType）创建捕获请求，在需要预览、拍照、再次预览的时候都需要通过创建请求来完成；</li>
</ul>
</li>
<li><p>CameraCaptureSession：系统向摄像头发送 Capture 请求，而摄像头会返回 CameraMetadata，这一切都是在由对应的 <strong>CameraDevice创建的CameraCaptureSession 会话</strong> 完成，当程序需要预览、拍照、再次预览时，都需要先通过会话。（A configured capture session for a CameraDevice, used for capturing images from the camera or reprocessing images captured from the camera in the same session previously.A CameraCaptureSession is created by providing a set of target output surfaces to createCaptureSession, or by providing an InputConfiguration and a set of target output surfaces to createReprocessableCaptureSession for a reprocessable capture session. Once created, the session is active until a new session is created by the camera device, or the camera device is closed.）CameraCaptureSession一旦被创建，直到对应的CameraDevice关闭才会死掉。虽然CameraCaptureSession会话用于从摄像头中捕获图像，但是 <strong>只有同一个会话才能再次从同一摄像头中捕获图像</strong>。另外，创建会话是一项耗时的异步操作，可能需要几百毫秒，因为它需要配置相机设备的内部管道并分配内存缓冲区以将图像发送到所需的目标，因而createCaptureSession和createReprocessableCaptureSession会将随时可用的CameraCaptureSession发送到提供的监听器的onConfigured回调中。如果无法完成配置，则触发onConfigureFailed回调，并且会话将不会变为活动状态。最后需要注意的是，<strong>如果摄像头设备创建了一个新的会话，那么上一个会话是被关闭的，并且会回调与其关联的onClosed</strong>，如果不处理好，当会话关闭之后再次调用会话的对应方法那么所有方法将会跑出IllegalStateException异常。关闭的会话清除任何重复的请求（和调用了stopRepeating()方法类似），但是在新创建的会话接管并重新配置摄像机设备之前，关闭的会话仍然会正常完成所有正在进行的捕获请求。简而言之，在Camera2中CameraCaptureSession承担很重要的角色：</p>
<ul>
<li>管理CameraCaptureSession.StateCallback状态回调，用于接收有关CameraCaptureSession状态的更新的回调对象，主要回调方法有两个当CameraDevice 完成配置，对应的会话开始处理捕获请求时触发onConfigured(CameraCaptureSession session)方法，反之配置失败时候触发onConfigureFailed(CameraCaptureSession session)方法；  </li>
<li>管理CameraCaptureSession.CaptureCallback捕获回调，用于接收捕获请求状态的回调，当请求触发捕获已启动时；捕获完成时；在捕获图像时发生错误的情况下；都会触发该回调对应的方法；  </li>
<li>通过调用方法capture(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)提交捕获图像请求（Submit a request for an image to be captured by the camera device.）即拍照，其中该请求定义了捕获单个图像的所有参数，包括传感器，镜头，闪光灯和后处理参数，每一次请求的结果将产生一个CaptureResult，可以为一个或多个Surface生成新的帧，然后 <strong>通过CaptureRequest.Builder的addTarget(Surface)方法附着到对应的Surface上显示</strong>，而且这个参数Surface必须是会话创建时候的一个子集，会话一次可以处理多个常规和重新处理请求。但如果只有常规请求或重新处理请求在进行，则以先进先出的顺序处理它们；如果两者都在进行中则分别以各自的先进先出顺序处理他们；然而，处理常规请求和重新处理请求的顺序并不是特定的，换言之，一个常规请求在下一个常规请求提交前被处理，同理重新处理请求也一样，但是一个常规请求不一定是在下一个重新处理请求提交之前被处理。通过capture方法提交的请求处理优先级比通过其他方式（ setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) 或者setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)）提交的请求的处理优先级高，一旦当前的repeat / repeatBurst处理完成，就会被处理。最后一点，所有CaptureSession可用于从相机捕获图像，但只有由createReprocessableCaptureSession创建的会话才可以提交重新处理捕获请求，<br>将重新处理请求提交到常规捕获会话将导致IllegalArgumentException；</li>
<li>通过调用方法setRepeatingRequest(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)请求不断重复捕获图像，即实现预览；  </li>
<li>通过方法调用stopRepeating()实现停止捕获图像，即停止预览；  </li>
</ul>
<ol>
<li><p>CameraCharacteristics：描述Cameradevice属性的对象，可以使用CameraManager通过getCameraCharacteristics（String cameraId）进行查询；</p>
</li>
<li><p>CameraRequest和CameraRequest.Builder：CameraRequest代表了一次捕获请求，而 <strong>CameraRequest.Builder用于描述捕获图片的各种参数设置，包含捕获硬件（传感器，镜头，闪存），对焦模式、曝光模式，处理流水线，控制算法和输出缓冲区的配置</strong>。，然后传递到对应的会话中进行设置，CameraRequest.Builder则负责生成CameraRequest对象。当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数。CameraRequest可以通过CameraRequest.Builder来进行初始化，通过调用createCaptureRequest来获得；</p>
</li>
<li><p>CaptureResult：CaptureRequest描述是从图像传感器捕获单个图像的结果的子集的对象。（CaptureResults are produced by a CameraDevice after processing a CaptureRequest）当CaptureRequest被处理之后由CameraDevice生成；</p>
</li>
<li><p>Camera2 主要角色之间的联系：<strong>CameraManager</strong>处于顶层管理位置<strong>负责检测获取所有摄像头及其特性和传入指定的CameraDevice.StateCallback回调打开指定摄像头</strong>，<strong>CameraDevice</strong> 是负责管理抽象对象，包括 <strong>监听Camera 的状态回调CameraDevice.StateCallback、创建CameraCaptureSession和CameraRequest，CameraCaptureSession</strong> 用于描述一次图像捕获操作，主要负责 <strong>监听自己会话的状态回调CameraCaptureSession.StateCallback和CameraCaptureSession.CaptureCallback捕获回调</strong>，还有发送处理 <strong>CameraRequest；CameraRequest</strong> 则可以看成是一个”JavaBean”的作用用于描述希望什么样的配置来处理这次请求；最后三个回调用于监听对应的状态。</p>
</li>
</ol>
</li>
</ol>
<h3 id="Camera2-使用"><a href="#Camera2-使用" class="headerlink" title="Camera2 使用"></a>Camera2 使用</h3><ol>
<li>权限配置：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//相机权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">//保存照片需要的权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">//录制视频需要的权限</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在6.0之后还需要在使用相机时动态判断是否具备权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private String[] permission = new String[]&#123;</span><br><span class="line">            Manifest.permission.CAMERA&#125;;</span><br><span class="line">if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                   requestPermissions(permission, 101);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>打开相机并实时预览：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread=new HandlerThread(&quot;Camera2&quot;);</span><br><span class="line">handlerThread.start();</span><br><span class="line">Handler childHandler=new Handler(handlerThread.getLooper());</span><br><span class="line">handler mainHandler=new Handler(getMainLooper());</span><br><span class="line"></span><br><span class="line">private void initCamera() &#123;</span><br><span class="line"></span><br><span class="line">  CameraManager cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">  try &#123;</span><br><span class="line">      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //打开摄像头</span><br><span class="line">      cameraManager.openCamera(CameraCharacteristics.LENS_FACING_BACK + &quot;&quot;, stateCallback, mainHandler);</span><br><span class="line">  &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相机状态监听回调</span><br><span class="line">private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onOpened(CameraDevice camera) &#123;//打开摄像头</span><br><span class="line">        mCameraDevice = camera;</span><br><span class="line">        //开启预览</span><br><span class="line">        takePreview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDisconnected(CameraDevice camera) &#123;//关闭摄像头</span><br><span class="line">        if (null != mCameraDevice) &#123;</span><br><span class="line">            mCameraDevice.close();</span><br><span class="line">            MainActivity.this.mCameraDevice = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(CameraDevice camera, int error) &#123;//发生错误</span><br><span class="line">        Toast.makeText(MainActivity.this, &quot;摄像头开启失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开始预览</span><br><span class="line"> */</span><br><span class="line">private void takePreview() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建预览需要的CaptureRequest.Builder</span><br><span class="line">        final CaptureRequest.Builder previewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        // 将SurfaceView的surface作为CaptureRequest.Builder的目标</span><br><span class="line">        previewRequestBuilder.addTarget(surfaceHolder.getSurface());</span><br><span class="line">        // 创建CameraCaptureSession，该对象负责管理处理预览请求和拍照请求</span><br><span class="line">        mCameraDevice.createCaptureSession(Arrays.asList(surfaceHolder.getSurface(), mImageReader.getSurface()), new CameraCaptureSession.StateCallback() // ③</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onConfigured(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                if (null == mCameraDevice) return;</span><br><span class="line">                // 当摄像头已经准备好时，开始显示预览</span><br><span class="line">                mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 自动对焦</span><br><span class="line">                    previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                    // 打开闪光灯</span><br><span class="line">                    previewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);</span><br><span class="line">                    // 显示预览</span><br><span class="line">                    CaptureRequest previewRequest = previewRequestBuilder.build();</span><br><span class="line">                    mCameraCaptureSession.setRepeatingRequest(previewRequest, null, childHandler);</span><br><span class="line">                &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onConfigureFailed(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, childHandler);</span><br><span class="line">    &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用相机拍照</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//设置Surface旋转角</span><br><span class="line">    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();</span><br><span class="line">    static &#123;</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_0,90);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_90,0);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_180,270);</span><br><span class="line">        ORIENTATIONS.append(Surface.ROTATION_270,180);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //imageReader初始化,！！！这个在初始化摄像头时赋值。</span><br><span class="line">    mImageReader = ImageReader.newInstance(mPreviewSize.getWidth(),</span><br><span class="line">    mPreviewSize.getHeight(),</span><br><span class="line">    ImageFormat.JPEG,</span><br><span class="line">    2 );                   </span><br><span class="line">     mImageReader.setOnImageAvailableListener(onImageAvailableListener , mBackgroundHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void takePicture()&#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);  </span><br><span class="line">        // 将imageReader的surface作为CaptureRequest.Builder的目标  </span><br><span class="line">        captureRequestBuilder.addTarget(imageReader.getSurface());  </span><br><span class="line">        // 自动对焦  </span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);  </span><br><span class="line">        // 获取手机方向  </span><br><span class="line">        int rotation = getWindowManager().getDefaultDisplay().getRotation();  </span><br><span class="line">        // 根据设备方向计算设置照片的方向  </span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATIONS.get(rotation));  </span><br><span class="line">        //拍照  </span><br><span class="line">        CaptureRequest mCaptureRequest = captureRequestBuilder.build();  </span><br><span class="line">        mSession.stopRepeating();  </span><br><span class="line">        mSession.capture(mCaptureRequest, null, mHandler);  </span><br><span class="line">    &#125; catch (CameraAccessException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**监听拍照的图片*/</span><br><span class="line">   private ImageReader.OnImageAvailableListener imageAvailableListener= new ImageReader.OnImageAvailableListener()</span><br><span class="line">   &#123;</span><br><span class="line">       // 当照片数据可用时激发该方法</span><br><span class="line">       @Override</span><br><span class="line">       public void onImageAvailable(ImageReader reader) &#123;</span><br><span class="line"></span><br><span class="line">           //先验证手机是否有sdcard</span><br><span class="line">           String status = Environment.getExternalStorageState();</span><br><span class="line">           if (!status.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">               Toast.makeText(getApplicationContext(), &quot;你的sd卡不可用。&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           // 获取捕获的照片数据</span><br><span class="line">           Image image = reader.acquireNextImage();</span><br><span class="line">           ByteBuffer buffer = image.getPlanes()[0].getBuffer();</span><br><span class="line">           byte[] data = new byte[buffer.remaining()];</span><br><span class="line">           buffer.get(data);</span><br><span class="line"></span><br><span class="line">           //手机拍照都是存到这个路径</span><br><span class="line">           String filePath = Environment.getExternalStorageDirectory().getPath() + &quot;/DCIM/Camera/&quot;;</span><br><span class="line">           String picturePath = System.currentTimeMillis() + &quot;.jpg&quot;;</span><br><span class="line">           File file = new File(filePath, picturePath);</span><br><span class="line">           try &#123;</span><br><span class="line">               //存到本地相册</span><br><span class="line">               FileOutputStream fileOutputStream = new FileOutputStream(file);</span><br><span class="line">               fileOutputStream.write(data);</span><br><span class="line">               fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">               //显示图片</span><br><span class="line">               BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">               options.inSampleSize = 2;</span><br><span class="line">               Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, options);</span><br><span class="line">               iv.setImageBitmap(bitmap);</span><br><span class="line">           &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               image.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用相机录像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//设置MediaRecoder属性</span><br><span class="line">private void setUpMediaRecorder() throws IOException &#123;</span><br><span class="line">       //设置音频源</span><br><span class="line">       mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">       //设置视频源</span><br><span class="line">       mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">       mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">       //存储路径</span><br><span class="line">       if (mNextVideoAbsolutePath == null || mNextVideoAbsolutePath.isEmpty()) &#123;</span><br><span class="line">           mNextVideoAbsolutePath = getVideoFilePath(getApplicationContext());</span><br><span class="line">       &#125;</span><br><span class="line">       mMediaRecorder.setOutputFile(mNextVideoAbsolutePath);</span><br><span class="line">       mMediaRecorder.setVideoEncodingBitRate(10000000);</span><br><span class="line">       mMediaRecorder.setVideoFrameRate(30);</span><br><span class="line">       //视屏宽高</span><br><span class="line">       mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">       //视屏编码格式</span><br><span class="line">       mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">       //音频编码格式</span><br><span class="line">       mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">       int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">       switch (mSensorOrientation) &#123;</span><br><span class="line">           case SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">               mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">               break;</span><br><span class="line">           case SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">               mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       mMediaRecorder.prepare();</span><br><span class="line">   &#125;</span><br><span class="line">   //视频录制</span><br><span class="line">private void startRecordingVideo() &#123;</span><br><span class="line">        if (null == mCameraDevice || !textureView.isAvailable() || null == mPreviewSize) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            closePreviewSession();</span><br><span class="line">            setUpMediaRecorder();</span><br><span class="line">            SurfaceTexture texture = textureView.getSurfaceTexture();</span><br><span class="line">            assert texture != null;</span><br><span class="line">            texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">            mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">            List&lt;Surface&gt; surfaces = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            // Set up Surface for the camera preview</span><br><span class="line">            Surface previewSurface = new Surface(texture);</span><br><span class="line">            surfaces.add(previewSurface);</span><br><span class="line">            mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line"></span><br><span class="line">            // Set up Surface for the MediaRecorder</span><br><span class="line">            Surface recorderSurface = mMediaRecorder.getSurface();</span><br><span class="line">            surfaces.add(recorderSurface);</span><br><span class="line">            mPreviewBuilder.addTarget(recorderSurface);</span><br><span class="line"></span><br><span class="line">            // Start a capture session</span><br><span class="line">            // Once the session starts, we can update the UI and start recording</span><br><span class="line">            mCameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                    mPreviewSession = cameraCaptureSession;</span><br><span class="line">                    updatePreview();</span><br><span class="line">                    runOnUiThread(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            // UI</span><br><span class="line">                            button.setText(&quot;stop&quot;);</span><br><span class="line">                            mIsRecordingVideo = true;</span><br><span class="line"></span><br><span class="line">                            // Start recording</span><br><span class="line">                            mMediaRecorder.start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;Failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, mBackgroundHandler);</span><br><span class="line">        &#125; catch (CameraAccessException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>录像主要时通过TextureView实现实时预览，同时使用MediaRecorder录制视屏。</p>
<p>参考：<br>[1]. Camera2完全解析 <a href="https://www.jianshu.com/p/d83161e77e90" target="_blank" rel="noopener">https://www.jianshu.com/p/d83161e77e90</a><br>[2]. Camera2介绍 <a href="https://blog.csdn.net/vinicolor/article/details/50992692" target="_blank" rel="noopener">https://blog.csdn.net/vinicolor/article/details/50992692</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/15/webpack4安装使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/webpack4安装使用/" itemprop="url">webpack4安装使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T16:07:35+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;官网手册为<a href="https://webpack.js.org/guides/getting-started/，但是在最后一步会出现npx" target="_blank" rel="noopener">https://webpack.js.org/guides/getting-started/，但是在最后一步会出现npx</a> webpack可能会出现错误，官网说是npx是在node 8.2或更高版本才行，但我的已经是v8.11.3。</p>
<p>其中dist为最终文件输出目录，src为需要编译打包的源文件；</p>
<ol>
<li><p>webpack安装：<br>webpack安装分两种模式：</p>
<ul>
<li>全局安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global webpack</span><br><span class="line">npm install --global webpack-cli</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面主要安装了webpakc基础库和webpack控制台（主要作用是命令行处理），通过上面那安装后在终端<br>运行webpack -v会显示webpack版本号，如果没有安装webpack-cli，此时会有提示让安装webpack-cli或者webpack-command两个中的一个,如果两个都安装了此时会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have installed webpack-cli and webpack-command together. To work with the &quot;webpack&quot; command you need only one CLI package, please remove one of them or use them directly via their binary.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时需要移除其中一个即可，执行npm remove  webpack-cli 或者 npm remove webpack-command移除当前项目的， 全局的话使用npm remove –global webpack-cli。  </p>
<ul>
<li>安装到你的项目目录：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>!!! 全局安装了webpack后在npm脚本配置时，需要在当前目录安装npm install  –save-dev webpack-command，否则会报错误显示找不到webpack的module。</p>
<ol>
<li><p>项目包结构：<br><img src="images/webpack_package_struct.png" alt="包结构"><br>其中dist为webpack <strong>默认</strong> 的打包后最终输出的文件所在目录，src为webpack <strong>默认</strong> 的编写的js所在目录，main.js为webpack将src下的js打包集成的 <strong>默认</strong> 文件。<br>此时package.json中的依赖应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.12.0&quot;,</span><br><span class="line">    &quot;webpack-command&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.9.7&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack配置：<br>webpack配置的文件名称 <strong>默认</strong> 为：webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry:  &quot;./src/index.js&quot;, //入口文件,使用相对路径</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: __dirname + &quot;/dist&quot;,   //打包后的文件存放的地方，使用绝对路径</span><br><span class="line">      filename: &quot;bundle.js&quot;   //打包后输出文件的文件名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时打包命令为：webpack –config webpack.config.js，也可以不加config参数。</p>
<ol>
<li>npm脚本化：<br>通过npm实现打包编译则需要对package.json文件处理：主要是在scripts下添加build属性：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;   //脚本化的命令和执行者</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^2.0.9&quot;,</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.5&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后打包命令则为 <strong>npm run build</strong>。</p>
<p>参考地址：<br>[1].  官网 <a href="https://webpack.js.org/guides/getting-started/" target="_blank" rel="noopener">https://webpack.js.org/guides/getting-started/</a><br>[2].  webpack入门 <a href="https://segmentfault.com/a/1190000006178770" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006178770</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/14/AndroidSupport库-AsynListUtil/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/AndroidSupport库-AsynListUtil/" itemprop="url">Android Support库:AsynListUtil</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T09:21:13+08:00">
                2018-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;在介绍完 Android Support 库发展历程（<a href="http://blog.chengyunfeng.com/?p=1047）后，" target="_blank" rel="noopener">http://blog.chengyunfeng.com/?p=1047）后，</a> 再分别介绍下 Android Support 库中有用但是被忽略的一些功能。了解这些功能，在需要的时候可以避免在引入其他类似的第三方库或者避免自己重复制造轮子，提高开发效率。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这是一系列的介绍文章，每次介绍 Support 库中的一个功能，篇幅尽可能的短，方便大家利用碎片时间阅读。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这次介绍来自 recyclerview-v7 中的 AsyncListUtil 类。</p>
<h4 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RecyclerView 发布后大家应该都放弃使用 ListView 了。使用 RecyclerView 需要对数据控制的更精细，比如如果删除了某个位置的数据，则需要使用 RecyclerView.Adapter 的 notifyItemRemoved(int position) 函数来通知 RecyclerView 被删除的数据，这样 RecyclerView 就可以实现一个删除该条数据的动画，而 ListView 只要数据变化了，都只需要调用 notifyDataSetChanged() 即可。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而在使用 RecyclerView 过程中数据来源是各种各样的，数据可以来自于网络、也可以是数据库、还可以是读取文件，不同的数据来源对 Adapter 的处理也是有差别的。本次介绍的 AsyncListUtil <strong>适用于数据来源数据库或者本地磁盘的情况</strong>。</p>
<h4 id="AsyncListUtil"><a href="#AsyncListUtil" class="headerlink" title="AsyncListUtil"></a>AsyncListUtil</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;AsyncListUtil 是一个用来异步加载数据的类。例如，如果你的数据是来至于数据库的，则可以使用 AsyncListUtil 在后台批量加载 Cursor 中的数据，当数据加载完成后在通知 UI 线程使用，并且 AsyncListUtil 支持数据缓存，这样可以实现非常流畅的滚动性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;AsyncListUtil 在后台线程加载数据，每次加载一批数据，数据的个数是可以配置的，并且在内存中缓存了一些数据来提高效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;AsyncListUtil 使用一个后台线程来加载数据，所以 AsyncListUtil 适合用来从磁盘加载数据的情况（比如，读取数据库、读取文件等），而不适合从网络获取数据的情况。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;AsyncListUtil 有如下四个函数可以使用：</p>
<ul>
<li>T getItem (int position)： 返回 position 位置的数据，如果数据尚未加载完成，则返回 null;</li>
<li>int getItemCount () 返回数据集的个数，该数值为 DataCallback.refreshData() 函数返回的值</li>
<li>void onRangeChanged () 更新当前数据可见范围，当 RecyclerView 滚动的时候，需要回调这个函数来告诉 AsyncListUtil 可见数据范围发生变化，需要根据当前新的可见数据范围来加载所需数据，在 RecyclerView 的 <a href="https://developer.android.google.cn/reference/android/support/v7/widget/RecyclerView.OnScrollListener.html#onScrolled(android.support.v7.widget.RecyclerView, int, int" target="_blank" rel="noopener">onScrolled(RecyclerView, int, int)</a>) 中调用该函数即可。</li>
<li>void refresh () ： 如果数据发生了变化， 调用该函数来强制重新加载数据，丢弃之前缓存的数据。<br>AsyncListUtil 有两个回调函数分别处理数据加载和 UI 通知事件：AsyncListUtil.DataCallback 和 AsyncListUtil.ViewCallback。</li>
</ul>
<h4 id="AsyncListUtil-DataCallback"><a href="#AsyncListUtil-DataCallback" class="headerlink" title="AsyncListUtil.DataCallback"></a>AsyncListUtil.DataCallback</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;DataCallback 类提供了在后台加载数据的功能，里面定义了如下四个函数，这些函数都是在后台线程中执行的:</p>
<ul>
<li>int refreshData () ： 刷新数据，返回新的数据个数，如果你所加载的数据来自于 Cursor，则当数据发生变化的时候，在这里从新生成一个 Cursor 并返回 Cursor 的数目。</li>
<li>void fillData (T[] data, int startPosition, int itemCount) ：加载数据，其中 data 数组是加载后的数据，而 startPosition 是数据开始的位置，而 itemCount 是加载数据的 个数。 data 数组中的对象是可以重复利用的，如果 data[i] 的数据不为 null，则可以重复利用而无需重新创建数据对象。</li>
<li>int getMaxCachedTiles () ： 返回缓存数量的限制，一般不用实现这个函数，默认实现即可。</li>
<li>void recycleData (T[] data, int itemCount) ： 回收 fillData 中所创建的数据，如果你的数据包含需要回收的资源，则可以在这里处理。  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一般只需要实现 refreshData 和 fillData 函数即可。</p>
<h4 id="AsyncListUtil-ViewCallback"><a href="#AsyncListUtil-ViewCallback" class="headerlink" title="AsyncListUtil.ViewCallback"></a>AsyncListUtil.ViewCallback</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ViewCallback 类提供了和 RecyclerView 关联的接口，里面的函数都是在 UI 线程中调用的，该类同样定义了四个函数：</p>
<ul>
<li>void onItemLoaded (int position) ： 当 position 位置的数据加载完后会调用该函数；</li>
<li>void onDataRefresh () ： 当数据集发生变化的时候调用；</li>
<li>void getItemRangeInto (int[] outRange) ： 返回当前可见的数据范围，参数 outRange 数组长度为2， outRange[0] 为第一个可见数据的位置，outRange[1] 为 最后一个可见数据的位置；</li>
<li>void extendRangeInto (int[] range, int[] outRange, int scrollHint) 用来计算平滑滚动所需要加载的额外数据，一般不用实现这个函数，默认实现即可；</li>
</ul>
<p> 参考：<br> [1]. 示例代码 <a href="https://github.com/CattleFoot/RecyclerViewUtils" target="_blank" rel="noopener">https://github.com/CattleFoot/RecyclerViewUtils</a><br> [2]. 官网文档 <a href="https://developer.android.google.cn/reference/android/support/v7/util/AsyncListUtil" target="_blank" rel="noopener">https://developer.android.google.cn/reference/android/support/v7/util/AsyncListUtil</a><br> [3]. 译文 <a href="http://blog.chengyunfeng.com/?p=1057" target="_blank" rel="noopener">http://blog.chengyunfeng.com/?p=1057</a><br> [4]. 分页加载ORM数据 <a href="https://blog.csdn.net/zhangphil/article/details/78661838" target="_blank" rel="noopener">https://blog.csdn.net/zhangphil/article/details/78661838</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/13/java单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/java单例模式/" itemprop="url">java单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T16:42:17+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ol>
<li><p>什么是Singleton类？你之前用过Singleton吗？<br>Singleton是一个类，在整个应用程序中只有一个实例，并提供一个getInstance（）方法来访问单例实例。在JDK中有许多类是使用Singleton模式实现的，如java.lang.Runtime，它提供了getRuntime（）方法来访问它并用于获得Java中的可用内存和总内存。</p>
</li>
<li><p>单例模式优缺点：</p>
<ul>
<li>优点：  <ul>
<li>提供了对唯一实例的受控访问；</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；</li>
<li>允许可变数目的实例；</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难；</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="单例模式的五种实现"><a href="#单例模式的五种实现" class="headerlink" title="单例模式的五种实现"></a>单例模式的五种实现</h4><ol>
<li><p>懒汉</p>
<ul>
<li>1.1 懒汉，线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。</p>
<ul>
<li>1.2 懒汉，线程安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。  </p>
</li>
<li><p>饿汉</p>
<ul>
<li>2.1 饿汉，基本型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</span><br><span class="line"></span><br><span class="line"> - <span class="number">2.2</span> 饿汉，变种   </span><br><span class="line"> ```Java</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表面上看起来差别挺大，其实跟2.1方式差不多，都是在类初始化即实例化instance。  </p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟2.1和2.2方式不同的是（很细微的差别）：2.1和2.2方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比2.1和2.2种方式就显得很合理。  </p>
</li>
<li>双重校验锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个是1.2方式的升级版，俗称双重检查锁定，详细介绍请查看：<a href="http://www.ibm.com/developerworks/cn/java/j-dcl.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-dcl.html</a><br>在JDK1.5之后，双重检查锁定才能够正常达到单例效果。  </p>
<ol>
<li>枚举<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化和通过反射重新创建新的对象，可谓是很坚强的壁垒啊，这种方式在1.5中才加入的enum特性。</p>
<h4 id="单例模式的安全性问题"><a href="#单例模式的安全性问题" class="headerlink" title="单例模式的安全性问题"></a>单例模式的安全性问题</h4><p>懒汉式、饿汉式、内部类、双重锁、枚举这5种单例模式中，枚举最为特殊，由于是官方提供的一种模式，所以不能被破解，是十分安全的。其他四种在一定程度上会有一定安全问题。</p>
<p>关于懒汉式的单利破解：</p>
<ol>
<li>用反射破解单例模式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Singleton s011 = Singleton.getInstance();  </span><br><span class="line">        Singleton s012 = Singleton.getInstance();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用反射创建新对象  </span></span><br><span class="line">        Class&lt;Singleton&gt; h1 = (Class&lt;Singleton&gt;) Class.forName(<span class="string">"Singleton"</span>);<span class="comment">//反射获取H1对象  </span></span><br><span class="line">        Constructor c = h1.getDeclaredConstructor(<span class="keyword">null</span>);<span class="comment">//获取无参构造函数  </span></span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);<span class="comment">//更改无参构造函数权限为公开  </span></span><br><span class="line">        Singleton s013 = (Singleton) c.newInstance(<span class="keyword">null</span>);<span class="comment">//创建新对象  </span></span><br><span class="line"></span><br><span class="line">        System.out.println(s011);  </span><br><span class="line">        System.out.println(s012);  </span><br><span class="line">        System.out.println(s013);  </span><br><span class="line">        System.out.println(s011 == s012);  </span><br><span class="line">        System.out.println(s011 == s013);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singleton@<span class="number">1</span>bc4459  </span><br><span class="line">Singleton@<span class="number">1</span>bc4459  </span><br><span class="line">Singleton@<span class="number">12</span>b6651  </span><br><span class="line"><span class="keyword">true</span>  </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>用反序列化（需要实现Serializable）单例模式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Singleton s011 = Singleton.getInstance();  </span><br><span class="line">        Singleton s012 = Singleton.getInstance();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用反序列化创建新对象  </span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/a.txt"</span>);  </span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);  </span><br><span class="line">        oos.writeObject(s011);  </span><br><span class="line">        fos.close();  </span><br><span class="line">        oos.close();  </span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);  </span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);  </span><br><span class="line">        Singleton s013 = (Singleton) ois.readObject();  </span><br><span class="line">        fis.close();  </span><br><span class="line">        ois.close();  </span><br><span class="line"></span><br><span class="line">        System.out.println(s011);  </span><br><span class="line">        System.out.println(s012);  </span><br><span class="line">        System.out.println(s013);  </span><br><span class="line">        System.out.println(s011 == s012);  </span><br><span class="line">        System.out.println(s011 == s013);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出的结果是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singleton@<span class="number">13</span>bad12  </span><br><span class="line">Singleton@<span class="number">13</span>bad12  </span><br><span class="line">Singleton@<span class="number">1</span>a626f  </span><br><span class="line"><span class="keyword">true</span>  </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>以上知道了如果破解,那么如果避免,代码应该这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;  </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式模式：在类加载时不初始化，当需要时再反馈（延迟加载）</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">//私有化构造函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;<span class="comment">//防止反射破解  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//添加synchronized防止多线程插入问题  </span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止反序列化破解  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> wife;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>   </p>
<p>有两个问题需要注意：</p>
<ol>
<li><p>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每 个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>该问题修复的办法是:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;     </span><br><span class="line">     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();     </span><br><span class="line">     <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)     </span><br><span class="line">        classLoader = Singleton.class.getClassLoader();     </span><br><span class="line">     <span class="keyword">return</span> (classLoader.loadClass(classname));     </span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>该问题修复的办法是：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();     </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">   &#125;     </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//主要在这里！！！   </span></span><br><span class="line">            <span class="keyword">return</span> INSTANCE;     </span><br><span class="line">      &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<br>[1]. 单例模式的实现 <a href="https://blog.csdn.net/liangxw1/article/details/51353654" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51353654</a><br>[2]. 单例模式面试问题 <a href="https://blog.csdn.net/u012613251/article/details/79477525" target="_blank" rel="noopener">https://blog.csdn.net/u012613251/article/details/79477525</a><br>[3]. 单例模式的破解 <a href="https://blog.csdn.net/a445849497/article/details/57531266" target="_blank" rel="noopener">https://blog.csdn.net/a445849497/article/details/57531266</a><br>[4]. 单例模式的优缺点 <a href="https://blog.csdn.net/tayanxunhua/article/details/8250329" target="_blank" rel="noopener">https://blog.csdn.net/tayanxunhua/article/details/8250329</a><br>[5]. 枚举实现单例模式更好 <a href="https://blog.csdn.net/normallife/article/details/51152246" target="_blank" rel="noopener">https://blog.csdn.net/normallife/article/details/51152246</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/06/06/DDComponent原理剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/DDComponent原理剖析/" itemprop="url">DDComponentForAndroid原理剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T11:11:27+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DDComponentForAndroid组件化实现原理主要基于两点：  </p>
<ol>
<li>静态注解：作用是实现路由的扫描、路由注册接口实现、路由表生成、路由参数的传递；  </li>
<li>gladle plugin：作用是动态调整编译脚本、资源管理和类修改；</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>注解知识点和自定义注解请参考：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DDComponentForAndroid中定义了两个注解：RouteNode（路由节点）和Autowired（参数装配），这个两个注解分别用于标记那些页面（DD中指的时activity）可以作为一个路由节点和这个页面需要那些参数。再看看DDComponentForAndroid中怎么根据这个两个注解去实现路由的扫描、路由注册接口的实现、路由表的生成、路由参数注入。</p>
<ol>
<li>RouteNode注解的注解处理器为RouterProcessor，该注解处理器主要做以下几件事情：  <ul>
<li>解析注解：查找所有activity上标注了RouteNode注解元素，并记录路由节点同时扫描Autowired注解同样记录注解标记的参数和参数类型；</li>
<li>路由注册接口的实现，根据gradle脚本下host属性并结合RouteNode中的path值生成一个java类该类通过继承BaseCompRouter然后实现getHost和initMap分别返回host标志和向父类登记路由（path）；</li>
<li>生成路由表：依照解析注解时记录的路由节点生成一个txt文件，文件写明了host名称，path路径和每个节点需要的参数；</li>
</ul>
</li>
<li>Autowired注解的注解处理器为AutowiredProcessor，该注解处理器主要做以下几件事情：  <ul>
<li>解析注解：查找所有activity中属性标注了Autowired注解元素，并根据activity名称进行分类记录下标记的属性；</li>
<li>生成参数注入的辅助类：依照解析注解记录的参数分类记录为每个activity生成一个注入辅助类（类名后缀为：$$Router$$Autowired，这个可以根据自己喜好来的），这个辅助类是类ISyringe接口的实现；<br>sign<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上静态注解处理器生成的java类都在[module名称]/build/generated/source/apt下的debug或release下。而路由表的生成路径就看源码里面设置的在哪里，主要还是<strong>注解处理器生成的java类</strong>。</li>
</ul>
</li>
</ol>
<p>通过以上分析，静态注解部分工作已经完成，也可以看到所有的结果还是在具体module下，各个module还是对非自身内的路由不可见的，结下就是让各个module的路由对其他module可见，这个呢则是通过gladle plugin来达到这个目的。接下来分析gladle plugin如何去实现各个module的路由可见。</p>
<p>gladle plugin主要工作是动态调整编译脚本、资源管理和类修改，进一步看下其是如何实现的；</p>
<ol>
<li><p>动态调整编译脚本：</p>
<ul>
<li>记录当前assemble的module的名称，也就是点击AS的右三角运行的module；</li>
<li>查找module下gradle配置文件中的isRunAlone属性，同时查找根项目下的gradle配置文件中的mainModuleName属性；</li>
<li>根据上面两步的结果，判定当前module是主项目还是依赖的项目，如果是主项目则动态设置编译脚本应用的插件为application，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.apply plugin: <span class="string">'com.android.application'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果是依赖的项目则动态设置编译脚本应用的插件为library，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.apply plugin: <span class="string">'com.android.library'</span></span><br></pre></td></tr></table></figure>
<p>通过动态调整编译脚本，现在已经实现了各个module的class文件对其他module是可见的了，但是目前还是不能实现路由间的跳转，继续分析。</p>
</li>
<li>资源文件管理：  <ul>
<li>在第1步中前两步知道当前那些module是依赖的项目，注意！！android中application和library的AndroidManifest，因此对于依赖的项目中的AndroidManifest文件进行管理或者修改，DDComponentForAndroid通过指定另外的路径来加载library的AndroidManifest文件。</li>
</ul>
</li>
<li><p>类修改：</p>
<ul>
<li>扫描所有项目的directory文件，扫描出application文件并记录；</li>
<li>扫描所有项目的directory文件，扫描出实现了接口IApplicationLike的文件并记录，应为在IApplicationLike实现类中会去注册路由实现类；</li>
</ul>
<p>通过类修改，这个样就达到了路由间的跳转。自此组件化就达到了，而且各个组件间可以独立调试无需手动再次设置。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/05/29/Android自定义注解处理器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/29/Android自定义注解处理器/" itemprop="url">Android自定义注解处理器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T15:24:49+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>  在开发中经常使用到注解，最近在研究DDComponent插件化时又碰到了。因此，也再次深入了解了注解，<br>记录下在学习过程中学到的一些知识。目前比较主流的框架也多数用到了注解技术，如：ButterKnife、Dagger2、<br>Retrofit、Glide等。<br>注解一般分为两种：运行时注解；编译时注解。<br>运行时注解：一般配合反射机制使用，相对编译时注解性能比较低，但灵活性好。例如：Retrofit用的就是<br>运行时注解。<br>编译时注解：编译时注解能够自动处理java源文件，并可以根据需要生成新的文件。</p>
<h3 id="基础知识点-元注解"><a href="#基础知识点-元注解" class="headerlink" title="基础知识点-元注解"></a>基础知识点-元注解</h3><p>  元注解的作用是负责注解其他注解，Java5.0定义了 <strong>4个标准的meta-annotation类型</strong>，它们被<br>用来提供对其它 annotation类型作说明。Java5.0定义的元注解：@Target、@Retention、@Documented、@Inherited。</p>
<ol>
<li>@Target:说明了Annotation所修饰的对象范围，其取值为枚举类java.lang.annotation.ElementType。<br>取值类型有：<ul>
<li>TYPE：Class, interface (including annotation type), or enum declaration（用于描述类、接口(包括注解类型) 或enum声明）;</li>
<li>FIELD：Field declaration (includes enum constants)（用于描述域）</li>
<li>METHOD：Method declaration（用于描述方法）;</li>
<li>PARAMETER：Formal parameter declaration（用于描述参数）;</li>
<li>CONSTRUCTOR：Constructor declaration（用于描述构造器）;</li>
<li>LOCAL_VARIABLE：Local variable declaration（用于描述局部变量）;</li>
<li>ANNOTATION_TYPE：Annotation type declaration（用于注解类型声明）;</li>
<li>PACKAGE：Package declaration（用于描述包）;</li>
<li>TYPE_PARAMETER：Type parameter declaration（用于类型定义），since 1.8;</li>
<li>TYPE_USE：Use of a type（？？？？？），since 1.8;</li>
</ul>
</li>
<li>@Retention:定义了Annotation被保留的时间长短,其取值为枚举类java.lang.annotation.RetentionPolicy。<br>取值类型有：<ul>
<li>SOURCE:Annotations are to be discarded by the compiler(注解仅存在于源码中，在class字节码文件中不包含);</li>
<li>CLASS:默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得;</li>
<li>RUNTIME:注解会在class字节码文件中存在，在运行时可以通过反射获取到;</li>
</ul>
</li>
<li>@Documented:用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类<br>的工具文档化。Documented是一个标记注解，没有成员。</li>
<li>@Inherited:阐述了某个被标注的类型是被继承的，同样是一个标记注解，没有成员。</li>
</ol>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<h4 id="定义注解格式："><a href="#定义注解格式：" class="headerlink" title="定义注解格式："></a>定义注解格式：</h4><p>　　public @interface 注解名 {定义体}<br>　　注解参数的可支持数据类型：<br>　　　　1. 所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>　　　　2. String类型<br>　　　　3. Class类型<br>　　　　4. enum类型<br>　　　　5. Annotation类型<br>　　　　6. 以上所有类型的数组<br>　　Annotation类型里面的参数该怎么设定:<br>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；<br>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;<br>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号。<br>一个简单的自定义注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。</p>
<h4 id="注解处理器类库（java-lang-reflect-AnnotatedElement"><a href="#注解处理器类库（java-lang-reflect-AnnotatedElement" class="headerlink" title="注解处理器类库（java.lang.reflect.AnnotatedElement"></a>注解处理器类库（java.lang.reflect.AnnotatedElement</h4><p>Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：<br>　　- Class：类定义<br>　　- Constructor：构造器定义<br>　　- Field：累的成员变量定义<br>　　- Method：类的方法定义<br>　　- Package：类的包定义</p>
<p>　　java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。<br>  AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p>
<ol>
<li><t extends="" annotation=""> T getAnnotation(Class<t> annotationClass): 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。  </t></t></li>
<li>Annotation[] getAnnotations():返回该程序元素上存在的所有注解。   </li>
<li>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。</li>
<li><p>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。  </p>
<p>示例程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFruitInfo</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String strFruitName=<span class="string">" 水果名称："</span>;</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(FruitName.class))&#123;</span><br><span class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);</span><br><span class="line">                strFruitName=strFruitName+fruitName.value();</span><br><span class="line">                System.out.println(strFruitName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是<strong>理论</strong>部分提到的运行时注解，在运行时配合反射机制使用。早期的butterknife确实是使用的动态注解的方式。可是后来，静态注解出现了，如燎原之火般席卷而来。接下来是静态注解。</p>
</li>
</ol>
<h3 id="Android自定义注解处理器"><a href="#Android自定义注解处理器" class="headerlink" title="Android自定义注解处理器"></a>Android自定义注解处理器</h3><p>在Android中自定义注解处理器一般通过继承AbstractProcessor类来实现，通过process方法进行处理。需要注意的是，注解处理器只能生成新的文件，不能修改已存在的源文件。AbstractProcessor类是接口Processor类，其在Java1.7加入，用于处理编译时的注解。<br>自定义注解处理其主要分为6个步骤:</p>
<h4 id="第一步-创建Java-Library项目"><a href="#第一步-创建Java-Library项目" class="headerlink" title="第一步 创建Java Library项目"></a>第一步 创建Java Library项目</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们新建一个Java Library项目，来作为注解处理器模块。注意是Java Library，不是Android Library。因为我们要用到的是javax包中的类，而Android Library中的JDK不包含这些类。</p>
<h4 id="第二步-新建自定义注解"><a href="#第二步-新建自定义注解" class="headerlink" title="第二步 新建自定义注解"></a>第二步 新建自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RouteNode &#123;</span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步-新建自定义注解处理器"><a href="#第三步-新建自定义注解处理器" class="headerlink" title="第三步 新建自定义注解处理器"></a>第三步 新建自定义注解处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过新建的AutowiredProcessor，知道要实现抽象类<br>AbstractProcessor的process方法，在这个方法中处理注解与生成新文件的。另外需要注意的是：<br><strong>1.需要配置注解处理器支持处理的注解；2.需要指定支持java的源码版本</strong>，这两点我们可以通过Override<br>抽象类AbstractProcessor的getSupportedAnnotationTypes()和getSupportedSourceVersion()方法类配置，或者通过注解的形式来配置，这个稍后再升级下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该处理器支持的所有注解类集合，在这里可以添加自定义注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加自定义注解</span></span><br><span class="line">        set.add(RouteNode.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该处理器支持的JDK版本，例如：SourceVersion.RELEASE_7</span></span><br><span class="line"><span class="comment">     * 一般返回SourceVersion.latestSupported()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="第四步-处理process-方法，并生成文件"><a href="#第四步-处理process-方法，并生成文件" class="headerlink" title="第四步 处理process()方法，并生成文件"></a>第四步 处理process()方法，并生成文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">     StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"package com.xuhj.java.processor;\n"</span>)</span><br><span class="line">              .append(<span class="string">"public class GeneratedTemplate&#123;\n"</span>)</span><br><span class="line">              .append(<span class="string">"\tpublic String getMessage()&#123;\n"</span>)</span><br><span class="line">              .append(<span class="string">"\t\treturn \""</span>);</span><br><span class="line">      <span class="keyword">for</span> (Element element : roundEnvironment.getElementsAnnotatedWith(Template.class)) &#123;</span><br><span class="line">          String objectType = element.getSimpleName().toString();</span><br><span class="line">          sb.append(objectType).append(<span class="string">" say hello!\\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sb.append(<span class="string">"\";\n"</span>)</span><br><span class="line">              .append(<span class="string">"\t&#125;\n"</span>)</span><br><span class="line">              .append(<span class="string">"&#125;\n"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          JavaFileObject source = processingEnv.getFiler()</span><br><span class="line">                  .createSourceFile(<span class="string">"com.xuhj.java.processor.generated.GeneratedTemplate"</span>);</span><br><span class="line">          Writer writer = source.openWriter();</span><br><span class="line">          writer.write(sb.toString());</span><br><span class="line">          writer.flush();</span><br><span class="line">          writer.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上我们自定义注解处理器已经写好了，下一步就是如何集成到具体项目中。</p>
<h4 id="第五步-声明自定义注解处理器"><a href="#第五步-声明自定义注解处理器" class="headerlink" title="第五步 声明自定义注解处理器"></a>第五步 声明自定义注解处理器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用前，还需要声明注解处理器，也即广而告之当前项目下有那些注解处理器。<br>其声明主要在 <strong>main目录</strong> 下，新建 <strong>resource/META-INF/services目录</strong>，并在目录下新建一个 <strong>javax.annotation.processing.Processor</strong> 文件，这个也可以通过注解的形式来配置，这个稍后再升级下。<br>在文件中使用文本声明已经编写好的注解处理器，每个注解处理器各占一行。<br>最后执行 <strong>Make Project</strong>，就可以在build目录下看到生成好的jar包。可以直接拿jar包集成到项目中或者依赖该项目亦可。</p>
<h4 id="第六步-集成到项目中"><a href="#第六步-集成到项目中" class="headerlink" title="第六步 集成到项目中"></a>第六步 集成到项目中</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将生成的jar包放到项目的libs中或者使项目依赖注解处理器的项目，就可以使用注解处理器了，执行Make Project，就会在项目的build/generated/source/apt/debug下看到通过注解处理器生成的java文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有生成java文件，请检查注解器的声明是否写错。</p>
<p><strong>总结</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面自定义注解处理器已经可以使用了，其主要是通过继承抽象AbstractProcessor类并实现process方法，同时配置注解器支持的java版本和注解，最后对外声明注解器本身在哪里即可。用注解处理器的好处是可以自动生成一些重复大量的代码，并且能让类变得干净、逻辑清晰。</p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第三步和第五步讲到可以通过注解的形式来配置注解器支持的java版本、注解和声明，为何要这样做呢，主要是在声明的时候容易人为的输入容易出错而且麻烦。使用注解配置前，需要引入注解所在的jar<br>包（com.google.auto.service:auto-service）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation ‘com.google.auto.service:auto-service:<span class="number">1.0</span>-rc2’</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意auto-service的不同版本（存在兼容性），然后通过注解来配置和声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明当前类为是注解处理器，Processor.class为静态注解入口也是一个接口</span></span><br><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="comment">//支持的注解</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"com.mugwort.annotation.RouteNode"</span>)</span><br><span class="line"><span class="comment">//支持的java版本</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong> 这里有一点不好就是注解的支持只能手写。</p>
<h4 id="调试注解器"><a href="#调试注解器" class="headerlink" title="调试注解器"></a>调试注解器</h4><p>编写代码不可避免会出现错误的，如何定位错误则需要调试的，而注解器如何调试呢？调试有两种方式：日志定位；断点调试；</p>
<ol>
<li><p>日志定位，繁琐但方便快捷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. sout</span></span><br><span class="line">System.out.println(xxx)</span><br><span class="line"><span class="comment">// 2. messager</span></span><br><span class="line">processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, <span class="string">"only support field"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断点调试：<br>注解器的断点调试比较麻烦点，不像java那样，其主要分为三个步骤。</p>
<ol>
<li>配置debug后台服务，在在gradle.properties文件中加入下面两句话，然后sync一下项目（或者在控制台执行./gradlew –daemon），会开启一个远程debug_server。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.daemon=<span class="keyword">true</span></span><br><span class="line">org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">5005</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>配置Remote Debugger，在AS中创建一个Remote Debugger。</p>
</li>
<li><p>执行编译过程，在需要的位置打开断点，在控制台输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDebug</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>或者，待清除功能的编译<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean assembleDebug</span><br></pre></td></tr></table></figure></p>
<p>配置没问题的话就会走到打开的断点，然后就可以调试了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/04/15/mvc-mvp和mvvm理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/mvc-mvp和mvvm理解/" itemprop="url">mvc_mvp和mvvm理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T10:25:44+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MVC、MVP和MVVM是Android耳熟能详的三个模式，且应用广泛。对于三者的内容、区别、使用场景有时很能道出个123，而且这些框架思想在各个平台都有，但对于各个平台具体的实现有一定差异和限制。本文主要从Android方面来介绍它们。主要有：  </p>
<ul>
<li>了解并区分MVC、MVP和MVVM；</li>
<li>它们在Android中如何使用；</li>
<li>走出data binding的误区；</li>
<li>理解MVP+data binding开发模式；</li>
</ul>
<h2 id="MVC、MVP和MVVM基础介绍"><a href="#MVC、MVP和MVVM基础介绍" class="headerlink" title="MVC、MVP和MVVM基础介绍"></a>MVC、MVP和MVVM基础介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;水之积也不厚，则其负大舟也无力：正如庄子逍遥游所说，水不深则没有能够担负大船的力量。在涉及代码前，我们需要对MVC、MVP和MVVM有足够的了解。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVC：（Model View Controller）是软件架构中常见的一种模式，其通过controller层的控制去操作model层的数据，并且返回给view层展示，具体如下：<br><img src="../images/mvc.png" alt="MVC执行图"><br>&nbsp;&nbsp;&nbsp;&nbsp;其工作原理为：当用户触发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新晚数据以后直接显示在view层。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;那具体到android上又是如何？，我们知道android工程有java的class文件、有res文件夹、asset、还有manifest文案等等，对于原生的android项目来说，layout.xml里面的xml<br>文件就对应于MVC的view层，而各种java bean、还有类是repository类就是对应于model层，至于controller层，则是各种activity。当我们在页面触发一个按钮去加载网络资源时，加载网络资源xiangg代码和结果类，则是model层，view和model的关联则是通过按钮的点击事件，这个在activity中，也就是contrller层。android中完整的MVC流程就是这样。<br>&nbsp;&nbsp;&nbsp;&nbsp;Android这样处理有何问题？显然有的。问题在于xml作为view层，其控制<br>内里太弱，当要改变一个页面的背景或者动态控制按钮的隐藏或显示，这些都只能在activity中控制，这样<br>activity的cotroller职责就多了。不符合六大原子的 <strong>单一原则</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp; 通过以上我们知道MVC重要的缺陷是view层和model层是相互可知，意味着两层之间存在耦合。这是因为这个缺陷，才演化出MVP和MVVM两种框架。  </p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVP（View、Presenter、model）作为MVC的演化，解决了MVC不少缺点。对于Android来说，MVP的model层相对于MVC是一样的，而activity和fragment不在是controller层，而是纯粹的view层，所有相关用户的事件的转发全部交由presenter处理，其原理图如下：<br><img src="../images/MVP.png" alt="MVP原理图"><br>&nbsp;&nbsp;&nbsp;&nbsp;由图我们可知，最明显的差别就是view层和model层不在相互告知，完全解耦，取而代之的是有presenter层充当桥梁作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，，并将数据返回给view层，整个过程中view层和model层完全没有关系。也许有人会问，虽然view层和model层解耦了，但是view层和presenter层不是耦合在一起吗？其实不是的，对于view层和presenter的通行是可以通过接口实现的，也就是说activity，fragment可以去实现定义好的接口，而在对应的presenter中通过接口调用方法。同时，我们还可以编写测试用的view，模拟用户操作，从而实现对presenter的测试，解决了MVC模式中测试，维护难问题。<br><strong>当然</strong>，其实最好的方式是使用fragment作为view层，而activity则是用于创建view层(fragment)和presenter层(presenter)的一个控制器。  </p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVVM（View、ViewModel、Model）最早有微软提供的，其原理图如下：<br><img src="../images/MVVM.png" alt="MVVM原理图"><br>&nbsp;&nbsp;&nbsp;&nbsp;由图可知，其和MVP的区别不到，只不过是presenter层换成viewmodel层，还有就是view层和viewmodel层是相互绑定的关系，意味着当更新viewmodel层的数据的时候，view层会相应的变动ui。<br>&nbsp;&nbsp;&nbsp;&nbsp; 很难说MVP和MVVM这两个MVC的变种孰优孰劣，需要具体分析。</p>
<h2 id="纸上得来终觉浅，绝知此事要躬行"><a href="#纸上得来终觉浅，绝知此事要躬行" class="headerlink" title="纸上得来终觉浅，绝知此事要躬行"></a>纸上得来终觉浅，绝知此事要躬行</h2><h2 id="路漫漫其修远兮，吾将上下而求索"><a href="#路漫漫其修远兮，吾将上下而求索" class="headerlink" title="路漫漫其修远兮，吾将上下而求索"></a>路漫漫其修远兮，吾将上下而求索</h2><p>参考地址：<br>[1].MVC、MVP、MVVM详解 <a href="https://blog.csdn.net/jdsjlzx/article/details/51174396" target="_blank" rel="noopener">https://blog.csdn.net/jdsjlzx/article/details/51174396</a><br>[2].MVC在Android中的使用 <a href="https://blog.csdn.net/feiduclear_up/article/details/46363207" target="_blank" rel="noopener">https://blog.csdn.net/feiduclear_up/article/details/46363207</a><br>[3].Android中常见的MVC模式 <a href="https://blog.csdn.net/sylcc_/article/details/7346149" target="_blank" rel="noopener">https://blog.csdn.net/sylcc_/article/details/7346149</a><br>[4].MVC,MVP,MVVM与架构经验谈 <a href="https://www.cnblogs.com/wytiger/p/5305087.html" target="_blank" rel="noopener">https://www.cnblogs.com/wytiger/p/5305087.html</a><br>[5].平台间的MVC、MVP、MVVM <a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank" rel="noopener">http://www.cnblogs.com/indream/p/3602348.html</a><br>[6].前端MVC、MVP、MVVM <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">the blog from a anroid coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
