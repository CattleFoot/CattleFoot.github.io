<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="the blog from a anroid coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/page/5/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="the blog from a anroid coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="the blog from a anroid coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/page/5/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/05/07/python的List与tuple操作方法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/python的List与tuple操作方法详解/" itemprop="url">python的List与tuple操作方法详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-07T09:40:40+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;列表是Python中最基本的数据结构，列表是最常用的Python数据类型，列表的数据项不需要具有相同的类型。列表中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>&ensp;&ensp;Python有6个序列的内置类型，但最常见的是列表和元组，因为列表和元组操作基本相似，只是tuple一旦初始化就不能修改，這里只介绍列表的。序列都可以进行的操作包括索引，切片，加，乘，检查成员。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<ol>
<li>创建一个列表<br>&ensp;&ensp;只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line">list3 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<ol>
<li>访问列表中的值<br>&ensp;&ensp;使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符， 如下所示:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"list1[0]: "</span>, list1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"list2[1:5]: "</span>, list2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1[<span class="number">0</span>]:  physics</span><br><span class="line">list2[<span class="number">1</span>:<span class="number">5</span>]:  [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>更新列表<br>&ensp;&ensp;你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">list = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Value available at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</span><br><span class="line">list[<span class="number">2</span>] = <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"New value available at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value available at index <span class="number">2</span> :</span><br><span class="line"><span class="number">1997</span></span><br><span class="line">New value available at index <span class="number">2</span> :</span><br><span class="line"><span class="number">2001</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>删除列表元素<br>&ensp;&ensp;可以使用 del 语句来删除列表的的元素，如下实例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</span><br><span class="line"><span class="keyword">print</span> list1;</span><br><span class="line"><span class="keyword">del</span> list1[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="string">"After deleting value at index 2 : "</span></span><br><span class="line"><span class="keyword">print</span> list1;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">After deleting value at index <span class="number">2</span> :</span><br><span class="line">[<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Python列表脚本操作符<br>&ensp;&ensp;列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。如下所示： </li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Python 表达式</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">len([1, 2, 3])</td>
<td style="text-align:left">3</td>
<td style="text-align:left">长度</td>
</tr>
<tr>
<td style="text-align:left">[1, 2, 3] + [4, 5, 6]</td>
<td style="text-align:left">[1, 2, 3, 4, 5, 6]</td>
<td style="text-align:left">组合</td>
</tr>
<tr>
<td style="text-align:left">[‘Hi!’] * 4</td>
<td style="text-align:left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td style="text-align:left">重复</td>
</tr>
<tr>
<td style="text-align:left">3 in [1, 2, 3]</td>
<td style="text-align:left">True</td>
<td style="text-align:left">元素是否存在于列表中</td>
</tr>
<tr>
<td style="text-align:left">for x in [1, 2, 3]: print x,</td>
<td style="text-align:left">1 2 3</td>
<td style="text-align:left">迭代</td>
</tr>
</tbody>
</table>
<ol>
<li>Python列表截取或切片<br>Python的列表截取与字符串操作类型，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'spam'</span>, <span class="string">'Spam'</span>, <span class="string">'SPAM!'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python 表达式</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">L[2]</td>
<td style="text-align:left"></td>
<td style="text-align:left">‘SPAM!’</td>
<td>读取列表中第三个元素</td>
</tr>
<tr>
<td style="text-align:left">L[-2]</td>
<td style="text-align:left">‘Spam’</td>
<td style="text-align:left">读取列表中倒数第二个元素</td>
</tr>
<tr>
<td style="text-align:left">L[1:]</td>
<td style="text-align:left">[‘Spam’, ‘SPAM!’]</td>
<td style="text-align:left">从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<ol>
<li>Python列表操作的函数和方法<br>列表操作包含以下函数:</li>
</ol>
<ul>
<li>cmp(list1, list2)：比较两个列表的元素 </li>
<li>len(list)：列表元素个数 </li>
<li>max(list)：返回列表元素最大值 </li>
<li>min(list)：返回列表元素最小值 </li>
<li>list(seq)：将元组转换为列表<br>列表操作包含以下方法:</li>
<li>list.append(obj)：在列表末尾添加新的对象</li>
<li>list.count(obj)：统计某个元素在列表中出现的次数</li>
<li>list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li>list.index(obj)：从列表中找出某个值第一个匹配项的索引位置,<strong>注意</strong>这个有个前提，obj必须在list中不然会抛异常</li>
<li>list.insert(index, obj)：将对象插入列表</li>
<li>list.pop(obj=list[-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li>
<li>list.remove(obj)：移除列表中某个值的第一个匹配项</li>
<li>list.reverse()：反向列表中元素</li>
<li>list.sort([func])：对原列表进行排序</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://www.jb51.net/article/47978.htm" target="_blank" rel="noopener">http://www.jb51.net/article/47978.htm</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819318453af120e8751ea4d2696d8a1ffa5ffdfd7000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819318453af120e8751ea4d2696d8a1ffa5ffdfd7000</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/05/06/python编码中问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/06/python编码中问题/" itemprop="url">python编码中问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-06T21:02:51+08:00">
                2017-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.mysql 模块集成：<br>&ensp;&ensp;通过pycharm IDE引入mysql模块时会报错<img src="/images/python_mysql_error.png" alt="mysql引入错误">，此时到<a href="https://dev.mysql.com/downloads/connector/python/" target="_blank" rel="noopener">mysql conenctor</a>下载对应系统的mysql 模块安装包即可。</p>
<ol>
<li>关于BeautifulSoup使用时引入问题：<br>&ensp;&ensp;网上普遍的引入方法是：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最近在使用是发现此方法报错，因此尝试使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;发下该方法才正确，My god。<br><strong>注意</strong>具体那个版本使用那种形式暂时不是很清楚，希望有人告知。</p>
<ol>
<li>python中import x和from x import y的区别<br>&ensp;&ensp;简单解释：<br>import x：把x给我；from x import y：从x里把y拿出来给我。<br>举例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.datetime.now())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;引入的是整个datetime包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.now())</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;只引入datetime包里的datetime类<br><strong>注意</strong>两者的意义何在？：主要是引入内存中的东西大小不一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/05/06/python切片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/06/python切片/" itemprop="url">python切片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-06T15:21:32+08:00">
                2017-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原理上分析切片运算：<br>&ensp;&ensp;list的切片，内部是调用<strong>getitem</strong>，<strong>setitem</strong>,<strong>delitem</strong>和slice函数。而slice函数又是和range()函数相关的，给切片传递的键是一个特殊的slice对象。该对象拥有可描述所请求切片方位的属性，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</span><br><span class="line">x = a [ <span class="number">1</span> : <span class="number">5</span> ]   <span class="comment">#  x = a.__getitem__( slice ( 1, 5, None ) )</span></span><br><span class="line">a [ <span class="number">1</span> : <span class="number">3</span> ] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> ]<span class="comment">#  a.__setitem__( slice ( 1, 3, None ), [ 10, 11, 12 ] )</span></span><br><span class="line"><span class="keyword">del</span> a [ <span class="number">1</span> : <span class="number">4</span> ]  <span class="comment">#  a.__delitem__( slice ( 1, 4, None ) )</span></span><br></pre></td></tr></table></figure></p>
<p>Python 的切片功能实际上比很多程序员认为的更强大，其形式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=m[start:end:step]   <span class="comment">#  带步进的切片（步进值=step）</span></span><br></pre></td></tr></table></figure></p>
<p>可见，列表的下标有三个参数：start（起始下标），end（终止下标），step（变化量），简单解释如下：</p>
<ul>
<li>当step大于0时，beg默认为0，end默认为最末之后；</li>
<li>当step小于0时，start默认为len（array）-1，end默认为开头之前；</li>
<li>当step未给出时：start默认为1；</li>
</ul>
<p>比较复杂的解释如下：<br>&ensp;&ensp;<strong>注意：</strong>步进值为step</p>
<ol>
<li>当step &gt; 0 时切片从 start(含start)处开始，到end（不含end）处结束，<strong>从左往右</strong>，每隔（step-1）（索引之间的差仍为step，但相隔的元素是step-1个）个元素进行一次截取。这时，start 指向的位置应该在end指向的位置的左边，否则返回值为空；</li>
<li>当step &lt; 0 时，切片从 start(含start)处开始，到end（不含end）处结束，<strong>从右往左</strong>，每隔（step-1）（索引之间的差仍为step，但相隔的元素是step-1个）个元素进行一次截取。这时，start 指向的位置应该在end指向的位置的右边，否则返回值为空；</li>
</ol>
<p>示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"abcdefh"</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#截取第一位到第三位的字符</span></span><br><span class="line"><span class="keyword">print</span> str[:] <span class="comment">#截取字符串的全部字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">6</span>:] <span class="comment">#截取第七个字符到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-3</span>] <span class="comment">#截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>] <span class="comment">#截取第三个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-1</span>] <span class="comment">#截取倒数第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[::<span class="number">-1</span>] <span class="comment">#创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment">#截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:] <span class="comment">#截取倒数第三位到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取,从末尾到倒数第五个，每三步截取一个；</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取,从末尾到开始，每三步截取一个；</span></span><br></pre></td></tr></table></figure></p>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cnblogs.com/weidiao/p/6428681.html" target="_blank" rel="noopener">http://www.cnblogs.com/weidiao/p/6428681.html</a></li>
<li><a href="http://www.pythontab.com/html/2013/pythonjichu_0128/182.html" target="_blank" rel="noopener">http://www.pythontab.com/html/2013/pythonjichu_0128/182.html</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/05/06/python字符串连接的N种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/06/python字符串连接的N种方式/" itemprop="url">python字符串连接的N种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-06T13:46:34+08:00">
                2017-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> &ensp;&ensp;python中有很多字符串连接方式，今天在写代码，顺便总结一下：</p>
<ul>
<li>最原始的字符串连接方式：str1 + str2</li>
<li>python 新字符串连接语法：str1, str2</li>
<li>奇怪的字符串方式：str1 str2</li>
<li>% 连接字符串：‘name:%s; sex: ’ % (‘tom’, ‘male’)</li>
<li>字符串列表连接：str.join(some_list)</li>
</ul>
<p><strong>第一种</strong>&ensp;&ensp;想必只要是有编程经验的人，估计都知道，直接用 “+” 来连接两个字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Jim'</span> + <span class="string">'Green'</span> <span class="comment">#结果：'JimGreen'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>第二种</strong>&ensp;&ensp;比较特殊，如果两个字符串用“逗号”隔开，那么这两个字符串将被连接，但是，字符串之间会多出一个空格：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Jim'</span>, <span class="string">'Green'</span> <span class="comment">#结果： 'Jim Green'</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>第三种</strong>&ensp;&ensp; python 独有的，只要把两个字符串放在一起，中间有空白或者没有空白：两个字符串自动连接为一个字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Jim'</span><span class="string">'Green'</span>   <span class="comment">#结果： 'JimGreen'</span></span><br><span class="line"><span class="string">'Jim'</span>  <span class="string">'Green'</span> <span class="comment">#结果： 'JimGreen'</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>第四种</strong>&ensp;&ensp;功能比较强大，借鉴了C语言中 printf 函数的功能，如果你有C语言基础，看下文档就知道了。这种方式用符号“%”连接一个字符串和一组变量，字符串中的特殊标记会被自动用右边变量组中的变量替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'%s, %s'</span> % (<span class="string">'Jim'</span>, <span class="string">'Green'</span>) <span class="comment">#结果： 'Jim, Green'</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>第五种</strong>&ensp;&ensp;就属于技巧了，利用字符串的函数 join 。这个函数接受一个列表，然后用字符串依次连接列表中每一个元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_list = [<span class="string">'tom'</span>, <span class="string">'david'</span>, <span class="string">'john'</span>]</span><br><span class="line">a = <span class="string">'###'</span></span><br><span class="line">a.join(var_list) <span class="comment">#结果： 'tom###david###john'</span></span><br></pre></td></tr></table></figure></p>
<p>   <strong>其实</strong>&ensp;&ensp;python 中还有一种字符串连接方式，不过用的不多，就是字符串乘法，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'abc'</span></span><br><span class="line">a * <span class="number">3</span> <span class="comment">#结果 'abcabcabc'</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/05/06/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/06/python/" itemprop="url">python中@的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-06T10:44:28+08:00">
                2017-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;在python2.4以上的函数中经常看到函数定义上一行有@functionName的修饰，注意下这个语法细节，有点像c语言中带参数的宏操作，当解释器读到这样的修饰之后，会先解析@后的内容，直接把@下一行的函数或者类作为@后边的函数的参数，然后将返回值赋值给下一行修饰的函数对象。<br>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funa</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"funa"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funb</span><span class="params">(b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"funB"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@funa</span></span><br><span class="line"><span class="meta">@funb</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"funC"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;最后得到的结果是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">funB  </span><br><span class="line">funA</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;通过结果我们可以认为:return funa(funb(func))，也即第一个函数修饰符开始，自下而上做参数传递，这样实际是使用了约定的函数修饰符达到函数嵌套的目的。记得没错Java中SSH也有这样的用法哦。<br>其他例子：<br>1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamrun</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayspam</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"spam,spam,spam"</span></span><br><span class="line">    <span class="keyword">return</span> sayspam</span><br><span class="line">    </span><br><span class="line"><span class="meta">@spamrun</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useful</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a**<span class="number">2</span>+b**<span class="number">2</span></span><br><span class="line">   </span><br><span class="line">useful(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam，spam，spam</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;解释:只是将函数useful传递给spamrun，并没用使用，因此最终返回的是spamrun函数的结果。<br>2.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamrun</span><span class="params">(fn)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"spam,spam,spam"</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">@spamrun</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useful</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a**<span class="number">2</span>+b**<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam，spam，spam</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;解释:只是将函数useful传递给spamrun，并没用使用，因此最终返回的是spamrun函数的结果。<br>3.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"My god!"</span>*<span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> fn(*args)</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">other</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a**<span class="number">2</span>+b**<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    other(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">    other(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My god!My god!My god!</span><br><span class="line">25</span><br><span class="line">My god!My god!My god!</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>注释掉//return fn(*args)，结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My god!My god!My god!</span><br><span class="line">My god!My god!My god!</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;解释：要想使other函数能正常运行（即调用other函数并将其参数继续往下传），必须加返回值，@decorator是一个statement,会将other函数当作参数传入来执行test方法。</p>
<p>&ensp;&ensp;总结：’@’符号用作函数修饰符是python2.4新增加的功能，修饰符必须出现在函数定义前一行，不允许和函数定义在同一行。也就是说＠A def f(): 是非法的。 只可以在模块或类定义层内对函数进行修饰，不允许修修饰一个类。一个修饰符就是一个函数，它将被修饰的函数做为参数，并返回修饰后的同名函数或其它可调用的东西。</p>
<p>&ensp;&ensp;<strong>感悟</strong>：@的作用有点像代理模式，即@functionName修饰的函数是由functionName函数管理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/26/LeastRecentlyUsed-最近最少使用/" itemprop="url">LeastRecentlyUsed_最近最少使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T21:13:53+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache</span><br><span class="line"> 1</span><br><span class="line"> 100</span><br><span class="line"> 2</span><br><span class="line"> </span><br><span class="line"> CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line"> DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line"> REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line"> CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line"> READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;文件内容解析：</p>
<ol>
<li>第一行固定字符串内容，没有多大意义；</li>
<li>第二行DiskLruCache的版本好，源码常量1；</li>
<li>第三行为app的版本好，这个可以自己传入；</li>
<li>第四行值得是每个key对应几个文件，一般为1；</li>
<li>空行做分割下面内容用；</li>
<li>DIRTY 表示一个正在被写入（其实就是吧文件的outputstream交给你），写入分我两种情况：成功则写入一行CLEAN的记录；失败则写入一条REMOVE的记录,如果一条DIRTY没有一条CLEAN或REMOVE和它对应，那么这条记录就可以删除；</li>
<li>REMOVE除了上述情况，当自己手动调用删除remover（key）方法也会写入一条记录；</li>
<li>READ 说明有一次读取的记录；</li>
<li>Clean的后面记录了文件的长度，和key关联了多少个文件；<br>&ensp;&ensp;这里看出，只有CLEAN且没有REMOVE的记录，才是真正可用的Cache Entry记录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // If a bkp file exists, use it instead.</span><br><span class="line">    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">    if (backupFile.exists()) &#123;</span><br><span class="line">      File journalFile = new File(directory, JOURNAL_FILE);</span><br><span class="line">      // If journal file also exists just delete backup file.</span><br><span class="line">      if (journalFile.exists()) &#123;</span><br><span class="line">        backupFile.delete();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        renameTo(backupFile, journalFile, false);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prefer to pick up where we left off.</span><br><span class="line">    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    if (cache.journalFile.exists()) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.readJournal();</span><br><span class="line">        cache.processJournal();</span><br><span class="line">        return cache;</span><br><span class="line">      &#125; catch (IOException journalIsCorrupt) &#123;</span><br><span class="line">        System.out</span><br><span class="line">            .println(&quot;DiskLruCache &quot;</span><br><span class="line">                + directory</span><br><span class="line">                + &quot; is corrupt: &quot;</span><br><span class="line">                + journalIsCorrupt.getMessage()</span><br><span class="line">                + &quot;, removing&quot;);</span><br><span class="line">        cache.delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create a new empty cache.</span><br><span class="line">    directory.mkdirs();</span><br><span class="line">    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    return cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;验证记录文件是否存在，首先检查存不存在journal.bkp（journal的备份文件）如果存在：然后检查journal文件是否存在，如果正主在，bkp文件就可以删除了；如果不存在，将bkp文件重命名为journal文件。<br>接下里判断journal文件是否存在，</p>
<ul>
<li>如果不存在创建directory；重新构造disklrucache；调用rebuildJournal建立journal文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Creates a new journal that omits redundant information. This replaces the</span><br><span class="line">   * current journal if it exists.</span><br><span class="line">   */</span><br><span class="line">  private synchronized void rebuildJournal() throws IOException &#123;</span><br><span class="line">    if (journalWriter != null) &#123;</span><br><span class="line">      journalWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Writer writer = new BufferedWriter(</span><br><span class="line">        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">    try &#123;</span><br><span class="line">      writer.write(MAGIC);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(VERSION_1);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(Integer.toString(appVersion));</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(Integer.toString(valueCount));</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">      for (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">        if (entry.currentEditor != null) &#123;</span><br><span class="line">          writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\n&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      renameTo(journalFile, journalFileBackup, true);</span><br><span class="line">    &#125;</span><br><span class="line">    renameTo(journalFileTmp, journalFile, false);</span><br><span class="line">    journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">    journalWriter = new BufferedWriter(</span><br><span class="line">        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&ensp;&ensp;可以看到首先构建一个journal.tmp文件，然后写入文件头（5行），然后遍历lruEntries（lruEntries = new LinkedHashMap<string, entry="">(0, 0.75f, true);），当然我们这里没有任何数据。接下来将tmp文件重命名为journal文件。</string,></p>
<ul>
<li>如果已经存在，那么调用readJournal</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readJournal() throws IOException &#123;</span><br><span class="line">StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">try &#123;</span><br><span class="line">  String magic = reader.readLine();</span><br><span class="line">  String version = reader.readLine();</span><br><span class="line">  String appVersionString = reader.readLine();</span><br><span class="line">  String valueCountString = reader.readLine();</span><br><span class="line">  String blank = reader.readLine();</span><br><span class="line">  if (!MAGIC.equals(magic)</span><br><span class="line">      || !VERSION_1.equals(version)</span><br><span class="line">      || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">      || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">      || !&quot;&quot;.equals(blank)) &#123;</span><br><span class="line">    throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot;</span><br><span class="line">        + valueCountString + &quot;, &quot; + blank + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int lineCount = 0;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      readJournalLine(reader.readLine());</span><br><span class="line">      lineCount++;</span><br><span class="line">    &#125; catch (EOFException endOfJournal) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">  // If we ended on a truncated line, rebuild the journal before appending to it.</span><br><span class="line">  if (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">    rebuildJournal();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    journalWriter = new BufferedWriter(new OutputStreamWriter(</span><br><span class="line">        new FileOutputStream(journalFile, true), Util.US_ASCII));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  Util.closeQuietly(reader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;首先校验文件头，接下来调用readJournalLine按行读取内容。我们来看看readJournalLine中的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void readJournalLine(String line) throws IOException &#123;</span><br><span class="line">int firstSpace = line.indexOf(&apos; &apos;);</span><br><span class="line">if (firstSpace == -1) &#123;</span><br><span class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int keyBegin = firstSpace + 1;</span><br><span class="line">int secondSpace = line.indexOf(&apos; &apos;, keyBegin);</span><br><span class="line">final String key;</span><br><span class="line">if (secondSpace == -1) &#123;</span><br><span class="line">  key = line.substring(keyBegin);</span><br><span class="line">  if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  key = line.substring(keyBegin, secondSpace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry entry = lruEntries.get(key);</span><br><span class="line">if (entry == null) &#123;</span><br><span class="line">  entry = new Entry(key);</span><br><span class="line">  lruEntries.put(key, entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">  String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);</span><br><span class="line">  entry.readable = true;</span><br><span class="line">  entry.currentEditor = null;</span><br><span class="line">  entry.setLengths(parts);</span><br><span class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">  entry.currentEditor = new Editor(entry);</span><br><span class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">  // This work was already done by calling lruEntries.get().</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;大家可以回忆下：每个记录至少有一个空格，有的包含两个空格。首先，拿到key，如果是REMOVE的记录呢，会调用lruEntries.remove(key);如果不是REMOVE记录，继续往下，如果该key没有加入到lruEntries，则创建并且加入。接下来，如果是CLEAN开头的合法记录，初始化entry，设置readable=true,currentEditor为null，初始化长度等。如果是DIRTY，设置currentEditor对象。如果是READ，那么直接不管。ok，经过上面这个过程，大家回忆下我们的记录格式，一般DIRTY不会单独出现，会和REMOVE、CLEAN成对出现（正常操作）；也就是说，经过上面这个流程，基本上加入到lruEntries里面的只有CLEAN且没有被REMOVE的key。好了，回到readJournal方法，在我们按行读取的时候，会记录一下lineCount，然后最后给redundantOpCount赋值，这个变量记录的应该是没用的记录条数（文件的行数-真正可以的key的行数）。</p>
<p>最后，如果读取过程中发现journal文件有问题，则重建journal文件。没有问题的话，初始化下journalWriter，关闭reader。<br>readJournal完成了，会继续调用processJournal()这个方法内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void processJournal() throws IOException &#123;</span><br><span class="line">deleteIfExists(journalFileTmp);</span><br><span class="line">for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">  Entry entry = i.next();</span><br><span class="line">  if (entry.currentEditor == null) &#123;</span><br><span class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">      size += entry.lengths[t];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    entry.currentEditor = null;</span><br><span class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">      deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">      deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">    &#125;</span><br><span class="line">    i.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>统计所有可用的cache占据的容量，赋值给size；对于所有非法DIRTY状态（就是DIRTY单独出现的）的entry，如果存在文件则删除，并且从lruEntries中移除。此时，剩的就真的只有CLEAN状态的key记录了。<br>&ensp;&ensp;到此就初始化完毕了，太长了，根本记不住，我带大家总结下上面代码。根据我们传入的dir，去找journal文件，如果找不到，则创建个，只写入文件头(5行)。 如果找到，则遍历该文件，将里面所有的CLEAN记录的key，存到lruEntries中。这么长的代码，其实就两句话的意思。经过open以后，journal文件肯定存在了；lruEntries里面肯定有值了；size存储了当前所有的实体占据的容量；</p>
<p><strong>存入缓存</strong><br>存入操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String key = generateKey(url);  </span><br><span class="line">DiskLruCache.Editor editor = mDiskLruCache.edit(key); </span><br><span class="line">OuputStream os = editor.newOutputStream(0); </span><br><span class="line">//...after op</span><br><span class="line">editor.commit()；</span><br></pre></td></tr></table></figure></p>
<p>首先就是editor方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Returns an editor for the entry named &#123;@code key&#125;, or null if another</span><br><span class="line">   * edit is in progress.</span><br><span class="line">   */</span><br><span class="line">  public Editor edit(String key) throws IOException &#123;</span><br><span class="line">    return edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123;</span><br><span class="line">      checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null</span><br><span class="line">        || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">      return null; // Snapshot is stale.</span><br><span class="line">    &#125;</span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">      entry = new Entry(key);</span><br><span class="line">      lruEntries.put(key, entry);</span><br><span class="line">    &#125; else if (entry.currentEditor != null) &#123;</span><br><span class="line">      return null; // Another edit is in progress.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Editor editor = new Editor(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    // Flush the journal before creating files to prevent file leaks.</span><br><span class="line">    journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    return editor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&nesp;&nesp;首先验证key，可以必须是字母、数字、下划线、横线（-）组成，且长度在1-120之间。然后通过key获取实体，因为我们是存，只要不是正在编辑这个实体，理论上都能返回一个合法的editor对象。所以接下来判断，如果不存在，则创建一个Entry加入到lruEntries中（如果存在，直接使用），然后为entry.currentEditor进行赋值为new Editor(entry);，最后在journal文件中写入一条DIRTY记录，代表这个文件正在被操作。</p>
<p>注意，如果entry.currentEditor != null不为null的时候，意味着该实体正在被编辑，会retrun null ;拿到editor对象以后，就是去调用newOutputStream去获得一个文件输入流了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a new unbuffered output stream to write the value at</span><br><span class="line">     * &#123;@code index&#125;. If the underlying output stream encounters errors</span><br><span class="line">     * when writing to the filesystem, this edit will be aborted when</span><br><span class="line">     * &#123;@link #commit&#125; is called. The returned output stream does not throw</span><br><span class="line">     * IOExceptions.</span><br><span class="line">     */</span><br><span class="line">    public OutputStream newOutputStream(int index) throws IOException &#123;</span><br><span class="line">      if (index &lt; 0 || index &gt;= valueCount) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Expected index &quot; + index + &quot; to &quot;</span><br><span class="line">                + &quot;be greater than 0 and less than the maximum value count &quot;</span><br><span class="line">                + &quot;of &quot; + valueCount);</span><br><span class="line">      &#125;</span><br><span class="line">      synchronized (DiskLruCache.this) &#123;</span><br><span class="line">        if (entry.currentEditor != this) &#123;</span><br><span class="line">          throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!entry.readable) &#123;</span><br><span class="line">          written[index] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">        FileOutputStream outputStream;</span><br><span class="line">        try &#123;</span><br><span class="line">          outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          // Attempt to recreate the cache directory.</span><br><span class="line">          directory.mkdirs();</span><br><span class="line">          try &#123;</span><br><span class="line">            outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">          &#125; catch (FileNotFoundException e2) &#123;</span><br><span class="line">            // We are unable to recover. Silently eat the writes.</span><br><span class="line">            return NULL_OUTPUT_STREAM;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new FaultHidingOutputStream(outputStream);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先校验index是否在valueCount范围内，一般我们使用都是一个key对应一个文件所以传入的基本都是0。接下来就是通过entry.getDirtyFile(index);拿到一个dirty File对象，为什么叫dirty file呢，其实就是个中转文件，文件格式为key.index.tmp。<br>将这个文件的FileOutputStream通过FaultHidingOutputStream封装下传给我们。<br>最后，别忘了我们通过os写入数据以后，需要调用commit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void commit() throws IOException &#123;</span><br><span class="line">      if (hasErrors) &#123;</span><br><span class="line">        completeEdit(this, false);</span><br><span class="line">        remove(entry.key); // The previous entry is stale.</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        completeEdit(this, true);</span><br><span class="line">      &#125;</span><br><span class="line">      committed = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过hasErrors判断，是否有错误发生，如果有调用completeEdit(this, false)且调用remove(entry.key);。如果没有就调用completeEdit(this, true);。</p>
<p>那么这里这个hasErrors哪来的呢？还记得上面newOutputStream的时候，返回了一个os，这个os是FileOutputStream，但是经过了FaultHidingOutputStream封装么，这个类实际上就是重写了FilterOutputStream的write相关方法，将所有的IOException给屏蔽了，如果发生IOException就将hasErrors赋值为true.</p>
<p>这样的设计还是很nice的，否则直接将OutputStream返回给用户，如果出错没法检测，还需要用户手动去调用一些操作。</p>
<p>接下来看completeEdit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</span><br><span class="line">    Entry entry = editor.entry;</span><br><span class="line">    if (entry.currentEditor != editor) &#123;</span><br><span class="line">      throw new IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If this edit is creating the entry for the first time, every index must have a value.</span><br><span class="line">    if (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        if (!editor.written[i]) &#123;</span><br><span class="line">          editor.abort();</span><br><span class="line">          throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">          editor.abort();</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">      File dirty = entry.getDirtyFile(i);</span><br><span class="line">      if (success) &#123;</span><br><span class="line">        if (dirty.exists()) &#123;</span><br><span class="line">          File clean = entry.getCleanFile(i);</span><br><span class="line">          dirty.renameTo(clean);</span><br><span class="line">          long oldLength = entry.lengths[i];</span><br><span class="line">          long newLength = clean.length();</span><br><span class="line">          entry.lengths[i] = newLength;</span><br><span class="line">          size = size - oldLength + newLength;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        deleteIfExists(dirty);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    entry.currentEditor = null;</span><br><span class="line">    if (entry.readable | success) &#123;</span><br><span class="line">      entry.readable = true;</span><br><span class="line">      journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</span><br><span class="line">      if (success) &#123;</span><br><span class="line">        entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lruEntries.remove(entry.key);</span><br><span class="line">      journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    journalWriter.flush();</span><br><span class="line"></span><br><span class="line">    if (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;首先判断if (success &amp;&amp; !entry.readable)是否成功，且是第一次写入（如果以前这个记录有值，则readable=true），内部的判断，我们都不会走，因为written[i]在newOutputStream的时候被写入true了。而且正常情况下，getDirtyFile是存在的。<br>&ensp;&ensp;接下来，如果成功，将dirtyFile 进行重命名为 cleanFile，文件名为：key.index。然后刷新size的长度。如果失败，则删除dirtyFile.<br>&ensp;&ensp;接下来，如果成功或者readable为true，将readable设置为true，写入一条CLEAN记录。如果第一次提交且失败，那么就会从lruEntries.remove(key)，写入一条REMOVE记录。</p>
<p>写入缓存，肯定要控制下size。于是最后，判断是否超过了最大size，或者需要重建journal文件，什么时候需要重建呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private boolean journalRebuildRequired() &#123;</span><br><span class="line">   final int redundantOpCompactThreshold = 2000;</span><br><span class="line">   return redundantOpCount &gt;= redundantOpCompactThreshold //</span><br><span class="line">       &amp;&amp; redundantOpCount &gt;= lruEntries.size();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> &ensp;&ensp;如果redundantOpCount达到2000，且超过了lruEntries.size()就重建，这里就可以看到redundantOpCount的作用了。防止journal文件过大。<br> &ensp;&ensp;ok，到此我们的存入缓存就分析完成了。再次总结下，首先调用editor，拿到指定的dirtyFile的OutputStream，你可以尽情的进行写操作，写完以后呢，记得调用commit。<br> &ensp;&ensp;commit中会检测是你是否发生IOException，如果没有发生，则将dirtyFile-&gt;cleanFile，将readable=true，写入CLEAN记录。如果发生错误，则删除dirtyFile,从lruEntries中移除，然后写入一条REMOVE记录。<br><strong>读取缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);  </span><br><span class="line">if (snapShot != null) &#123;  </span><br><span class="line">  InputStream is = snapShot.getInputStream(0);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么首先看get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Snapshot get(String key) throws IOException &#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!entry.readable) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Open all streams eagerly to guarantee that we see a single published</span><br><span class="line">    // snapshot. If we opened streams lazily then the streams could come</span><br><span class="line">    // from different edits.</span><br><span class="line">    InputStream[] ins = new InputStream[valueCount];</span><br><span class="line">    try &#123;</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        ins[i] = new FileInputStream(entry.getCleanFile(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">      // A file must have been deleted manually!</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        if (ins[i] != null) &#123;</span><br><span class="line">          Util.closeQuietly(ins[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(READ + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    if (journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法比较简单，如果取到的为null，或者readable=false，则返回null.否则将cleanFile的FileInputStream进行封装返回Snapshot，且写入一条READ语句。 然后getInputStream就是返回该FileInputStream了。<br>好了，到此，我们就分析完成了创建</p>
<p>DiskLruCache，存入缓存和取出缓存的源码。<br>除此以外，还有一些别的方法我们需要了解的。</p>
<p><strong>其他方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Drops the entry for &#123;@code key&#125; if it exists and can be removed. Entries</span><br><span class="line">   * actively being edited cannot be removed.</span><br><span class="line">   *</span><br><span class="line">   * @return true if an entry was removed.</span><br><span class="line">   */</span><br><span class="line">  public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (entry == null || entry.currentEditor != null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">      File file = entry.getCleanFile(i);</span><br><span class="line">      if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">        throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">      &#125;</span><br><span class="line">      size -= entry.lengths[i];</span><br><span class="line">      entry.lengths[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(REMOVE + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">    if (journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果实体存在且不在被编辑，就可以直接进行删除，然后写入一条REMOVE记录。</p>
<p>与open对应还有个remove方法，大家在使用完成cache后可以手动关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** Closes this cache. Stored values will remain on the filesystem. */</span><br><span class="line">  public synchronized void close() throws IOException &#123;</span><br><span class="line">    if (journalWriter == null) &#123;</span><br><span class="line">      return; // Already closed.</span><br><span class="line">    &#125;</span><br><span class="line">    for (Entry entry : new ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">      if (entry.currentEditor != null) &#123;</span><br><span class="line">        entry.currentEditor.abort();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize();</span><br><span class="line">    journalWriter.close();</span><br><span class="line">    journalWriter = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关闭前，会判断所有正在编辑的实体，调用abort方法，最后关闭journalWriter。至于abort方法，其实我们分析过了，就是存储失败的时候的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void abort() throws IOException &#123;</span><br><span class="line">      completeEdit(this, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此，我们的整个源码分析就结束了。可以看到DiskLruCache，利用一个journal文件，保证了保证了cache实体的可用性（只有CLEAN的可用），且获取文件的长度的时候可以通过在该文件的记录中读取。利用FaultHidingOutputStream对FileOutPutStream很好的对写入文件过程中是否发生错误进行捕获，而不是让用户手动去调用出错后的处理方法。其内部的很多细节都很值得推敲。</p>
<p>不过也可以看到，存取的操作不是特别的容易使用，需要大家自己去操作文件流，但在存储比较小的数据的时候（不存在内存问题），很多时候还是希望有类似put(key,value），getAsT(key)等方法直接使用。我看了ASimpleCache 提供的API属于比较好用的了。于是萌生想法，对DiskLruCache公开的API进行扩展，对外除了原有的存取方式以外，提供类似ASimpleCache那样比较简单的API用于存储，而内部的核心实现，依然是DiskLruCache原本的。</p>
<p>考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/47251585" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/47251585</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/22/reactNative/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/22/reactNative/" itemprop="url">关于react native页面全屏设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T21:27:45+08:00">
                2017-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;在React Native中，页面使用的是flexbox规则来指定某个组件的子元素布局，因此要实现页面的全拼设置，是需要对view的flex相关属性进行设置。<br>&ensp;&ensp;通常情况下我们考虑的是设置宽高来制定页面为全屏，那系统也没有提供全屏的变量之给我们，我们只能通过系统属性实例const {width, height} = Dimensions.get(‘window’);获取窗口的宽高，在指定view的宽高，这个是一般情况的想法。<br>&ensp;&ensp;正如开头所说，React Native是以flexbox的规则来制定某个组件的子元素布局，因此需要考虑从flex的属性着手，flex属性代表了试图占取窗口比例，默认情况为0，即按照子元素大小绘制内容，如果指定了非0值x，则代表占取总flex的x份，如果其他子元素没有制定flex值，则在绘制完其他子元素后剩余的空间都是该制定flex值的元素的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/22/linux系统磁盘挂载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/22/linux系统磁盘挂载/" itemprop="url">linux系统磁盘挂载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T11:24:00+08:00">
                2017-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>linux系统挂载知识</p>
<ul>
<li>linux的硬盘识别<br>2.6 kernel以后，linux会将识别到的硬件设备在/dev下建立相应的设备文件，如：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">设备前缀</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sda</td>
<td style="text-align:center">表示SCSI类硬盘</td>
</tr>
<tr>
<td style="text-align:center">hda</td>
<td style="text-align:center">表示IDE类硬盘</td>
</tr>
<tr>
<td style="text-align:center">scd</td>
<td style="text-align:center">表示USB类设备</td>
</tr>
</tbody>
</table>
<p>我们可以通过fdisk -l命令来查看设备信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xxxxxx:~ $ sudo fdisk -l</span><br><span class="line">Device         Boot  Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1        8192   137215   129024   63M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2      137216 30367743 30230528 14.4G 83 Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 74.5 GiB, 80026361856 bytes, 156301488 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x7780b3c2</span><br><span class="line"></span><br><span class="line">Device     Boot Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1        2048 156301487 156299440 74.5G 83 Linux</span><br></pre></td></tr></table></figure></p>
<p>通过命令我们可以看到/dev/sda1设备信息，这个设备标识已经分过区并且格式化过了，现在就可以挂载了，但在挂在前我们得设置一个挂载点啊，要不凭空怎么挂呢，是吧，一般可以选择/mnt目录下获知/media目录下，先在选定目录下创建一个文件夹，然后就可以挂载在文件夹上了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 /dev/sda1 /media/disk1</span><br><span class="line">umount /dev/sda1</span><br></pre></td></tr></table></figure></p>
<p>其中第一句中的ext4 表示文件系统类型（可以通过parted程序查看）；iocharset=utf8文件读取格式，可选参数；umask表示让挂载的分区允许所有用户读取和修改，可选参数。第二句为卸载命令。<br>这个只是临时的挂在，如果要在开机的时候就挂载的话则需要修改/etc/fstab。</p>
<p>下面详细来说下mount 命令和mount相关参数设定：<br>标准模式的mount命令使用是如下的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t type device dir</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;其中type代表的是挂在文件的文件系统，device代表fdisk查找的块设备，dir代表的是需要挂在的路径；<br><strong>文件系统独立挂载选项</strong><br>&ensp;&ensp;这些参数只在/etc/fstab文件中用到，有些参数在系统内核已经给定了默认值来启用或关闭某些特性，如果要查看这些参数，可以查看/proc/mounts文件。<br>&ensp;&ensp;下面这些参数可以用在一些文件系统挂载时,但是不是每个文件系统都可以使用这些参数，比如sync目前只使用于 ext2、ext3、fat、vfat和ufs文件系统：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">async</td>
<td style="text-align:left">所有的i/o都要满足异步输入输出，同样sync亦是如此</td>
</tr>
<tr>
<td style="text-align:left">atime</td>
<td style="text-align:left">不要使用noatime特性，那么对inode的访问将使用内核默认的</td>
</tr>
<tr>
<td style="text-align:left">noatime</td>
<td style="text-align:left">不更新文件的访问时间</td>
</tr>
<tr>
<td style="text-align:left">auto</td>
<td style="text-align:left">!自动挂载,可以在mount时候使用-a参数启用</td>
</tr>
<tr>
<td style="text-align:left">noauto</td>
<td style="text-align:left">只能显示挂载</td>
</tr>
</tbody>
</table>
<p><strong>/etc/fstab</strong><br>&ensp;&ensp;该文件包含了不同的文件系统的描述信息，是静态的文件系统信息。它由系统管理员修改和管理的，只能通过系统程序读取，对其他用户是不可写的。<br>&ensp;&ensp;文件中每一行代表了一个文件系统，以#开头的是解释性内容，空白行会被忽略。在文件中，每条记录的顺序也是很重要的，因为fsck、mount和umount命令都是顺序迭代fstab来做它们自身的业务。<br>&ensp;&ensp;该文件中每行由六个字段属性组合而成，各字段功能解析：</p>
<ol>
<li>（文件块）该字段描述了需要挂载的块设备和远程文件系统。对于普通的挂在，其会保持一个块设备节点（由mknod创建），如‘/dev/cdrom’、‘/dev/sdb7/’，而对于NFS格式文件系统会以<host>:dir形式挂载，如‘knuth.aeb.nl:/’。<br>&ensp;&ensp;除了明确指定块设备路径，我们还可以通过标签或者UUID来挂载块设备，如‘LABEL=Boot’，‘UUID=3e6be9de-8139-11d1-<pre><code>-9106-a43f08d823a6’。
</code></pre>&ensp;&ensp;另外还可以通过PARTUUID= and PARTLABEL=z来挂载快设备，但是这两个特性只支持GUID分区表（GPT）和MAC分区表。</host></li>
<li>文件挂载点，对于swap分区，该字段需要指定为‘none’，如果文件挂载点包含了空格字符，需要以‘\040’替换。</li>
<li>文件系统格式，说明挂载的块设备是什么类型的文件格式，目前linux支持文件系统有：adfs, affs, autofs, coda,<pre><code>coherent, cramfs, devpts, efs, ext2, ext3, hfs,  hpfs,  iso9660,
jfs,  minix,  msdos,  ncpfs,  nfs,  ntfs,     proc, qnx4, reiserfs,
romfs, smbfs, sysv, tmpfs, udf, ufs, umsdos, vfat,  xenix,  xfs和其他，如果要更详细的可以通过mount查看。
</code></pre></li>
<li>声明与文件系统相关的选项，选项列表是以逗号分割开来的，包含挂载类型以及任何适合于文件系统类型的附加选项。有关可用安装选项的文档，请参考<a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=mount(8" target="_blank" rel="noopener">mount(8)</a>)，在可用的swap选项文件，请参考<a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=swapon(8" target="_blank" rel="noopener">wapon(8)</a>)。<br>基础的一些参数选项有：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">defaults</td>
<td style="text-align:left">使用默认参数:rw,suid,dev,exec,auto,nouser and async</td>
</tr>
<tr>
<td style="text-align:left">noauto</td>
<td style="text-align:left">在‘mount -a’命令下，不挂载文件系统</td>
</tr>
<tr>
<td style="text-align:left">user</td>
<td style="text-align:left">允许一个用户挂载</td>
</tr>
<tr>
<td style="text-align:left">owner</td>
<td style="text-align:left">允许块设备拥有者挂载</td>
</tr>
<tr>
<td style="text-align:left">comment 或 x-<name></name></td>
<td style="text-align:left">使用fstab维护程序</td>
</tr>
<tr>
<td style="text-align:left">nofail</td>
<td style="text-align:left">如果快设备不存在，不要报告错误</td>
</tr>
</tbody>
</table>
<ol>
<li>指定该文件系统是否需要备份，如果该字段没有指定，默认则是为0，也即该文件系统不需要备份，如果需要查看备份选项可以看<a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=dump(8" target="_blank" rel="noopener">dump(8)</a>)。</li>
<li>指定文件系统是否需要检查和检查顺序，具体选项意义可以查看<a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=fsck(8" target="_blank" rel="noopener">fsck(8)</a>),对于root文件系统需要指定为1，其他文件系统指定为2，如果字段没有指定，默认值为0，也即表明文件系统不需要检查。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=mount" target="_blank" rel="noopener">http://man.yolinux.com/cgi-bin/man2html?cgi_command=mount</a></li>
<li><a href="http://blog.chinaunix.net/uid-7411781-id-2056205.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-7411781-id-2056205.html</a></li>
<li><a href="http://www.jb51.net/os/RedHat/1117.html" target="_blank" rel="noopener">http://www.jb51.net/os/RedHat/1117.html</a></li>
<li><a href="http://qq85609655.iteye.com/blog/1449899" target="_blank" rel="noopener">http://qq85609655.iteye.com/blog/1449899</a></li>
<li><a href="http://freearth.blog.chinaunix.net/uid-20769015-id-3478861.html" target="_blank" rel="noopener">http://freearth.blog.chinaunix.net/uid-20769015-id-3478861.html</a></li>
<li><a href="http://blog.csdn.net/jiyuanyi1992/article/details/43866273" target="_blank" rel="noopener">http://blog.csdn.net/jiyuanyi1992/article/details/43866273</a></li>
<li>/etc/fstab文件解析：<a href="http://blog.csdn.net/richerg85/article/details/17917129" target="_blank" rel="noopener">http://blog.csdn.net/richerg85/article/details/17917129</a></li>
<li><a href="http://blog.163.com/fan_yishan/blog/static/47692213200951343813425/" target="_blank" rel="noopener">http://blog.163.com/fan_yishan/blog/static/47692213200951343813425/</a>    </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/22/hexo写blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/22/hexo写blog/" itemprop="url">hexo写blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T10:00:19+08:00">
                2017-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;上一篇我们讲了怎么使用hexo向guthub发布自己的blog，这篇我们讲讲怎么通过hexo写blog。<br>&ensp;&ensp;在我们开始写blog之前，我们先了解下hexo的blog目录结构：<br><img src="/images/1492826647877.png" alt="hexo的blog目录"></p>
<ol>
<li>deploy_git一看名称我们就知道大概作何用的，是的，最终发布到github的所有东西都在这个目录下，hexo自动生成的；</li>
<li>node_modules是node执行的资源文件；</li>
<li>scaffolds模板文件存放的地方；</li>
<li>source文章资源存放的地方；</li>
<li>themes主题存放的地方；</li>
<li>_config.yml我们的blog配置文件,在上篇中也提到过的;<br>暂时理解到这里，以后发现不对会及时补充。</li>
</ol>
<p><strong>生成一篇新博客</strong><br>&ensp;&ensp;好了现在可以开始准备写自己的blog啦<br>hexo通过下面的命令来创建一片新的文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中[]表示可选填的参数，&lt;&gt;表示必填的参数，(layout)为制定了文章的布局，默认为post，这个默认值可以通过 _config.yml 中的 default_layout 参数来修改，其他还有page和draft两种布局，它们也代表了文章最终放在哪里：</p>
<table>
<thead>
<tr>
<th style="text-align:left">布局</th>
<th style="text-align:left">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">post</td>
<td style="text-align:left">source/_posts</td>
</tr>
<tr>
<td style="text-align:left">page</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left">draft</td>
<td style="text-align:left">source/_drafts</td>
</tr>
</tbody>
</table>
<p><em>！注意！</em>  如果我们自定义了布局，并且和post相同，也是会放到source/_posts下。<br>&ensp;&ensp;有生成bolg那也有移除（删除）blog，只要删除需要删除的blog的.md文件并运行以下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该命令会删除node的数据库并重新生成。</p>
<p><strong>文件名称</strong><br>&ensp;&ensp;Hexo默认是以标题作为文件名称，可以通过new_post_name参数修改默认的文件名称，如:year-:month-:day-:title.md 可让您更方便的通过日期来管理文章，且最终文件的后缀是.md。</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:title</td>
<td style="text-align:left">标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td style="text-align:left">:year</td>
<td style="text-align:left">建立的年份，比如， 2015</td>
</tr>
<tr>
<td style="text-align:left">:month</td>
<td style="text-align:left">建立的月份（有前导零），比如， 04</td>
</tr>
<tr>
<td style="text-align:left">:i_month</td>
<td style="text-align:left">建立的月份（无前导零），比如， 4</td>
</tr>
<tr>
<td style="text-align:left">:day</td>
<td style="text-align:left">建立的日期（有前导零），比如， 07</td>
</tr>
<tr>
<td style="text-align:left">:i_day</td>
<td style="text-align:left">建立的日期（无前导零），比如， 7</td>
</tr>
</tbody>
</table>
<p><strong>草稿</strong><br>&ensp;&ensp;如上提到的三种布局中的draft，其代表为文件为草稿，存放在source/_drafts 文件夹，在默认发布blog时是不会将草稿发布到github，需要通过publish命令将草稿移动到source/_posts 文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 草稿默认不会显示在页面中，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。<br><strong>模板</strong><br>&ensp;&ensp;在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">layout</td>
<td style="text-align:left">布局</td>
</tr>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">标题</td>
</tr>
<tr>
<td style="text-align:left">draft</td>
<td style="text-align:left">文件建立日期</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>在做表格的时候，一定要<strong>回车换行</strong>、<strong>回车换行</strong>、<strong>回车换行</strong>后做表格，要不不会被解析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/22/使用hexo向github发布自己的blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/22/使用hexo向github发布自己的blog/" itemprop="url">使用hexo向github发布自己的blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T09:41:34+08:00">
                2017-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><strong>准备</strong>：使用hexo在github上搭建博客需要以下东西：</li>
</ul>
<ol>
<li><p>git，下载安装即可</p>
</li>
<li><p>node,下载安装即可，如果自己用压缩包安装，<strong>注意</strong>配置好环境变量。</p>
</li>
<li><p>通过node安装好hexo。</p>
</li>
</ol>
<ul>
<li><strong>安装hexo</strong>：<br>在装好node才可以安装hexo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm　install　-g hexo</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建hexo文件夹即自己的blog项目文件夹，切换到目录下，按住shirt键并右击，可以看到《在此处打开命令窗口》,点击进入输入下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<p>运行完后，可以看到建立网站所需要的所有文件，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。<br>生成静态页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p>
<p>本地启动:<br>启动本地服务，进行文章预览调试，命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>浏览器输入<a href="http://localhost:4000，这样本地博客已经建立好了，如何才能发布到github上呢，首先我们的配置下我们githu的信息，hexo配置github的信息在文件夹的_config.yml这个文件里面，打开文件我们可以看到以下内容：" target="_blank" rel="noopener">http://localhost:4000，这样本地博客已经建立好了，如何才能发布到github上呢，首先我们的配置下我们githu的信息，hexo配置github的信息在文件夹的_config.yml这个文件里面，打开文件我们可以看到以下内容：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site</span><br><span class="line"></span><br><span class="line">title: CallteFoot&apos;s blog</span><br><span class="line"></span><br><span class="line">subtitle:</span><br><span class="line"></span><br><span class="line">description:</span><br><span class="line"></span><br><span class="line">author: John Doe</span><br><span class="line"></span><br><span class="line">language:</span><br><span class="line"></span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line"></span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line"></span><br><span class="line">url: https://cattlefoot.github.io/</span><br><span class="line"></span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line"></span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line"></span><br><span class="line">source_dir: source</span><br><span class="line"></span><br><span class="line">public_dir: public</span><br><span class="line"></span><br><span class="line">tag_dir: tags</span><br><span class="line"></span><br><span class="line">archive_dir: archives</span><br><span class="line"></span><br><span class="line">category_dir: categories</span><br><span class="line"></span><br><span class="line">code_dir: downloads/code</span><br><span class="line"></span><br><span class="line">i18n_dir: :lang</span><br><span class="line"></span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line"></span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line"></span><br><span class="line">default_layout: post</span><br><span class="line"></span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line"></span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line"></span><br><span class="line">filename_case: 0</span><br><span class="line"></span><br><span class="line">render_drafts: false</span><br><span class="line"></span><br><span class="line">post_asset_folder: false</span><br><span class="line"></span><br><span class="line">relative_link: false</span><br><span class="line"></span><br><span class="line">future: true</span><br><span class="line"></span><br><span class="line">highlight:</span><br><span class="line"></span><br><span class="line">enable: true</span><br><span class="line"></span><br><span class="line">line_number: true</span><br><span class="line"></span><br><span class="line">auto_detect: false</span><br><span class="line"></span><br><span class="line">tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line"></span><br><span class="line">default_category: uncategorized</span><br><span class="line"></span><br><span class="line">category_map:</span><br><span class="line"></span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line"></span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line"></span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line"></span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line"></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line"></span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line"></span><br><span class="line">per_page: 10</span><br><span class="line"></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">type: git</span><br><span class="line"></span><br><span class="line">#我的github项目地址：https://github.com/CattleFoot/CattleFoot.github.io.git</span><br><span class="line"></span><br><span class="line">repo: https://｛username｝:｛password｝@github.com/CattleFoot/CattleFoot.github.io.git</span><br><span class="line"></span><br><span class="line">＃注意上面这个，要不发布到github时会要输账号、密码的，反正我是一直输错的，哭死。</span><br><span class="line"></span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line">message: hexo build blog</span><br></pre></td></tr></table></figure>
<p>接下来就的配置hexo发布github服务依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>这个安装好了，基本就可以发布自己的博客到github上了，但是还缺少了ssh登陆认证。</p>
<p>生成ssh密码，主要目的是使github和发布机器建立信任关系，在生产密钥前先运行下ssh-keygen是否全局命令，如果不是需要在环境变量中配置下，其所在的目录是Git\usr\bin，即git安装目录下的usr下的bin文件夹下。</p>
<p>ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。</p>
<p>在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。</p>
<p>生成好了之后到<a href="https://github.com/settings/ssh点击Add" target="_blank" rel="noopener">https://github.com/settings/ssh点击Add</a> SSH key，并将id_rsa.pub内容粘贴进去。</p>
<ul>
<li><strong>发布博客</strong><br>如果上面一切都搞定，接着就可以发布自己的博客到github啦：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后到github就可以看到自己的博客文件资源啦，然后可以进入自己的blog看看，如我的blog地址：<a href="https://cattlefoot.github.io/。">https://cattlefoot.github.io/。</a></p>
<p>参考文献：</p>
<ul>
<li><p><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/server.html</a>　官方文档，hexo是台湾人写的，文档也是中文。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/701b1095da11" target="_blank" rel="noopener">http://www.jianshu.com/p/701b1095da11</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">http://www.jianshu.com/p/465830080ea9</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">the blog from a anroid coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
