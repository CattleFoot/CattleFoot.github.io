<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CallteFoot&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="CallteFoot&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CallteFoot&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cattlefoot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基础数据与byte间的转化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/基础数据与byte间的转化/" class="article-date">
  <time datetime="2018-08-27T08:42:52.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/基础数据与byte间的转化/">基础数据与byte间的转化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>   <strong>计算机中存储是用补码！！，同时注意一下计算省略了高位不变部分和 字节大小端问题</strong>  </p>
<h4 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h4><ul>
<li>byte：有符号，在网络传输中都是会用到byte的，它占1个字节，共8位，比如说11111111就可以用1个<br>byte表示，转化为10进制：- （2的6次+2的5次+2的4次+2的3次+2的2次+2的1次+2的0次） = -127。<br>其中前7位表示数字，最高位表示符号，0为正，1为负。范围是 （-2的7次 ~ 2的7次 - 1），那为什么前<br>面最小是-127，范围最小又是-128呢？因为规定-0（10000000）为-128。</li>
<li>short：有符号，占2个字节，共16位。同byte一样，它的取值范围就是 （-2的15次 ~ 2的15次 - 1）。</li>
<li>int：有符号，占4个字节，共32位。它的取值范围就是（-2的31次 ~ 2的31次）。</li>
<li>long：有符号，占8个字节，共64位，它的取值范围就是（-2的63次 ~ 2的63次）。</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ul>
<li>^：表示异或位运算，两者相同则为0，两者不同则为1。比如说15^2，15用二进制表示就是1111，2用2<br>进制表示就是0010，两者进行异或运算，结果就是1101，转换为十进制就是13。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A^B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>|：表示或运算，两者只有有一个为1就为1， 比如说13|2，13用二进制表示就是1101，2用二进制表示<br>就是0010，两者进行或运算，那么结果就是1111，转换为十进制就是15。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A &#124; B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>&amp;：表示与运算，两者都为1就为1，其余都为0，比如说15&amp;2， 13用二进制表示就是1111，2用二进制<br>表示就是0010， 两者进行与运算，那么结果就是0010，转换为十进制就是2。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A&amp;B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li><p>~：取反，就是本来是0变成1，本来是1变成0。<br>| A    |  ～A     |<br>| :————- | :————- |<br>| 1     | 0    |<br>| 0     | 1    |</p>
</li>
<li><p>&lt;&lt;:左移运算符，不需要考虑符号位，因为在后面补0，把二进制的数字向左移动，低位补0。比如说 3&lt;&lt;2。<br>3的二进制码为11，向左移动2位就是1100，那么结果就是12。</p>
</li>
<li><p>>&gt;：右移运算符，带符号位。根据这个要移动的数字决定正负，如果是正数，那么就在前面补0，如果是<br>负数就在前面补1。比如说 3&gt;&gt;2，3的二进制码为00000011，向右移动2位，就变成00000000，转化为十<br>进制就是0了（3是正数所以在高位补0）。再比如说-3&gt;&gt;2，-3的二进制码为10000011，转化为补码<br>（只要涉及到负数，就需要转换到补码计算，正数之所以不用转化，是因为他们的补码和原码是一致的）<br>11111101，进行位移运算，就是11111111，这个是补码，需要再转回原码。那么就是取反+1，结果就是<br>10000001，转化为十进制就是-1。</p>
</li>
<li><p>>&gt;&gt;：右移运算符，与上面的区别就是这个运算符是 <strong>无符号的</strong>。不论正负，高位都补0。如果要用<br>-3&gt;&gt;2来验证，因为高位补0，就需要把所有的位数都写全了。如果是int，那就要写成32位来运算。切记切记。<br>上面很多因为高位的变化“取反再取反”会导致前面所有的位都没变所以我就简化了，但是这个&gt;&gt;&gt;运算符不行哦，<br>它会把负数变为正数。</p>
</li>
</ul>
<p>栗子（eg）：<br>比如说-15|3等于多少呢？有些人会觉得-15转化为二进制就是10001111，而3转化为二进制就是00000011，<br>那么结果应该是10001111呀，转换为十进制就是-15呀？大家可以自己写个demo就会发现是不对的。要注意<br>在计算机中所有的都是用补码的形式存储的，之所以上面介绍两个正数是对的，因为 <strong>正数的反码和补码都是一样的。而负数求补码应该是除去符号位取反+1</strong>，我们再来看看这个题-15|3，其中-15的原码为10001111，反码为11110000，那么补码就是11110001，然后3的补码为00000011，两者进行或操作就是11110011，你以为结束了么？还没有，再又要求它的原码了，<strong>原码就是补码再求补码再+1</strong>（是不是已经晕掉了？），也就是<br>10001101，结果就是-13。为了大家都好理解，我这里用算式整理一下：</p>
<p>求 -15|3</p>
<p>[-15]原码 = 10001111<br>[-15]反码 = 11110000 //原码求反码符号位不变<br>[-15]补码 = 11110001 //反码+1等于补码</p>
<p>[3]原码 = 00000011<br>[3]反码 = 00000011 //正数都一致<br>[3]补码 = 00000011 //正数都一致</p>
<p>-15|3 = 11110011 //两个补码进行或操作</p>
<p>[结果]补码 = 11110011 //上面求得的值<br>[结果]反码 = 10001100 //符号位不变<br>[结果]原码 = 10001101 //反码+1</p>
<p>100001101 转化为十进制就是-13。<br>不知道我这么解释会不会更加清楚一些呢？同理的，上面那些（尤其是求反‘~’我故意没写例子，大家自己去试试吧）。</p>
<p>在说一次，正数的原码，补码，反码都一样，如果一定要说为什么一样，我就举个例子。有这么一个等式7+（-7）=0。<br>我们知道<br>[-7]原 = 10000111<br>[-7]反 = 11111000<br>[-7]补 = 11111001</p>
<p>那么如果要存在一个值和[-7]补码相加等于0，是不是就是00000111！！所以正数的补码和原码是一致的。<br>这样解释虽然怪怪的，但是可以知道的确是这样的。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>基本步骤：<br>① 分析转化和代转化之间位数的关系<br>② 计算偏移量。每次都取最后8位<br>③ 把最后8位和0xff进行&amp;操作<br>④ 得出结果。  </p>
<p>有人会问，为什么要和0xff进行&amp;操作？这里解释下，因为再分割的时候，我们要保证最后8位是一致的，更高位都要置0，这样才能保证数据的一致性。比如说由byte转化成short。位数从8位变成了16位，那么在计算机自己看来，它会把前面多出来的8位置1。而&amp;0xff就可以把前面所有的位数都置0。</p>
<ol>
<li>short与byte的相互转化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 前提：在计算机中所有的都是用补码的形式存储的。</span><br><span class="line">    * 将short转换为字节</span><br><span class="line">    *</span><br><span class="line">    * 例如 8的补码为0000 0000 0000 1000，所以要将转换为两个字节，第一个字节是将8右移8位然后和0x00ff求与，</span><br><span class="line">    * 而第二个字节则是右移0位，然后求与</span><br><span class="line">    */</span><br><span class="line">public static byte[] short2byte(short s)&#123;</span><br><span class="line">        byte[] b = new byte[2];</span><br><span class="line">        for(int i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">            int offset = 16 - (i+1)*8;          //因为byte占1个字节，所以要计算偏移量</span><br><span class="line">            b[i] = (byte)((s &gt;&gt; offset)&amp;0xff); //把16位分为2个8位进行分别存储</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static short byte2short(byte[] b)&#123;</span><br><span class="line">       short l = 0;</span><br><span class="line">       for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">           l&lt;&lt;=8;               //&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span><br><span class="line">           l |= (b[i] &amp; 0xff); //和上面也是一样的  l = l | (b[i]&amp;0xff)</span><br><span class="line">       &#125;</span><br><span class="line">       return l;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>int与byte的相互转化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] int2byte(int s)&#123;</span><br><span class="line">         byte[] b = new byte[2];</span><br><span class="line">         for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">             int offset = 16 - (i+1)*8;         //因为byte占1个字节，所以要计算偏移量</span><br><span class="line">             b[i] = (byte)((s &gt;&gt; offset)&amp;0xff); //把32位分为4个8位进行分别存储</span><br><span class="line">         &#125;</span><br><span class="line">         return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int byte2int(byte[] b)&#123;</span><br><span class="line">        int l = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            l&lt;&lt;=8;              //&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span><br><span class="line">            l |= (b[i] &amp; 0xff); //和上面也是一样的  l = l | (b[i]&amp;0xff)</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>long与byte的相互转化   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * @方法功能 字节数组和长整型的转换</span><br><span class="line">	 * @param 字节数组</span><br><span class="line">	 * @return 长整型</span><br><span class="line">	 */</span><br><span class="line">	public static byte[] longToByte(long number) &#123;</span><br><span class="line">		long temp = number;</span><br><span class="line">		byte[] b = new byte[8];</span><br><span class="line">		for (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = new Long(temp &amp; 0xff).byteValue();</span><br><span class="line">			// 将最低位保存在最低位</span><br><span class="line">			temp = temp &gt;&gt; 8;</span><br><span class="line">			// 向右移8位</span><br><span class="line">		&#125;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @方法功能 字节数组和长整型的转换</span><br><span class="line">	 * @param 字节数组</span><br><span class="line">	 * @return 长整型</span><br><span class="line">	 */</span><br><span class="line">	public static long byteToLong(byte[] b) &#123;</span><br><span class="line">		long s = 0;</span><br><span class="line">		long s0 = b[0] &amp; 0xff;// 最低位</span><br><span class="line">		long s1 = b[1] &amp; 0xff;</span><br><span class="line">		long s2 = b[2] &amp; 0xff;</span><br><span class="line">		long s3 = b[3] &amp; 0xff;</span><br><span class="line">		long s4 = b[4] &amp; 0xff;// 最低位</span><br><span class="line">		long s5 = b[5] &amp; 0xff;</span><br><span class="line">		long s6 = b[6] &amp; 0xff;</span><br><span class="line">		long s7 = b[7] &amp; 0xff; // s0不变</span><br><span class="line">		s1 &lt;&lt;= 8;</span><br><span class="line">		s2 &lt;&lt;= 16;</span><br><span class="line">		s3 &lt;&lt;= 24;</span><br><span class="line">		s4 &lt;&lt;= 8 * 4;</span><br><span class="line">		s5 &lt;&lt;= 8 * 5;</span><br><span class="line">		s6 &lt;&lt;= 8 * 6;</span><br><span class="line">		s7 &lt;&lt;= 8 * 7;</span><br><span class="line">		s = s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>char与byte的转化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 字符到字节转换</span><br><span class="line">	 *</span><br><span class="line">	 * @param ch</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static void putChar(byte[] bb, char ch, int index) &#123;</span><br><span class="line">		int temp = (int) ch;</span><br><span class="line">		// byte[] b = new byte[2];</span><br><span class="line">		for (int i = 0; i &lt; 2; i ++ ) &#123;</span><br><span class="line">			bb[index + i] = new Integer(temp &amp; 0xff).byteValue(); // 将最高位保存在最低位</span><br><span class="line">			temp = temp &gt;&gt; 8; // 向右移8位</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 字节到字符转换</span><br><span class="line">	 *</span><br><span class="line">	 * @param b</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static char getChar(byte[] b, int index) &#123;</span><br><span class="line">		int s = 0;</span><br><span class="line">		if (b[index + 1] &gt; 0)</span><br><span class="line">			s += b[index + 1];</span><br><span class="line">		else</span><br><span class="line">			s += 256 + b[index + 0];</span><br><span class="line">		s *= 256;</span><br><span class="line">		if (b[index + 0] &gt; 0)</span><br><span class="line">			s += b[index + 1];</span><br><span class="line">		else</span><br><span class="line">			s += 256 + b[index + 0];</span><br><span class="line">		char ch = (char) s;</span><br><span class="line">		return ch;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>float与byte的转化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * float转换byte</span><br><span class="line"> *</span><br><span class="line"> * @param bb</span><br><span class="line"> * @param x</span><br><span class="line"> * @param index</span><br><span class="line"> */</span><br><span class="line">public static void putFloat(byte[] bb, float x, int index) &#123;</span><br><span class="line">	// byte[] b = new byte[4];</span><br><span class="line">	int l = Float.floatToIntBits(x);</span><br><span class="line">	for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">		bb[index + i] = new Integer(l).byteValue();</span><br><span class="line">		l = l &gt;&gt; 8;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过byte数组取得float</span><br><span class="line"> *</span><br><span class="line"> * @param bb</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static float getFloat(byte[] b, int index) &#123;</span><br><span class="line">	int l;</span><br><span class="line">	l = b[index + 0];</span><br><span class="line">	l &amp;= 0xff;</span><br><span class="line">	l |= ((long) b[index + 1] &lt;&lt; 8);</span><br><span class="line">	l &amp;= 0xffff;</span><br><span class="line">	l |= ((long) b[index + 2] &lt;&lt; 16);</span><br><span class="line">	l &amp;= 0xffffff;</span><br><span class="line">	l |= ((long) b[index + 3] &lt;&lt; 24);</span><br><span class="line">	return Float.intBitsToFloat(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>double与byte的转化   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * double转换byte</span><br><span class="line">	 *</span><br><span class="line">	 * @param bb</span><br><span class="line">	 * @param x</span><br><span class="line">	 * @param index</span><br><span class="line">	 */</span><br><span class="line">	public static void putDouble(byte[] bb, double x, int index) &#123;</span><br><span class="line">		// byte[] b = new byte[8];</span><br><span class="line">		long l = Double.doubleToLongBits(x);</span><br><span class="line">		for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">			bb[index + i] = new Long(l).byteValue();</span><br><span class="line">			l = l &gt;&gt; 8;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 通过byte数组取得float</span><br><span class="line">	 *</span><br><span class="line">	 * @param bb</span><br><span class="line">	 * @param index</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static double getDouble(byte[] b, int index) &#123;</span><br><span class="line">		long l;</span><br><span class="line">		l = b[0];</span><br><span class="line">		l &amp;= 0xff;</span><br><span class="line">		l |= ((long) b[1] &lt;&lt; 8);</span><br><span class="line">		l &amp;= 0xffff;</span><br><span class="line">		l |= ((long) b[2] &lt;&lt; 16);</span><br><span class="line">		l &amp;= 0xffffff;</span><br><span class="line">		l |= ((long) b[3] &lt;&lt; 24);</span><br><span class="line">		l &amp;= 0xffffffffl;</span><br><span class="line">		l |= ((long) b[4] &lt;&lt; 32);</span><br><span class="line">		l &amp;= 0xffffffffffl;</span><br><span class="line">		l |= ((long) b[5] &lt;&lt; 40);</span><br><span class="line">		l &amp;= 0xffffffffffffl;</span><br><span class="line">		l |= ((long) b[6] &lt;&lt; 48);</span><br><span class="line">		l &amp;= 0xffffffffffffffl;</span><br><span class="line">		l |= ((long) b[7] &lt;&lt; 56);</span><br><span class="line">		return Double.longBitsToDouble(l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>boolean与byte的相互转化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 将boolean转成byte[]</span><br><span class="line">     * @param val</span><br><span class="line">     * @return byte[]</span><br><span class="line">     */  </span><br><span class="line">    public static byte[] Boolean2ByteArray(boolean val) &#123;</span><br><span class="line">        int tmp = (val == false) ? 0 : 1;</span><br><span class="line">        return ByteBuffer.allocate(4).putInt(tmp).array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转成boolean</span><br><span class="line">     * @param data</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    public static boolean ByteArray2Boolean(byte[] data) &#123;</span><br><span class="line">        if (data == null || data.length &lt; 4) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = ByteBuffer.wrap(data, 0, 4).getInt();</span><br><span class="line">        return (tmp == 0) ? false : true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考地址：<br>[1].long、shrot和int转化 <a href="https://blog.csdn.net/u012403290/article/details/68943827" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/68943827</a><br>[2].long、shrot和int转化 <a href="https://blog.csdn.net/thanklife/article/details/17002641" target="_blank" rel="noopener">https://blog.csdn.net/thanklife/article/details/17002641</a><br>[3]. char、float、double与byte转化 <a href="https://blog.csdn.net/LEEtcWorks/article/details/7390731" target="_blank" rel="noopener">https://blog.csdn.net/LEEtcWorks/article/details/7390731</a><br>[4]. 通过buffer转换 <a href="https://blog.csdn.net/u010983881/article/details/60870360" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/60870360</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/08/27/基础数据与byte间的转化/" data-id="cjlc1dmur004ca4s6s5ws4tki" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boolen/">boolen</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/byte/">byte</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/char/">char</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/double/">double</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/int/">int</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/long/">long</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/short/">short</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-Buffer解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/NIO-Buffer解析/" class="article-date">
  <time datetime="2018-08-23T08:18:47.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/NIO-Buffer解析/">NIO-Buffer解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&nbsp; &nbsp; &nbsp; &nbsp;在NIO中，数据的读写操作始终是与缓冲区相关联的。Channel将数据<br>读入缓冲区，然后我们又从缓冲区访问数据。写数据时，首先将要发送的数据按顺序填入缓冲区。基本上，<br>缓冲区只是一个列表，它的所有元素都是基本数据类型（通常为字节型）。缓冲区是定长的，它不像一些类<br>那样可以扩展容量（例如，List，StringBuffer等）。注意，ByteBuffer是最常用的缓冲区，因为：1）<br>它提供了读写其他数据类型的方法，2）信道的读写方法只接收ByteBuffer。</p>
<h4 id="Buffer索引"><a href="#Buffer索引" class="headerlink" title="Buffer索引"></a>Buffer索引</h4><p>缓冲区不仅仅是用来存放一组元素的列表。在读写数据时，它有内部状态来跟踪缓冲区的当前位置，以及有效<br>可读数据的结束位置等。为了实现这些功能，每个缓冲区维护了指向其元素列表的4个索引，如下表所示。<br>（不久我们将看到如何使用缓冲区的各种方法来修改索引值。）   </p>
<table>
<thead>
<tr>
<th style="text-align:left">索引</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">存取器/修改器/用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">capacity</td>
<td style="text-align:left">缓冲区的元素总是（不可修改）</td>
<td style="text-align:left">int capacity（）</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">下一个要读/写的元素（从0开始）</td>
<td style="text-align:left">int position(), Buffer position(int newPosition)</td>
</tr>
<tr>
<td style="text-align:left">limit</td>
<td style="text-align:left">第一个不可读/写元素</td>
<td style="text-align:left">int limit(), Buffer limit(int newLimit)</td>
</tr>
<tr>
<td style="text-align:left">mark</td>
<td style="text-align:left">用户选定的position 高的前一个位置或0</td>
<td style="text-align:left">Buffer mark(),Buffer reset()</td>
</tr>
</tbody>
</table>
<p>position和limit之间的距离指示了可读取/存入的字节数，java中提供了两个方便的方法来计算这个距离。  </p>
<ul>
<li>boolean hasRemaining（）：当缓冲区至少还有一个元素时，返回true；</li>
<li>int remaining（）：返回缓冲区包含的元素个数；<br>在这些变量中，始终保持以下关系不变：<br>0  ≤ mark ≤ position ≤ limit ≤ capacity<br>mark变量的值“记录”了一个将来可返回的位置，reset（）方法则将postion的值还原成上次调用mark（）<br>方法后的position值（除非这样做会违背上面的不变关系）；</li>
</ul>
<h4 id="Buffer创建"><a href="#Buffer创建" class="headerlink" title="Buffer创建"></a>Buffer创建</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;通常使用分配空间或包装一个现有的基本类型数组来创建缓冲区。创建ByteBuffer的静态工厂方法，以及<br>相应的capacity，position，和limit的初始值下表。所有新创建的Buffer实例都没有定义其mark值，<br>在调用mark()方法前，任何试图使用reset()方法来设置position的值的操作都将抛出InvalidMarkException异常。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteBuffer    allocate(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    allocateDirect(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">0</td>
<td style="text-align:left">array.length</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array,int offer,int length)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">offset</td>
<td style="text-align:left">offset-array.length</td>
</tr>
</tbody>
</table>
<p>要分配一个新的实例，只需要简单地调用想要创建的缓冲区类型的allocate()静态方法，并指定元素的总数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(20);</span><br><span class="line">DoubleBuffer dblBuf = DoubleBuffer.allocate(5);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在上面代码中，byteBuf分配了20个字节，dblBuf分配了5个Java的<br>double型数据。这些缓冲区都是定长的，因此无法扩展或缩减它们的容量。如果发现刚创建的缓冲区容量太小，<br>惟一的选择就是重新创建一个大小合适的缓冲区。<br>还可以通过调用wrap()静态方法，以一个已有的数组为参数，来创建缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byteArray[] = new byte[BUFFERSIZE];</span><br><span class="line">// ...Fill array...</span><br><span class="line">ByteBuffer byteWrap = ByteBuffer.wrap(byteArray);</span><br><span class="line">ByteBuffer subByteWrap = ByteBuffer.wrap(byteArray, 3,3);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过包装的方法创建的缓冲区 <strong>保留了被包装数组内保存的数据</strong>。实际上，<br>wrap()方法只是简单地创建了一个具有指向被包装数组的引用的缓冲区，该数组称为 <strong>后援数组</strong>。对后援数组<br>中的数据做的任何修改都将改变缓冲区中的数据，反之亦然。如果我们为wrap()方法指定了偏移量（offset）<br>和长度（length），缓冲区将使用整个数组为后援数组，同时将position和limit的值初始化为偏移量<br>（offset）和偏移量+长度（offset+length）。在偏移量之前和长度之后的元素依然可以通过缓冲区访问。<br>使用分配空间的方式来创建缓冲区其实与使用包装的方法区别不大。惟一的区别是allocate()方法创建了<br>自己的后援数组。在缓冲区上调用array()方法即可获得后援数组的引用。通过调用arrayOffset()方法，<br>甚至还可以获取缓冲区中第一个元素在后援数组中的偏移量。使用wrap()方法和非零偏移量参数创建的缓冲区，<br>其数组偏移量依然是0。<br>&nbsp; &nbsp; &nbsp; &nbsp;到目前为止，我们实现的所有缓冲区都将数据存放在Java分配的后援数组中。<br>通常，底层平台（操作系统）不能使用这些缓冲区进行I/O操作。操作系统必须使用自己的缓冲区来进行I/O，<br>并将结果复制到缓冲区的后援数组中。这些复制过程 <strong>可能非常耗费系统资源</strong>，尤其是在有很多读写需求的时候。<br>Java的NIO提供了一种 <strong>直接缓冲区（direct buffers）</strong> 来解决这个问题。使用直接缓冲区，Java将从平台<br>能够直接进行I/O操作的存储空间中为缓冲区分配后援存储空间，从而省略了数据的复制过程。这种低层的、<br>本地的I/O通常在字节层进行操作，因此只能为 <strong>ByteBuffer进行直接缓冲区分配</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBufDirect =ByteBuffer.allocateDirect(BUFFERSIZE);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过调用isDirect()方法可以查看一个缓冲区是否是直接缓冲区。由于<br>直接缓冲区没有后援数组，在它上面调用array()或arrayOffset()方法都将抛出<br>UnsupportedOperationException异常。在考虑是否使用直接缓冲区时需要牢记几点。首先，要知道调用<br>allocateDirect()方法并不能保证能成功分配直接缓冲区–有的平台或JVM可能不支持这个操作，因此在<br>尝试分配直接缓冲区后必须调用isDirect()方法进行检查。其次，要知道 <strong>分配和销毁直接缓冲区通常比分配<br>和销毁非直接缓冲区要消耗更多的系统资源</strong>，因为直接缓冲区的后援存储空间通常存在与JVM之外，对它的管理<br>需要与操作系统进行交互。所以，只有当需要在很多I/O操作上长时间使用时，才分配直接缓冲区。实际上，<br>在相对于非直接缓冲区能明显提高系统性能时，使用直接缓冲区是个不错的主意。</p>
<h4 id="存储和接受数据"><a href="#存储和接受数据" class="headerlink" title="存储和接受数据"></a>存储和接受数据</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;只要有了缓冲区，就可以用它来存放数据了。作为数据的”容器”，缓冲区<br><strong>既可用来输入也可用来输出。这一点就与流不同，流只能向一个方向传递数据</strong>。使用put()方法可以将数据放入<br>缓冲区，使用get()方法则可以从缓冲区获取数据。信道的read()方法隐式调用了给定缓冲区的put()，而其<br>write()方法则隐式调用了缓冲区的get()方法。下面展示ByteBuffer的get()和put()方法，当然，其他<br>类型的缓冲区也有类似的方法。<br>ByteBuffer:获取和存放字节，有两种类型的get()和put()：基于相对位置和基于绝对位置。基于相对位置<br>的版本根据position的当前值，从”下一个”位置读取或存放数据，然后根据数据量给position增加适当的值<br>（即，单字节形式增加1数组形式增加array.length，     数组/偏移量/长度形式则增加length）。也就是<br>说，每次调用put()方法，都是在缓冲区中的已有元素后面追加数据，每次调用get()方法，都是读取缓冲区的<br>后续元素。不过，如果这些操作会导致position的值超出limit的限制，get()方法将抛出BufferUnderflowException异常，<br>put()方法将抛出BufferOverflowException异常。例如，如果传给get()方法的目标数组长度大于缓冲区<br>的剩余空间大小，get()方法将抛出BufferUnderflowException异常，部分数据的get/put是不允许的。<br>基于绝对位置的get()和put()以指定的索引位置为参数，从该位置读取数据或向该位置写入数据。绝对位置<br>形式的get和put不会改变position的值。如果给定的索引值超出了limit的限制，它们将抛出IndexOutOfBoundsException异常。<br>除了字节类型外，ByteBuffer类还提供了其他类型数据的相当位置和绝对位置的get/put方法。这样一来，就有点像DataOutputStream了。</p>
<ul>
<li>相对位置：<ul>
<li>byte get()</li>
<li>ByteBuffer get(byte[] dst)</li>
<li>ByteBuffer get(byte[] dst, int offset, int length)</li>
<li>ByteBuffer put(byte b)</li>
<li>ByteBuffer put(byte[] src)</li>
<li>ByteBuffer put(byte[] src, int offset, int length)</li>
<li>ByteBuffer put(ByteBuffer src)</li>
</ul>
</li>
<li><p>绝对位置：</p>
<ul>
<li>byte get(int index)</li>
<li>ByteBuffer put(int index, byte b)</li>
</ul>
</li>
<li><p>ByteBuffer:读取和存放Java多字节基本数据</p>
<ul>
<li><type> get<type>()</type></type></li>
<li><type> get<type>(int index)</type></type></li>
<li>ByteBuffer put<type>(<type> value)</type></type></li>
<li>ByteBuffer put<type>(int index,<type> value)</type></type></li>
</ul>
</li>
</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp;其中”<type>“代表Char，Double，Int，Long，Short之一，<br>而”<type>“代表char，double，int，long，short之一。<br>每次调用基于相对位置的put()或get()方法，都将根据特定参数类型的长度增加position的值：short加2，<br>int加4，等。不过，如果这样做会导致position的值超出limit的限制，get()和put()方法将分别抛出<br>BufferUnderflowException和BufferOverflowException异常：get和put不允许只对部分数据进行操作。<br>发生了下溢/上溢（under/overflow）时，position的值不变。可能你已经注意到，很多get/put方法都<br>返回一个ByteBuffer。实际上它们返回的就是调用它们的那个ByteBuffer。这样做可以实现 <strong>链式调用（call chaining）</strong>，<br>即第一次调用的结果可以直接用来进行后续的方法调用。例如，可以像下面那样将整数1和2存入ByteBuffer实例<br>myBuffer中：myBuffer.putInt(1).putInt(2);<br>&nbsp; &nbsp; &nbsp; &nbsp;<strong>多字节数据类型有一个字节顺序，称为big-endian或little-endian。<br>Java默认使用big-endian</strong>。通过使用内置的ByteOrder.BIG_ENDIAN和ByteOrder.LITTLE_ENDIAN实例，<br>可以获取和设定多字节数据类型写入字节缓冲区时的字节顺序。</type></type></p>
<ul>
<li>ByteBuffer:缓冲区中的字节顺序<ul>
<li>ByteOrder order()</li>
<li>ByteBuffer order(ByteOrder order)<br>第一个方法以ByteOrder常量的形式返回缓冲区的当前字节顺序。第二个方法用来设置写多字节数据时的字节顺序。</li>
</ul>
</li>
</ul>
<p>下面来看一个使用字节顺序的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(4);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">// Predict the byte values for buffer and test your prediction</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;看了这些有关字节顺序的讨论，你可能希望知道自己的处理器是什么字节<br>顺序，ByteOrder定义了一个方法来解答这个问题：<br>ByteOrder:查找字节顺序<br>static final ByteOrder BIG_ENDIAN<br>static final ByteOrder LITTLE_ENDIAN<br>static ByteOrder nativeOrder()<br>nativeOrder()方法返回常量BIG_ENDIAN或LITTLE_ENDIAN之一。</p>
<h4 id="Buffer准备：clear（）、flip（）和rewind（）"><a href="#Buffer准备：clear（）、flip（）和rewind（）" class="headerlink" title="Buffer准备：clear（）、flip（）和rewind（）"></a>Buffer准备：clear（）、flip（）和rewind（）</h4><p>在使用缓冲区进行输入输出数据之前，必须确定缓冲区的position，limit都已经设置了正确的值。首先<br>我们看看上面三个方法对position和limit的修改操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ByteBuffer方法</th>
<th style="text-align:left">准备Buffer以实现</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clear()</td>
<td style="text-align:left">将数据read()/put()进缓冲区</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">flip()</td>
<td style="text-align:left">从缓冲区write()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">position</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">rewind()</td>
<td style="text-align:left">从缓冲区rewrite()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>三种在Buffer类的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Clears this buffer.  The position is set to zero, the limit is set to</span><br><span class="line">    * the capacity, and the mark is discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span><br><span class="line">    * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.clear();     // Prepare buffer for reading</span><br><span class="line">    * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span><br><span class="line">    * is named as if it did because it will most often be used in situations</span><br><span class="line">    * in which that might as well be the case. &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer clear() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Flips this buffer.  The limit is set to the current position and then</span><br><span class="line">    * the position is set to zero.  If the mark is defined then it is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span><br><span class="line">    * this method to prepare for a sequence of channel-write or relative</span><br><span class="line">    * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.put(magic);    // Prepend header</span><br><span class="line">    * in.read(buf);      // Read data into rest of buffer</span><br><span class="line">    * buf.flip();        // Flip buffer</span><br><span class="line">    * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method is often used in conjunction with the &#123;@link</span><br><span class="line">    * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span><br><span class="line">    * one place to another.  &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer flip() &#123;</span><br><span class="line">       limit = position;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Rewinds this buffer.  The position is set to zero and the mark is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span><br><span class="line">    * operations, assuming that the limit has already been set</span><br><span class="line">    * appropriately.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * out.write(buf);    // Write remaining data</span><br><span class="line">    * buf.rewind();      // Rewind buffer</span><br><span class="line">    * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer rewind() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释：（参考：<a href="https://blog.csdn.net/FS1360472174/article/details/52141800）" target="_blank" rel="noopener">https://blog.csdn.net/FS1360472174/article/details/52141800）</a></p>
<ul>
<li>clear: clear 并没有真正的清除数据，将position设置为0，limit设置为capacity;</li>
<li><p>flip ：一般是切换到读操作。或者是为写操作准备一个新的序列<br>eg：重复向一个ByteBuffer写数据的时候，赋值完毕，必须要flip.开始一个新的新序列，否则position<br>会等于limit，返回空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       byte[] bytes1=new byte[]&#123;1, 6, 3&#125;;</span><br><span class="line">       ByteBuffer buffer =fromByteArray(bytes1);</span><br><span class="line">       System.out.println(buffer);</span><br><span class="line">       byte[] bytes2 =new byte[]&#123;1,2,3&#125;;</span><br><span class="line">       ByteBuffer buffer2=fromByteArray(bytes2);</span><br><span class="line">       System.out.println(buffer2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * If you are building up a ByteBuffer by repeatedly writing into it, and then want to give it away, you must remember to flip() it.</span><br><span class="line">    * If we did not flip() it, the returned ByteBuffer would be empty because the position would be equal to the limit.</span><br><span class="line">    * @param bytes</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static ByteBuffer fromByteArray(byte[] bytes) &#123;</span><br><span class="line">       final ByteBuffer ret = ByteBuffer.wrap(new byte[bytes.length]);</span><br><span class="line"></span><br><span class="line">       ret.put(bytes);</span><br><span class="line">       ret.flip();</span><br><span class="line"></span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rewind:倒回，将position 设置为0，重新读取;</p>
</li>
</ul>
<h4 id="压缩Buffer中数据"><a href="#压缩Buffer中数据" class="headerlink" title="压缩Buffer中数据"></a>压缩Buffer中数据</h4><p>compact()方法将position与limit之间的元素复制到缓冲区的开始位置，从而为后续的put()/read()调<br>用让出空间。position的值将设置为要复制的数据的长度，limit的值将设置为capacity，mark则变成未定义。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">      byte[] bytes = new byte[]&#123;1, 6, 3, 1, 1, 1, 1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">      ByteBuffer buffer = ByteBuffer.wrap(bytes);</span><br><span class="line">      byte b = buffer.get();</span><br><span class="line">      System.out.println(&quot;b:&quot; + b + &quot; position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.compact();</span><br><span class="line">      System.out.println(&quot;compact  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.flip();</span><br><span class="line">      System.out.println(&quot;flip  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>b:1 position:1 limit:11 capacity:11<br>compact  position:10 limit:11 capacity:11<br>flip  position:0 limit:10 capacity:11</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;为什么要使用这个操作呢？假设你有一个缓冲区要写数据。回顾前面的内容我们知道，对write()方法的非阻塞调用只会写出其能够发送的数据，而不会阻塞等待所有数据发送完。因此write()方法不一定会将缓冲区中的所有元素都发送出去。又假设现在要调用read()方法，在缓冲区中没有发送的数据后面读入新数据。处理方法之一就是简单地设置position = limit和limit = capacity。当然，在读入新数据后，再次调用write()方法前，还需要将这些值还原。这样做有个问题即缓冲区的空间最终将消耗殆尽，如上图中，只剩下一个元素位置可以再存入一个字节。此外，缓冲区前面的空间又被浪费掉了。这就是compact()方法要解决的问题。在调用write()方法后和添加新数据的read()方法前调用compact()方法，则将所有”剩余”的数据移动到缓冲区的开头，从而为释放最大的空间来存放新数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for reading</span><br><span class="line">while (channel.read(buffer) != -1) &#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">channel.write(buffer);</span><br><span class="line">buffer.compact();</span><br><span class="line">&#125;</span><br><span class="line">while (buffer.hasRemaining())</span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，如开始已经提到的，复制数据是一个非常耗费系统资源的操作，因此要保守地使用compact()方法。</p>
<h4 id="Buffer透视：duplicate-slice-等"><a href="#Buffer透视：duplicate-slice-等" class="headerlink" title="Buffer透视：duplicate(),slice()等"></a>Buffer透视：duplicate(),slice()等</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;NIO提供了多种方法来创建一个与给定缓冲区共享内容的新缓冲区，这些方法对元素的处理过程各有不同。基本上，这种新缓冲区有自己独立的状态变量（position，limit，capacity和mark），但与原始缓冲区共享了同一个后援存储空间。任何对新缓冲区 <strong>内容</strong> 的修改都将反映到 <strong>原始缓冲区上</strong> 。可以将新缓冲区看作是从另一个角度对同一数据的透视。</p>
<p>duplicate()方法用于创建一个与原始缓冲区共享内容的新缓冲区。新缓冲区的position，limit，mark和capacity都初始化为原始缓冲区的索引值，然而，它们的这些值是相互独立的。如下表格为在ByteBuffer上创建不同透视的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">duplicate()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">slice()</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asReadOnlyBuffer()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">asCharBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asDoubleBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asFloatBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asIntBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asLongBuffer()</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asShortBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由于共享了内容，对原始缓冲区或任何复本所做的改变在所有复本上都可见。<br>下面回到前面的例子，假设要将在网络上发送的所有数据都写进日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for writing</span><br><span class="line">ByteBuffer logBuffer = buffer.duplicate();</span><br><span class="line">while (buffer.hasRemaining()) // Write all data to network</span><br><span class="line">networkChannel.write(buffer);</span><br><span class="line">while (logBuffer.hasRemaining()) // Write all data to</span><br><span class="line">//logger</span><br><span class="line">loggerChannel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，使用了缓冲区复制操作，向网络写数据和写日志就可以在不同的线程中并行进行。slice()方法用于创建一个共享了原始缓冲区子序列的新缓冲区。新缓冲区的position值是0，而其limit和capacity的值都等于原始缓冲区的limit和position的差值。slice()方法将新缓冲区数组的offset值设置为原始缓冲区的position值，然而，在新缓冲区上调用array()方法还是会返回整个数组。<br>Channel在读写数据时只以ByteBuffer为参数，然而我们可能还对使用其他基本类型的数据进行通信感兴趣。ByteBuffer能够创建一种独立的”视图缓冲区（view buffer）”，用于将ByteBuffer的内容解释成其他基本类型（如CharBuffer）。这样就可以从该缓冲区中读取（写入数据是可选操作）新类型的数据。新缓冲区与原始缓冲区共享了同一个后援存储空间，因此，在 <strong>任一缓冲区上的修改在新缓冲区和原始缓冲区上都可以看到</strong>。新创建的视图缓冲区的position值为0，其内容从原始缓冲区的position所指位置开始。这与slice()操作非常相似。不过，由于视图缓冲区操作的是多字节元素，新缓冲区的capacity和limit的值等于剩余总字节数除以每个该类型元素对应的字节数（例如，创建DoubleBuffer时则除以8）。<br>下面来看一个例子。假设通过某个Channel接收到一条消息，该消息由一个单独字节，后跟大量big-endian顺序的双字节整数（如short型）组成。由于该消息是通过Channel送达的，它一定在一个ByteBuffer中，在此为buf。消息的第一个字节包含了消息中双字节整数的数量。你可能要调用第一个字节指定次数的buf.getShort()方法，或者你可以一次获取所有的整数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ...get message by calling channel.read(buf) ...</span><br><span class="line">int numShorts = (int)buf.get();</span><br><span class="line">if (numShorts &lt; 0) &#123;</span><br><span class="line">throw new SomeException()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">short[] shortArray = new short[numShorts];</span><br><span class="line">ShortBuffer sbuf = buf.asShortBuffer();</span><br><span class="line">sbuf.get(shortArray); // note: will throw if header was</span><br><span class="line">incorrect!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asReadOnlyBuffer()方法的功能与duplicate()方法相似，只是任何会修改新缓冲区内容的方法都将抛出ReadOnlyBufferException异常。包括各种型式的put()，compact()等，甚至连在缓冲区上调用无方向性的array()和arrayOffset()方法也会抛出这个异常。当然，对产生这个只读缓冲区的非只读缓冲区进行的任何修改，<br>仍然会与新的只读缓冲区共享。就像用duplicate()创建的缓冲区一样，只读缓冲区也有独立的缓冲区状态变量。可以使用isReadOnly()方法来检查一个缓冲区是否是只读的。如果原缓冲区已经是只读的，调用duplicate()或slice()方法也将创建新的只读缓冲区。</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;字符是由字节序列进行编码的，而且在字节序列与字符集合之间有各种映射（称为字符集）方式。NIO缓冲区的另一个用途是在各种字符集之间进行转换。要使用这个功能，还需要了解java.nio.charset包中另外两个类：CharsetEncoder和CharsetDecoder类。要进行编码，需要使用一个Charset实例来创建一个编码器并调用encode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Charset charSet = Charset.forName(&quot;US-ASCII&quot;);</span><br><span class="line">CharsetEncoder encoder = charSet.newEncoder();</span><br><span class="line">ByteBuffer buffer = encoder.encode(CharBuffer.wrap(&quot;Hi</span><br><span class="line">mom&quot;));</span><br></pre></td></tr></table></figure></p>
<p>要进行解码，需要使用Charset实例来创建一个解码器，并调用decode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = charSet.newDecoder();</span><br><span class="line">CharBuffer cBuf = decoder.decode(buffer);</span><br></pre></td></tr></table></figure></p>
<p>虽然这种方法能够正常工作，但当需要进行多次编码时，效率就会变得较低。例如，每次调用encode/decode<br>方法都会创建一个新Byte/CharBuffer实例。其他导致低效率的地方与编码器的创建和操作有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">encoder.reset();</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Hi &quot;),buffer,false)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... deal with lack of space in buffer ...</span><br><span class="line">&#125;</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Mom&quot;),buffer,true)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... ditto ...</span><br><span class="line">&#125;</span><br><span class="line">encoder.flush(buffer);</span><br></pre></td></tr></table></figure></p>
<p>encode()方法将给定CharBuffer转换为一个字节序列，并将其写入给定的缓冲区。如果缓冲区太小，encode()方法的返回值等于CoderResult.OVERFLOW。如果输入的数据完全被接收，并且编码器还准备对更多数据进行编码，encode()方法的返回值则等于CoderResult.UNDERFLOW。另外，如果输入的数据格式有错误，则将返回一个CoderResult对象，并指示了所存在的问题的位置和类型。只有到达了输入数据的结尾时，才将最后的boolean参数设为true。flush()方法将任何缓存的编码数据推送到缓冲区。注意，在新创建的编码器上调用reset()方法并不是必需的，该方法用来重新设置编码器的内部状态，以使其能够进行再次编码。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后通过一段简短代码展示allocate、flip、get、compact和clear方法对position、limit的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws IOException &#123;</span><br><span class="line"></span><br><span class="line"> ByteBuffer buffer1 = ByteBuffer.allocate(10);</span><br><span class="line"> RandomAccessFile fine = new RandomAccessFile(new File(&quot;b.txt&quot;), &quot;rw&quot;);</span><br><span class="line"> FileChannel fc = fine.getChannel();//分配空间后position为0，limit=capacity=10；</span><br><span class="line"> output(&quot;allocate&quot;, buffer1);</span><br><span class="line"> fc.read(buffer1);</span><br><span class="line"> output(&quot;read&quot;, buffer1);</span><br><span class="line"> buffer1.flip();                 //将limit设置为position，然后将position设置为0</span><br><span class="line"> output(&quot;flip&quot;, buffer1);</span><br><span class="line"> buffer1.get();                          //将position加一</span><br><span class="line"> output(&quot;get&quot;, buffer1);</span><br><span class="line"> buffer1.rewind();                       //重置position为0</span><br><span class="line"> output(&quot;rewind&quot;, buffer1);</span><br><span class="line"> buffer1.compact();                         //将position到limit的数据移到数组前端，并将position设置为（limit-position的距离），limit=capacity</span><br><span class="line"> output(&quot;compact&quot;, buffer1);</span><br><span class="line"> buffer1.clear();                    //重置position为0，limit=capacity</span><br><span class="line"> output(&quot;clear&quot;, buffer1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void output(String tag, ByteBuffer buffer) &#123;</span><br><span class="line">      System.out.println(tag + &quot; position:&quot; + buffer.position() + &quot; limit:&quot; + buffer.limit() + &quot; capacity:&quot; + buffer.capacity());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>allocate position:0 limit:10 capacity:10<br>read position:6 limit:10 capacity:10<br>flip position:0 limit:6 capacity:10<br>get position:1 limit:6 capacity:10<br>rewind position:0 limit:6 capacity:10<br>compact position:6 limit:10 capacity:10<br>clear position:0 limit:10 capacity:10<br>get position:2 limit:10 capacity:10</p>
<p>参考：<br>[1] （译文）java中的ShortBuffer <a href="https://blog.csdn.net/u010142437/article/details/42082735" target="_blank" rel="noopener">https://blog.csdn.net/u010142437/article/details/42082735</a><br>[2] Buffer详解 <a href="https://blog.csdn.net/guofengpu/article/details/51995730" target="_blank" rel="noopener">https://blog.csdn.net/guofengpu/article/details/51995730</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/08/23/NIO-Buffer解析/" data-id="cjlc1dmtg000ta4s6urinyyv6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Buffer/">Buffer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ByteBuffer/">ByteBuffer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-根据Uri获取文档的路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/根据Uri获取文档的路径/" class="article-date">
  <time datetime="2018-08-16T06:11:33.000Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/根据Uri获取文档的路径/">根据Uri获取文档的路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>根据Url获取文档的绝对路径，解决Android4.4以上版本Uri转换。<br>Android在4.4之后的版本(包括4.4)中，从相册中选取图片返回Uri进行了改动。所以无法通过该Uri来取得文件路径从而解码图片将其显示出来。<br><code>在4.3或以下可以直接用Intent.ACTION_GET_CONTENT打开相册;在4.4或以上,官方建议用ACTION_OPEN_DOCUMENT打开相册</code><br>在Android4.4之前得到的Uri为：</p>
<ul>
<li>content://media/external/images/media/8302  </li>
<li>content://media/external/video/media  </li>
<li>content://media/external/images/media  </li>
</ul>
<p>而在Android4.4后得到的可能是以下：</p>
<ul>
<li>content://com.android.providers.media.documents/document/image:8302</li>
<li>content://com.android.providers.downloads.documents/document/5</li>
</ul>
<p>以下为Android4.4之后的适配：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *</span><br><span class="line"> * 专为Android4.4设计的从Uri获取文件绝对路径</span><br><span class="line"> */</span><br><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public static String getPath(final Context context, final Uri uri) &#123;</span><br><span class="line">    final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line">    LogUtil.d(&quot;uri:&quot; + uri);</span><br><span class="line">    // DocumentProvider</span><br><span class="line">    if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">        // ExternalStorageProvider</span><br><span class="line">        if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1];</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO handle non-primary volumes</span><br><span class="line">        &#125;</span><br><span class="line">        // DownloadsProvider</span><br><span class="line">        else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">            final String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">            return getDataColumn(context, contentUri, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // MediaProvider</span><br><span class="line">        else if (isMediaDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            Uri contentUri = null;</span><br><span class="line">            if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String selection = &quot;_id=?&quot;;</span><br><span class="line">            final String[] selectionArgs = new String[]&#123;split[1]&#125;;</span><br><span class="line">            LogUtil.d(&quot;format uri:&quot; + contentUri);</span><br><span class="line">            return getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // MediaStore (and general)</span><br><span class="line">    else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return getDataColumn(context, uri, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // File</span><br><span class="line">    else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return uri.getPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the value of the data column for this Uri. This is useful for</span><br><span class="line"> * MediaStore Uris, and other file-based ContentProviders.</span><br><span class="line"> *</span><br><span class="line"> * @param context       The context.</span><br><span class="line"> * @param uri           The Uri to query.</span><br><span class="line"> * @param selection     (Optional) Filter used in the query.</span><br><span class="line"> * @param selectionArgs (Optional) Selection arguments used in the query.</span><br><span class="line"> * @return The value of the _data column, which is typically a file path.</span><br><span class="line"> */</span><br><span class="line">public static String getDataColumn(Context context, Uri uri, String selection,</span><br><span class="line">                                   String[] selectionArgs) &#123;</span><br><span class="line"></span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    final String column = &quot;_data&quot;;</span><br><span class="line">    final String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                null);</span><br><span class="line">        if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">            final int column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor != null)</span><br><span class="line">            cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is ExternalStorageProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is DownloadsProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is MediaProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看一个获取Mp3文档的Uri，其格式类似：content://com.android.providers.media.documents/document/audio%3A39，<br>然后我根据代码进一步分析，首先看判断条件：isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)，<br>这里判断了版本号和该Uri是否是文档类Uri，之所以要判断版本号是Uri的生成在Api19以后发送变化，通过官方文档DocumentsContract，我们也可以验证这点，DocumentsContract是在Api19加入的，其定义就是定义文档提供者与平台之间的协议，其主要作用就是关于文档Uri的一系列操作。<br>下面是其内部实现代码（代码都是在DocumentsContract类中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT = &quot;document&quot;;</span><br><span class="line">private static final String PATH_TREE = &quot;tree&quot;;</span><br><span class="line">public static final String PROVIDER_INTERFACE = &quot;android.content.action.DOCUMENTS_PROVIDER&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Test if the given URI represents a &#123;@link Document&#125; backed by a</span><br><span class="line">   * &#123;@link DocumentsProvider&#125;.</span><br><span class="line">   *</span><br><span class="line">   * @see #buildDocumentUri(String, String)</span><br><span class="line">   * @see #buildDocumentUriUsingTree(Uri, String)</span><br><span class="line">   */</span><br><span class="line">  public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">      if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">          final List&lt;String&gt; paths = uri.getPathSegments();</span><br><span class="line">          if (paths.size() == 2) &#123;</span><br><span class="line">              return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">          &#125; else if (paths.size() == 4) &#123;</span><br><span class="line">              return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  /** &#123;@hide&#125; */</span><br><span class="line">   public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">      // public static final String SCHEME_CONTENT = &quot;content&quot;;     !!add by custom</span><br><span class="line">       return uri != null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent = new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos = context.getPackageManager()</span><br><span class="line">            .queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看出，前提条件是判断是否是contentUri&amp;&amp;documentProvider，然后在进一步判断其pathSegments<br>是否是document/或者tree/document/开头。其中isDocumentsProvider方法不是特别理解，希望大神指点下。</p>
<p>参考地址：<br>[1] 解决Android4.4以上版本Uri转换  <a href="https://blog.csdn.net/q445697127/article/details/40537945" target="_blank" rel="noopener">https://blog.csdn.net/q445697127/article/details/40537945</a><br>[2] <a href="https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework" target="_blank" rel="noopener">https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/08/16/根据Uri获取文档的路径/" data-id="cjlc1dmuv004ga4s69aj2lzye" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Uri/">Uri</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LinearLayout源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/12/LinearLayout源码解读/" class="article-date">
  <time datetime="2018-08-12T02:01:49.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/LinearLayout源码解读/">LinearLayout源码解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="LinearLayout基础"><a href="#LinearLayout基础" class="headerlink" title="LinearLayout基础"></a>LinearLayout基础</h3><p>LinearLayout所具有的属性：</p>
<ul>
<li>orientation：视图的布局方向，默认值：-1；</li>
<li>gravity：绘制起始点，默认值：-1；</li>
<li>baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true；</li>
<li>weightSum：子视图权重和，默认值：-1.0f；</li>
<li>baselineAlignedChildIndex：以第Index个子视图的基准线为对齐，该LinearLayout下的view以<br>某个继承TextView的View的基线对齐，默认值：-1；</li>
<li>measureWithLargestChild：以最大子视图宽高，为其子视图的宽高，<strong>其起作用前提是为true，且LinearLayout在该方向的宽或高为warp_content，且子视图具有权重</strong>。默认值：false；</li>
<li>divider：分割线；</li>
<li>showDividers：分割线显示样式（middle|end|beginning|non），默认值：SHOW_DIVIDER_NONE；</li>
<li><p>dividerPadding：分割线内边距，默认值：0；</p>
<p>解释：</p>
</li>
<li>基准线<br>其主要作用是在绘制字母的时候有个基线对齐，这个类似我们学习英语字母的时候用的四线谱：<br><img src="./images/baselineAligned_expand.png" alt="基线示意图"><br>其中红线就是基线（baseline），和下面我们书写英语字母的四线谱是不是很像，基线就是第三条。<br><img src="./images/baselineAligned_ch.png" alt="英语书写四线谱"></li>
</ul>
<ul>
<li>源码之垂直方向测量（void measureVertical(int widthMeasureSpec, int heightMeasureSpec)）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Measures the children when the orientation of this LinearLayout is set</span><br><span class="line">     * to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.</span><br><span class="line">     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.</span><br><span class="line">     *</span><br><span class="line">     * @see #getOrientation()</span><br><span class="line">     * @see #setOrientation(int)</span><br><span class="line">     * @see #onMeasure(int, int)</span><br><span class="line">     */</span><br><span class="line">    void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		// mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">		// maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">		// 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		* 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">		* 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">		* 否则，则跟maxWidth的计算方法一样</span><br><span class="line">		*/</span><br><span class="line">		// 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">		// 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">		// 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">		// 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">		// 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">		// 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">		// 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // See how tall everyone is. Also remember max width.</span><br><span class="line"></span><br><span class="line">		//查看每一个高，并记住最大宽度</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">			//首先获取子View</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">			//如果子View是null就继续测量下一个子View</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">				// 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">			//如果子View是GONE的也不算在总高度里面，这里也能看出GONE和INVISIBLE的区别</span><br><span class="line">            if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">				// 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line">			//有时候我们在代码里面通过Inflater服务，动态加载一个布局，然后去设置他的LayoutParams，</span><br><span class="line">			//如果不引用父容器的LayoutParams就会报一个强转错误，原因就在这个父容器在add,measure的时候都会</span><br><span class="line">			//把子View的LayoutParams强转成自己的类型</span><br><span class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">			//得到每个子控件的LayoutParams后，累加权重和,后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束,基本没有用到</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">			//这里就值得注意下了如果当前的LinearLayout是EXACTLY模式，且子view的高度为0，且权重大于0</span><br><span class="line">			//这个子view只有在LinearLayout高度有剩余的时候，才会根据权重的占比去平分剩余空间</span><br><span class="line">			//上文说的二次测量也就指的这部分</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // Optimization: don&apos;t bother measuring children who are going to use</span><br><span class="line">                // leftover space. These views will get measured again down below if</span><br><span class="line">                // there is any leftover space.</span><br><span class="line">				// 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0   	</span><br><span class="line"></span><br><span class="line">				// 如果LinearLayout的垂直方向测量模式是EXACTLY，即确定值，且子视图的高度为0，weight大于0，</span><br><span class="line">        //则先将总高度加上子视图的topMargin和bottomMargin，并设置skippedMeasure（暂时跳过测量标识）为true</span><br><span class="line"></span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法，此时需要记住view的topMargin和bottomMargin（对于方向为）</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">				// 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // heightMode is !!either UNSPECIFIED or AT_MOST!!, and this</span><br><span class="line">                    // child wanted to stretch to fill available space.</span><br><span class="line">                    // Translate that to WRAP_CONTENT so that it does not end up</span><br><span class="line">                    // with a height of 0</span><br><span class="line">					// 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line"></span><br><span class="line">					//这里其实官方的注释讲了也挺清楚的，到了这步，当前的LinearLayout的模式</span><br><span class="line">					//肯定是UNSPECIFIED或者MOST，因为EXACTLY模式会进入上一个判断</span><br><span class="line">					//然后把子View的高度赋值成-1(WRAP_CONTENT)</span><br><span class="line">					// 如果垂直方向测量模式为UNSPECIFIED或AT_MOST，同时子视图想要尽量获取可用的剩余空间，</span><br><span class="line">          //把子视图的高度改为WRAP_CONTENT，这样子视图的最终高度就不会是0</span><br><span class="line"></span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Determine how big this child would like to be. If this or</span><br><span class="line">                // previous children have given a weight, then we allow it to</span><br><span class="line">                // use all available space (and we will shrink things later</span><br><span class="line">                // if needed).</span><br><span class="line">				/**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line"></span><br><span class="line">				// 这个函数最后会调用child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</span><br><span class="line">        //测量出子视图要占用多大空间，并设置子视图的mMeasuredWidth和mMeasuredHeight</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">				// 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line"></span><br><span class="line">				// getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">				//加上子View的margin值</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">				// 重新设置最大子视图高度</span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * If applicable, compute the additional offset to the child&apos;s baseline</span><br><span class="line">             * we&apos;ll need later when asked &#123;@link #getBaseline&#125;.</span><br><span class="line">             */</span><br><span class="line">			// 计算子视图baseline的偏移量</span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // if we are trying to use a child index for our baseline, the above</span><br><span class="line">            // book keeping only works if there are no children above it with</span><br><span class="line">            // weight.  fail fast to aid the developer.</span><br><span class="line">			// 如果要为baseline指定子视图索引，只有在此子视图之上的视图没有设置weight属性时才有效</span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 下面开始测量宽度</span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // The width of the linear layout will scale, and at least one</span><br><span class="line">                // child said it wanted to match our width. Set a flag</span><br><span class="line">                // indicating that we need to remeasure at least that view when</span><br><span class="line">                // we know our width.</span><br><span class="line">				//如果LinearLayout宽度不是已确定的，如wrap_content,而子视图是MATCH_PARENT，  </span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 计算子视图总宽度（包含左右外边距）</span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">			// 合并子元素的测量状态</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">			// 子视图宽度是否都为MATCH_PARENT</span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Widths of weighted Views are bogus if we end up</span><br><span class="line">                 * remeasuring, so keep them separate.</span><br><span class="line">                 */</span><br><span class="line">				//如设置了weigh属性，则子视图的宽度需要在父视图确定后才能确定。这里并不是真实的宽度  </span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">		//for 循环结束</span><br><span class="line"></span><br><span class="line">		// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过</span><br><span class="line">        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">			// 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，</span><br><span class="line">      //重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                // Account for negative margins</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//在这两段代码之间还有些杂七杂八的处理，如果读者有兴趣可以自己阅读分析下</span><br><span class="line">		//当测量完子View的大小后，总高度会再加上padding的高度</span><br><span class="line">        // Add in our padding</span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        int heightSize = mTotalLength;</span><br><span class="line">		    //如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较</span><br><span class="line">        //然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值</span><br><span class="line">        // Check against our minimum height</span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        // Reconcile our calculated size with the heightMeasureSpe</span><br><span class="line">		// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，</span><br><span class="line">    //剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）</span><br><span class="line">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line">		//到了这里，会再对带weight属性的子View进行一次测绘</span><br><span class="line">        //首先计算剩余高度</span><br><span class="line"></span><br><span class="line">		//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的</span><br><span class="line">        // Either expand children with weight to take up available space or</span><br><span class="line">        // shrink them if they extend beyond our current bounds. If we skipped</span><br><span class="line">        // measurement on any children, we need to measure them now.</span><br><span class="line">        int delta = heightSize - mTotalLength;</span><br><span class="line">        if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123;</span><br><span class="line">			//如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦</span><br><span class="line">            float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = 0;</span><br><span class="line">			//这里的代码就和第一次测量很像了</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                float childExtra = lp.weight;</span><br><span class="line">                if (childExtra &gt; 0) &#123;</span><br><span class="line">					// 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure</span><br><span class="line">					//子控件的weight占比*剩余高度</span><br><span class="line">                    // Child said it could absorb extra space -- give him his share</span><br><span class="line">                    int share = (int) (childExtra * delta / weightSum);</span><br><span class="line">					// weightSum计余</span><br><span class="line">                    weightSum -= childExtra;</span><br><span class="line">					//剩余高度减去分配出去的高度</span><br><span class="line">                    delta -= share;</span><br><span class="line"></span><br><span class="line">                    final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight +</span><br><span class="line">                                    lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line">					//如果是当前LinearLayout的模式是EXACTLY</span><br><span class="line">                    //那么这个子View是没有被测量过的，就需要测量一次</span><br><span class="line">                    //如果不是EXACTLY的，在第一次循环里就被测量一些了</span><br><span class="line">                    // TODO: Use a field like lp.isMeasured to figure out if this</span><br><span class="line">                    // child has been previously measured</span><br><span class="line">                    if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        // child was measured once already above...</span><br><span class="line">                        // base new measurement on stored values</span><br><span class="line">						//如果是非EXACTLY模式下的子View就再加上</span><br><span class="line">                        //weight分配占比*剩余高度</span><br><span class="line">						// 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小</span><br><span class="line">                        int childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                        if (childHeight &lt; 0) &#123;</span><br><span class="line">                            childHeight = 0;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">						//重新测量一次，因为高度发生了变化</span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // child was skipped in the loop above.</span><br><span class="line">                        // Measure for this first time here  </span><br><span class="line"></span><br><span class="line">						//如果是EXACTLY模式下的</span><br><span class="line">                        //这里只会把weight占比所拥有的高度分配给你的子View</span><br><span class="line">						// 上面测量的时候被跳过，那么在这里进行测量    </span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Child may now not fit in vertical dimension.</span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里得到最终高度</span><br><span class="line">            // Add in our padding</span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            // TODO: Should we recompute the heightSpec based on the new total length?</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			 // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // We have no limit, so make all weighted views as tall as the largest child.</span><br><span class="line">            // Children will have already been measured once.</span><br><span class="line">			// 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次</span><br><span class="line">            if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                    if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    float childExtra = lp.weight;</span><br><span class="line">                    if (childExtra &gt; 0) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        // Check against our minimum width</span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">		// 设置测量完的宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        if (matchWidth) &#123;</span><br><span class="line">			// 使宽度一致</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在垂直绘制中主要执行逻辑在两大块代码，第一个for循环，第二个if判断中的for循环，接下来我们分块分析该函数源码：</p>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;      </span><br><span class="line">        // mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">        // maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">        // 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">         * 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">         * 否则，则跟maxWidth的计算方法一样</span><br><span class="line">         */</span><br><span class="line">        // 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">        // 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">        // 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">        // 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">        // 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        // 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        // 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // ...... 底下两个for循环</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在变量定义中，我们主要留意三个方面：</p>
<ul>
<li>mTotalLength：这个就是最终得到的整个LinearLayout的高度（子控件高度累加及自身padding）</li>
<li>三个跟width相关的变量</li>
<li>weight相关的变量</li>
</ul>
<h4 id="第一个for代码块和baselineChildIndex处理"><a href="#第一个for代码块和baselineChildIndex处理" class="headerlink" title="第一个for代码块和baselineChildIndex处理"></a>第一个for代码块和baselineChildIndex处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // ...上面的一大堆局部变量</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                // 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (child.getVisibility() == GONE) &#123;</span><br><span class="line">               // 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerWidth;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            // 得到每个子控件的LayoutParams后，累加权重和，后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            // 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0</span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">                // 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                // getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">        //... 底下第二个for循环</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">  在第一个for循环中，主要是if()&#123;&#125;else&#123;&#125;分支，判断是heightMode == MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">  lp.height == 0 &amp;&amp; lp.weight &gt; 0，这个主要是linearLayout测量模式为EXACTLY且子视图明确</span><br><span class="line"> 了是使用linearLayout的剩余空间，此时将其上下间距计入总高度并以之前的做对比去大值，并设置</span><br><span class="line"> skippedMeasure标志为true。而在else中则为复杂点，else中首先对lp.height == 0 &amp;&amp;</span><br><span class="line">  lp.weight &gt; 0的子视图的height做预处理使其为LayoutParams.WRAP_CONTENT（因为父类即</span><br><span class="line">  LinearLayout此时是wrap_content，或者mode为UNSPECIFIED），接着对子视图进行测量（</span><br><span class="line">  这个受总权重影响），并将其高度和上下间距计入到总高度中。之后对baselineChildIndex做处理，</span><br><span class="line">  计入总的基线高度并判定基线配置是否合理，不合理抛出异常，最后根据子视图设置最大宽度、</span><br><span class="line">  allFillParent、weightedMaxWidth或alternativeMaxWidth变量。</span><br><span class="line"></span><br><span class="line">#### 第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行前的处理 ####</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>// … 局部变量定义和第一个for循环<br>// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过<br>        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) {<br>            mTotalLength += mDividerHeight;<br>        }</p>
<pre><code>  if (useLargestChild &amp;&amp;
          (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
      mTotalLength = 0;

      // 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，
//重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸
      for (int i = 0; i &lt; count; ++i) {
          final View child = getVirtualChildAt(i);

          if (child == null) {
              mTotalLength += measureNullChild(i);
              continue;
          }

          if (child.getVisibility() == GONE) {
              i += getChildrenSkipCount(child, i);
              continue;
          }

          final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                  child.getLayoutParams();
          // Account for negative margins
          final int totalLength = mTotalLength;
          mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                  lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }
  }
  //... 第2个重要代码块
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里主要对useLargestChild属性处理，执行前提是设置了useLargestChild属性，且LinearLayout的垂直</span><br><span class="line">方向测量模式是AT_MOST或UNSPECIFIED，重新测量总高度，useLargestChild属性会使所有带weight属性的子视</span><br><span class="line">图具有最大子视图的最小尺寸</span><br><span class="line"></span><br><span class="line">第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行逻辑</span><br></pre></td></tr></table></figure>
<p>//当测量完子View的大小后，总高度会再加上padding的高度<br>        // Add in our padding<br>        mTotalLength += mPaddingTop + mPaddingBottom;</p>
<pre><code>int heightSize = mTotalLength;
//如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较
//然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值
// Check against our minimum height
heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

// Reconcile our calculated size with the heightMeasureSpe
// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）
int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;

//到了这里，会再对带weight属性的子View进行一次测绘
//首先计算剩余高度

//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的
// Either expand children with weight to take up available space or
// shrink them if they extend beyond our current bounds. If we skipped
// measurement on any children, we need to measure them now.
int delta = heightSize - mTotalLength;
if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) {
    //如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦
    float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;

    mTotalLength = 0;
    //这里的代码就和第一次测量很像了
    for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);

        if (child.getVisibility() == View.GONE) {
            continue;
        }

        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

        float childExtra = lp.weight;
        if (childExtra &gt; 0) {
            // 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure
            //子控件的weight占比*剩余高度
            // Child said it could absorb extra space -- give him his share
            int share = (int) (childExtra * delta / weightSum);
            // weightSum计余
            weightSum -= childExtra;
            //剩余高度减去分配出去的高度
            delta -= share;

            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                    mPaddingLeft + mPaddingRight +
                            lp.leftMargin + lp.rightMargin, lp.width);
            //如果是当前LinearLayout的模式是EXACTLY
            //那么这个子View是没有被测量过的，就需要测量一次
            //如果不是EXACTLY的，在第一次循环里就被测量一些了
            // TODO: Use a field like lp.isMeasured to figure out if this
            // child has been previously measured
            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                // child was measured once already above...
                // base new measurement on stored values
                //如果是非EXACTLY模式下的子View就再加上
                //weight分配占比*剩余高度
                // 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小
                int childHeight = child.getMeasuredHeight() + share;
                if (childHeight &lt; 0) {
                    childHeight = 0;
                }

                //重新测量一次，因为高度发生了变化
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
            } else {
                // child was skipped in the loop above.
                // Measure for this first time here  

                //如果是EXACTLY模式下的
                //这里只会把weight占比所拥有的高度分配给你的子View
                // 上面测量的时候被跳过，那么在这里进行测量    
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,
                                MeasureSpec.EXACTLY));
            }

            // Child may now not fit in vertical dimension.
            childState = combineMeasuredStates(childState, child.getMeasuredState()
                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
        }

        final int margin =  lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);

        boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;
                lp.width == LayoutParams.MATCH_PARENT;

        alternativeMaxWidth = Math.max(alternativeMaxWidth,
                matchWidthLocally ? margin : measuredWidth);

        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
    }
    // 这里得到最终高度
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
} else {
     // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略
    alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);


    // We have no limit, so make all weighted views as tall as the largest child.
    // Children will have already been measured once.
    // 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次
    if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) {
        for (int i = 0; i &lt; count; i++) {
            final View child = getVirtualChildAt(i);

            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            float childExtra = lp.weight;
            if (childExtra &gt; 0) {
                child.measure(
                        MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(largestChildHeight,
                                MeasureSpec.EXACTLY));
            }
        }
    }
}
</code></pre><p>```<br>在进入ifelse分支前，先计算视图的总高度，并与测量模式进行比较（resolveSizeAndState）得到最终高度，<br>在减去总高度，得到最终还剩多高（也就是可以分配给带权重的视图的高）；<br>ifelse首先判断（skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f），</p>
<ul>
<li><p>如果该条件为true，先将总高度置为0再进入for循环，此处根据子视图的权重，再次判定(lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)</p>
<ul>
<li>true：子视图再次测量 则计算子视图可以得到多少高（有可能为负，也就是子视图要吐出一定高度出来），然后子视图测量高度和分配的高度相加，小于0，则重置为0，最后在测量一次。</li>
<li><p>false：直接测量子视图，这个是之前被跳过没有测量的子视图；<br>最后再次测量视图的宽和总高度。</p>
</li>
<li><p>如果该条件为false：看useLargestChild参数，如果都无相关，那就走layout流程了，<br>我们可以看到这里直接判断是useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY，如果条件成立的话，遍历子视图，再次判断子视图是否含有权重，如果有则直接将子视图高度都是largestChildHeight。如果条件不成立，则啥也不做。</p>
</li>
</ul>
</li>
</ul>
<p>最后就是视图maxWidth计算，并setMeasuredDimension（这个是一定要的），自此垂直方向已经测量完毕。</p>
<p><strong>总结</strong><br>这里大篇幅讲解measureVertical()的流程，事实上对于LinearLayout来说，其最大的特性也正是两个<br>方向的排布以及weight的计算方式。回过头来看测量过程，我们可以看出设计者的测量计算思路，就是将有weight<br>和不含有weight的测量分开处理，再利用height跟0比较来更加的细分每一种情况。<br>最后我们在理下其测量不同情况和原理：</p>
<ul>
<li>父控件为match_parent（或者精确值），子控件拥有weight，并且高度给定为0，也即子控件明确表示使用剩余空间：<ul>
<li>子控件的高度比例将会跟我们分配的layout_weight一致，原因在于weight二次测量时走了else分支，传入的是计算出来的share值；</li>
</ul>
</li>
<li>父控件是match_parent（或者精确值），子控件拥有weight，但高度给定为match_parent（或者精确值），子控件使用自己的高度或者父控件的高度，但在父控件空间不足时，其大小可以调整：<ul>
<li>子控件高度比例将会跟我们分配的layout_weight相反，原因在于在此之前子控件测量过一次，同时子控件的测量高度为父控件的高度，在计算剩余空间的时候得出一个负值，加上自身的测量高度的时候反而更小；</li>
</ul>
</li>
<li>父控件是wrap_content，子控件拥有weight：<ul>
<li>子控件的高度将会强行置为其wrap_content给的值并以wrap_content模式进行测量</li>
</ul>
</li>
<li>父控件是wrap_content，子控件没有weight：<ul>
<li>子控件的高度跟其他的viewgroup一致</li>
</ul>
</li>
</ul>
<p>自此，LinearLayout在垂直方向的测量分析已经结束。</p>
<p>参考地址：<br>[1]. baselineAligned解析 <a href="http://www.bubuko.com/infodetail-612730.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-612730.html</a><br>[2]. measureWithLargestChild使用解析 <a href="https://blog.csdn.net/a87b01c14/article/details/49420449" target="_blank" rel="noopener">https://blog.csdn.net/a87b01c14/article/details/49420449</a><br>[3]. LinearLayout垂直测量分析 <a href="https://www.jianshu.com/p/aea27bac7c8e" target="_blank" rel="noopener">https://www.jianshu.com/p/aea27bac7c8e</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/" data-id="cjlc1dmtc000la4s65h5bijwo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinearLayout/">LinearLayout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SourceCode/">SourceCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-camera2预览拍照录制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/android-camera2预览拍照录制/" class="article-date">
  <time datetime="2018-07-22T02:06:52.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/android-camera2预览拍照录制/">android-camera2预览拍照录制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android 5.0(Lollipop)增加了Camera2 API，并将原有的Camera API标记为废弃。对于原有的Camera API来说，Camera2重新定义了相机的API，也重构了相机API的架构。在Camera2中其主要思想是基于会话模式和事件驱动与相机实现交互，对于预览、拍照、录制等操作都是在会话的基础下请求某种类型的会话操作。</p>
<p>比如一次拍照的操作：<br><img src="&quot;./images/take-picture.png&quot;" alt="拍照">    </p>
<p>下面一起看下camera2的操作：</p>
<ol>
<li>相机初始化<br>我们知道要使用相机，首先我们需要获得相关的权限，主要是在manifest中定义，其次在Android6.0还需要动态获取权限。</li>
</ol>
<ul>
<li>在manifest中定义需要的权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果要保存照片、录制视频，还需要两个权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>相机功能：相机特性，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>动态权限申请<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final String[] VIDEO_PERMISSIONS = &#123;</span><br><span class="line">           Manifest.permission.CAMERA,</span><br><span class="line">           Manifest.permission.RECORD_AUDIO,</span><br><span class="line">           Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">           Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">   &#125;;</span><br><span class="line">......</span><br><span class="line">   if (!hasPermissionsGranted(getApplicationContext(), VIDEO_PERMISSIONS)) &#123;</span><br><span class="line">               requestPermissions(VIDEO_PERMISSIONS, 1);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">hasPermissionsGranted(Context context, String[] permissions) &#123;</span><br><span class="line">       for (String permission : permissions) &#123;</span><br><span class="line">           if (ActivityCompat.checkSelfPermission(context, permission)</span><br><span class="line">                   != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上基础工作好了基本可以开始对相机操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//初始化相机设备</span><br><span class="line">private void initCamera() &#123;</span><br><span class="line">       //设备管理类</span><br><span class="line">       cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">       try &#123;</span><br><span class="line">         //获取相机设备特征类，通过该类可以获取相机的一些特性，如相机的方向</span><br><span class="line">           CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraManager.getCameraIdList()[0]);</span><br><span class="line">           mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">           Log.e(TAG, &quot;sensor_orientation is :&quot; + mSensorOrientation);</span><br><span class="line">           StreamConfigurationMap streamConfigurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);</span><br><span class="line">           //获取录制视屏时的宽高，这个通过MediaRecorder类获取系统支持的录制视频的宽高，主要是防止配置录制适配配置时失败</span><br><span class="line">           mVideoSize = chooseVideoSize(streamConfigurationMap.getOutputSizes(MediaRecorder.class));</span><br><span class="line">           //根据录制视频支持的宽高和SurfaceTexture支持的宽高，以及当前视图的宽高设置预览视图的宽高</span><br><span class="line">           mPreviewSize = chooseOptimalSize(streamConfigurationMap.getOutputSizes(SurfaceTexture.class), surfaceView.getWidth(), surfaceView.getHeight(), mVideoSize);</span><br><span class="line">           //imageReader初始化，用于获取拍照信息</span><br><span class="line">           imageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(), ImageFormat.JPEG, 2);</span><br><span class="line">           imageReader.setOnImageAvailableListener(new ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onImageAvailable(ImageReader reader) &#123;</span><br><span class="line">                   imageView.setVisibility(View.VISIBLE);</span><br><span class="line">                   // 拿到拍照照片数据</span><br><span class="line">                   Image image = reader.acquireNextImage();</span><br><span class="line">                   ByteBuffer buffer = image.getPlanes()[0].getBuffer();</span><br><span class="line">                   byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                   buffer.get(bytes);//由缓冲区存入字节数组</span><br><span class="line">                   final Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);</span><br><span class="line">                   if (bitmap != null) &#123;</span><br><span class="line">                       imageView.setImageBitmap(bitmap);</span><br><span class="line">                   &#125;</span><br><span class="line">                   updatePreView();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, mainHandler);</span><br><span class="line">           //打开摄像头，stateCallback为相机的状态监听回调</span><br><span class="line">           cameraManager.openCamera(cameraManager.getCameraIdList()[0], stateCallback, mainHandler);</span><br><span class="line">           mMediaRecorder = new MediaRecorder();</span><br><span class="line">           Log.d(TAG, &quot;open camera&quot;);</span><br><span class="line"></span><br><span class="line">       &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的</span><br><span class="line">     private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onOpened(@NonNull CameraDevice cameraDevice) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera open&quot;);</span><br><span class="line">             mCameraDevice = cameraDevice;</span><br><span class="line">             takePreview();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onDisconnected(@NonNull CameraDevice cameraDevice) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera onDisconnected&quot;);</span><br><span class="line"></span><br><span class="line">             if (null != mCameraDevice) &#123;</span><br><span class="line">                 mCameraDevice.close();</span><br><span class="line">                 mCameraDevice = null;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onError(@NonNull CameraDevice cameraDevice, int i) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera onError&quot;);</span><br><span class="line">             cameraDevice.close();</span><br><span class="line">             mCameraDevice = null;</span><br><span class="line">             Toast.makeText(ImageShowActivity.this, &quot;摄像头开启失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>开启相机预览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 开始预览,此处创建一个捕获视频信息的请求，以此来获取一个会话session，在获取会话时监听其配置状态，一旦成功，则此时通过会话构建一个重复预览的请求；</span><br><span class="line">   */</span><br><span class="line">  private void takePreview() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          closePreviewSession();</span><br><span class="line">          SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">          surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">          Log.e(TAG, &quot;preview SurfaceTexture buffer size is width:&quot; + mPreviewSize.getWidth() + &quot; height :&quot; + mPreviewSize.getHeight());</span><br><span class="line">          Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line">          List&lt;Surface&gt; surfaces = new ArrayList&lt;&gt;();</span><br><span class="line">          surfaces.add(previewSurface);</span><br><span class="line">          surfaces.add(imageReader.getSurface());</span><br><span class="line">          // 创建CameraCaptureSession，该对象负责管理处理预览请求和拍照请求</span><br><span class="line">          mCameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() //</span><br><span class="line">          &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void onConfigured(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                  Log.d(&quot;onConfigured&quot;, &quot;onConfigured&quot;);</span><br><span class="line">                  if (null == mCameraDevice) return;</span><br><span class="line">                  // 当摄像头已经准备好时，开始显示预览</span><br><span class="line">                  mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                  updatePreView();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              @Override</span><br><span class="line">              public void onConfigureFailed(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                  Log.d(&quot;onConfigureFailed&quot;, &quot;onConfigureFailed&quot;);</span><br><span class="line"></span><br><span class="line">                  Toast.makeText(ImageShowActivity.this, &quot;配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, childHandler);</span><br><span class="line">      &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">    * 更新预览视图，构建一个TEMPLATE_PREVIEW捕获请求，此时是对会话进行设置！！！setRepeatingRequest！！！</span><br><span class="line">    */  </span><br><span class="line">  private void updatePreView() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           // 创建预览需要的CaptureRequest.Builder</span><br><span class="line">           CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">           // 将SurfaceView的surface作为CaptureRequest.Builder的目标</span><br><span class="line">           SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">           Log.e(TAG, &quot;update preview SurfaceTexture buffer size is width:&quot; + mPreviewSize.getWidth() + &quot; height :&quot; + mPreviewSize.getHeight());</span><br><span class="line">           surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">           Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line"></span><br><span class="line">           mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">           mPreviewBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">           mCameraCaptureSession.setRepeatingRequest(mPreviewBuilder.build(), null, childHandler);</span><br><span class="line">       &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拍照</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 拍照，构建一个TEMPLATE_STILL_CAPTURE静态的相机信息捕获请求，需要注意的是需要获取ImageReader的surface并将其作为捕获去请求的目标输出。</span><br><span class="line">     */</span><br><span class="line">private void takePicture() &#123;</span><br><span class="line">      if (mCameraDevice == null)</span><br><span class="line">          return;</span><br><span class="line">      // 创建拍照需要的CaptureRequest.Builder</span><br><span class="line">      try &#123;</span><br><span class="line">          CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">          // 将surfaceHolder的surface作为CaptureRequest.Builder的目标</span><br><span class="line">          captureRequestBuilder.addTarget(imageReader.getSurface());</span><br><span class="line">          // 自动对焦</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">          // 自动曝光</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);</span><br><span class="line">          // 获取手机方向，手机竖屏和平板的方向是不同的，需要调整。</span><br><span class="line">          int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">          // 根据设备方向计算设置照片的方向</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line">          //拍照</span><br><span class="line">          CaptureRequest mCaptureRequest = captureRequestBuilder.build();</span><br><span class="line">          mCameraCaptureSession.capture(mCaptureRequest, null, childHandler);</span><br><span class="line">      &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * Retrieves the JPEG orientation from the specified screen rotation.</span><br><span class="line">    *</span><br><span class="line">    * @param rotation The screen rotation.</span><br><span class="line">    * @return The JPEG orientation (one of 0, 90, 270, and 360)</span><br><span class="line">    */</span><br><span class="line">   private int getOrientation(int rotation) &#123;</span><br><span class="line">       // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)</span><br><span class="line">       // We have to take that into account and rotate JPEG properly.</span><br><span class="line">       // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.</span><br><span class="line">       // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.</span><br><span class="line">       return (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>录制视频</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 视屏录制，比较上层api是直接通过Recorder类来实现录制，通过这个不需要自己对视屏数据进行处理，只需要指定具体编码格式即可，同时注意这里是重启一个会话。</span><br><span class="line">     */</span><br><span class="line">    private void startRecordingVideo() &#123;</span><br><span class="line">        //关闭预览会话</span><br><span class="line">        closePreviewSession();</span><br><span class="line">        //对Recoder类进行设置</span><br><span class="line">        setUpMediaRecorder();</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建录制的session会话中的请求</span><br><span class="line">            CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">            //向CaptureRequest添加surface</span><br><span class="line">            SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">            Log.e(TAG, &quot;video SurfaceTexture  buffer size is width:&quot; + mVideoSize.getWidth() + &quot; height :&quot; + mVideoSize.getHeight());</span><br><span class="line">            surfaceTexture.setDefaultBufferSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">            Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line">            mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">            //向CaptureRequest添加surface</span><br><span class="line">            mPreviewBuilder.addTarget(mMediaRecorder.getSurface());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            mCameraDevice.createCaptureSession(Arrays.asList(previewSurface, mMediaRecorder.getSurface()), new</span><br><span class="line">                    CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                            mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                            updatePreView();</span><br><span class="line">                            runOnUiThread(new Runnable() &#123;</span><br><span class="line">                                @Override</span><br><span class="line">                                public void run() &#123;</span><br><span class="line">                                    mMediaRecorder.start();</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                            Log.d(&quot;onConfigureFailed&quot;, &quot;onConfigureFailed&quot;);</span><br><span class="line"></span><br><span class="line">                            Toast.makeText(ImageShowActivity.this, &quot;RecordingVideo 配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, childHandler);</span><br><span class="line">        &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 对Recorder类进行设置，主要包括音频、视频源、视频输出格式、输出路径、编码频率、视频帧频率、视频宽高、视频编码格式、音频编码格式</span><br><span class="line">     */</span><br><span class="line">    private void setUpMediaRecorder() &#123;</span><br><span class="line">        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">        mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">        //!!!这里需要设置路径，要不获取surface时会为空。context.getExternalFilesDir(null);</span><br><span class="line">        mMediaRecorder.setOutputFile(Environment</span><br><span class="line">                .getExternalStorageDirectory() + &quot;/&quot; + System.currentTimeMillis() + &quot;.mp4&quot;);</span><br><span class="line">        mMediaRecorder.setVideoEncodingBitRate(10000000);</span><br><span class="line">        mMediaRecorder.setVideoFrameRate(30);</span><br><span class="line">        // 设置视频录制的分辨率。必须放在设置编码和格式的后面，否则报错!!!!!!需要小心设置，同时需要根据Recorder类来遴选出当前设备支持的分辨率，如果不恰当，则录制视频的时候会显示配置失败</span><br><span class="line">        Log.e(TAG, &quot;video size is width:&quot; + mVideoSize.getWidth() + &quot; height :&quot; + mVideoSize.getHeight());</span><br><span class="line">        mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line"></span><br><span class="line">        mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">        mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">        int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        //调整视频的方向</span><br><span class="line">        switch (mSensorOrientation) &#123;</span><br><span class="line">            case SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">                break;</span><br><span class="line">            case SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mMediaRecorder.prepare();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>手机支持的一些分辨率：<br>width:4608 height:3456<br>width:4608 height:2304<br>width:3456 height:3456<br>width:3840 height:2160<br>width:3280 height:2448<br>width:3264 height:2448<br>width:3264 height:1840<br>width:3264 height:1632<br>width:2448 height:2448<br>width:2592 height:1952<br>width:2048 height:1536<br>width:1920 height:1080<br>width:1440 height:1080<br>width:1536 height:864<br>width:1456 height:1456<br>width:1920 height:960<br>width:1440 height:720<br>width:1280 height:960<br>width:1280 height:720<br>width:960 height:720</p>
<p>参考地址：<br>[1].官网示例 <a href="https://github.com/googlesamples/android-Camera2Basic" target="_blank" rel="noopener">https://github.com/googlesamples/android-Camera2Basic</a><br>[2]. <a href="https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/22/android-camera2预览拍照录制/" data-id="cjlc1dmte000qa4s65phnrjar" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/camera2/">camera2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http之head解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/http之head解析/" class="article-date">
  <time datetime="2018-07-17T03:31:15.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/http之head解析/">http之head解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th style="text-align:left">Header</th>
<th style="text-align:left">Header 解释</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">表明服务器是否支持指定范围请求及那种类型的分段请求</td>
<td style="text-align:left">Accept-Ranges: bytes</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td style="text-align:left">Age：12</td>
</tr>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">对某网络资源的有效请求行为，不允许则返回405</td>
<td style="text-align:left">Allow：GET，HEAD</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">告诉所有的缓存机制是否可以缓存及那种类型</td>
<td style="text-align:left">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">web服务器支持的返回内容压缩编码类型</td>
<td style="text-align:left">Content-Encoding:gzip</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">响应体的语言</td>
<td style="text-align:left">Content-Language: en,zh</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">响应体的长度</td>
<td style="text-align:left">Content-Length:348</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">请求资源可替代的备用的另一个地址</td>
<td style="text-align:left">Content-Location: /index.htm</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">返回资源的MD5校验值</td>
<td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">在整个返回体中本部分的字节位置</td>
<td style="text-align:left">Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td style="text-align:left">Content-type</td>
<td style="text-align:left">返回内容的MIME类型</td>
<td style="text-align:left">Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">原始服务器消息发出的时间</td>
<td style="text-align:left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">请求变量的实体标签的当前值</td>
<td style="text-align:left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">响应过期的日期和时间</td>
<td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">请求资源的最后修改时间</td>
<td style="text-align:left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">用来重定向接收方到非请求URL的位置来完成请求和标识新的资源</td>
<td style="text-align:left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td style="text-align:left">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">它指出认证方案和可应用到代理的该URL上的参数</td>
<td style="text-align:left">Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td style="text-align:left">refresh</td>
<td style="text-align:left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td style="text-align:left">Refresh: 5; url=</td>
</tr>
</tbody>
</table>
<p><a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a> |<br>| Retry-After | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试  | Retry-After: 120 |<br>| Server | web服务器软件名称 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) |<br>| Set-Cookie | 设置Http Cookie | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 |<br>| Trailer | 指出头域在分块传输编码的尾部存在 | Trailer: Max-Forwards |<br>| Transfet-Encoding | 文件传输编码 | Transfer-Encoding:chunked |<br>| Vary | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: * |<br>| Via | 告诉代理客户端响应是通过哪里发送的 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) |<br>| Warning | 警告实体可能存在的问题 | Warning: 199 Miscellaneous warning |<br>| WWW-Authenticate | 表明客户端请求实体应该使用的授权方案  | WWW-Authenticate: Basic |</p>
<h3 id="HTTP-Request的Header信息"><a href="#HTTP-Request的Header信息" class="headerlink" title="HTTP Request的Header信息"></a>HTTP Request的Header信息</h3><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文。请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：<br>POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1<br>一个简单的请求头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1</span><br><span class="line">Host	adash.m.taobao.com</span><br><span class="line">Content-Type	multipart/form-data; boundary=--iphone_BOUNDARY--</span><br><span class="line">Connection	keep-alive</span><br><span class="line">Accept	*/*</span><br><span class="line">User-Agent	%E9%92%89%E9%92%89/400 CFNetwork/901.1 Darwin/17.6.0 (x86_64)</span><br><span class="line">Accept-Language	zh-cn</span><br><span class="line">Accept-Encoding	gzip</span><br><span class="line">Content-Length	702</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HTTP请求方式</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">向Web服务器请求一个文件</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">向Web服务器发送数据让Web服务器进行处理</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">向Web服务器发送数据并存储在Web服务器内部</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">检查一个对象是否存在</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">从Web服务器上删除一个文件</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">对通道提供支持</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">跟踪到服务器的路径</td>
</tr>
<tr>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">查询Web服务器的性能</td>
</tr>
</tbody>
</table>
<p>说明：<br>主要使用到“GET”和“POST”。</p>
<p>实例：<br>POST /test/tupian/cm HTTP/1.1<br>分成三部分：</p>
<ul>
<li><p>POST：HTTP请求方式</p>
</li>
<li><p>/test/tupian/cm：请求Web服务器的目录地址（或者指令）</p>
</li>
<li><p>HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本</p>
</li>
</ul>
<p><strong>备注：</strong>  在Ajax中，对应method属性设置。</p>
<ol>
<li>Host</li>
</ol>
<p>说明：<br>请求的web服务器域名地址</p>
<p>实例：<br>例如web请求URL：<a href="http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm" target="_blank" rel="noopener">http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm</a> ，Host就为zjm-forum-test10.zjm.baidu.com:8088</p>
<ol>
<li>User-Agent</li>
</ol>
<p>说明：<br>HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。</p>
<p>实例：<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11</p>
<ol>
<li>Accept</li>
</ol>
<p>说明：<br>指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。</p>
<p>实例：<br>Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,<em>/</em>;q=0.5</p>
<p>备注：<br>在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/javascript, text/html, application/xml, text/xml, <em>/</em>”。这是因为Ajax默认获取服务器返回的Json数据模式。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。</p>
<ol>
<li>Accept-Language</li>
</ol>
<p>说明：<br>指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。</p>
<p>实例：<br>Accept-Language: zh-cn,zh;q=0.5   ,这里默认为中文。</p>
<ol>
<li>Accept-Encoding</li>
</ol>
<p>说明：<br>指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。</p>
<p>实例：<br>Accept-Encoding: gzip,deflate</p>
<p><strong>备注：</strong>  其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。</p>
<p>另外有关deflate压缩介绍：<a href="http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html" target="_blank" rel="noopener">http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html</a></p>
<ol>
<li>Accept-Charset</li>
</ol>
<p>说明：<br>浏览器可以接受的字符编码集。</p>
<p>实例：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7</p>
<ol>
<li>Content-Type</li>
</ol>
<p>说明：  显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。</p>
<p>实例：  Content-type: application/x-www-form-urlencoded;charset:UTF-8</p>
<p>有关Content-Type属性值可以如下两种编码类型：  </p>
<ul>
<li>“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。</li>
<li>“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。  </li>
</ul>
<p>当提交为表单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。</p>
<p>在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。 一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。</p>
<ol>
<li>Connection</li>
</ol>
<p>说明： 表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。</p>
<p>实例： Connection: keep-alive</p>
<ol>
<li>Keep-Alive</li>
</ol>
<p>说明：显示此HTTP连接的Keep-Alive时间。使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<p>以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。</p>
<p>实例： Keep-Alive: 300</p>
<ol>
<li>cookie</li>
</ol>
<p>说明：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p>
<ol>
<li>Referer</li>
</ol>
<p>说明：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</p>
<h3 id="服务器端返回HTTP头部信息"><a href="#服务器端返回HTTP头部信息" class="headerlink" title="服务器端返回HTTP头部信息"></a>服务器端返回HTTP头部信息</h3><p>简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type	text/plain</span><br><span class="line">Content-Length	8</span><br><span class="line">Last-Modified	Mon, 15 May 2017 18:04:40 GMT</span><br><span class="line">ETag	&quot;ae780585f49b94ce1444eb7d28906123&quot;</span><br><span class="line">Accept-Ranges	bytes</span><br><span class="line">Server	AmazonS3</span><br><span class="line">X-Amz-Cf-Id	jodC9tJqDu4my9HVAend7hMtgKNcrlV4SUHJOKveUP-hHSIJ6ewkig==</span><br><span class="line">Cache-Control	no-cache, no-store, must-revalidate</span><br><span class="line">Date	Tue, 17 Jul 2018 02:28:52 GMT</span><br><span class="line">Proxy-Connection	Keep-alive</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Content-Length</li>
</ol>
<p>说明：表示web服务器返回消息正文的长度</p>
<ol>
<li>Content-Type:</li>
</ol>
<p>说明：返回数据的类型（例如text/html文本类型）和字符编码格式。</p>
<p>实例： Content-Type: text/html;charset=utf-8</p>
<ol>
<li>Date<br>说明：显示当前的时间</li>
</ol>
<p>本文根据RFC2616(HTTP/1.1规范),参考</p>
<p><a href="http://www.w3.org/Protocols/rfc2068/rfc2068" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2068/rfc2068</a></p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616</a></p>
<p><a href="http://www.ietf.org/rfc/rfc3229.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3229.txt</a></p>
<p><a href="https://blog.csdn.net/u012359618/article/details/50240617" target="_blank" rel="noopener">https://blog.csdn.net/u012359618/article/details/50240617</a>  </p>
<p><a href="https://www.cnblogs.com/wenqiang/p/5698772.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenqiang/p/5698772.html</a></p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可 选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域 值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/17/http之head解析/" data-id="cjlc1dmtk0012a4s6kqho8m12" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/head/">head</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-okhttp使用记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/okhttp使用记录/" class="article-date">
  <time datetime="2018-07-17T01:27:19.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/okhttp使用记录/">okhttp使用记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>Applicaion Interceptor和NetworkInterceptor区别<br>Application interceptors：</li>
</ol>
<ul>
<li>Don’t need to worry about intermediate responses like redirects and retries.（不必担心重定向和重试等中间响应，因为它处于第一个拦截器，会获取到最终的响应 response 。）</li>
<li>Are always invoked once, even if the HTTP response is served from the cache.（即使从缓存提供HTTP响应，也始终调用一次）</li>
<li>Observe the application’s original intent. Unconcerned with OkHttp-injected headers like If-None-Match.（观察应用程序的原始意图。 不去关注OkHttp注入的头信息，如If-None-Match。）</li>
<li>Permitted to short-circuit and not call Chain.proceed().（允许短路而不调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有权决定了是否要调用其他拦截，也就是 Chain.proceed() 方法是否要被执行。）</li>
<li>Permitted to retry and make multiple calls to Chain.proceed().（允许重试并多次调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有可以多次调用 Chain.proceed() 方法，其实也就是相当与重新请求的作用了。）</li>
</ul>
<p>Network Interceptors  </p>
<ul>
<li>Able to operate on intermediate responses like redirects and retries.（能够对重定向和重试等中间响应进行操作，因为 NetworkInterceptor 是排在第 6 个拦截器中，因此可以操作经过 RetryAndFollowup 进行失败重试或者重定向之后得到的resposne）</li>
<li>Not invoked for cached responses that short-circuit the network.（未调用使网络短路的缓存响应，对于从缓存获取的 response 则不会去触发 NetworkInterceptor 。因为响应直接从 CacheInterceptor 返回了）</li>
<li>Observe the data just as it will be transmitted over the network.（观察数据，就像它将通过网络传输一样）</li>
<li>Access to the Connection that carries the request.（访问带有请求的Connection）</li>
</ul>
<p>参考地址：<br>[1]. 官网 <a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki/Interceptors</a><br>[2]. 简书 <a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d04b463806c8</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/17/okhttp使用记录/" data-id="cjlc1dmtr001ga4s634teyeap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interceptors/">Interceptors</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/">okhttp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android开发记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/Android开发记录/" class="article-date">
  <time datetime="2018-07-13T05:45:40.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/Android开发记录/">Android开发记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="Android-studio中如何修改运行环境中最低版本和目标版本"><a href="#Android-studio中如何修改运行环境中最低版本和目标版本" class="headerlink" title="Android studio中如何修改运行环境中最低版本和目标版本"></a>Android studio中如何修改运行环境中最低版本和目标版本</h4><p>最近发现使用Android Studio创建的项目中，最低版本和目标版本已经不在AndroidManifest.xml中显示了。那我们应该去那里需改呢？</p>
<p>原来放到了File -&gt; Project Structure中了。直接上图吧，一目了然。<br><a href="&quot;images/AndroidDownBuildVersion.jpg&quot;">修改最低版本和目标版本</a></p>
<p>参考地址：   </p>
<ul>
<li><a href="https://blog.csdn.net/kingroc/article/details/50947143" target="_blank" rel="noopener">https://blog.csdn.net/kingroc/article/details/50947143</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/13/Android开发记录/" data-id="cjlc1dmt10002a4s6xmxn1b9u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-Studio/">Android Studio</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Flutter编写第一个应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/Flutter编写第一个应用/" class="article-date">
  <time datetime="2018-07-12T11:07:44.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/Flutter编写第一个应用/">编写第一个Flutter应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="&quot;images/startup-namer-app.gif&quot;">Animated GIF of the app that you will be building.</a><br>这篇教程将指导你创建第一个 Flutter 应用程序。如果你熟悉面向对象程序设计和基本的编程概念（如变量，循环和条件），即可完成本教程。无需具有使用 Dart 语言或移动编程的相关经验。</p>
<ul>
<li>第1步：创建初始Flutter应用</li>
<li>第2步：使用外部 package</li>
<li>第3步：添加有状态的widget</li>
<li>第4步：创建一个无限滚动的 ListView</li>
<li>第5步：添加可交互性</li>
<li>第6步：导航到新页面</li>
<li>第7步：使用主题更改UI</li>
<li>干得漂亮！<h3 id="你需要做什么"><a href="#你需要做什么" class="headerlink" title="你需要做什么"></a>你需要做什么</h3></li>
</ul>
<p>完成一个简单的移动应用程序，为一家创业公司进行命名推荐。用户可以选择和取消选择名称，并保存最好的一个。代码一次生成十个名称。当用户滚动时，会新生成一批名称。用户可以点击应用栏右上方的列表图标，跳转到仅显示已被收藏的名称的列表页面。</p>
<p>这个GIF动画可以显示出该应用是如何工作的。</p>
<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会学到</strong>:<br>- Flutter 应用程序的基本结构 。<br>- 查找和使用 package 来扩展功能。<br>- 使用热加载加快开发效率。<br>- 如何实现一个有状态的 widget 。<br>- 如何创建一个无限长度的延迟加载列表。<br>- 如何创建并导航到第二个页面。<br>- 如何使用主题更改应用程序的外观。<br></td></tr></table>

<table><tr><td bgcolor="#f0f0f0"><br><strong>你将会用到</strong>:<br><br>需要安装以下工具:<br><br>- Flutter SDK<br>Flutter SDK 包括 Flutter 的引擎，框架，控件，工具和 Dart SDK 。这个 codelab 需要 v0.1.4 或更高版本。<br><br>-  Android Studio IDE<br>这个 codelab 基于 Android Studio IDE 构建，但也可以使用其他 IDE ，或者从命令行运行。<br><br>- 安装 IDE 插件<br>插件必须为您的编译器单独安装 Flutter 和 Dart 插件。除了Android Studio，Flutter和Dart插件也可用于 <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">VS Code</a> 和 <a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">IntelliJ IDE</a>。<br><br>有关如何设置环境的信息，<a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">请参阅 Flutter安装和配置</a>。<br></td></tr></table>

<h3 id="第1步：创建初始Flutter应用"><a href="#第1步：创建初始Flutter应用" class="headerlink" title="第1步：创建初始Flutter应用"></a>第1步：创建初始Flutter应用</h3><p>使用<a href="http://doc.flutter-dev.cn/get-started/test-drive/#create-app" target="_blank" rel="noopener">第一个入门 Flutter 应用</a>中的说明创建一个简单的模板化 Flutter 应用。将项目命名为 <strong>startup_namer</strong>（而不是myapp）。你将修改这个应用并最终完成它。</p>
<p>在这个 codelab 中，将主要编辑 Dart 代码所在的 lib / main.dart。</p>
<table><tr><td bgcolor="#f0f0f0"><br> 小贴士： 将代码粘贴到应用程序中时，缩进可能会错位。你可以使用 Flutter 工具自动修复此问题：<br><br>1. Android Studio / IntelliJ IDEA: 右键单击 dart 代码，然后选择 <strong>Reformat Code with dartfmt</strong>。<br>2. VS Code: 单击右键，选择 <strong>Format Document</strong>.<br>3. 命令行: 运行 flutter format <filename>.<br></filename></td></tr></table>

<ol>
<li><p>替换 lib / main.dart 。<br>删除 lib / main.dart 中的所有代码。替换为下面的代码，它在屏幕中心显示 “Hello World” 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Text(&apos;Hello World&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行应用程序。现在应该可以看到下面的页面。<br><a href="hello-world-screenshot.png">screenshot of hello world app</a></p>
<p>小结</p>
<ul>
<li><p>本示例创建了一个 Material app 。 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material</a> 设计语言是一套移动设备和网页上的视觉设计标准。Flutter 提供了一套丰富的 Material Widgets 。</p>
</li>
<li><p>main 方法采用了 fat arrow (=&gt;) 表示法，这是一种用于单行函数或方法的简写。</p>
</li>
<li><p>该 app 继承了使它本身成为一个 widget 的 StatelessWidget 类。在 Flutter 中，大多数时候一切都可以看作 widget , 包括 alignment，padding 和 layout 。</p>
</li>
<li><p>Material 库中的 Scaffold widget 提供了默认的应用栏 (app bar)，标题和构成主页面 widget 树结构的 body 属性。 widget 的子树可以非常复杂。</p>
</li>
<li><p>widget 的主要工作是提供一个build()方法，描述如何根据其他更低层级的 widget，来对这个 widget 进行展示。</p>
</li>
<li><p>本示例的 widget 树由包含了 Text child widget 的 Center widget 组成。Center widget 可将它的所有子树对齐到屏幕中心。</p>
</li>
</ul>
<h3 id="第2步：使用外部-package"><a href="#第2步：使用外部-package" class="headerlink" title="第2步：使用外部 package"></a>第2步：使用外部 package</h3><p>在这一步，将开始使用名为 <strong>english_words</strong> 的开源软件包 ，其中包含数千个最常用的英文单词以及一些实用功能。</p>
<p>可以在 <a href="https://pub.dartlang.org/flutter/" target="_blank" rel="noopener">pub.dartlang.org</a> 上找到 <a href="https://pub.dartlang.org/packages/english_words" target="_blank" rel="noopener">english_words</a> 软件包以及其他许多开源软件包。</p>
<ol>
<li><p>pubspec 文件管理着 Flutter 应用程序的静态资源文件(assets)。 在 <strong>pubspec.yaml</strong> 文件中， 将 <strong>english_words</strong>（3.1.0或更高版本）添加到依赖列表。新的一行高亮如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  cupertino_icons: ^0.1.0</span><br><span class="line">  english_words: ^3.1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Android Studio 的 editor 视图中查看 pubspec 时, 点击右上角的 <strong>Packages get</strong> ，将把 package 拉取到项目中。现在应该可以在控制台中看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br><span class="line">Running &quot;flutter packages get&quot; in startup_namer...</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <strong>lib/main.dart</strong> 中，为 english_words 添加导入，如高亮的行所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br></pre></td></tr></table></figure>
<p>在键入该行时， Android Studio 会提供有关库导入的建议。然后将导入字符串显示为灰色，让你知道导入的库尚未使用（到目前为止）。</p>
</li>
<li><p>改用英文单词的 package 来生成文本，而不是字符串 “Hello World” 。</p>
<table><tr><td bgcolor="#f0f0f0"><br>小贴士： “Pascal case”（也被称为“大骆驼拼写法”），意味着字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，“uppercamelcase” 变成 “UpperCamelCase” 。<br></td></tr></table>

</li>
</ol>
<p>对代码进行以下更改，如!!!所示：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final wordPair = new WordPair.random();   //!!!!</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          //child: new Text(&apos;Hello World&apos;), // Replace the highlighted text...</span><br><span class="line">          child: new Text(wordPair.asPascalCase),  // With this highlighted text. !!!</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果应用正在运行，请使用 Flutter Hot Reload (热重载)按钮 (lightning bolt icon)更新应用程序。每次单击按钮或保存项目时，都会看到随机的词组文本，这是因为配对的词组是在 build 方法内部生成的，每次应用需要渲染时，或在 Flutter Inspector 中切换 Platform 时都会运行  </li>
</ol>
<p><a href="&quot;images/step2-screenshot.png&quot;">screenshot at completion of second step</a>  </p>
<h4 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h4><p>如果应用程序运行不正常，请检查拼写错误。如有需要，可使用以下链接中的代码使项目恢复正常</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/pubspec.yaml" target="_blank" rel="noopener">pubspec.yaml</a> (pubspec.yaml文件不会再更改。)</li>
<li><a href="https://gist.githubusercontent.com/Sfshaza/bb51e3b7df4ebbf3dfd02a4a38db2655/raw/57c25b976ec34d56591cb898a3df0b320e903b99/main.dart" target="_blank" rel="noopener">lib/main.dart</a>   </li>
</ul>
<h3 id="第3步：添加有状态的widget"><a href="#第3步：添加有状态的widget" class="headerlink" title="第3步：添加有状态的widget"></a>第3步：添加有状态的widget</h3><p>Stateless widgets 是不可改变的，这意味着它们的属性不能改变——所有的值都是 final 的。</p>
<p>Statefulwidget 在其 <strong>生命周期</strong> 保持的状态可能会变化，<strong>实现一个有状态的 widget 至少需要两个类</strong>：StatefulWidgets类和State类，其中StatefulWidgets类创建了一个State类的实例。StatefulWidget类本身是不可变的，但State类可存在于Widget的整个生命周期中。</p>
<p>在这一步，将添加一个有状态的 RandomWords widget ，它可以创建其 State 类 RandomWordsState 。 State 类会为 widget 保存被推荐和被收藏的词组。  </p>
<ol>
<li><p>将有状态的 RandomWords widget 添加到 main.dart 。它可以在 MyApp 类之外的任何位置使用，但当前将把它放在文件底部。 RandomWords widget 除了创建 State 类之外几乎没有任何其他代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class RandomWords extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  createState() =&gt; new RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 RandomWordsState 类。这个类保存了 RandomWords widget 的状态，该应用程序的大部分代码都放在该类中。这个类将保存随着用户的滑动操作而生成的无限增长的词组，以及保存用户收藏的词组，用户通过触发心形图标来添加或删除收藏的词组列表。  </p>
</li>
</ol>
<p>你可以一点点建立这个类。首先，通过以下!!!代码，创建一个最简的类：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  class RandomWordsState extends State&lt;RandomWords&gt; &#123; //!!!</span><br><span class="line">  &#125;</span><br><span class="line">  ```   </span><br><span class="line"></span><br><span class="line">3. 添加这个 state 类之后，IDE 会提示该类缺少 build 方法。接下来，需要添加一个基本的 build 方法，并将生成单词的代码行从 MyApp 类移动到 RandomWordsState 类的 build 方法中，生成词组。  </span><br><span class="line">将 build 方法添加到 RandomWordState 中，如!!!代码所示：</span><br></pre></td></tr></table></figure>
<p>  class RandomWordsState extends State<randomwords> {<br>    @override     //-!!!<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();<br>      return new Text(wordPair.asPascalCase);<br>    }  //-!!!<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 根据!!!部分的更改，从 MyApp 中删除生成单词的代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      final wordPair = new WordPair.random();  // !!! Delete this line</p>
<pre><code>  return new MaterialApp(
    title: &apos;Welcome to Flutter&apos;,
    home: new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Welcome to Flutter&apos;),
     ),
      body: new Center(
        //child: new Text(wordPair.asPascalCase), // !!!Change the highlighted text to...
        child: new RandomWords(), // !!!... this highlighted text
      ),
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启应用。如果尝试热重载，则可能会看到警告:</span><br></pre></td></tr></table></figure></p>
<p>  Reloading…<br>  Not all changed program elements ran during view reassembly; consider<br>  restarting.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这可能是一个误报，但可以考虑重启应用，以确保更改能正常反映在应用的 UI 界面中。</span><br><span class="line"></span><br><span class="line">应用程序应该像之前一样运行，每次热重载或保存应用程序时都会显示一个词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of third step](step3-screenshot.png)   </span><br><span class="line">#### 有问题吗? ####</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](lib/main.dart)</span><br><span class="line"></span><br><span class="line">### 第4步：创建一个无限滚动的 ListView ###</span><br><span class="line">在这一步，可以扩展 RandomWordsState 类，生成并展示词组列表。当用户滑动列表，ListView widget 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许按需建立一个延迟加载的列表 view 。</span><br><span class="line"></span><br><span class="line">1. \_suggestions 变量向 RandomWordsState 类中添加一个数组列表，用来保存推荐词组。 该变量以下划线(\_)开头，在 Dart 语言中使用下划线前缀表示强制私有。   </span><br><span class="line">此外，添加一个 biggerFont 变量来增大字体。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_buildSuggestions() 函数，用于构建一个显示词组的 ListView 。   </span><br><span class="line">ListView 类提供了一个 itemBuilder 属性，这是一个工厂 builder 并作为匿名函数进行回调。它有两个传入参数— BuildContext 上下文和行迭代器 i 。对于每个推荐词组都会执行一次函数调用，迭代器从 0 开始，每调用一次函数就累加 1 。这个模块允许推荐列表在用户滑动时无限增长。  </span><br><span class="line">添加如下代码行：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …<br>    Widget _buildSuggestions() {<br>      return new ListView.builder(<br>        padding: const EdgeInsets.all(16.0),<br>        // The itemBuilder callback is called once per suggested word pairing,<br>        // and places each suggestion into a ListTile row.<br>        // For even rows, the function adds a ListTile row for the word pairing.<br>        // For odd rows, the function adds a Divider widget to visually<br>        // separate the entries. Note that the divider may be difficult<br>        // to see on smaller devices.<br>        itemBuilder: (context, i) {<br>          // Add a one-pixel-high divider widget before each row in theListView.<br>          if (i.isOdd) return new Divider();</randomwords></p>
<pre><code>      // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.
      // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
      // This calculates the actual number of word pairings in the ListView,
      // minus the divider widgets.
      final index = i ~/ 2;
      // If you&apos;ve reached the end of the available word pairings...
      if (index &gt;= _suggestions.length) {
        // ...then generate 10 more and add them to the suggestions list.
        _suggestions.addAll(generateWordPairs().take(10));
      }
      return _buildRow(_suggestions[index]);
    }
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.  函数都调用一次 \_buildRow 函数。这个函数每次会在一个 ListTile widget 中展示一条新词组，这将在下一步操作中，使一行数据更有表现力。    </span><br><span class="line">  添加 \_buildRow 函数到 RandomWordsState 类中：</span><br></pre></td></tr></table></figure></p>
<p>  class RandomWordsState extends State<randomwords> {<br>    …</randomwords></p>
<pre><code>Widget _buildRow(WordPair pair) {
  return new ListTile(
    title: new Text(
      pair.asPascalCase,
      style: _biggerFont,
    ),
  );
}
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 更新 RandomWordsState 类的 build 方法来使用 \_buildSuggestions() 函数，而不是直接调用单词生成库。对部分进行修改：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    final wordPair = new WordPair.random(); // Delete these two lines.<br>    Return new Text(wordPair.asPascalCase);<br>    return new Scaffold (<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>      ),<br>    body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 更新 MyApp 类的 build 方法。从 MyApp 中删除 Scaffold 和 AppBar 实例。这些将由 RandomWordsState 类进行统一管理，这样在下一步操作中，可以使用户从一个页面导航到另一页面时，更方便的更改应用栏中的页面名称。</span><br><span class="line"></span><br><span class="line">  用下面高亮的 build 方法替换原始代码：</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  class MyApp extends StatelessWidget {<br>    @override<br>    Widget build(BuildContext context) {<br>      return new MaterialApp(<br>        title: ‘Startup Name Generator’,<br>        home: new RandomWords(),<br>      );<br>    }<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重启应用程序，将可以看到一个词组清单。尽量向下滑动，将继续看到新的词组。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of fourth step](step4-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/d6f9460a04d3a429eb6ac0b0f07da564/raw/34fe240f4122435c871bb737708ee0357741801c/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第5步：添加可交互性 ###</span><br><span class="line">在这一步，将为每一行添加可点击的心形图标。当用户点击列表中的条目，切换其“收藏”状态，词组就会添加到收藏栏，或从已保存词组的收藏栏中删除。</span><br><span class="line"></span><br><span class="line">1. 添加一个 Set 集合 \_saved 到 RandomWordsState 类。保存用户收藏的词组。Set 集合比 List 更适用于此，因为它不允许重复元素。</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  final _suggestions = <wordpair>[];</wordpair></randomwords></p>
<p>  final _saved = new Set<wordpair>();</wordpair></p>
<p>  final _biggerFont = const TextStyle(fontSize: 18.0);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 在 \_buildRow 函数中，添加 alreadySaved 标志检查来确保一个词组还没有被添加到收藏。</span><br></pre></td></tr></table></figure></p>
<p>Widget _buildRow(WordPair pair) {<br>  final alreadySaved = _saved.contains(pair);<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3. 在 \_buildRow() 的 ListTiles widget 中，添加一个心形图标来使用收藏功能，随后将添加与心形图标进行交互的功能。  </span><br><span class="line"></span><br><span class="line">  添加以下高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4. 重启应用。现在应该可以在每一行看到心形图标，但还没有交互功能。</span><br><span class="line"></span><br><span class="line">5. 在 \_buildRow 函数中使心形可点击。如果词条已经被加入收藏，再次点击它将从收藏中删除。当心形图标被点击，函数将调用 setState() 通知应用框架state已经改变。</span><br><span class="line"></span><br><span class="line">  添加高亮代码行：</span><br></pre></td></tr></table></figure></p>
<p>  Widget _buildRow(WordPair pair) {<br>    final alreadySaved = _saved.contains(pair);<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _biggerFont,<br>      ),<br>      trailing: new Icon(<br>        alreadySaved ? Icons.favorite : Icons.favorite_border,<br>        color: alreadySaved ? Colors.red : null,<br>      ),<br>      onTap: () {<br>        setState(() {<br>          if (alreadySaved) {<br>            _saved.remove(pair);<br>          } else {<br>            _saved.add(pair);<br>          }<br>        });<br>      },<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f0f0f0&gt;</span><br><span class="line">  小贴士： 在 Flutter 的响应式风格框架中，调用 setState() ，将为 State 对象触发 build() 方法的调用，从而实现对UI的更新。</span><br><span class="line">  &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">热重载应用。可以点击任意一行来收藏或取消收藏条目。 请注意，点击一行可以产生从心形图标展开的泼墨动画效果。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 5th step](step5-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.githubusercontent.com/Sfshaza/936ce0059029a8c6e88aaa826a3789cd/raw/a3065d5c681a81eff32f75a9cd5f4d9a5b24f9ff/main.dart)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第6步：导航到新页面 ###</span><br><span class="line">在这一步，将添加一个显示收藏夹的新页面(在 Flutter 中称为 route(路由))。你将学习如何在主路由和新路由之间导航。</span><br><span class="line"></span><br><span class="line">在 Flutter 中， Navigator 管理着包含了应用程序所有路由的一个堆栈。将一个路由push到 Navigator 的堆栈，将显示更新为新页面路由。将一个路由 pull 出 Navigator 的堆栈，显示将返回到前一个页面路由。</span><br><span class="line"></span><br><span class="line">1. 在 RandomWordsState 类的 build 方法中，向 AppBar 添加一个列表图标。当用户点击列表图标时，包含了已收藏条目的新路由将被 push 到 Navigator 堆栈并显示新页面。</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#f1f1f1&gt;</span><br><span class="line"> 小贴士： 某些 widget 属性使用独立 widget(child) 和其他属性例如 action 组成一个子 widget 数组(children)，用方括号([])表示。</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">将该图标及其相应的 action 操作添加到 build 方法中：</span><br></pre></td></tr></table></figure></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  @override<br>  Widget build(BuildContext context) {<br>    return new Scaffold(<br>      appBar: new AppBar(<br>        title: new Text(‘Startup Name Generator’),<br>        actions: <widget>[<br>          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),<br>        ],<br>      ),<br>      body: _buildSuggestions(),<br>    );<br>  }<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 向 RandomWordsState 类添加一个 \_pushSaved() 函数。</span><br></pre></td></tr></table></figure></widget></randomwords></p>
<p>class RandomWordsState extends State<randomwords> {<br>  …<br>  void _pushSaved() {<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重新加载应用程序。列表图标将出现在应用栏中。点击它不会有任何响应，因为 \_pushSaved 这个函数还未实现功能。</span><br><span class="line"></span><br><span class="line">3. 当用户点击应用栏中的列表图标时，将建立一个新路由并 push 到 Navigator 的路由堆栈中，这个操作将改变界面显示，展示新的路由页面。   </span><br><span class="line"></span><br><span class="line">  新页面的内容使用匿名函数在 MaterialPageRoute widget的builder属性中创建。</span><br><span class="line"></span><br><span class="line">  将函数调用添加到 Navigator.push 中作为参数,如高亮代码所示，将路由 push 到 Navigator 的堆栈中。</span><br></pre></td></tr></table></figure></randomwords></p>
<p>  void _pushSaved() {<br>    Navigator.of(context).push(<br>    );<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 添加 MaterialPageRoute widget 及其 builder 属性。先添加生成 ListTile widget 的代码。其中 ListTile 的 divideTiles() 方法为每个 ListTile widget 之间添加水平间距。divided变量保存最终生成的所有行，并用 toList() 函数转换为列表。</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();<br>      },<br>    ),<br>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. builder 属性返回一个 Scaffold widget ，其中包含了应用栏标题名为 “Saved Suggestions” 的新路由页面。新页面的body属性由包含多个 ListTile widget 的 ListView 组成。</span><br><span class="line"></span><br><span class="line">  添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>void _pushSaved() {<br>  Navigator.of(context).push(<br>    new MaterialPageRoute(<br>      builder: (context) {<br>        final tiles = _saved.map(<br>              (pair) {<br>            return new ListTile(<br>              title: new Text(<br>                pair.asPascalCase,<br>                style: _biggerFont,<br>              ),<br>            );<br>          },<br>        );<br>        final divided = ListTile<br>            .divideTiles(<br>          context: context,<br>          tiles: tiles,<br>        )<br>            .toList();</p>
<pre><code>    return new Scaffold(
      appBar: new AppBar(
        title: new Text(&apos;Saved Suggestions&apos;),
      ),
      body: new ListView(children: divided),
    );
  },
),
</code></pre><p>  );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6. 热重载应用程序。对一些条目点击收藏，然后点击应用栏右侧的列表图标。显示出包含收藏夹列表的新页面。注意，Navigator 会在应用栏左侧添加一个“返回”按钮。不必再显式实现 Navigator.pop 。点击返回按钮会返回到主页面。</span><br><span class="line"></span><br><span class="line">[screenshot at completion of 6th stepsecond route](step6a-screenshot.png)  </span><br><span class="line">有问题吗?</span><br><span class="line"></span><br><span class="line">如果应用运行不正常，则可以使用以下链接中的代码使其恢复正常。</span><br><span class="line"></span><br><span class="line">- [lib/main.dart](https://gist.github.com/Sfshaza/bc5547e112e4dc3a1aa87afdf917caeb)</span><br><span class="line"></span><br><span class="line">### 第7步：使用主题更改UI ##</span><br><span class="line">在最后一步中，将使用该应用的主题。 theme 控制的是应用程序的观感。可以使用默认主题，该主题取决于使用的模拟器或真机，也可以自定义主题以反映你的品牌。</span><br><span class="line"></span><br><span class="line">可以通过配置 ThemeData 类轻松更改应用程序的主题。应用程序目前使用默认主题，现在将更改主要颜色为白色。</span><br><span class="line"></span><br><span class="line">1. 将高亮代码添加到 MyApp 类中，可以把应用程序的主题更改为白色：</span><br></pre></td></tr></table></figure></p>
<p>class MyApp extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return new MaterialApp(<br>      title: ‘Startup Name Generator’,<br>      theme: new ThemeData(<br>        primaryColor: Colors.white,<br>      ),<br>      home: new RandomWords(),<br>    );<br>  }<br>}<br>```</p>
<ol>
<li><p>热重载应用程序。请注意，整个背景都是白色的，甚至包括应用栏。</p>
</li>
<li><p>作为读者的练习，可使用 <a href="https://docs.flutter.io/flutter/material/ThemeData-class.html" target="_blank" rel="noopener">ThemeData</a> 来改变用户界面的其他方面。 Material 库中的 <a href="https://docs.flutter.io/flutter/material/Colors-class.html" target="_blank" rel="noopener">Colors</a> 类提供了多种可以使用的颜色常量，而热重载使用户界面的修改变得简单快捷。<br><a href="step7-themes.png">screenshot at completion of 7th step</a><br>有问题吗?</p>
</li>
</ol>
<p>如果又不能正常运行了，请使用以下链接中的代码查看最终应用的代码。</p>
<ul>
<li><a href="https://gist.githubusercontent.com/Sfshaza/c07c91a4061fce4b5eacaaf4d82e4993/raw/4001a72c0133b97c8e16bdeb3195ca03525696bd/main.dart" target="_blank" rel="noopener">lib/main.dart</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/12/Flutter编写第一个应用/" data-id="cjlc1dmt9000da4s64wihkbsu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/First-App/">First App</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flutter初体验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/flutter初体验/" class="article-date">
  <time datetime="2018-07-12T08:44:17.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/flutter初体验/">flutter初体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这篇文档中你将了解如何在 Flutter 开发中进行调试和修改：从我们提供的项目模板创建一个 Flutter 应用程序，运行然后学习如何使用热重载来修改程序。</p>
<p>Flutter 是一个扩展性极强的工具集，因此你可以选择你钟爱的开发工具或者平台来写代码，编译以及运行 Flutter 应用程序。</p>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p>Android Studio: 一个完整的，高度集成的 Flutter 开发编辑器。</p>
<h4 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>依次选择 <strong>File&gt;New Flutter Project</strong></li>
<li>选择 <strong>Flutter application</strong> 作为项目类型，然后点击下一步</li>
<li>输入项目名称（例如：myapp），然后点击下一步</li>
<li>点击 Finish</li>
<li>等待 Android Studio 安装好 SDK 和创建好这个项目。<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <strong><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a></strong> 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序"><a href="#运行这个程序" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>找到 Android Studio 的主工具栏：<br><a href="&quot;images/main-toolbar.png&quot;">IntelliJ 的主工具栏</a></li>
<li>在 <strong>target selector</strong> 中，选择一个已连接的 Android 设备来运行这个程序。如果列表中没有可用的设备， 那么依次选择 <strong>Tools&gt;Android&gt;AVD Manager</strong> 创建一个可用的模拟器。了解更多，请查看 管理 AVDs。</li>
<li>点击工具栏中的 <strong>Run icon</strong>，或者在菜单栏中一次选择 <strong>Run &gt; Run</strong>。</li>
<li>如果一切正常，那么你现在就可以在你的手机或者模拟器上看到程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载"><a href="#尝试一下热重载" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p><strong>VS Code</strong>: 包含了运行和调试 Flutter 应用程序的轻量级编辑器。</p>
<h4 id="创建应用程序-1"><a href="#创建应用程序-1" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><ol>
<li>启动 VS Code</li>
<li>依次执行 View&gt;Command Palette…</li>
<li>输入 ‘flutter’，选择 ‘Flutter: New Project’ 命令</li>
<li>输入项目名称（例如：myapp），回车</li>
<li>找到一个用于保存项目的目录，然后点击蓝色的确认按钮</li>
<li>项目会自动进行创建，创建完毕之后，main.dart 文件会被自动打开<br>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 Material 组件 的项目。</li>
</ol>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 <strong>lib/main.dart</strong> 中。</p>
<h4 id="运行这个程序-1"><a href="#运行这个程序-1" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ol>
<li>确保在 VS Code 的右下角能看到目标设备的名称</li>
<li>使用键盘上的 F5 按钮，或者依次执行 Debug&gt;Start Debugging</li>
<li>等待应用程序启动</li>
<li>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></li>
</ol>
<h4 id="尝试一下热重载-1"><a href="#尝试一下热重载-1" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>
<h3 id="控制台-文本编辑器"><a href="#控制台-文本编辑器" class="headerlink" title="控制台 + 文本编辑器"></a>控制台 + 文本编辑器</h3><p>控制台 + 文本编辑器 你自己选择的代码编辑器加上 Flutter 提供的命令行工具来运行和构建 Flutter 应用程序。</p>
<p>创建应用程序</p>
<ol>
<li>使用 flutter create 命令来创建一个新的应用程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create myapp</span><br><span class="line">$ cd myapp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上的命令创建了一个名叫 myapp 的 Flutter 项目，并且放在 ‘myapp’ 文件夹中。这是一个很简单的，基于 <a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material 组件</a> 的项目。</p>
<p>在这个项目的文件夹中，和项目业务相关的代码都在 lib/main.dart 中。</p>
<h4 id="运行这个程序-2"><a href="#运行这个程序-2" class="headerlink" title="运行这个程序"></a>运行这个程序</h4><ul>
<li><p>确保 Android 设备当前处于运行状态。如果没有发现在运行的设备，查看 <a href="http://doc.flutter-dev.cn/get-started/install/" target="_blank" rel="noopener">安装</a> 页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter devices</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 flutter run 命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一切正常，构建完应用程序之后，你就可以在你的手机或者模拟器上看到应用程序的起始界面了：<br><a href="flutter-starter-app-android.png">Android 设备/模拟器上的起始界面</a></p>
</li>
</ul>
<h4 id="尝试一下热重载-2"><a href="#尝试一下热重载-2" class="headerlink" title="尝试一下热重载"></a>尝试一下热重载</h4><p>Flutter 提供了一种非常高效的开发方式，叫做 热重载 ，这个功能可以在应用程序运行的状态下替换部分代码，并且运行中的程序不会丢失任何状态。简单的对你的源代码做一些修改，告诉你的 IDE 或者命令行工具，你需要进行热重载，然后你就可以在模拟器或者手机中看到你的修改了。</p>
<p>在你最钟爱的 Dart 开发编辑器中打开 lib/main.dart 文件</p>
<ol>
<li>把字符串<br>‘You have pushed the button this many times:’修改为<br>‘You have clicked      the button this many times:’</li>
<li>不需要点击 ‘Stop’ 按钮；让应用程序继续运行。</li>
<li>只需要将代码 全部保存 (cmd-s / ctrl-s)，或者点击 热重载 按钮（那个像闪电⚡️一样的图标按钮）你就可以看到你的修改已经被执行了。</li>
</ol>
<p>你几乎可以立刻就在应用程序里看到你对字符串的修改。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/07/12/flutter初体验/" data-id="cjlc1dmtj0010a4s69o465b3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/start/">start</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/7/">7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/">Android Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Support/">Android Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/">Annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsynListUtil/">AsynListUtil</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-DataCallback/">AsyncListUtil.DataCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-ViewCallback/">AsyncListUtil.ViewCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Buffer/">Buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ByteBuffer/">ByteBuffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DynamicLoadApk/">DynamicLoadApk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Error/">Error</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-App/">First App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Instant-Run/">Instant Run</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interceptors/">Interceptors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinearLayout/">LinearLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC-MVP-MVVM/">MVC MVP MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Media/">Media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaExtractor/">MediaExtractor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MulitiDex/">MulitiDex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NNotificationChannelGroup/">NNotificationChannelGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NestedScrolling/">NestedScrolling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notification/">Notification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NotificationChannel/">NotificationChannel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Options/">Options</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Small/">Small</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SourceCode/">SourceCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Support/">Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Uri/">Uri</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/andrid/">andrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boolen/">boolen</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/byte/">byte</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera2/">camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/char/">char</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/double/">double</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle-plugin/">gradle plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/head/">head</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ide/">ide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/install/">install</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/int/">int</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/long/">long</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/okhttp/">okhttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/short/">short</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start/">start</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/7/" style="font-size: 10px;">7</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-Studio/" style="font-size: 10px;">Android Studio</a> <a href="/tags/Android-Support/" style="font-size: 10px;">Android Support</a> <a href="/tags/Annotation/" style="font-size: 12.5px;">Annotation</a> <a href="/tags/AsynListUtil/" style="font-size: 10px;">AsynListUtil</a> <a href="/tags/AsyncListUtil-DataCallback/" style="font-size: 10px;">AsyncListUtil.DataCallback</a> <a href="/tags/AsyncListUtil-ViewCallback/" style="font-size: 10px;">AsyncListUtil.ViewCallback</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/BitmapFactory/" style="font-size: 10px;">BitmapFactory</a> <a href="/tags/Buffer/" style="font-size: 10px;">Buffer</a> <a href="/tags/ByteBuffer/" style="font-size: 10px;">ByteBuffer</a> <a href="/tags/Camera2/" style="font-size: 12.5px;">Camera2</a> <a href="/tags/Download-Manager/" style="font-size: 12.5px;">Download Manager</a> <a href="/tags/DynamicLoadApk/" style="font-size: 10px;">DynamicLoadApk</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/First-App/" style="font-size: 10px;">First App</a> <a href="/tags/Flutter/" style="font-size: 17.5px;">Flutter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Instant-Run/" style="font-size: 10px;">Instant Run</a> <a href="/tags/Interceptors/" style="font-size: 10px;">Interceptors</a> <a href="/tags/LinearLayout/" style="font-size: 10px;">LinearLayout</a> <a href="/tags/MVC-MVP-MVVM/" style="font-size: 10px;">MVC MVP MVVM</a> <a href="/tags/Media/" style="font-size: 15px;">Media</a> <a href="/tags/MediaCodeC/" style="font-size: 10px;">MediaCodeC</a> <a href="/tags/MediaExtractor/" style="font-size: 12.5px;">MediaExtractor</a> <a href="/tags/MulitiDex/" style="font-size: 10px;">MulitiDex</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/NNotificationChannelGroup/" style="font-size: 10px;">NNotificationChannelGroup</a> <a href="/tags/NestedScrolling/" style="font-size: 10px;">NestedScrolling</a> <a href="/tags/Notification/" style="font-size: 10px;">Notification</a> <a href="/tags/NotificationChannel/" style="font-size: 10px;">NotificationChannel</a> <a href="/tags/Options/" style="font-size: 10px;">Options</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Small/" style="font-size: 10px;">Small</a> <a href="/tags/SourceCode/" style="font-size: 10px;">SourceCode</a> <a href="/tags/Support/" style="font-size: 10px;">Support</a> <a href="/tags/Tool/" style="font-size: 12.5px;">Tool</a> <a href="/tags/Uri/" style="font-size: 10px;">Uri</a> <a href="/tags/andrid/" style="font-size: 15px;">andrid</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/boolen/" style="font-size: 10px;">boolen</a> <a href="/tags/byte/" style="font-size: 10px;">byte</a> <a href="/tags/camera2/" style="font-size: 10px;">camera2</a> <a href="/tags/char/" style="font-size: 10px;">char</a> <a href="/tags/double/" style="font-size: 10px;">double</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gradle-plugin/" style="font-size: 10px;">gradle plugin</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/ide/" style="font-size: 10px;">ide</a> <a href="/tags/install/" style="font-size: 12.5px;">install</a> <a href="/tags/int/" style="font-size: 10px;">int</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/long/" style="font-size: 10px;">long</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/okhttp/" style="font-size: 10px;">okhttp</a> <a href="/tags/short/" style="font-size: 10px;">short</a> <a href="/tags/start/" style="font-size: 10px;">start</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/27/基础数据与byte间的转化/">基础数据与byte间的转化</a>
          </li>
        
          <li>
            <a href="/2018/08/23/NIO-Buffer解析/">NIO-Buffer解析</a>
          </li>
        
          <li>
            <a href="/2018/08/16/根据Uri获取文档的路径/">根据Uri获取文档的路径</a>
          </li>
        
          <li>
            <a href="/2018/08/12/LinearLayout源码解读/">LinearLayout源码解读</a>
          </li>
        
          <li>
            <a href="/2018/07/22/android-camera2预览拍照录制/">android-camera2预览拍照录制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 CallteFoot<br>
      Powered by <a href="https://cattlefoot.github.io" target="_blank">CallteFoot</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>