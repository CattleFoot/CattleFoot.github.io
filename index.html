<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CallteFoot&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="CallteFoot&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CallteFoot&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cattlefoot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/13/java单例模式/" class="article-date">
  <time datetime="2018-06-13T08:42:17.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/java单例模式/">java单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ol>
<li><p>什么是Singleton类？你之前用过Singleton吗？<br>Singleton是一个类，在整个应用程序中只有一个实例，并提供一个getInstance（）方法来访问单例实例。在JDK中有许多类是使用Singleton模式实现的，如java.lang.Runtime，它提供了getRuntime（）方法来访问它并用于获得Java中的可用内存和总内存。</p>
</li>
<li><p>单例模式优缺点：</p>
<ul>
<li>优点：  <ul>
<li>提供了对唯一实例的受控访问；</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；</li>
<li>允许可变数目的实例；</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难；</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="单例模式的五种实现"><a href="#单例模式的五种实现" class="headerlink" title="单例模式的五种实现"></a>单例模式的五种实现</h4><ol>
<li><p>懒汉</p>
<ul>
<li>1.1 懒汉，线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。</p>
<ul>
<li>1.2 懒汉，线程安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。  </p>
</li>
<li><p>饿汉</p>
<ul>
<li>2.1 饿汉，基本型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</span><br><span class="line"></span><br><span class="line"> - <span class="number">2.2</span> 饿汉，变种   </span><br><span class="line"> ```Java</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表面上看起来差别挺大，其实跟2.1方式差不多，都是在类初始化即实例化instance。  </p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟2.1和2.2方式不同的是（很细微的差别）：2.1和2.2方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比2.1和2.2种方式就显得很合理。  </p>
</li>
<li>双重校验锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个是1.2方式的升级版，俗称双重检查锁定，详细介绍请查看：<a href="http://www.ibm.com/developerworks/cn/java/j-dcl.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-dcl.html</a><br>在JDK1.5之后，双重检查锁定才能够正常达到单例效果。  </p>
<ol>
<li>枚举<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化和通过反射重新创建新的对象，可谓是很坚强的壁垒啊，这种方式在1.5中才加入的enum特性。</p>
<h4 id="单例模式的安全性问题"><a href="#单例模式的安全性问题" class="headerlink" title="单例模式的安全性问题"></a>单例模式的安全性问题</h4><p>懒汉式、饿汉式、内部类、双重锁、枚举这5种单例模式中，枚举最为特殊，由于是官方提供的一种模式，所以不能被破解，是十分安全的。其他四种在一定程度上会有一定安全问题。</p>
<p>关于懒汉式的单利破解：</p>
<ol>
<li>用反射破解单例模式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Singleton s011 = Singleton.getInstance();  </span><br><span class="line">        Singleton s012 = Singleton.getInstance();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用反射创建新对象  </span></span><br><span class="line">        Class&lt;Singleton&gt; h1 = (Class&lt;Singleton&gt;) Class.forName(<span class="string">"Singleton"</span>);<span class="comment">//反射获取H1对象  </span></span><br><span class="line">        Constructor c = h1.getDeclaredConstructor(<span class="keyword">null</span>);<span class="comment">//获取无参构造函数  </span></span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);<span class="comment">//更改无参构造函数权限为公开  </span></span><br><span class="line">        Singleton s013 = (Singleton) c.newInstance(<span class="keyword">null</span>);<span class="comment">//创建新对象  </span></span><br><span class="line"></span><br><span class="line">        System.out.println(s011);  </span><br><span class="line">        System.out.println(s012);  </span><br><span class="line">        System.out.println(s013);  </span><br><span class="line">        System.out.println(s011 == s012);  </span><br><span class="line">        System.out.println(s011 == s013);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singleton@<span class="number">1</span>bc4459  </span><br><span class="line">Singleton@<span class="number">1</span>bc4459  </span><br><span class="line">Singleton@<span class="number">12</span>b6651  </span><br><span class="line"><span class="keyword">true</span>  </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>用反序列化（需要实现Serializable）单例模式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Singleton s011 = Singleton.getInstance();  </span><br><span class="line">        Singleton s012 = Singleton.getInstance();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用反序列化创建新对象  </span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/a.txt"</span>);  </span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);  </span><br><span class="line">        oos.writeObject(s011);  </span><br><span class="line">        fos.close();  </span><br><span class="line">        oos.close();  </span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);  </span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);  </span><br><span class="line">        Singleton s013 = (Singleton) ois.readObject();  </span><br><span class="line">        fis.close();  </span><br><span class="line">        ois.close();  </span><br><span class="line"></span><br><span class="line">        System.out.println(s011);  </span><br><span class="line">        System.out.println(s012);  </span><br><span class="line">        System.out.println(s013);  </span><br><span class="line">        System.out.println(s011 == s012);  </span><br><span class="line">        System.out.println(s011 == s013);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出的结果是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singleton@<span class="number">13</span>bad12  </span><br><span class="line">Singleton@<span class="number">13</span>bad12  </span><br><span class="line">Singleton@<span class="number">1</span>a626f  </span><br><span class="line"><span class="keyword">true</span>  </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>以上知道了如果破解,那么如果避免,代码应该这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;  </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式模式：在类加载时不初始化，当需要时再反馈（延迟加载）</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">//私有化构造函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;<span class="comment">//防止反射破解  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//添加synchronized防止多线程插入问题  </span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止反序列化破解  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> wife;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>   </p>
<p>有两个问题需要注意：</p>
<ol>
<li><p>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每 个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>该问题修复的办法是:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;     </span><br><span class="line">     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();     </span><br><span class="line">     <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)     </span><br><span class="line">        classLoader = Singleton.class.getClassLoader();     </span><br><span class="line">     <span class="keyword">return</span> (classLoader.loadClass(classname));     </span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>该问题修复的办法是：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();     </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">   &#125;     </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//主要在这里！！！   </span></span><br><span class="line">            <span class="keyword">return</span> INSTANCE;     </span><br><span class="line">      &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<br>[1]. 单例模式的实现 <a href="https://blog.csdn.net/liangxw1/article/details/51353654" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51353654</a><br>[2]. 单例模式面试问题 <a href="https://blog.csdn.net/u012613251/article/details/79477525" target="_blank" rel="noopener">https://blog.csdn.net/u012613251/article/details/79477525</a><br>[3]. 单例模式的破解 <a href="https://blog.csdn.net/a445849497/article/details/57531266" target="_blank" rel="noopener">https://blog.csdn.net/a445849497/article/details/57531266</a><br>[4]. 单例模式的优缺点 <a href="https://blog.csdn.net/tayanxunhua/article/details/8250329" target="_blank" rel="noopener">https://blog.csdn.net/tayanxunhua/article/details/8250329</a><br>[5]. 枚举实现单例模式更好 <a href="https://blog.csdn.net/normallife/article/details/51152246" target="_blank" rel="noopener">https://blog.csdn.net/normallife/article/details/51152246</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/06/13/java单例模式/" data-id="cjicvd90m0006wqs670uzl4b2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Singleton/">Singleton</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DDComponent原理剖析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/06/DDComponent原理剖析/" class="article-date">
  <time datetime="2018-06-06T03:11:27.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/DDComponent原理剖析/">DDComponentForAndroid原理剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DDComponentForAndroid组件化实现原理主要基于两点：  </p>
<ol>
<li>静态注解：作用是实现路由的扫描、路由注册接口实现、路由表生成、路由参数的传递；  </li>
<li>gladle plugin：作用是动态调整编译脚本、资源管理和类修改；</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>注解知识点和自定义注解请参考：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DDComponentForAndroid中定义了两个注解：RouteNode（路由节点）和Autowired（参数装配），这个两个注解分别用于标记那些页面（DD中指的时activity）可以作为一个路由节点和这个页面需要那些参数。再看看DDComponentForAndroid中怎么根据这个两个注解去实现路由的扫描、路由注册接口的实现、路由表的生成、路由参数注入。</p>
<ol>
<li>RouteNode注解的注解处理器为RouterProcessor，该注解处理器主要做以下几件事情：  <ul>
<li>解析注解：查找所有activity上标注了RouteNode注解元素，并记录路由节点同时扫描Autowired注解同样记录注解标记的参数和参数类型；</li>
<li>路由注册接口的实现，根据gradle脚本下host属性并结合RouteNode中的path值生成一个java类该类通过继承BaseCompRouter然后实现getHost和initMap分别返回host标志和向父类登记路由（path）；</li>
<li>生成路由表：依照解析注解时记录的路由节点生成一个txt文件，文件写明了host名称，path路径和每个节点需要的参数；</li>
</ul>
</li>
<li>Autowired注解的注解处理器为AutowiredProcessor，该注解处理器主要做以下几件事情：  <ul>
<li>解析注解：查找所有activity中属性标注了Autowired注解元素，并根据activity名称进行分类记录下标记的属性；</li>
<li>生成参数注入的辅助类：依照解析注解记录的参数分类记录为每个activity生成一个注入辅助类（类名后缀为：$$Router$$Autowired，这个可以根据自己喜好来的），这个辅助类是类ISyringe接口的实现；<br>sign<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上静态注解处理器生成的java类都在[module名称]/build/generated/source/apt下的debug或release下。而路由表的生成路径就看源码里面设置的在哪里，主要还是<strong>注解处理器生成的java类</strong>。</li>
</ul>
</li>
</ol>
<p>通过以上分析，静态注解部分工作已经完成，也可以看到所有的结果还是在具体module下，各个module还是对非自身内的路由不可见的，结下就是让各个module的路由对其他module可见，这个呢则是通过gladle plugin来达到这个目的。接下来分析gladle plugin如何去实现各个module的路由可见。</p>
<p>gladle plugin主要工作是动态调整编译脚本、资源管理和类修改，进一步看下其是如何实现的；</p>
<ol>
<li><p>动态调整编译脚本：</p>
<ul>
<li>记录当前assemble的module的名称，也就是点击AS的右三角运行的module；</li>
<li>查找module下gradle配置文件中的isRunAlone属性，同时查找根项目下的gradle配置文件中的mainModuleName属性；</li>
<li>根据上面两步的结果，判定当前module是主项目还是依赖的项目，如果是主项目则动态设置编译脚本应用的插件为application，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.apply plugin: <span class="string">'com.android.application'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果是依赖的项目则动态设置编译脚本应用的插件为library，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.apply plugin: <span class="string">'com.android.library'</span></span><br></pre></td></tr></table></figure>
<p>通过动态调整编译脚本，现在已经实现了各个module的class文件对其他module是可见的了，但是目前还是不能实现路由间的跳转，继续分析。</p>
</li>
<li>资源文件管理：  <ul>
<li>在第1步中前两步知道当前那些module是依赖的项目，注意！！android中application和library的AndroidManifest，因此对于依赖的项目中的AndroidManifest文件进行管理或者修改，DDComponentForAndroid通过指定另外的路径来加载library的AndroidManifest文件。</li>
</ul>
</li>
<li><p>类修改：</p>
<ul>
<li>扫描所有项目的directory文件，扫描出application文件并记录；</li>
<li>扫描所有项目的directory文件，扫描出实现了接口IApplicationLike的文件并记录，应为在IApplicationLike实现类中会去注册路由实现类；</li>
</ul>
<p>通过类修改，这个样就达到了路由间的跳转。自此组件化就达到了，而且各个组件间可以独立调试无需手动再次设置。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/06/06/DDComponent原理剖析/" data-id="cjicvd90i0004wqs6pxni6fgc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Annotation/">Annotation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradle-plugin/">gradle plugin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android自定义注解处理器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/29/Android自定义注解处理器/" class="article-date">
  <time datetime="2018-05-29T07:24:49.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/Android自定义注解处理器/">Android自定义注解处理器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>  在开发中经常使用到注解，最近在研究DDComponent插件化时又碰到了。因此，也再次深入了解了注解，<br>记录下在学习过程中学到的一些知识。目前比较主流的框架也多数用到了注解技术，如：ButterKnife、Dagger2、<br>Retrofit、Glide等。<br>注解一般分为两种：运行时注解；编译时注解。<br>运行时注解：一般配合反射机制使用，相对编译时注解性能比较低，但灵活性好。例如：Retrofit用的就是<br>运行时注解。<br>编译时注解：编译时注解能够自动处理java源文件，并可以根据需要生成新的文件。</p>
<h3 id="基础知识点-元注解"><a href="#基础知识点-元注解" class="headerlink" title="基础知识点-元注解"></a>基础知识点-元注解</h3><p>  元注解的作用是负责注解其他注解，Java5.0定义了 <strong>4个标准的meta-annotation类型</strong>，它们被<br>用来提供对其它 annotation类型作说明。Java5.0定义的元注解：@Target、@Retention、@Documented、@Inherited。</p>
<ol>
<li>@Target:说明了Annotation所修饰的对象范围，其取值为枚举类java.lang.annotation.ElementType。<br>取值类型有：<ul>
<li>TYPE：Class, interface (including annotation type), or enum declaration（用于描述类、接口(包括注解类型) 或enum声明）;</li>
<li>FIELD：Field declaration (includes enum constants)（用于描述域）</li>
<li>METHOD：Method declaration（用于描述方法）;</li>
<li>PARAMETER：Formal parameter declaration（用于描述参数）;</li>
<li>CONSTRUCTOR：Constructor declaration（用于描述构造器）;</li>
<li>LOCAL_VARIABLE：Local variable declaration（用于描述局部变量）;</li>
<li>ANNOTATION_TYPE：Annotation type declaration（用于注解类型声明）;</li>
<li>PACKAGE：Package declaration（用于描述包）;</li>
<li>TYPE_PARAMETER：Type parameter declaration（用于类型定义），since 1.8;</li>
<li>TYPE_USE：Use of a type（？？？？？），since 1.8;</li>
</ul>
</li>
<li>@Retention:定义了Annotation被保留的时间长短,其取值为枚举类java.lang.annotation.RetentionPolicy。<br>取值类型有：<ul>
<li>SOURCE:Annotations are to be discarded by the compiler(注解仅存在于源码中，在class字节码文件中不包含);</li>
<li>CLASS:默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得;</li>
<li>RUNTIME:注解会在class字节码文件中存在，在运行时可以通过反射获取到;</li>
</ul>
</li>
<li>@Documented:用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类<br>的工具文档化。Documented是一个标记注解，没有成员。</li>
<li>@Inherited:阐述了某个被标注的类型是被继承的，同样是一个标记注解，没有成员。</li>
</ol>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<h4 id="定义注解格式："><a href="#定义注解格式：" class="headerlink" title="定义注解格式："></a>定义注解格式：</h4><p>　　public @interface 注解名 {定义体}<br>　　注解参数的可支持数据类型：<br>　　　　1. 所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>　　　　2. String类型<br>　　　　3. Class类型<br>　　　　4. enum类型<br>　　　　5. Annotation类型<br>　　　　6. 以上所有类型的数组<br>　　Annotation类型里面的参数该怎么设定:<br>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；<br>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;<br>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号。<br>一个简单的自定义注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。</p>
<h4 id="注解处理器类库（java-lang-reflect-AnnotatedElement"><a href="#注解处理器类库（java-lang-reflect-AnnotatedElement" class="headerlink" title="注解处理器类库（java.lang.reflect.AnnotatedElement"></a>注解处理器类库（java.lang.reflect.AnnotatedElement</h4><p>Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：<br>　　- Class：类定义<br>　　- Constructor：构造器定义<br>　　- Field：累的成员变量定义<br>　　- Method：类的方法定义<br>　　- Package：类的包定义</p>
<p>　　java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。<br>  AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p>
<ol>
<li><t extends="" annotation=""> T getAnnotation(Class<t> annotationClass): 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。  </t></t></li>
<li>Annotation[] getAnnotations():返回该程序元素上存在的所有注解。   </li>
<li>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。</li>
<li><p>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。  </p>
<p>示例程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFruitInfo</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String strFruitName=<span class="string">" 水果名称："</span>;</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(FruitName.class))&#123;</span><br><span class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);</span><br><span class="line">                strFruitName=strFruitName+fruitName.value();</span><br><span class="line">                System.out.println(strFruitName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是<strong>理论</strong>部分提到的运行时注解，在运行时配合反射机制使用。早期的butterknife确实是使用的动态注解的方式。可是后来，静态注解出现了，如燎原之火般席卷而来。接下来是静态注解。</p>
</li>
</ol>
<h3 id="Android自定义注解处理器"><a href="#Android自定义注解处理器" class="headerlink" title="Android自定义注解处理器"></a>Android自定义注解处理器</h3><p>在Android中自定义注解处理器一般通过继承AbstractProcessor类来实现，通过process方法进行处理。需要注意的是，注解处理器只能生成新的文件，不能修改已存在的源文件。AbstractProcessor类是接口Processor类，其在Java1.7加入，用于处理编译时的注解。<br>自定义注解处理其主要分为6个步骤:</p>
<h4 id="第一步-创建Java-Library项目"><a href="#第一步-创建Java-Library项目" class="headerlink" title="第一步 创建Java Library项目"></a>第一步 创建Java Library项目</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们新建一个Java Library项目，来作为注解处理器模块。注意是Java Library，不是Android Library。因为我们要用到的是javax包中的类，而Android Library中的JDK不包含这些类。</p>
<h4 id="第二步-新建自定义注解"><a href="#第二步-新建自定义注解" class="headerlink" title="第二步 新建自定义注解"></a>第二步 新建自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RouteNode &#123;</span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步-新建自定义注解处理器"><a href="#第三步-新建自定义注解处理器" class="headerlink" title="第三步 新建自定义注解处理器"></a>第三步 新建自定义注解处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过新建的AutowiredProcessor，知道要实现抽象类<br>AbstractProcessor的process方法，在这个方法中处理注解与生成新文件的。另外需要注意的是：<br><strong>1.需要配置注解处理器支持处理的注解；2.需要指定支持java的源码版本</strong>，这两点我们可以通过Override<br>抽象类AbstractProcessor的getSupportedAnnotationTypes()和getSupportedSourceVersion()方法类配置，或者通过注解的形式来配置，这个稍后再升级下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该处理器支持的所有注解类集合，在这里可以添加自定义注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加自定义注解</span></span><br><span class="line">        set.add(RouteNode.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该处理器支持的JDK版本，例如：SourceVersion.RELEASE_7</span></span><br><span class="line"><span class="comment">     * 一般返回SourceVersion.latestSupported()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="第四步-处理process-方法，并生成文件"><a href="#第四步-处理process-方法，并生成文件" class="headerlink" title="第四步 处理process()方法，并生成文件"></a>第四步 处理process()方法，并生成文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">     StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"package com.xuhj.java.processor;\n"</span>)</span><br><span class="line">              .append(<span class="string">"public class GeneratedTemplate&#123;\n"</span>)</span><br><span class="line">              .append(<span class="string">"\tpublic String getMessage()&#123;\n"</span>)</span><br><span class="line">              .append(<span class="string">"\t\treturn \""</span>);</span><br><span class="line">      <span class="keyword">for</span> (Element element : roundEnvironment.getElementsAnnotatedWith(Template.class)) &#123;</span><br><span class="line">          String objectType = element.getSimpleName().toString();</span><br><span class="line">          sb.append(objectType).append(<span class="string">" say hello!\\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sb.append(<span class="string">"\";\n"</span>)</span><br><span class="line">              .append(<span class="string">"\t&#125;\n"</span>)</span><br><span class="line">              .append(<span class="string">"&#125;\n"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          JavaFileObject source = processingEnv.getFiler()</span><br><span class="line">                  .createSourceFile(<span class="string">"com.xuhj.java.processor.generated.GeneratedTemplate"</span>);</span><br><span class="line">          Writer writer = source.openWriter();</span><br><span class="line">          writer.write(sb.toString());</span><br><span class="line">          writer.flush();</span><br><span class="line">          writer.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上我们自定义注解处理器已经写好了，下一步就是如何集成到具体项目中。</p>
<h4 id="第五步-声明自定义注解处理器"><a href="#第五步-声明自定义注解处理器" class="headerlink" title="第五步 声明自定义注解处理器"></a>第五步 声明自定义注解处理器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用前，还需要声明注解处理器，也即广而告之当前项目下有那些注解处理器。<br>其声明主要在 <strong>main目录</strong> 下，新建 <strong>resource/META-INF/services目录</strong>，并在目录下新建一个 <strong>javax.annotation.processing.Processor</strong> 文件，这个也可以通过注解的形式来配置，这个稍后再升级下。<br>在文件中使用文本声明已经编写好的注解处理器，每个注解处理器各占一行。<br>最后执行 <strong>Make Project</strong>，就可以在build目录下看到生成好的jar包。可以直接拿jar包集成到项目中或者依赖该项目亦可。</p>
<h4 id="第六步-集成到项目中"><a href="#第六步-集成到项目中" class="headerlink" title="第六步 集成到项目中"></a>第六步 集成到项目中</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将生成的jar包放到项目的libs中或者使项目依赖注解处理器的项目，就可以使用注解处理器了，执行Make Project，就会在项目的build/generated/source/apt/debug下看到通过注解处理器生成的java文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有生成java文件，请检查注解器的声明是否写错。</p>
<p><strong>总结</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面自定义注解处理器已经可以使用了，其主要是通过继承抽象AbstractProcessor类并实现process方法，同时配置注解器支持的java版本和注解，最后对外声明注解器本身在哪里即可。用注解处理器的好处是可以自动生成一些重复大量的代码，并且能让类变得干净、逻辑清晰。</p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第三步和第五步讲到可以通过注解的形式来配置注解器支持的java版本、注解和声明，为何要这样做呢，主要是在声明的时候容易人为的输入容易出错而且麻烦。使用注解配置前，需要引入注解所在的jar<br>包（com.google.auto.service:auto-service）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation ‘com.google.auto.service:auto-service:<span class="number">1.0</span>-rc2’</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意auto-service的不同版本（存在兼容性），然后通过注解来配置和声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明当前类为是注解处理器，Processor.class为静态注解入口也是一个接口</span></span><br><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="comment">//支持的注解</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"com.mugwort.annotation.RouteNode"</span>)</span><br><span class="line"><span class="comment">//支持的java版本</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteNodeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong> 这里有一点不好就是注解的支持只能手写。</p>
<h4 id="调试注解器"><a href="#调试注解器" class="headerlink" title="调试注解器"></a>调试注解器</h4><p>编写代码不可避免会出现错误的，如何定位错误则需要调试的，而注解器如何调试呢？调试有两种方式：日志定位；断点调试；</p>
<ol>
<li><p>日志定位，繁琐但方便快捷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. sout</span></span><br><span class="line">System.out.println(xxx)</span><br><span class="line"><span class="comment">// 2. messager</span></span><br><span class="line">processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, <span class="string">"only support field"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断点调试：<br>注解器的断点调试比较麻烦点，不像java那样，其主要分为三个步骤。</p>
<ol>
<li>配置debug后台服务，在在gradle.properties文件中加入下面两句话，然后sync一下项目（或者在控制台执行./gradlew –daemon），会开启一个远程debug_server。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.daemon=<span class="keyword">true</span></span><br><span class="line">org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">5005</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>配置Remote Debugger，在AS中创建一个Remote Debugger。</p>
</li>
<li><p>执行编译过程，在需要的位置打开断点，在控制台输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDebug</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>或者，待清除功能的编译<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean assembleDebug</span><br></pre></td></tr></table></figure></p>
<p>配置没问题的话就会走到打开的断点，然后就可以调试了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/05/29/Android自定义注解处理器/" data-id="cjicvd90e0002wqs6iwgekk78" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Annotation/">Annotation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mvc-mvp和mvvm理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/mvc-mvp和mvvm理解/" class="article-date">
  <time datetime="2018-04-15T02:25:44.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/mvc-mvp和mvvm理解/">mvc_mvp和mvvm理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MVC、MVP和MVVM是Android耳熟能详的三个模式，且应用广泛。对于三者的内容、区别、使用场景有时很能道出个123，而且这些框架思想在各个平台都有，但对于各个平台具体的实现有一定差异和限制。本文主要从Android方面来介绍它们。主要有：  </p>
<ul>
<li>了解并区分MVC、MVP和MVVM；</li>
<li>它们在Android中如何使用；</li>
<li>走出data binding的误区；</li>
<li>理解MVP+data binding开发模式；</li>
</ul>
<h2 id="MVC、MVP和MVVM基础介绍"><a href="#MVC、MVP和MVVM基础介绍" class="headerlink" title="MVC、MVP和MVVM基础介绍"></a>MVC、MVP和MVVM基础介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;水之积也不厚，则其负大舟也无力：正如庄子逍遥游所说，水不深则没有能够担负大船的力量。在涉及代码前，我们需要对MVC、MVP和MVVM有足够的了解。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVC：（Model View Controller）是软件架构中常见的一种模式，其通过controller层的控制去操作model层的数据，并且返回给view层展示，具体如下：<br><img src="../images/mvc.png" alt="MVC执行图"><br>&nbsp;&nbsp;&nbsp;&nbsp;其工作原理为：当用户触发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新晚数据以后直接显示在view层。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;那具体到android上又是如何？，我们知道android工程有java的class文件、有res文件夹、asset、还有manifest文案等等，对于原生的android项目来说，layout.xml里面的xml<br>文件就对应于MVC的view层，而各种java bean、还有类是repository类就是对应于model层，至于controller层，则是各种activity。当我们在页面触发一个按钮去加载网络资源时，加载网络资源xiangg代码和结果类，则是model层，view和model的关联则是通过按钮的点击事件，这个在activity中，也就是contrller层。android中完整的MVC流程就是这样。<br>&nbsp;&nbsp;&nbsp;&nbsp;Android这样处理有何问题？显然有的。问题在于xml作为view层，其控制<br>内里太弱，当要改变一个页面的背景或者动态控制按钮的隐藏或显示，这些都只能在activity中控制，这样<br>activity的cotroller职责就多了。不符合六大原子的 <strong>单一原则</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp; 通过以上我们知道MVC重要的缺陷是view层和model层是相互可知，意味着两层之间存在耦合。这是因为这个缺陷，才演化出MVP和MVVM两种框架。  </p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVP（View、Presenter、model）作为MVC的演化，解决了MVC不少缺点。对于Android来说，MVP的model层相对于MVC是一样的，而activity和fragment不在是controller层，而是纯粹的view层，所有相关用户的事件的转发全部交由presenter处理，其原理图如下：<br><img src="../images/MVP.png" alt="MVP原理图"><br>&nbsp;&nbsp;&nbsp;&nbsp;由图我们可知，最明显的差别就是view层和model层不在相互告知，完全解耦，取而代之的是有presenter层充当桥梁作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，，并将数据返回给view层，整个过程中view层和model层完全没有关系。也许有人会问，虽然view层和model层解耦了，但是view层和presenter层不是耦合在一起吗？其实不是的，对于view层和presenter的通行是可以通过接口实现的，也就是说activity，fragment可以去实现定义好的接口，而在对应的presenter中通过接口调用方法。同时，我们还可以编写测试用的view，模拟用户操作，从而实现对presenter的测试，解决了MVC模式中测试，维护难问题。<br><strong>当然</strong>，其实最好的方式是使用fragment作为view层，而activity则是用于创建view层(fragment)和presenter层(presenter)的一个控制器。  </p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MVVM（View、ViewModel、Model）最早有微软提供的，其原理图如下：<br><img src="../images/MVVM.png" alt="MVVM原理图"><br>&nbsp;&nbsp;&nbsp;&nbsp;由图可知，其和MVP的区别不到，只不过是presenter层换成viewmodel层，还有就是view层和viewmodel层是相互绑定的关系，意味着当更新viewmodel层的数据的时候，view层会相应的变动ui。<br>&nbsp;&nbsp;&nbsp;&nbsp; 很难说MVP和MVVM这两个MVC的变种孰优孰劣，需要具体分析。</p>
<h2 id="纸上得来终觉浅，绝知此事要躬行"><a href="#纸上得来终觉浅，绝知此事要躬行" class="headerlink" title="纸上得来终觉浅，绝知此事要躬行"></a>纸上得来终觉浅，绝知此事要躬行</h2><h2 id="路漫漫其修远兮，吾将上下而求索"><a href="#路漫漫其修远兮，吾将上下而求索" class="headerlink" title="路漫漫其修远兮，吾将上下而求索"></a>路漫漫其修远兮，吾将上下而求索</h2><p>参考地址：<br>[1].MVC、MVP、MVVM详解 <a href="https://blog.csdn.net/jdsjlzx/article/details/51174396" target="_blank" rel="noopener">https://blog.csdn.net/jdsjlzx/article/details/51174396</a><br>[2].MVC在Android中的使用 <a href="https://blog.csdn.net/feiduclear_up/article/details/46363207" target="_blank" rel="noopener">https://blog.csdn.net/feiduclear_up/article/details/46363207</a><br>[3].Android中常见的MVC模式 <a href="https://blog.csdn.net/sylcc_/article/details/7346149" target="_blank" rel="noopener">https://blog.csdn.net/sylcc_/article/details/7346149</a><br>[4].MVC,MVP,MVVM与架构经验谈 <a href="https://www.cnblogs.com/wytiger/p/5305087.html" target="_blank" rel="noopener">https://www.cnblogs.com/wytiger/p/5305087.html</a><br>[5].平台间的MVC、MVP、MVVM <a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank" rel="noopener">http://www.cnblogs.com/indream/p/3602348.html</a><br>[6].前端MVC、MVP、MVVM <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/04/15/mvc-mvp和mvvm理解/" data-id="cjicvd90x000ewqs65bh5m8fb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC-MVP-MVVM/">MVC MVP MVVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-插件化种种和思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/28/插件化种种和思考/" class="article-date">
  <time datetime="2017-06-27T23:47:36.000Z" itemprop="datePublished">2017-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/插件化种种和思考/">插件化种种和思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="个人态度"><a href="#个人态度" class="headerlink" title="个人态度"></a>个人态度</h4><p>&ensp;&ensp;学习这项技术是关心技术后的本质，在项目中能不用就不用，因为本身这种做法是 Google 不推荐的，RN才是今后的发展方向。但是RN性能方面的优化也很重要，这方面没深入了解。</p>
<h4 id="在项目中引入新技术"><a href="#在项目中引入新技术" class="headerlink" title="在项目中引入新技术"></a>在项目中引入新技术</h4><p>&ensp;&ensp;在项目中使用新技术，哪怕是引入一个第三方库也要小心谨慎，确定是否确实需要。但是还是要对不了解的新的东西要积极学习、积极研究，这样在引入实际生产环境后也能快速踩坑出坑。<br>个人认为开发不能脱离业务，不能脱离实际场景为了技术而技术，也不能害怕引入新技术，风险和效率等优点是并存的，但是要合理的控制风险。</p>
<h4 id="介绍名词"><a href="#介绍名词" class="headerlink" title="介绍名词"></a>介绍名词</h4><p><strong>插件化</strong> – apk 分为宿主和插件部分，插件在需要的时候才加载进来<br><strong>热修复</strong> – 更新的类或者插件粒度较小的时候，我们会称之为热修复，一般用于修复bug<br><strong>热更新</strong> – 2016 Google 的 Android Studio 推出了Instant Run 功能 同时提出了3个名词<br><strong>“热部署” </strong>– 方法内的简单修改，无需重启app和Activity。 “暖部署” – app无需重启，但是activity需要重启，比如资源的修改。 “冷部署” – app需要重启，比如继承关系的改变或方法的签名变化等。</p>
<p>&ensp;&ensp;所以站在app开发者角度的“热”是指在不发版的情况来实现更新，而Google提出的“热”是指值是否需要重新启动。 同时在开发插件化的时候也有两种情景，一种是插件与宿主apk没有交互，只是在用户使用到的时候进行一次吊起，还有一种是与宿主有很多的交互。</p>
<h4 id="从MulitiDex开始"><a href="#从MulitiDex开始" class="headerlink" title="从MulitiDex开始"></a>从MulitiDex开始</h4><p>&ensp;&ensp;当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt 。DexOpt 的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODex 的效率会比直接执行 Dex 文件的效率要高很多。</p>
<p>&ensp;&ensp;但是在早期的 Android 系统中，DexOpt 有一个问题，DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结 构里面。但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的 Android 系统中，DexOpt 修复了这个问题，但是我们仍然需要对低版本的 Android 系统做兼容。</p>
<p>&ensp;&ensp;为了解决方法数超限的问题，需要将该dex文件拆成两个或多个，为此谷歌官方推出了 multidex 兼容包，配合 AndroidStudio 实现了一个 APK 包含多个 dex 的功能。</p>
<p>MulitDex 引起的问题有:</p>
<ul>
<li>在应用安装到手机上的时候dex文件的安装是复杂的(complex)有可能会因为第二个dex文件太大导致ANR。</li>
<li>使用了mulitDex的App有可能在4.0(api level 14)以前的机器上无法启动，因为Dalvik linearAlloc bug(Issue 22586) 。</li>
<li>使用了mulitDex的App在runtime期间有可能因为Dalvik linearAlloc limit (Issue 78035) Crash。该内存分配限制在 4.0版本被增大，但是5.0以下的机器上的Apps依然会存在这个限制。</li>
<li>主dex被dalvik虚拟机执行时候，哪些类必须在主dex文件里面这个问题比较复杂。build tools 可以搞定这个问题。但是如果你代码存在反射和native的调用也不保证100%正确。</li>
</ul>
<p>对于 davilk 和 art 虚拟机 Mulitdex 的不同: </p>
<ol>
<li>ART模式相比原来的Dalvik，会在安装APK的时候，使用Android系统自带的dex2oat工具把APK里面的.dex文件转化成OAT文件。<br>这里说一下罗迪的快速加载 Mulitdex 方案：art虚拟机对dex优化需要很长时间，加载插件dex跳过优化实现加速。跳过会影响类加载的性能。</li>
</ol>
<h4 id="插件化实现方案分析对比"><a href="#插件化实现方案分析对比" class="headerlink" title="插件化实现方案分析对比"></a>插件化实现方案分析对比</h4><p>下面对实现插件化需要关注的一些点，和主流插件化框架进行了一些总结分析。<br>实现插件化需要解决的技术点：</p>
<ul>
<li>资源如何加载（资源冲突问题如何解决）？</li>
<li>代码如何加载访问访问？</li>
<li>插件的管理后台包括的内容？</li>
<li>插件的增量更新问题（非必须） ？</li>
<li>加载插件中的so库 （非必须）？</li>
</ul>
<p>针对如上问题的解决方案：</p>
<ul>
<li><p>针对问题1<br>&ensp;&ensp;原理： &gt; 资源id是在编译时生成的，其生成的规则是0xPPTTNNNN,PP段，是用来标记apk的，默认情况下系统资源PP是01，应用程序的PP是07。TT段，是用来标记资源类型的，比如图标、布局等，相同的类型TT值相同，但是同一个TT值不代表同一种资源，例如这次编译的时候可能使用03作为layout的TT，那下次编译的时候可能会使用06作为TT的值，具体使用那个值，实际上和当前APP使用的资源类型的个数是相关联的。NNNN则是某种资源类型的资源id，默认从1开始，依次累加。<br>&ensp;&ensp;那么我们要解决资源id问题，就可从TT的值开始入手，只要将每次编译时的TT值固定，即可是资源id达到分组的效果，从而避免重复。例如将宿主程序的layout资源的TT固定为33，将插件程序资源的layout的TT值固定为03（也可不对插件程序的资源id做任何处理，使其使用编译出来的原生的值）, 即可解决资源id重复的问题了。<br>固定资源id的TT值的办法也非常简单，提供一份public.xml，在public.xml中指定什么资源类型以什么TT值开头即可<br>&ensp;&ensp;还有一个方法是通过定制过的aapt在编译时指定插件的PP段的值来实现分组，重写过的aapt指定PP段来实现id分组。<br><strong>方案一</strong>: 将插件apk资源解压，通过操作文件的方式来使用，这个只是理论上可行，实际使用的时候还是有很多的问题。（主要是混淆后就懵逼了）<br><strong>方案二</strong>: 重写 Context 的getResource() getAsset() 之类的方法。资源冲突需要扩展 aapt 实现。<br><strong>方案三</strong>: 打包后执行一个脚本修改资源ID。</p>
</li>
<li><p>针对问题2<br>&ensp;&ensp;原理说明：主要就是 classloader 加载dex，代理模式就是本身宿主中有Activity，通过欺骗系统来创建Activity，欺骗系统的部分hook的有深有浅（对比DroidPlugin和Small），让这个Activity有生命周期，而动态加载模式就是运行时动态创建并编译一个Activity类，需要使用动态创建类的工具实现动态字节码操作。<br><strong>方案一</strong>: 简单加载模式。<br><strong>方案二</strong>: Activity代理模式。<br><strong>方案三</strong>: 动态加载模式。</p>
</li>
<li><p>针对问题3：</p>
</li>
</ul>
<ol>
<li>提供插件信息查询和下载，包括回滚到某一版本。</li>
<li>管理使用插件的apk,可以向不同版本apk 提供不同插件。</li>
<li>MD5校检插件的合法性。</li>
</ol>
<p>插件化现有框架分析对比：</p>
<table>
<thead>
<tr>
<th style="text-align:left">框架名称</th>
<th style="text-align:right">出现时间</th>
<th style="text-align:center">作者</th>
<th style="text-align:left">实现简介</th>
<th style="text-align:left">已知存在问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AndroidDynamicLoader</td>
<td style="text-align:right">2012年7月</td>
<td style="text-align:center">mmin18</td>
<td style="text-align:left">不使用Activity采用Fragment实现</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DynamicAPK</td>
<td style="text-align:right"></td>
<td style="text-align:center">携程</td>
<td style="text-align:left">扩展aapt解决资源问题</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">android-pluginmg</td>
<td style="text-align:right"></td>
<td style="text-align:center">houkx</td>
<td style="text-align:left">动态创建Activity来实现插件化</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DynamicLoadApk</td>
<td style="text-align:right">2014年底</td>
<td style="text-align:center">百度工程师-任玉刚</td>
<td style="text-align:left">通过代理Activity来实现插件化</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DroidPlugin</td>
<td style="text-align:right">2015年8月</td>
<td style="text-align:center">奇虎360</td>
<td style="text-align:left">深度hook实现</td>
<td style="text-align:left">不支持通知栏定制</td>
</tr>
<tr>
<td style="text-align:left">Small</td>
<td style="text-align:right">2015年底</td>
<td style="text-align:center">林光亮</td>
<td style="text-align:left">比较DroidPlugin轻量一点，脚本来解决资源问题</td>
<td style="text-align:left">不支持Service插件化</td>
</tr>
<tr>
<td style="text-align:left">ACCD</td>
<td style="text-align:right">2015年4月</td>
<td style="text-align:center">bunnyblue</td>
<td style="text-align:left">OpenAtlas 之后改为ACCD</td>
<td style="text-align:left">携程开源框架参考了这个</td>
</tr>
<tr>
<td style="text-align:left">nuwa</td>
<td style="text-align:right">2015年9月</td>
<td style="text-align:center">贾吉新</td>
<td style="text-align:left">通过前置相同Dex来实现热修复</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">AndFix</td>
<td style="text-align:right">2015年11月</td>
<td style="text-align:center">阿里</td>
<td style="text-align:left">使用JNI实现的热修复，针对Davilk和Art调用的方法不同</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Dexposed</td>
<td style="text-align:right"></td>
<td style="text-align:center">阿里</td>
<td style="text-align:left">不支持Art虚拟机</td>
</tr>
</tbody>
</table>
<p>来源：<br><a href="http://www.ntkexun.net/inc/exchanges/android_news.asp?id=2377" target="_blank" rel="noopener">http://www.ntkexun.net/inc/exchanges/android_news.asp?id=2377</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/28/插件化种种和思考/" data-id="cjicvd923001jwqs6wsn9no6y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DynamicLoadApk/">DynamicLoadApk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Instant-Run/">Instant Run</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MulitiDex/">MulitiDex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Small/">Small</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/">Tool</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nestedscollin原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/28/nestedscollin原理/" class="article-date">
  <time datetime="2017-06-27T23:20:19.000Z" itemprop="datePublished">2017-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/nestedscollin原理/">nestedscollin原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android在发布 5.0（Lollipop）版本之后，Google为我们提供了嵌套滑动（NestedScrolling） 的特性，接下来主要介绍嵌套滑动机制是怎样的原理？</p>
<h3 id="首先，NestedScrolling特性实现时使用到的4个类"><a href="#首先，NestedScrolling特性实现时使用到的4个类" class="headerlink" title="首先，NestedScrolling特性实现时使用到的4个类"></a>首先，NestedScrolling特性实现时使用到的4个类</h3><ul>
<li><a href="developer.android.com/reference/android/support/v4/view/NestedScrollingChild.html">NestedScrollingChild</a></li>
<li><a href="developer.android.com/reference/android/support/v4/view/NestedScrollingChildHelper.html">NestedScrollingChildHelper</a></li>
<li><a href="http://developer.android.com/reference/android/support/v4/view/NestedScrollingParent.html" target="_blank" rel="noopener">NestedScrollingParent</a></li>
<li><a href="http://developer.android.com/reference/android/support/v4/view/NestedScrollingParentHelper.html" target="_blank" rel="noopener">NestedScrollingParentHelper</a></li>
</ul>
<p>&ensp;&ensp;接下来从这四个类分析看看具体做什么的：</p>
<ol>
<li>NestedScrollingChild<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 设置嵌套滑动是否能用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> enabled true to enable nested scrolling, false to disable</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断嵌套滑动是否可用 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if nested scrolling is enabled</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 开始嵌套滑动</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> axes 表示方向轴，有横向和竖向</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 停止嵌套滑动 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断是否有父View 支持嵌套滑动 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether this view has a nested scrolling parent</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dx  x轴上滑动的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dy  y轴上滑动的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumed 父view消费掉的scroll长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offsetInWindow   子View的窗体偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支持的嵌套的父View 是否处理了 滑动事件 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 子view处理scroll后调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dxConsumed x轴上被消费的距离（横向） </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dyConsumed y轴上被消费的距离（竖向）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dxUnconsumed x轴上未被消费的距离 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dyUnconsumed y轴上未被消费的距离 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offsetInWindow 子View的窗体偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  true if the event was dispatched, false if it could not be dispatched.</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,  </span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span></span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 滑行时调用 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityX x 轴上的滑动速率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityY y 轴上的滑动速率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumed 是否被消费 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  true if the nested scrolling parent consumed or otherwise reacted to the fling</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 进行滑行前调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityX x 轴上的滑动速率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityY y 轴上的滑动速率 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if a nested scrolling parent consumed the fling</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;类的方法虽然不多，但主要还是他的作用？我们想想一种场景：CoordinatorLayout里嵌套着RecyclerView和Toolbar,我们上下滑动RecyclerView的时候，Toolbar会随之显现隐藏,这是典型的嵌套滑动机制情景。这里，RecyclerView作为嵌套的子View,我们猜测，它一定实现了NestedScrollingChild 接口，上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span>, <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line">..................................................................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出RecyclerView 实现了NestedScrollingChild 接口里的方法，我们在跟进去看看各个方法是怎么实现的？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        getScrollingChildHelper().setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().isNestedScrollingEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getScrollingChildHelper().stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedScroll(dxConsumed, dyConsumed,</span><br><span class="line">                dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedFling(velocityX, velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedPreFling(velocityX, velocityY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;通过代码我们知道，全部都是由getScrollingChildHelper()这个方法的返回对象处理了，看看这个方法是怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;NestedScrollingChild 接口的方法都交给NestedScrollingChildHelper这个代理对象处理了。现在我们继续深入，分析下NestedScrollingChildHelper中开始嵌套滑动startNestedScroll(int axes)方法是怎么实现的。<br> NestedScrollingChildHelper#startNestedScroll<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNestedScrollingParent()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;<span class="comment">//判断是否可以滑动</span></span><br><span class="line">            ViewParent p = mView.getParent();</span><br><span class="line">            View child = mView;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123;<span class="comment">//回调了父View的onStartNestedScroll方法</span></span><br><span class="line">                    mNestedScrollingParent = p;</span><br><span class="line">                    ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    child = (View) p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.getParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>方法主要做了：</p>
<ol>
<li>判断是否有嵌套滑动的父View,返回值 true 表示找到了嵌套滑动的父View和同意一起处理 Scroll 事件。</li>
<li>用While的方式寻找最近嵌套滑动的父View ，如果找到调用父view的onNestedScrollAccepted.</li>
</ol>
<p>从这里至少可以得出 子view在调用某个方法都会回调嵌套父view相应的方法，比如子view开始了startNestedScroll，如果嵌套父view存在，就会回调父view的onStartNestedScroll、onNestedScrollAccepted方法。</p>
<p>接下来，在来看看嵌套滑动父view NestedScrollingParent，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(View target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNestedFling</span><span class="params">(View target, <span class="keyword">float</span> velocityX, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">float</span> velocityY,<span class="keyword">boolean</span> consumed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNestedPreFling</span><span class="params">(View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细对比一下会发现，其实和子view差不多的方法，大致一一对应关系，而且它的具体实现也交给了NestedScrollingParentHelper这个代理类。</p>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ol>
<li>当 NestedScrollingChild(下文用Child代替) 要开始滑动的时候会调用 onStartNestedScroll ,然后交给代理类NestedScrollingChildHelper（下文ChildHelper代替）的onStartNestedScroll请求给最近的NestedScrollingParent(下文Parent代替).</li>
<li>当ChildHelper的onStartNestedScroll方法 返回 true 表示同意一起处理 Scroll 事件的时候时候,ChildHelper会通知Parent回调onNestedScrollAccepted 做一些准备动作</li>
<li>当Child 要开始滑动的时候,会先发送onNestedPreScroll,交给ChildHelper的onNestedPreScroll 请求给Parent ,告诉它我现在要滑动多少距离,你觉得行不行,这时候Parent 根据实际情况告诉Child 现在只允许你滑动多少距离.然后 ChildHelper根据 onNestedPreScroll 中回调回来的信息对滑动距离做相对应的调整.</li>
<li>在滑动的过程中 Child 会发送onNestedScroll通知ChildeHelpaer的onNestedScroll告知Parent 当前 Child 的滑动情况.</li>
<li>当要进行滑行的时候,会先发送onNestedFling 请求给Parent,告诉它 我现在要滑行了,你说行不行, 这时候Parent会根据情况告诉 Child 你是否可以滑行.</li>
<li>Child 通过onNestedFling 返回的 Boolean 值来觉得是否进行滑行.如果要滑行的话,会在滑行的时候发送onNestedFling 通知告知 Parent 滑行情况.</li>
<li>当滑动事件结束就会child发送onStopNestedScroll通知 Parent 去做相关操作.<br><img src="images/nestedScrolling流程图.jpg" alt="nestedScrolling流程图"></li>
</ol>
<p><strong>小结</strong><br>&ensp;&ensp;通过上面可以知道，要实现NestedScrolling特性，我们需要使用到开始提到四个的类，并在需要一个父view与子view（父view与子view也可能为同一个view）配合来实现。</p>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>&ensp;&ensp;5.0之前的ListView是没有实现NestedScrollingChild这个接口的，如果要实现CoordinatorLayout里嵌套着ListView和Toolbar，在上下滑动ListView的时候，Toolbar会随之显现隐藏，就必须重写ListView。show code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjj.nestedlistview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.MotionEventCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.NestedScrollingChild;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.NestedScrollingChildHelper;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.ViewCompat;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.widget.ListView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> <span class="keyword">implements</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NestedScrollingChildHelper mChildHelper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLastY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] mScrollOffset = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] mScrollConsumed = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNestedOffsetY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        setNestedScrollingEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mChildHelper.setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mChildHelper.stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.dispatchNestedFling(velocityX, velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mChildHelper.dispatchNestedPreFling(velocityX, velocityY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        event.offsetLocation(<span class="number">0</span>, mNestedOffsetY);</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastY = y;</span><br><span class="line">                mNestedOffsetY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> dy = mLastY - y;</span><br><span class="line">                <span class="keyword">int</span> oldY = getScrollY();</span><br><span class="line"></span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);</span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, dy, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">                    dy -= mScrollConsumed[<span class="number">1</span>];</span><br><span class="line">                    event.offsetLocation(<span class="number">0</span>, -mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">                    mNestedOffsetY += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                mLastY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (dy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newScrollY = Math.max(<span class="number">0</span>, oldY + dy);</span><br><span class="line">                    dy -= newScrollY - oldY;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchNestedScroll(<span class="number">0</span>, newScrollY - dy, <span class="number">0</span>, dy, mScrollOffset)) &#123;</span><br><span class="line">                        event.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">                        mNestedOffsetY += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                        mLastY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stopNestedScroll();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line"></span><br><span class="line">                stopNestedScroll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="images/nestScrolling.gif" alt="嵌套滚动视图效果"></p>
<p>来源：</p>
<ul>
<li><a href="http://www.jianshu.com/p/6547ec3202bd" target="_blank" rel="noopener">http://www.jianshu.com/p/6547ec3202bd</a></li>
<li><a href="https://race604.com/android-nested-scrolling/" target="_blank" rel="noopener">https://race604.com/android-nested-scrolling/</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/52204039" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/52204039</a></li>
<li><a href="http://blog.csdn.net/zf6688/article/details/56677350" target="_blank" rel="noopener">http://blog.csdn.net/zf6688/article/details/56677350</a> ？？</li>
<li><a href="http://blog.csdn.net/happy_horse/article/details/54631695" target="_blank" rel="noopener">http://blog.csdn.net/happy_horse/article/details/54631695</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/28/nestedscollin原理/" data-id="cjicvd90z000fwqs6y3ycgn9p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NestedScrolling/">NestedScrolling</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-downloadManagerSupport7-0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/downloadManagerSupport7-0/" class="article-date">
  <time datetime="2017-06-24T13:41:50.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/24/downloadManagerSupport7-0/">downloadManagerSupport7.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="DownloadManager"><a href="#DownloadManager" class="headerlink" title="DownloadManager"></a>DownloadManager</h3><ol>
<li><p>downloadmanager概述<br>DownloadManager是Android SDK中封装的下载文件类，可以很方便开发者使用下载文件。其具体看官方API<a href="https://developer.android.com/reference/android/app/DownloadManager.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/DownloadManager.html</a></p>
</li>
<li><p>使用DownloadManager下载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class DownloadUtils &#123;</span><br><span class="line"></span><br><span class="line"> private DownloadManager mDownloadManager;</span><br><span class="line"> private Context mContext;</span><br><span class="line"> private long downloadId;</span><br><span class="line"> private String apkName;</span><br><span class="line"></span><br><span class="line"> public DownloadUtils(Context context) &#123;</span><br><span class="line">     mContext = context;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void download(String url, String name) &#123;</span><br><span class="line">     final String packageName = <span class="string">"com.android.providers.downloads"</span>;</span><br><span class="line">     int state = mContext.getPackageManager().getApplicationEnabledSetting(packageName);</span><br><span class="line">     //检测下载管理器是否被禁用</span><br><span class="line">     <span class="keyword">if</span> (state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED</span><br><span class="line">         || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER</span><br><span class="line">         || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) &#123;</span><br><span class="line">         AlertDialog.Builder builder = new AlertDialog.Builder(mContext).setTitle(<span class="string">"温馨提示"</span>).setMessage</span><br><span class="line">             (<span class="string">"系统下载管理器被禁止，需手动打开"</span>).setPositiveButton(<span class="string">"确定"</span>, new DialogInterface.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void onClick(DialogInterface dialog, int <span class="built_in">which</span>) &#123;</span><br><span class="line">                 dialog.dismiss();</span><br><span class="line">                 try &#123;</span><br><span class="line">                     Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">                     intent.setData(Uri.parse(<span class="string">"package:"</span> + packageName));</span><br><span class="line">                     mContext.startActivity(intent);</span><br><span class="line">                 &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">                     Intent intent = new Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS);</span><br><span class="line">                     mContext.startActivity(intent);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).setNegativeButton(<span class="string">"取消"</span>, new DialogInterface.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void onClick(DialogInterface dialog, int <span class="built_in">which</span>) &#123;</span><br><span class="line">                 dialog.dismiss();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         builder.create().show();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         //正常下载流程</span><br><span class="line">         apkName = name;</span><br><span class="line">         DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));</span><br><span class="line">         request.setAllowedOverRoaming(<span class="literal">false</span>);</span><br><span class="line">         //通知栏显示  request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);</span><br><span class="line">         request.setTitle(AppUtils.getAppName(mContext));</span><br><span class="line">         request.setDescription(<span class="string">"正在下载中..."</span>);</span><br><span class="line">         request.setVisibleInDownloadsUi(<span class="literal">true</span>);</span><br><span class="line">         //设置下载存放的文件夹和文件名字  request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, apkName);</span><br><span class="line"></span><br><span class="line">         //获取DownloadManager</span><br><span class="line">         mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);</span><br><span class="line">         downloadId = mDownloadManager.enqueue(request);</span><br><span class="line">         mContext.registerReceiver(mReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private BroadcastReceiver mReceiver = new <span class="function"><span class="title">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">         checkStatus();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 检查下载状态</span><br><span class="line">  */</span><br><span class="line"> private void <span class="function"><span class="title">checkStatus</span></span>() &#123;</span><br><span class="line">     DownloadManager.Query query = new DownloadManager.Query();</span><br><span class="line">     query.setFilterById(downloadId);</span><br><span class="line">     Cursor cursor = mDownloadManager.query(query);</span><br><span class="line">     <span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">         int status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));</span><br><span class="line">         switch (status) &#123;</span><br><span class="line">             //下载暂停</span><br><span class="line">             <span class="keyword">case</span> DownloadManager.STATUS_PAUSED:</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">             //下载延迟</span><br><span class="line">             <span class="keyword">case</span> DownloadManager.STATUS_PENDING:</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">             //正在下载</span><br><span class="line">             <span class="keyword">case</span> DownloadManager.STATUS_RUNNING:</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">             //下载完成</span><br><span class="line">             <span class="keyword">case</span> DownloadManager.STATUS_SUCCESSFUL:</span><br><span class="line">                 installAPK();</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">             //下载失败</span><br><span class="line">             <span class="keyword">case</span> DownloadManager.STATUS_FAILED:</span><br><span class="line">                 Toast.makeText(mContext, <span class="string">"下载失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     cursor.close();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 7.0兼容</span><br><span class="line">  */</span><br><span class="line"> private void <span class="function"><span class="title">installAPK</span></span>() &#123;</span><br><span class="line">     File apkFile =</span><br><span class="line">         new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), apkName);</span><br><span class="line">     Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">     // 由于没有在Activity环境下启动Activity,设置下面的标签</span><br><span class="line">     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">     <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">         Uri apkUri = FileProvider.getUriForFile(mContext, mContext.getPackageName() + <span class="string">".provider"</span>, apkFile);</span><br><span class="line">         intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">         intent.setDataAndType(apkUri, <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         intent.setDataAndType(Uri.fromFile(apkFile), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     mContext.startActivity(intent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="android-7-0-DownloadManager不在按照文件名分享私人存储的文件"><a href="#android-7-0-DownloadManager不在按照文件名分享私人存储的文件" class="headerlink" title="android 7.0 DownloadManager不在按照文件名分享私人存储的文件"></a>android 7.0 DownloadManager不在按照文件名分享私人存储的文件</h4><ol>
<li><p>按照开发者官网上的描述，DownloadManager不在支持使用COLUMN_LOCAL_FILENAME访问路径，其会触发SecurityException。官方建议有DownloadManager公开的文件，首选<br>的访问方式是使用ContentResolver.openFileDescriptor()。</p>
</li>
<li><p>如果使用downloadManager做下载功能的且没有做7.0适配的话，在7.0读取数据库内容时会遇到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: COLUMN_LOCAL_FILENAME is deprecated; use ContentResolver.openFileDescriptor() instead</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在Android 7.0中通过DownloadManager根据downId获取的uri安装apk是会得到如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Caused by: android.os.FileUriExposedException: </span><br><span class="line">file:///storage/emulated/0/Download/myApp.apk exposed beyond app through Intent.getData()</span><br></pre></td></tr></table></figure></p>
<p>同时在7.0上通过DownloadManager根据downId获取的uri变为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content://downloads/all_downloads/430</span><br></pre></td></tr></table></figure></p>
<p>这些都是由于Android7.0执行了“StrictMode API 政策禁”的原因，可以用FileProvider来解决这一问题。</p>
<ol>
<li>原来的代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DownloadManager manager = (DownloadManager) mContext</span><br><span class="line">    .getSystemService(Context.DOWNLOAD_SERVICE);</span><br><span class="line">Cursor downloadCursor = dm.query(myDownloadQuery);</span><br><span class="line"><span class="keyword">if</span> (myDownload != null &amp;&amp; downloadCursor.moveToFirst()) &#123;</span><br><span class="line">    int fileNameIdx = downloadCursor</span><br><span class="line">        .getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME); </span><br><span class="line">    String filePath = downloadCursor.getString(fileNameIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="7-0获取文件路径"><a href="#7-0获取文件路径" class="headerlink" title="7.0获取文件路径"></a>7.0获取文件路径</h4><ol>
<li>DownloadManager.COLUMN_LOCAL_URI：DownloadManager的数据库表中应该是存放了对应的URI,目测应该是file: 协议开头。那看来可以通过查询这个URI，随后将URI转换成文件path路径。</li>
<li>代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DownloadManager manager = (DownloadManager) mContext</span><br><span class="line">    .getSystemService(Context.DOWNLOAD_SERVICE);</span><br><span class="line">Cursor downloadCursor= dm.query(myDownloadQuery);</span><br><span class="line"><span class="keyword">if</span> (downloadCursor!= null &amp;&amp; downloadCursor.moveToFirst()) &#123;</span><br><span class="line">    String filePath = null;</span><br><span class="line">    String downloadFileLocalUri = downloadCursor</span><br><span class="line">        .getString(downloadCursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));</span><br><span class="line">    <span class="keyword">if</span> (downloadFileLocalUri != null) &#123;</span><br><span class="line">        filePath = new File(Uri.parse(downloadFileLocalUri).getPath())</span><br><span class="line">            .getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h3><h4 id="Why-FileProvider？"><a href="#Why-FileProvider？" class="headerlink" title="Why FileProvider？"></a>Why FileProvider？</h4><ol>
<li>老生常谈的内容，为什么Android推荐使用FileProvider呢？其实FileProvider也不是一个新概念了，Google很早就提出这个概念了。这是因为Android上的权限管理过于松散，但是随着系统版本的不断提升，权限的不断收紧，对于进程之间的数据共享就产生了问题。于是FileProvider就出现了。</li>
<li>它通过在AndroidManifest中定义Provider，为指定的文件提供一个ContentURI，通过这个URI临时赋予第三方应用授权处理指定的某些文件。简而言之，也可以说成是使用ContentURI代替了FileURI。</li>
</ol>
<h4 id="fileprovider-使用场景"><a href="#fileprovider-使用场景" class="headerlink" title="fileprovider 使用场景"></a>fileprovider 使用场景</h4><ol>
<li>正如上面我们说到的DownloadManager的变更中，我们通过DownloadManager下载了一个APK。此时我们需要发送一个Intent，带着我们下载下来的APK的URI，通知系统的APK安装管理服务，安装这个应用。</li>
<li>此时，这个Intent就要带着这个URI离开我们的App，去到另一个应用。此时，我们就需要对这个URI进行处理。如果发送的Intent带的是一个FileURI，就会导致：<br>FileUriExposedException。</li>
</ol>
<h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p><1>  AndroidManifest.xml:在manifest中加入如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">        android:exported=<span class="string">"false"</span></span><br><span class="line">        android:grantUriPermissions=<span class="string">"true"</span></span><br><span class="line">        android:authorities=<span class="string">"com.×××.fileprovider"</span></span><br><span class="line">        android:name=<span class="string">"android.support.v4.content.FileProvider"</span>&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">            android:name=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span><br><span class="line">            android:resource=<span class="string">"@xml/file_paths"</span></span><br><span class="line">            /&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure></1></p>
<ul>
<li>exported要设置为false，否则会报安全异常。</li>
<li>grantUriPermissions设置为true，表示的是设置URI临时访问权限。</li>
<li>authorities可以随便写，不过一般最好是包名.fileprovider。当然也可以是其他。</li>
</ul>
<p><2> file_paths.xml:</2></p>
<ul>
<li><p>在manifest中有下面这一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:resource=&quot;@xml/file_paths&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们需要在res/xml目录下新建一个file_paths.xml的文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;paths&gt;</span><br><span class="line">        &lt;root-path</span><br><span class="line">             name=&quot;/&quot;</span><br><span class="line">             path=&quot;/&quot; /&gt;</span><br><span class="line">    &lt;/paths&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用是指定临时授权的路径，其选项有：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">root-paty</td>
<td style="text-align:center">根目录（/）</td>
</tr>
<tr>
<td style="text-align:center">external-path</td>
<td style="text-align:center">Context.getExternalStorageDirectory()</td>
</tr>
<tr>
<td style="text-align:center">file-path</td>
<td style="text-align:center">Context.getFilesDir()</td>
</tr>
<tr>
<td style="text-align:center">cache-path</td>
<td style="text-align:center">Context.getCacheDir()</td>
</tr>
</tbody>
</table>
<p>其中root-path指的是Android系统根目录，众所周知Android是基于Linux内核，所以Android的根目录就是“/”</p>
<p><3> 使用FileProvider:</3></p>
<ul>
<li><p>当我们拿到一个Apk文件时，需要启动安装界面进行安装。则可以使用以下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= 24) &#123;</span><br><span class="line">    File apkFile=new File(apkFile Path);</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">    Uri contentUri = FileProvider.getUriForFile(mContext,</span><br><span class="line">             <span class="string">"com.×××.fileprovider"</span>, apkFile);</span><br><span class="line">    intent.setDataAndType(contentUri,</span><br><span class="line">             <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    mContext.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用FileProvider.getUriForFile()将一个FileURI转换成ContentURI</p>
</li>
<li>并且不要忘记添加Intent.FLAG_GRANT_READ_URI_PERMISSION临时的读或者写权限。这样就完成一个FileProvider共享的使用了。</li>
</ul>
<p><strong>后记</strong></p>
<ol>
<li>已兼容7.0私有文件权限问题</li>
<li>对于部分机型默认或者一些原因，下载管理器是被禁用掉的，必须手动开启或者写代码去跳转到设置界面开启，代码中已兼容。</li>
</ol>
<p>来源：<br><a href="http://www.ryanhuen.tech/2017/02/28/Android-N-Diff/" target="_blank" rel="noopener">http://www.ryanhuen.tech/2017/02/28/Android-N-Diff/</a><br><a href="http://www.jianshu.com/p/3eb4106133f4" target="_blank" rel="noopener">http://www.jianshu.com/p/3eb4106133f4</a><br><a href="http://blog.csdn.net/yulianlin/article/details/52775160" target="_blank" rel="noopener">http://blog.csdn.net/yulianlin/article/details/52775160</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/24/downloadManagerSupport7-0/" data-id="cjicvd90v000bwqs66h5ukxga" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/7/">7</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Support/">Support</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git命令和使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/git命令和使用/" class="article-date">
  <time datetime="2017-06-24T12:23:20.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/24/git命令和使用/">git命令和使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="git命令详解"><a href="#git命令详解" class="headerlink" title="git命令详解"></a>git命令详解</h3><p>git命令形式：<br>usage: git [–version] [–help] [-C &lt; path &gt;] [ -c name=value ]<br>           [–exec-path[ = &lt; path &gt; ] ] [–html-path] [–man-path] [–info-path]<br>           [-p | –paginate | –no-pager] [–no-replace-objects] [–bare]<br>           [–git-dir=&lt; path &gt;] [–work-tree=&lt; path &gt;] [–namespace=&lt; name &gt;]<br>           &lt; command &gt; [&lt; args &gt;]</p>
<p>These are common Git commands used in various situations:</p>
<ol>
<li><p>start a working area (see also: git help tutorial)</p>
<ul>
<li>clone  :    Clone a repository into a new directory</li>
<li>init    :   Create an empty Git repository or reinitialize an existing one</li>
</ul>
</li>
<li><p>work on the current change (see also: git help everyday)</p>
<ul>
<li>add     :   Add file contents to the index</li>
<li>mv      :   Move or rename a file, a directory, or a symlink</li>
<li>reset   :   Reset current HEAD to the specified state</li>
<li>rm      :   Remove files from the working tree and from the index</li>
</ul>
</li>
<li><p>examine the history and state (see also: git help revisions)</p>
<ul>
<li>bisect :    Use binary search to find the commit that introduced a bug</li>
<li>grep    :   Print lines matching a pattern</li>
<li>log     :   Show commit logs</li>
<li>show    :   Show various types of objects</li>
<li>status    : Show the working tree status</li>
</ul>
</li>
<li><p>grow, mark and tweak your common history</p>
<ul>
<li>branch :    List, create, or delete branches</li>
<li>checkout:   Switch branches or restore working tree files</li>
<li>commit   :  Record changes to the repository</li>
<li>diff      : Show changes between commits, commit and working tree, etc</li>
<li>merge  :    Join two or more development histories together</li>
<li>rebase  :   Reapply commits on top of another base tip</li>
<li>tag        :Create, list, delete or verify a tag object signed with GPG</li>
</ul>
</li>
<li><p>collaborate (see also: git help workflows)</p>
<ul>
<li>fetch    :  Download objects and refs from another repository</li>
<li>pull     :  Fetch from and integrate with another repository or a local branch</li>
<li>push    :   Update remote refs along with associated objects</li>
</ul>
</li>
</ol>
<p>‘git help -a’ and ‘git help -g’ list available subcommands and some<br>concept guides. See ‘git help &lt; command &gt;’ or ‘git help &lt; concept &gt;’<br>to read about a specific subcommand or concept.</p>
<h3 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h3><h4 id="git诞生"><a href="#git诞生" class="headerlink" title="git诞生"></a>git诞生</h4><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
<h4 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h4><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><img src="images/inCenter.jpg" alt="集中式管理"></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="images/onNode.jpg" alt="分布式管理"></p>
<p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>
<p>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p>
<p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p>
<p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p>
<p>》》》》读者解读<br>Git与SVN的主要差别：这两个工具主要的区别在于历史版本维护的位置。<br>Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史；<br>而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行；<br>这样的好处在于：<br>1、自己可以在脱机环境查看开发的版本历史<br>2、多人开发时如果充当中央仓库的Git仓库挂了，任何一个开发者的仓库都可以作为中央仓库进行服务<br>》》》</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<ol>
<li>在linux上安装Git<br>首先，你可以试着输入git，看看系统有没有安装Git：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program <span class="string">'git'</span> is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>安装Git</p>
<p>阅读: 1563566<br>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<p>在Linux上安装Git</p>
<p>首先，你可以试着输入git，看看系统有没有安装Git：</p>
<p>$ git<br>The program ‘git’ is currently not installed. You can install it by typing:<br>sudo apt-get install git<br>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<ol>
<li>在Mac OS X上安装Git<br>如果你正在使用Mac做开发，有两种安装Git的方法。</li>
</ol>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。<br><img src="images/MacInstallGit.jpg" alt="Mac下安装Git"></p>
<ol>
<li>在Windows上安装Git</li>
</ol>
<p>Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。</p>
<p>msysgit是Windows版的Git，从<a href="https://git-for-windows.github.io下载（网速慢的同学请移步国内镜像），然后按默认选项安装即可。" target="_blank" rel="noopener">https://git-for-windows.github.io下载（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</a></p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br><img src="images/WindowsInstallGit.jpg" alt="windows下安装Git"></p>
<p><strong>安装好最后</strong></p>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure></p>
<p>pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。</p>
<p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p>
<p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></p>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p>
<p><strong>把文件添加到版本库</strong></p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>使用Windows的童鞋要特别注意：</p>
<p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发的记事本会在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：<br><img src="images/notepad++.jpg" alt="notepad++设置"><br>言归正传，现在我们编写一个readme.txt文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令git add告诉Git，把文件添加到仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令git commit告诉Git，把文件提交到仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"wrote a readme file"</span></span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p>
<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p>git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步：</p>
<p>第一步，使用命令git add &lt; file &gt;，注意，可反复多次使用，添加多个文件；</p>
<p>第二步，使用命令git commit，完成。</p>
<h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>现在，运行git status命令看看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。</p>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add distributed"</span></span><br><span class="line">[master ea34578] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。<br><strong>小结</strong></p>
<ul>
<li>要随时掌握工作区的状态，使用git status命令。</li>
<li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容</li>
</ul>
<p>》》》读者解读</p>
<ol>
<li><p>git add 的各种区别:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A   // 添加所有改动</span><br><span class="line">git add *    // 添加新建文件和修改，但是不包括删除</span><br><span class="line">git add .    // 添加新建文件和修改，但是不包括删除</span><br><span class="line">git add -u   // 添加修改和删除，但是不包括新建文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 commit 前撤销 add:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt; // 撤销提交单独文件</span><br><span class="line">git reset        // unstage all due changes</span><br></pre></td></tr></table></figure>
</li>
<li><p>add/commit 前撤销对文件的修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- README.md  // 注意, add添加后(同commit提交后)就无法通过这种方式撤销修改</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>》》》</p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>然后尝试提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m <span class="string">"append GPL"</span></span><br><span class="line">[master 3628164] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>版本2：add distributed<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>版本3：append GPL<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL</span><br><span class="line">ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85 add distributed</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>需要友情提示的是，你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：<br><img src="images/timeline.jpg" alt="时间线"><br>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ea34578 add distributed</span><br></pre></td></tr></table></figure></p>
<p>–hard参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看readme.txt的内容是不是版本add distributed：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure></p>
<p>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8<span class="built_in">cd</span>576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3628164</span><br><span class="line">HEAD is now at 3628164 append GPL</span><br><span class="line">``` </span><br><span class="line">版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</span><br><span class="line"></span><br><span class="line">再小心翼翼地看看readme.txt的内容：</span><br><span class="line">```bash</span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure></p>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：<br><img src="images/headFirst.jpg" alt="head指向"><br>改为指向add distributed：</p>
<p><img src="images/headtwo.jpg" alt="修改head指向"><br>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<p> 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。<br><strong>小结</strong></p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。<br>》》》读者解读<br>git reflog  与 git log区别:</li>
<li>git log :是当你回退到某个版本，此版本之后的记录，就自动抹去了</li>
<li>git reflog:是你提交的完整的命令历史，回退到某个版本，仍然可以查到位于此版本之后的版本号。<br>》》》</li>
</ul>
<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br><strong> 工作区（Working Directory）</strong><br>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：<br><img src="images/workingDirect.png" alt="工作区"></p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="images/Repository.jpg" alt="版本库"></p>
<p>分支和HEAD的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure></p>
<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       LICENSE</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   LICENSE</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="images/gitAdd.jpg" alt="存放暂存区"><br>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master 27c9860] understand how stage works</span><br><span class="line"> 2 files changed, 675 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：<br><img src="images/gitCommit.jpg" alt="提交到本地仓库"><br>》》》读者解读</p>
<ul>
<li>git diff    #是工作区(work dict)和暂存区(stage)的比较</li>
<li>git diff –cached    #是暂存区(stage)和分支(master)的比较<br>》》》</li>
</ul>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure></p>
<p>然后，添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>然后，再修改readme.txt：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"git tracks changes"</span></span><br><span class="line">[master d4f25b6] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>提交后，再看看状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>咦，怎么第二次的修改没有被提交？</p>
<p>别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>
<p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>可见，第二次修改确实没有被提交。那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit<br>好，现在，把第二次修改提交了。</p>
<p><strong>小结</strong></p>
<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p>
<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>现在，看看readme.txt的文件内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files</span><br></pre></td></tr></table></figure>
<p>文件内容果然复原了。<br>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p>再用git status查看一下，现在暂存区是干净的，工作区有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>整个世界终于清静了！</p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong><br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。<br>》》》读者解读<br><img src="images/basic-usage.svg" alt="文件层面操作"></p>
<ul>
<li>git add files 把当前文件放入暂存区域。</li>
<li>git commit 给暂存区域生成快照并提交。</li>
<li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li>
<li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改</li>
</ul>
<p><img src="iamges/checkout-files.svg" alt="checkout"><br>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当给定某个文件名时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，git checkout HEAD~ foo.c会将提交节点HEAD~(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。<br><img src="images/checkout-branch.svg" alt="checkout-branch."><br>当不指定文件名，而是给出一个（本地）分支时，那么HEAD标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和HEAD对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。<br><img src="images/checkout-detached.svg" alt="checkout-detached"><br>如果既没有指定文件, 也没有指定分枝. 而是只给出一段提交的历史Hash, 只有HEAD会移动到相应的历史提交. 这会造成HEAD分离, 非常危险的操作, 这个命令的说明只是为了满足你的好奇心而已, 不要使用这个命令.<br><img src="images/reset-commit.svg" alt="reset-commit"><br>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变。</p>
<p><img src="images/reset.svg" alt="reset"><br>如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard选项，工作目录也同样。<br>》》》</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m <span class="string">"add test.txt"</span></span><br><span class="line">[master 94cdc44] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure></p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleted:    test.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">'test.txt'</span></span><br><span class="line">$ git commit -m <span class="string">"remove test.txt"</span></span><br><span class="line">[master d17efd8] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></p>
<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p><strong>小结</strong><br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure></p>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br><img src="images/addSshKey.png" alt="addSshKey"><br>点“Add Key”，你就应该看到已经添加的Key：<br><img src="images/SSHkeys.png" alt="keys"><br>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><img src="images/createRepo.png" alt="createRepo"><br>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库:<br><img src="images/seeRepo.png" alt="confirm repo"><br>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (19/19), 13.73 KiB, done.</span><br><span class="line">Total 23 (delta 6), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin</span><br></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：<br><img src="images/repoFiles.png" alt="files lise"><br>从现在起，只要本地作了提交，就可以通过命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！<br>SSH警告<br>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'github.com (xx.xx.xx.xx)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is xx.xx.xx.xx.xx.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'github.com'</span> (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。<br>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p>
<p><strong>小结</strong><br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；<br>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；<br>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>当远程库已经准备好了，下一步是用命令git clone克隆一个本地库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into <span class="string">'gitskills'</span>...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p>
<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。<br> 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。<br>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/**.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="noopener">https://github.com/michaelliao/**.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<p><strong>小结</strong><br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！<br>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="images/head_master.png" alt="head master"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="images/head_dev.png" alt="head dev"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p><img src="images/head_dev_new.png" alt="head pointer new"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="images/head_merge.png" alt="head merge"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="images/head_new.png" alt="head new"><br>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。<br>首先，我们创建dev分支，然后切换到dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>
<p>然后，用git branch命令查看当前分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure></p>
<p>然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev fec145a] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：<br><img src="images/head_master_dev.png" alt="head pointer master"></p>
<p>现在，我们把dev分支的工作成果合并到master分支上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure>
<p>删除后，查看branch，就只剩下master分支了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
<p><strong>小结</strong><br>Git鼓励大量使用分支：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch &lt; name &gt;</li>
<li>切换分支：git checkout &lt; name &gt;</li>
<li>创建+切换分支：git checkout -b &lt; name &gt;</li>
<li>合并某分支到当前分支：git merge &lt; name &gt;</li>
<li>删除分支：git branch -d &lt; name &gt;</li>
</ul>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的feature1分支，继续我们的新分支开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt最后一行，改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure></p>
<p>在feature1分支上提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 75a857c] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>切换到master分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br></pre></td></tr></table></figure></p>
<p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 400b400] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：</p>
<p><img src="images/head_master_branch.png" alt="master not same with branch"><br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></p>
<p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/master' by 2 commits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unmerged paths:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." as appropriate to mark resolution)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       both modified:      readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接查看readme.txt的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure></p>
<p>再提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master 59bc1cb] conflict fixed</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支变成了下图所示：<br><img src="images/head_branch_fix.png" alt="branch fix on master"></p>
<p>用带参数的git log也可以看到分支的合并情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 75a857c AND simple</span><br><span class="line">* | 400b400 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* fec145a branch <span class="built_in">test</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>最后，删除feature1分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> feature1</span><br><span class="line">Deleted branch feature1 (was 75a857c).</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用git log –graph命令可以看到分支合并图。</p>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt文件，并提交一个新的commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"add merge"</span></span><br><span class="line">[dev 6224937] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们切换回master：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></p>
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   7825a50 merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 6224937 add merge</span><br><span class="line">|/</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到，不使用Fast forward模式，merge后就像这样：<br><img src="images/head_merge_without_ff.png" alt="merge without fast forward"></p>
<p><strong>分支策略</strong><br>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：<br><img src="images/branchs.png" alt="分支管理"></p>
<p><strong>小结</strong><br>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   hello.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class="line">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure></p>
<p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure></p>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-101 cc17032] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p>
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">$ git branch <span class="_">-d</span> issue-101</span><br><span class="line">Deleted branch issue-101 (was cc17032).</span><br></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>
<p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</span><br></pre></td></tr></table></figure></p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line"><span class="comment"># On branch dev</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   hello.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure></p>
<p>再用git stash list查看，就看不到任何stash内容了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure></p>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong><br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch <span class="string">'feature-vulcan'</span></span><br></pre></td></tr></table></figure></p>
<p>5分钟后，开发完毕：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch feature-vulcan</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   vulcan.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ git commit -m <span class="string">"add feature vulcan"</span></span><br><span class="line">[feature-vulcan 756d4af] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure></p>
<p>切回dev，准备合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="_">-d</span> feature-vulcan</span><br><span class="line">error: The branch <span class="string">'feature-vulcan'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D feature-vulcan'</span>.</span><br></pre></td></tr></table></figure></p>
<p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p>
<p>现在我们强行删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 756d4af).</span><br></pre></td></tr></table></figure></p>
<p>终于删除成功！</p>
<p><strong>小结</strong></p>
<p>开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt; name &gt;强行删除。</p>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用git remote：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>或者，用git remote -v显示更详细的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<p><strong>推送分支</strong></p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>如果要推送其他分支，比如dev，就改成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p><strong>抓取分支</strong><br>多人协作时，大家都会往master和dev分支上推送各自的修改。<br>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 46, done.</span><br><span class="line">remote: Compressing objects: 100% (26/26), done.</span><br><span class="line">remote: Total 46 (delta 16), reused 45 (delta 15)</span><br><span class="line">Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (16/16), done.</span><br></pre></td></tr></table></figure></p>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>
<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add /usr/bin/env"</span></span><br><span class="line">[dev 291bea8] add /usr/bin/env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 349 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line">   <span class="built_in">fc</span>38031..291bea8  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.py </span><br><span class="line">$ git commit -m <span class="string">"add coding: utf-8"</span></span><br><span class="line">[dev bd6ae48] add coding: utf-8</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Merge the remote changes (e.g. <span class="string">'git pull'</span>)</span><br><span class="line">hint: before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure></p>
<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   <span class="built_in">fc</span>38031..291bea8  dev        -&gt; origin/dev</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream dev origin/&lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream dev origin/dev</span><br><span class="line">Branch dev <span class="built_in">set</span> up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure></p>
<p>再pull：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.py</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></p>
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"merge &amp; fix hello.py"</span></span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 10, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 747 bytes, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line">   291bea8..adca45d  dev -&gt; dev</span><br></pre></td></tr></table></figure></p>
<p>因此，多人协作的工作模式通常是这样：</p>
<ul>
<li>首先，可以试图用git push origin branch-name推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<pre><code>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。
</code></pre></li>
</ul>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<ul>
<li>查看远程库信息，使用git remote -v；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li>
<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”，“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”，“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>然后，敲命令git tag &lt; name &gt;就可以打一个新标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p>
<p>可以用命令git tag查看所有标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">6a5819e merged bug fix 101</span><br><span class="line">cc17032 fix bug 101</span><br><span class="line">7825a50 merge with no-ff</span><br><span class="line">6224937 add merge</span><br><span class="line">59bc1cb conflict fixed</span><br><span class="line">400b400 &amp; simple</span><br><span class="line">75a857c AND simple</span><br><span class="line">fec145a branch <span class="built_in">test</span></span><br><span class="line">d17efd8 remove test.txt</span><br></pre></td></tr></table></figure></p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 6224937</span><br></pre></td></tr></table></figure>
<p>再用命令git tag查看标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt; tagname &gt;查看标签信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 11:22:08 2013 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到，v0.9确实打在add merge这次提交上，还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-a</span> v0.1 -m <span class="string">"version 0.1 released"</span> 3628164</span><br></pre></td></tr></table></figure></p>
<p>用命令git show &lt; tagname &gt;可以看到说明文字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 26 07:28:11 2013 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure>
<p>还可以通过-s用私钥签名一个标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-s</span> v0.2 -m <span class="string">"signed version 0.2 released"</span> fec145a</span><br></pre></td></tr></table></figure></p>
<p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: signing failed: secret key not available</span><br><span class="line">error: gpg failed to sign the data</span><br><span class="line">error: unable to sign the tag</span><br></pre></td></tr></table></figure></p>
<p>如果报错，请参考GnuPG帮助文档配置Key，用命令git show &lt; tagname &gt;可以看到PGP签名信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.2</span><br><span class="line">tag v0.2</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 26 07:28:33 2013 +0800</span><br><span class="line"></span><br><span class="line">signed version 0.2 released</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1.4.12 (Darwin)</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">commit fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 10:37:30 2013 +0800</span><br><span class="line"></span><br><span class="line">    branch <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令git tag &lt; name &gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li>git tag -a &lt; tagname &gt; -m “blablabla…”可以指定标签信息；</li>
<li>git tag -s &lt; tagname &gt; -m “blablabla…”可以用PGP签名标签；</li>
<li>命令git tag可以查看所有标签。</li>
</ul>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-d</span> v0.1</span><br><span class="line">Deleted tag <span class="string">'v0.1'</span> (was e078af9)</span><br></pre></td></tr></table></figure></p>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。<br>如果要推送某个标签到远程，使用命令git push origin &lt; tagname &gt;：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure></p>
<p>或者，一次性推送全部尚未推送到远程的本地标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 554 bytes, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.2 -&gt; v0.2</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-d</span> v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was 6224937)</span><br></pre></td></tr></table></figure></p>
<p>然后，从远程删除。删除命令也是push，但是格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></p>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令git push origin &lt; tagname &gt;可以推送一个本地标签；</li>
<li>命令git push origin –tags可以推送全部未推送过的本地标签；</li>
<li>命令git tag -d &lt; tagname&gt;可以删除一个本地标签；</li>
<li>命令git push origin :refs/tags/&lt; tagname &gt;(git push origin –delete tag v0.9  )?可以删除一个远程标签。</li>
</ul>
<h3 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure></p>
<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：<br><img src="images/gitclone.png" alt="git clone"><br>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull" target="_blank" rel="noopener">https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，我会视心情而定是否接受。</p>
<p><strong>小结</strong></p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h3 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h3><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。比如，让Git显示颜色，会让命令输出看起来更醒目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>这样，Git会适当地显示不同的颜色，比如git status命令：<br><img src="images/gitcolor.png" alt="git设置好颜色后"><br>文件名就会标上颜色,我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。</p>
<h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动3. 生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>举个例子：<br>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python:</span></span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure></p>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows:</span></span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python:</span></span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"><span class="comment"># My configurations:</span></span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure></p>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use <span class="_">-f</span> <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure></p>
<p>如果你确实想添加该文件，可以用-f强制添加到Git：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="_">-f</span> App.class</span><br></pre></td></tr></table></figure>
<p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class    App.class</span><br></pre></td></tr></table></figure></p>
<p>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p><strong>小结</strong></p>
<ul>
<li>忽略某些文件时，需要编写.gitignore；</li>
<li>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</li>
</ul>
<h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。我们只需要敲一行命令，告诉Git，以后st就表示status：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure></p>
<p>好了，现在敲git st看看效果，当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure></p>
<p>以后提交就可以简写成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m <span class="string">"bala bala bala..."</span></span><br></pre></td></tr></table></figure></p>
<p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br></pre></td></tr></table></figure></p>
<p>当你敲入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure></p>
<p>实际上Git执行的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure></p>
<p>配置一个git last，让其显示最后一次提交信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last <span class="string">'log -1'</span></span><br></pre></td></tr></table></figure></p>
<p>这样，用git last就能显示最近一次的提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure>
<p>甚至还有人丧心病狂地把lg配置成了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure></p>
<p>来看看git lg的效果：<br><img src="images/gitcustom.png" alt="git 别名配置"><br>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p>
<p><strong>配置文件</strong></p>
<p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure></p>
<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure></p>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h4 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h4><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>第二步，创建一个git用户，用来运行git服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure></p>
<p>第三步，创建证书登录：<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure></p>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></p>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@server:/srv/sample.git</span><br><span class="line">Cloning into <span class="string">'sample'</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p>
<p>剩下的推送就简单了。</p>
<p><strong>管理公钥</strong></p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p>这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>
<p><strong>管理权限</strong></p>
<p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。</p>
<p>这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p>
<p><strong>小结</strong></p>
<ul>
<li>搭建Git服务器非常简单，通常10分钟即可完成；</li>
<li>要方便管理公钥，用Gitosis；</li>
<li>要像SVN那样变态地控制权限，用Gitolite。</li>
</ul>
<p>来源<br>教程：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/24/git命令和使用/" data-id="cjicvd92e001uwqs62n20egkh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/">Tool</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bitmap压缩" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/Bitmap压缩/" class="article-date">
  <time datetime="2017-06-21T15:44:41.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/Bitmap压缩/">Bitmap压缩</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>&ensp;&ensp;要做图片压缩首先我们的了解bitmap占用内存的计算方式：<br>bitmap大小=图片长度X图片宽度X一个像素点占用的字节数<br>&ensp;&ensp;而像素点占用的字节数通过压缩格式来指定：</p>
<table>
<thead>
<tr>
<th style="text-align:center">来源</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">所占字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ALPHA_8</td>
<td style="text-align:center">表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ARGB_4444</td>
<td style="text-align:center">表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">ARGB_8888</td>
<td style="text-align:center">表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节</td>
</tr>
<tr>
<td style="text-align:center">Bitmap.Config</td>
<td style="text-align:center">RGB_565</td>
<td style="text-align:center">表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节</td>
</tr>
</tbody>
</table>
<h3 id="压缩方法介绍"><a href="#压缩方法介绍" class="headerlink" title="压缩方法介绍"></a>压缩方法介绍</h3><p>&ensp;&ensp;下面我们开始介绍几种压缩方式：</p>
<ol>
<li>质量压缩<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> quality = Integer.valueOf(editText.getText().toString());</span><br><span class="line">            <span class="comment">//quality-压缩率：1~100的整数，越小压缩出的图片越小质量越差，100则不压缩。</span></span><br><span class="line">            bit.compress(CompressFormat.JPEG, quality, baos);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            bm = BitmapFactory.decodeByteArray(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight()</span><br><span class="line">                    + <span class="string">"bytes.length=  "</span> + (bytes.length / <span class="number">1024</span>) + <span class="string">"KB"</span></span><br><span class="line">                    + <span class="string">"quality="</span> + quality)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;其中quality是从edittext获取的数字或自己制定，可以从1–100改变，100表示百分百，也就是不压缩，原型输出，数字越小表示质量越差当然内存也就越小。<strong>注意</strong>bit.compress(CompressFormat.PNG, quality, baos);<em>设定png格式，quality就没有作用了，bytes.length不会变化，因为png图片是无损的?(待验证，网上资料都是通过减小这个值来减少内存)</em>，不能进行压缩，CompressFormat还有一个属性是，CompressFormat.WEBP格式，该格式是google自己推出来一个图片格式。</p>
<ol>
<li>采样率压缩<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果把options.inJustDecodeBounds 设置成true,表示只返回宽高。</span></span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options.inSampleSize = <span class="number">2</span>;</span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">"/DCIM/Camera/test.jpg"</span>, options);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;设置inSampleSize的值(int类型)后，假如设为2，则宽和高都为原来的1/2，宽高都减少了，自然内存也降低了。上面的代码没用过options.inJustDecodeBounds = true; 因为我是固定来取样的数据，为什么这个压缩方法叫采样率压缩，是因为配合inJustDecodeBounds，先获取图片的宽、高【这个过程就是取样】，然后通过获取的宽高，动态的设置inSampleSize的值，当inJustDecodeBounds设置为true的时候，BitmapFactory通过decodeResource或者decodeFile解码图片时，将会返回空(null)的Bitmap对象，这样可以避免Bitmap的内存分配，但是它可以返回Bitmap的宽度、高度以及MimeType。</p>
<ol>
<li>缩放法压缩(martix)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">            matrix.setScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            bm = Bitmap.createBitmap(bit, <span class="number">0</span>, <span class="number">0</span>, bit.getWidth(),</span><br><span class="line">                    bit.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;通过scale的设定，bitmap的长度和宽度分别缩小了一半，图片大小缩小了四分之一。</p>
<ol>
<li>RGB_565法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options2 = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options2.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line"></span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">"/DCIM/Camera/test.jpg"</span>, options2);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">"M宽度为"</span> + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;图片大小会直接缩小了一半，长度和宽度也没有变，相比argb_8888减少了一半的内存。</p>
<p><strong>注意</strong>：由于ARGB_4444的画质惨不忍睹，一般假如对图片没有透明度要求的话，可以改成RGB_565，相比ARGB_8888将节省一半的内存开销。</p>
<ol>
<li>createScaleBitmap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bm = Bitmap.createScaledBitmap(bit, <span class="number">150</span>, <span class="number">150</span>, <span class="keyword">true</span>);</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"压缩后图片的大小"</span> + (bm.getByteCount() / <span class="number">1024</span>) + <span class="string">"KB宽度为"</span></span><br><span class="line">                    + bm.getWidth() + <span class="string">"高度为"</span> + bm.getHeight());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&ensp;&ensp;这里是将图片压缩成用户所期望的长度和宽度，但是这里要说，如果用户期望的长度和宽度和原图长度宽度相差太多的话，图片会很不清晰。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&ensp;&ensp;以上就是5种图片压缩的方法，需要强调的是他们的压缩仅仅只是对android中的bitmap来说的。如果将这些压缩后的bitmap另存为sd中，他们的内存大小并不一样。android手机中，图片的所占的内存大小和很多因素相关，计算起来也很麻烦。为了计算出一个图片的内存大小，可以将图片当做一个文件来间接计算，用如下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory()</span><br><span class="line">         .getAbsolutePath() + <span class="string">"/DCIM/Camera/test.jpg"</span>);</span><br><span class="line">         Log.i(<span class="string">"wechat"</span>, <span class="string">"file.length()="</span> + file.length() / <span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"wechat"</span>, <span class="string">"fis.available()="</span> + fis.available() / <span class="number">1024</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;上面两个方法计算的结果是一样的。其实说白了，Bitmap压缩都是围绕公式：Bitmap所占用的内存 = 图片长度 x 图片宽度 x 一个像素点占用的字节数 ，3个参数，任意减少一个的值，就达到了压缩的效果。</p>
<p><strong>注意</strong> 当我们通过BitmapFactory来decode网络或者本地图片是需要提前计算出压缩出来的图片大小，如果不提前处理会出现OOM，举个栗子：从本地读取一个4M的图片到bitmap时，bitmap的内存占用可能是20M，而系统分配给app的内存最大空间可能为16M，结果就是OOM了，-^-。</p>
<p>来源：<a href="http://blog.csdn.net/harryweasley/article/details/51955467" target="_blank" rel="noopener">http://blog.csdn.net/harryweasley/article/details/51955467</a><br>参考：<br>Android Bitmap 优化(1) - 图片压缩 <a href="http://anany.me/2015/10/15/bitmap1/" target="_blank" rel="noopener">http://anany.me/2015/10/15/bitmap1/</a><br>多图比较谷歌WebP和JPEG图像格式<a href="http://www.win7china.com/html/8668.html" target="_blank" rel="noopener">http://www.win7china.com/html/8668.html</a><br>Android-使用Matrix对Bitmap进行处理<a href="http://blog.csdn.net/nupt123456789/article/details/24600055" target="_blank" rel="noopener">http://blog.csdn.net/nupt123456789/article/details/24600055</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/21/Bitmap压缩/" data-id="cjicvd90c0001wqs67lhfroq6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Options/">Options</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-download-manager使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/19/android-download-manager使用/" class="article-date">
  <time datetime="2017-06-19T14:51:02.000Z" itemprop="datePublished">2017-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/19/android-download-manager使用/">android_download_manager使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&ensp;&ensp;从Android 2.3（Api level 9）开始Android用系统服务的方式提供了Download Manager来优化处理长时间的下载操作。Download Manager处理<strong>HTTP/HTTPS</strong>连接并监控连接中的状态变化以及重启来确保每一个下载任务顺利完成。<br>&ensp;&ensp;在大多数涉及到下载的情况中使用Download Manager都是不错的选择，特别是当用户切换不同的应用以后下载需要在后台继续进行，以及当下载任务顺利完成非常重要的情况（DownloadManager对于断点续传功能支持很好）。<br>&ensp;&ensp;要想使用Download Manager，使用getSystemService方法请求系统的DOWNLOAD_SERVICE服务，代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String serviceString = Context.DOWNLOAD_SERVICE;  </span><br><span class="line">DownloadManager downloadManager;  </span><br><span class="line">downloadManager = (DownloadManager) getSystemService(serviceString);</span><br></pre></td></tr></table></figure></p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>&ensp;&ensp;需要一个请求下载操作，创建一个DownloadManager.Request对象，将要请求下载的文件的Uri传递给Download Manager的enqueue方法，代码片段如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"http://developer.android.com/shareables/icon_templates-v4.0.zip"</span>);  </span><br><span class="line">DownloadManager.Request request = <span class="keyword">new</span> Request(uri);  </span><br><span class="line"><span class="keyword">long</span> reference = downloadManager.enqueue(request);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;在这里返回的reference变量是系统为当前的下载请求分配的一个唯一的ID，我们可以通过这个ID重新获得这个下载任务，进行一些自己想要进行的操作或者查询下载的状态以及取消下载等等。</p>
<p>&ensp;&ensp;我们可以通过addRequestHeader方法为DownloadManager.Request对象request添加HTTP头，也可以通过setMimeType方法重写从服务器返回的mime type。</p>
<p>&ensp;&ensp;我们还可以指定在什么连接状态下执行下载操作。setAllowedNetworkTypes方法可以用来限定在WiFi还是手机网络下进行下载，setAllowedOverRoaming方法可以用来阻止手机在漫游状态下下载。</p>
<p>&ensp;&ensp;下面的代码片段用于指定一个较大的文件只能在WiFi下进行下载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setAllowedNetworkTypes(Request.NETWORK_WIFI);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Android API level 11 介绍了getRecommendedMaxBytesOverMobile类方法（静态方法），返回一个当前手机网络连接下的最大建议字节数，可以来判断下载是否应该限定在WiFi条件下。</p>
<p>&ensp;&ensp;调用enqueue方法之后，只要数据连接可用并且Download Manager可用，下载就会开始。</p>
<p>&ensp;&ensp;要在下载完成的时候获得一个系统通知（notification）,注册一个广播接受者来接收<strong>ACTION_DOWNLOAD_COMPLETE</strong>广播，这个广播会包含一个<br><strong>EXTRA_DOWNLOAD_ID</strong>信息在intent中包含了已经完成的这个下载的ID,代码片段如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);       </span><br><span class="line">BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (myDownloadReference == reference) &#123;  </span><br><span class="line">      <span class="comment">//do something </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;使用Download Manager的openDownloadedFile方法可以打开一个已经下载完成的文件，返回一个ParcelFileDescriptor对象。我们可以通过Download Manager来查询下载文件的保存地址，如果在下载时制定了路径和文件名，我们也可以直接操作文件。</p>
<p>&ensp;&ensp;我们可以为<strong>ACTION_NOTIFICATION_CLICKED</strong> action注册一个广播接受者，当用户从通知栏点击了一个下载项目或者从Downloads app点击可一个下载的项目的时候，系统就会发出一个点击下载项的广播。<br>代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(DownloadManager.ACTION_NOTIFICATION_CLICKED);    </span><br><span class="line">BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">    String extraID = DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS;  </span><br><span class="line">    <span class="keyword">long</span>[] references = intent.getLongArrayExtra(extraID);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> reference : references)  </span><br><span class="line">      <span class="keyword">if</span> (reference == myDownloadReference) &#123;  </span><br><span class="line">        <span class="comment">// Do something with downloading file.  </span></span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure></p>
<h3 id="定制Download-Manager-Notifications的样式"><a href="#定制Download-Manager-Notifications的样式" class="headerlink" title="定制Download Manager Notifications的样式"></a>定制Download Manager Notifications的样式</h3><p>&ensp;&ensp;默认情况下，通知栏中会显示被Download Manager管理的每一个download每一个Notification会显示当前的下载进度和文件的名字。通过Download Manager可以为每一个download request定制Notification的样式，包括完全隐藏Notification。下面的代码片段显示了通过setTitle和setDescription方法来定制显示在文件下载Notification中显示的文字（下载的通知icon不可更改？）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setTitle(“Earthquakes”);  </span><br><span class="line">request.setDescription(“Earthquake XML”);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;request.setNotificationVisibility方法可以用来控制什么时候显示Notification，甚至隐藏该request的Notification。有以下几个参数：</p>
<ol>
<li>Request.VISIBILITY_VISIBLE：在下载进行的过程中，通知栏中会一直显示该下载的Notification，当下载完成时，该Notification会被移除，这是默认的参数值；</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED：在下载过程中通知栏会一直显示该下载的Notification，在下载完成后该Notification会继续显示，直到用户点击该Notification或者消除该Notification；</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION：只有在下载完成后该Notification才会被显示；</li>
<li>Request.VISIBILITY_HIDDEN：不显示该下载请求的Notification。如果要使用这个参数，需要在应用的清单文件中加上DOWNLOAD_WITHOUT_NOTIFICATION权限。</li>
</ol>
<h3 id="指定下载保存地址"><a href="#指定下载保存地址" class="headerlink" title="指定下载保存地址"></a>指定下载保存地址</h3><p>&ensp;&ensp;默认情况下，所有通过Download Manager下载的文件都保存在一个共享下载缓存中，使用系统生成的文件名每一个Request对象都可以制定一个下载保存的地址，通常情况下，所有的下载文件都应该保存在外部存储中，所以我们需要在应用清单文件中加上WRITE_EXTERNAL_STORAGE权限：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE”/&gt;</span><br></pre></td></tr></table></figure></p>
<p> 下面的代码片段是在外部存储中指定一个任意的保存位置的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationUri(Uri.fromFile(f));   <span class="comment">// f是一个File对象</span></span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果下载的这个文件是你的应用所专用的，你可能会希望把这个文件放在你的应用在外部存储中的一个专有文件夹中。注意这个文件夹不提供访问控制，所以其他的应用也可以访问这个文件夹。在这种情况下，如果你的应用卸载了，那么在这个文件夹也会被删除。<br>&ensp;&ensp;下面的代码片段是指定存储文件的路径是应用在外部存储中的专用文件夹的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationInExternalFilesDir(<span class="keyword">this</span>,  </span><br><span class="line">  Environment.DIRECTORY_DOWNLOADS, “Bugdroid.png”);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;如果下载的文件希望被其他的应用共享，特别是那些你下载下来希望被Media Scanner扫描到的文件（比如音乐文件），那么你可以指定你的下载路径在外部存储的公共文件夹之下，下面的代码片段是将文件存放到外部存储中的公共音乐文件夹的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setDestinationInExternalPublicDir(Environment.DIRECTORY_MUSIC,  </span><br><span class="line">     <span class="string">"Android_Rock.mp3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;在默认的情况下，通过Download Manager下载的文件是不能被Media Scanner扫描到的，进而这些下载的文件（音乐、视频等）就不会在Gallery和Music Player这样的应用中看到。为了让下载的音乐文件可以被其他应用扫描到，我们需要调用Request对象的allowScaningByMediaScanner方法。如果我们希望下载的文件可以被系统的Downloads应用扫描到并管理，我们需要调用Request对象的setVisibleInDownloadsUi方法，传递参数true。</p>
<h3 id="取消或删除下载"><a href="#取消或删除下载" class="headerlink" title="取消或删除下载"></a>取消或删除下载</h3><p>&ensp;&ensp;Download Manager的remove方法可以用来取消一个准备进行的下载，中止一个正在进行的下载，或者删除一个已经完成的下载。remove方法接受若干个download 的ID作为参数，你可以设置一个或者几个你想要取消的下载的ID，如下代码段所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该方法返回成功取消的下载的个数，如果一个下载被取消了，所有相关联的文件，部分下载的文件和完全下载的文件都会被删除。 </p>
<h3 id="查询Download-Manager"><a href="#查询Download-Manager" class="headerlink" title="查询Download Manager"></a>查询Download Manager</h3><p>&ensp;&ensp;你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS<em><em>常量，可以指定正在<em>*进行、暂停、失败、完成</em></em>四种状态。Download Manager包含了一系列COLUMN</em><em>静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括<em>*状态，文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI</em></em>。</p>
<p>&ensp;&ensp;下面的代码段是通过注册监听下载完成事件的广播接受者来查询下载完成文件的本地文件名和URI的实现方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">long</span> reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -<span class="number">1</span>);  </span><br><span class="line">      <span class="keyword">if</span> (myDownloadReference == reference) &#123;  </span><br><span class="line">        Query myDownloadQuery = <span class="keyword">new</span> Query();  </span><br><span class="line">        myDownloadQuery.setFilterById(reference);  </span><br><span class="line">        Cursor myDownload = downloadManager.query(myDownloadQuery);  </span><br><span class="line">        <span class="keyword">if</span> (myDownload.moveToFirst()) &#123;</span><br><span class="line">        <span class="comment">//文件名称索引  </span></span><br><span class="line">          <span class="keyword">int</span> fileNameIdx =   </span><br><span class="line">     myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME);</span><br><span class="line">     <span class="comment">//下载文件存放地址uri索引</span></span><br><span class="line">          <span class="keyword">int</span> fileUriIdx =   </span><br><span class="line">myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI);  </span><br><span class="line"><span class="comment">//下载状态</span></span><br><span class="line">            <span class="keyword">int</span> status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));  </span><br><span class="line">             <span class="keyword">switch</span> (status) &#123;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_PAUSED:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_PAUSED"</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_PENDING:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_PENDING"</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_RUNNING:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_RUNNING"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_SUCCESSFUL:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_SUCCESSFUL"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> DownloadManager.STATUS_FAILED:  </span><br><span class="line">                statusMsg = <span class="string">"STATUS_FAILED"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                statusMsg = <span class="string">"未知状态"</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">          String fileName = myDownload.getString(fileNameIdx);  </span><br><span class="line">          String fileUri = myDownload.getString(fileUriIdx);  </span><br><span class="line">          <span class="comment">// TODO Do something with the file.  </span></span><br><span class="line">          Log.d(TAG, fileName + <span class="string">" : "</span> + fileUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">        myDownload.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。</p>
<ol>
<li>对于STATUS<em>PAUSED状态的下载，可以通过DownloadManager.PAUSED</em>* 静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。</li>
<li>对于STATUS<em>FAILED状态的下载，我们可以通过DownloadManager.ERROR</em>*来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。<br>&ensp;&ensp;下面的代码是如何查询出当前所有的暂停的下载任务，提取出暂停的原因以及文件名称，下载标题以及当前进度的实现方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain the Download Manager Service.  </span></span><br><span class="line">String serviceString = Context.DOWNLOAD_SERVICE;  </span><br><span class="line">DownloadManager downloadManager;  </span><br><span class="line">downloadManager = (DownloadManager)getSystemService(serviceString);  </span><br><span class="line"><span class="comment">// Create a query for paused downloads.  </span></span><br><span class="line">Query pausedDownloadQuery = <span class="keyword">new</span> Query();  </span><br><span class="line">pausedDownloadQuery.setFilterByStatus(DownloadManager.STATUS_PAUSED);  </span><br><span class="line"><span class="comment">// Query the Download Manager for paused downloads.  </span></span><br><span class="line">Cursor pausedDownloads = downloadManager.query(pausedDownloadQuery);  </span><br><span class="line"><span class="comment">// Find the column indexes for the data we require.  </span></span><br><span class="line"><span class="keyword">int</span> reasonIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_REASON);  </span><br><span class="line"><span class="keyword">int</span> titleIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TITLE);  </span><br><span class="line"><span class="keyword">int</span> fileSizeIdx =   </span><br><span class="line"> pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES);      </span><br><span class="line"><span class="keyword">int</span> bytesDLIdx =   </span><br><span class="line">pausedDownloads.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR);  </span><br><span class="line"><span class="comment">// Iterate over the result Cursor.  </span></span><br><span class="line"><span class="keyword">while</span> (pausedDownloads.moveToNext()) &#123;  </span><br><span class="line">  <span class="comment">// Extract the data we require from the Cursor.  </span></span><br><span class="line">  String title = pausedDownloads.getString(titleIdx);  </span><br><span class="line">  <span class="keyword">int</span> fileSize = pausedDownloads.getInt(fileSizeIdx);  </span><br><span class="line">  <span class="keyword">int</span> bytesDL = pausedDownloads.getInt(bytesDLIdx);  </span><br><span class="line">  <span class="comment">// Translate the pause reason to friendly text.  </span></span><br><span class="line">  <span class="keyword">int</span> reason = pausedDownloads.getInt(reasonIdx);  </span><br><span class="line">  String reasonString = <span class="string">"Unknown"</span>;  </span><br><span class="line">  <span class="keyword">switch</span> (reason) &#123;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_QUEUED_FOR_WIFI :   </span><br><span class="line">      reasonString = <span class="string">"Waiting for WiFi"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_WAITING_FOR_NETWORK :   </span><br><span class="line">      reasonString = <span class="string">"Waiting for connectivity"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> DownloadManager.PAUSED_WAITING_TO_RETRY :  </span><br><span class="line">      reasonString = <span class="string">"Waiting to retry"</span>; <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">default</span> : <span class="keyword">break</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// Construct a status summary  </span></span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">  sb.append(title).append(<span class="string">"\n"</span>);  </span><br><span class="line">  sb.append(reasonString).append(<span class="string">"\n"</span>);  </span><br><span class="line">  sb.append(<span class="string">"Downloaded "</span>).append(bytesDL).append(<span class="string">" / "</span> ).append(fileSize);  </span><br><span class="line">  <span class="comment">// Display the status   </span></span><br><span class="line">  Log.d(<span class="string">"DOWNLOAD"</span>, sb.toString());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Close the result Cursor.  </span></span><br><span class="line">pausedDownloads.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DownloadManager原理"><a href="#DownloadManager原理" class="headerlink" title="DownloadManager原理"></a>DownloadManager原理</h3><p>&ensp;&ensp;通过介绍我们已经可以灵活的使用DownloadManaged为我们服务了，为了更好的使用这个工具，得先了解它的工作原理、工作流程。下面就是整个工作流程的时序图：<br><img src="/images/DownloadManager.png" alt="Download Manager时序图"><br>&ensp;&ensp;从上面的时序图我们可以大致了解整个流程。从添加请求，到最后开启下载线程进行文件的下载。为了更好的理解这个下载工具的思想，下面将从源码上对一些重要的函数进行分析。</p>
<p>&ensp;&ensp;一开始，调用DownloadManager的enqueue()法进行下载请求的添加，然后就会调用DownloadProvider的insert()方法进行数据库的数据的插入，insert()不单单是把数据插入到数据库，还会启动DownloadService这个服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(<span class="keyword">final</span> Uri uri, <span class="keyword">final</span> ContentValues values)</span> </span>&#123;  </span><br><span class="line">    checkInsertPermissions(values);  </span><br><span class="line">    SQLiteDatabase db = mOpenHelper.getWritableDatabase();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// note we disallow inserting into ALL_DOWNLOADS  </span></span><br><span class="line">       <span class="keyword">if</span> (pckg != <span class="keyword">null</span> &amp;&amp; (clazz != <span class="keyword">null</span> || isPublicApi)) &#123;  </span><br><span class="line">        <span class="keyword">int</span> uid = Binder.getCallingUid();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span> || mSystemFacade.userOwnsPackage(uid, pckg)) &#123;  </span><br><span class="line">                filteredValues.put(Downloads.COLUMN_NOTIFICATION_PACKAGE,  </span><br><span class="line">                        pckg);  </span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    filteredValues.put(Downloads.COLUMN_NOTIFICATION_CLASS,  </span><br><span class="line">                            clazz);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ex) &#123;  </span><br><span class="line">    <span class="comment">/* ignored for now */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    copyString(Downloads.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_COOKIE_DATA, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_USER_AGENT, values, filteredValues);  </span><br><span class="line">    copyString(Downloads.COLUMN_REFERER, values, filteredValues);  </span><br><span class="line">    <span class="keyword">if</span> (getContext().checkCallingPermission(  </span><br><span class="line">            Downloads.PERMISSION_ACCESS_ADVANCED) == PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">        copyInteger(Downloads.COLUMN_OTHER_UID, values, filteredValues);  </span><br><span class="line">    &#125;  </span><br><span class="line">    filteredValues.put(Constants.UID, Binder.getCallingUid());  </span><br><span class="line">    <span class="keyword">if</span> (Binder.getCallingUid() == <span class="number">0</span>) &#123;  </span><br><span class="line">        copyInteger(Constants.UID, values, filteredValues);  </span><br><span class="line">    &#125;  </span><br><span class="line">    copyStringWithDefault(Downloads.COLUMN_TITLE, values, filteredValues,  </span><br><span class="line">            <span class="string">""</span>);  </span><br><span class="line">    copyStringWithDefault(Downloads.COLUMN_DESCRIPTION, values,  </span><br><span class="line">            filteredValues, <span class="string">""</span>);  </span><br><span class="line">    filteredValues.put(Downloads.COLUMN_TOTAL_BYTES, -<span class="number">1</span>);  </span><br><span class="line">    filteredValues.put(Downloads.COLUMN_CURRENT_BYTES, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    Context context = getContext();  </span><br><span class="line">    context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> rowID = db.insert(DB_TABLE, <span class="keyword">null</span>, filteredValues);  </span><br><span class="line">    <span class="keyword">if</span> (rowID == -<span class="number">1</span>) &#123;  </span><br><span class="line">        Log.d(Constants.TAG, <span class="string">"couldn't insert into downloads database"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    insertRequestHeaders(db, rowID, values);  </span><br><span class="line">    context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));  </span><br><span class="line">    notifyContentChanged(uri, match);  </span><br><span class="line">    <span class="keyword">return</span> ContentUris.withAppendedId(Downloads.CONTENT_URI, rowID);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到上面的代码很长，但是我们只需要关注一些核心的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rowID = db.insert(DB_TABLE, <span class="keyword">null</span>, filteredValues);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这行代码的作用主要是把下载的任务信息保存到数据库中，包括下载的URL、下载的控制状态、下载状态、总的文件大小、已下载的文件大小等默认的数据更新到数据库中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.startService(<span class="keyword">new</span> Intent(context, DownloadService.class));</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这行代码的作用就是启动DownloadService服务。</p>
<p>&ensp;&ensp;当我们启动DownloadService之后，DownloadService服务的onCreate()数就会被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">super</span>.onCreate();  </span><br><span class="line"><span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">    Log.v(Constants.TAG, <span class="string">"Service onCreate"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (mSystemFacade == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    mSystemFacade = <span class="keyword">new</span> RealSystemFacade(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mObserver = <span class="keyword">new</span> DownloadManagerContentObserver();  </span><br><span class="line">getContentResolver().registerContentObserver(  </span><br><span class="line">   Downloads.ALL_DOWNLOADS_CONTENT_URI, <span class="keyword">true</span>, mObserver);  </span><br><span class="line">  </span><br><span class="line">mNotifier = <span class="keyword">new</span> DownloadNotification(<span class="keyword">this</span>, mSystemFacade);  </span><br><span class="line">mSystemFacade.cancelAllNotifications();  </span><br><span class="line">  </span><br><span class="line">updateFromProvider();  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到，在onCreate()数中，会注册一个数据库变化监听器DownloadManagerContentObserver，就是说Downloads.ALL_DOWNLOADS_CONTENT_URI这个数据库的数据发生变化的时候，该监听器的监听函数onChange()会被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> selfChange)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">   Log.v(Constants.TAG,  </span><br><span class="line">      <span class="string">"Service ContentObserver received notification"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    updateFromProvider();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到onChange()函数会调用updateFromProvider()这个函数，从上面可以看到，onCreate()函数也会调到这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFromProvider</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </span><br><span class="line">    mPendingUpdate = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">if</span> (mUpdateThread == <span class="keyword">null</span>) &#123;  </span><br><span class="line">   mUpdateThread = <span class="keyword">new</span> UpdateThread();  </span><br><span class="line">   mSystemFacade.startThread(mUpdateThread);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以看到，updateFormProvider()函数其实就是会启动UpdateThread()这个线程。</p>
<p>&ensp;&ensp; 下面就进入到UpdateThread这个线程中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line">  </span><br><span class="line">    trimDatabase();  </span><br><span class="line">    removeSpuriousFiles();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">boolean</span> keepService = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="comment">// for each update from the database, remember which download is  </span></span><br><span class="line">    <span class="comment">// supposed to get restarted soonest in the future  </span></span><br><span class="line">    <span class="keyword">long</span> wakeUp = Long.MAX_VALUE;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">   <span class="keyword">synchronized</span> (DownloadService.<span class="keyword">this</span>) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (mUpdateThread != <span class="keyword">this</span>) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(  </span><br><span class="line">         <span class="string">"multiple UpdateThreads in DownloadService"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (!mPendingUpdate) &#123;  </span><br><span class="line">      mUpdateThread = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">if</span> (!keepService) &#123;  </span><br><span class="line">          stopSelf();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (wakeUp != Long.MAX_VALUE) &#123;  </span><br><span class="line">          scheduleAlarm(wakeUp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       mPendingUpdate = <span class="keyword">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">long</span> now = mSystemFacade.currentTimeMillis();  </span><br><span class="line">   keepService = <span class="keyword">false</span>;  </span><br><span class="line">   wakeUp = Long.MAX_VALUE;  </span><br><span class="line">   Set&lt;Long&gt; idsNoLongerInDatabase = <span class="keyword">new</span> HashSet&lt;Long&gt;(  </span><br><span class="line">      mDownloads.keySet());  </span><br><span class="line">  </span><br><span class="line">   Cursor cursor = getContentResolver().query(  </span><br><span class="line">      Downloads.ALL_DOWNLOADS_CONTENT_URI, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,  </span><br><span class="line">      <span class="keyword">null</span>);  </span><br><span class="line">   <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;  </span><br><span class="line">       <span class="keyword">continue</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">       DownloadInfo.Reader reader = <span class="keyword">new</span> DownloadInfo.Reader(  </span><br><span class="line">          getContentResolver(), cursor);  </span><br><span class="line">       <span class="keyword">int</span> idColumn = cursor.getColumnIndexOrThrow(Downloads._ID);  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">for</span> (cursor.moveToFirst(); !cursor.isAfterLast(); cursor  </span><br><span class="line">          .moveToNext()) &#123;  </span><br><span class="line">      <span class="keyword">long</span> id = cursor.getLong(idColumn);  </span><br><span class="line">      idsNoLongerInDatabase.remove(id);  </span><br><span class="line">      DownloadInfo info = mDownloads.get(id);  </span><br><span class="line">      <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;  </span><br><span class="line">          updateDownload(reader, info, now);  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          info = insertDownload(reader, now);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (info.hasCompletionNotification()) &#123;  </span><br><span class="line">          keepService = <span class="keyword">true</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">long</span> next = info.nextAction(now);  </span><br><span class="line">      <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;  </span><br><span class="line">          keepService = <span class="keyword">true</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next &gt; <span class="number">0</span> &amp;&amp; next &lt; wakeUp) &#123;  </span><br><span class="line">          wakeUp = next;  </span><br><span class="line">      &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">       cursor.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> (Long id : idsNoLongerInDatabase) &#123;  </span><br><span class="line">       deleteDownload(id);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// is there a need to start the DownloadService? yes, if there  </span></span><br><span class="line">   <span class="comment">// are rows to be deleted.  </span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> (DownloadInfo info : mDownloads.values()) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (info.mDeleted) &#123;  </span><br><span class="line">      keepService = <span class="keyword">true</span>;  </span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   mNotifier.updateNotification(mDownloads.values());  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// look for all rows with deleted flag set and delete the rows  </span></span><br><span class="line">   <span class="comment">// from the database  </span></span><br><span class="line">   <span class="comment">// permanently  </span></span><br><span class="line">   <span class="keyword">for</span> (DownloadInfo info : mDownloads.values()) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (info.mDeleted) &#123;  </span><br><span class="line">      Helpers.deleteFile(getContentResolver(), info.mId,  </span><br><span class="line">         info.mFileName, info.mMimeType);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到UpdateThread这个线程也是很长，我们大概分析一下它的作用。</p>
<p>&ensp;&ensp; 可以看到这里有一个for(;;)的死循环，它的作用是保证数据库中的下载任务都会被加载出来，然后启动所有的下载任务，同时会更新下载任务，包括更新下载任务的状态，删除一些下载任务。</p>
<p>&ensp;&ensp; 它会从数据库中取出所有的下载任务，然后根据id从mDownloads集合中找到对应的下载任务，如果没找到就会新建一个下载任务DownloadInfo。然后就会调用updateDown()和insertDown()，启动下载任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDownload</span><span class="params">(DownloadInfo.Reader reader, DownloadInfo info,  </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">int</span> oldVisibility = info.mVisibility;  </span><br><span class="line"><span class="keyword">int</span> oldStatus = info.mStatus;  </span><br><span class="line">  </span><br><span class="line">reader.updateFromDatabase(info);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> lostVisibility = oldVisibility == Downloads.VISIBILITY_VISIBLE_NOTIFY_COMPLETED  </span><br><span class="line">   &amp;&amp; info.mVisibility != Downloads.VISIBILITY_VISIBLE_NOTIFY_COMPLETED  </span><br><span class="line">   &amp;&amp; Downloads.isStatusCompleted(info.mStatus);  </span><br><span class="line"><span class="keyword">boolean</span> justCompleted = !Downloads.isStatusCompleted(oldStatus)  </span><br><span class="line">   &amp;&amp; Downloads.isStatusCompleted(info.mStatus);  </span><br><span class="line"><span class="keyword">if</span> (lostVisibility || justCompleted) &#123;  </span><br><span class="line">    mSystemFacade.cancelNotification(info.mId);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">info.startIfReady(now);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到该函数调用startIfReady()进行下载任务的启动。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startIfReady</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isReadyToStart(now)) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">        Log.v(Constants.TAG, <span class="string">"Service spawning thread to handle download "</span> + mId);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mHasActiveThread) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Multiple threads on same download"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mStatus != Downloads.STATUS_RUNNING) &#123;  </span><br><span class="line">        mStatus = Downloads.STATUS_RUNNING;  </span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();  </span><br><span class="line">        values.put(Downloads.COLUMN_STATUS, mStatus);  </span><br><span class="line">        mContext.getContentResolver().update(getAllDownloadsUri(), values, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    DownloadThread downloader = <span class="keyword">new</span> DownloadThread(mContext, mSystemFacade, <span class="keyword">this</span>);  </span><br><span class="line">    mHasActiveThread = <span class="keyword">true</span>;  </span><br><span class="line">    mSystemFacade.startThread(downloader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该函数是一个挺重要的函数，它会根据不同的情况判断下载任务是否需要启动。判断函数是isReadyToStart。这个函数十分关键，在我们要实现暂停下载，继续下载这个功能，都是在这里起作用的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReadyToStart</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mHasActiveThread) &#123;  </span><br><span class="line">        <span class="comment">// already running  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mControl == Downloads.CONTROL_PAUSED) &#123;  </span><br><span class="line">        <span class="comment">// the download is paused, so it's not going to start  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">switch</span> (mStatus) &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// status hasn't been initialized yet, this is a new download  </span></span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_PENDING: <span class="comment">// download is explicit marked as ready to start  </span></span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_RUNNING: <span class="comment">// download interrupted (process killed etc) while  </span></span><br><span class="line">                                            <span class="comment">// running, without a chance to update the database  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_WAITING_FOR_NETWORK:  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_QUEUED_FOR_WIFI:  </span><br><span class="line">            <span class="keyword">return</span> checkCanUseNetwork() == NETWORK_OK;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">case</span> Downloads.STATUS_WAITING_TO_RETRY:  </span><br><span class="line">            <span class="comment">// download was waiting for a delayed restart  </span></span><br><span class="line">            <span class="keyword">return</span> restartTime(now) &lt;= now;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到，当下载任务正在进行，或者下载任务状态为暂停状态，或者网络状态是否正常，这时会返回false，就是没有准备好，就不会启动下载任务。当返回true的时候，就会把当前下载任务的状态刷新为Downloads.STATUS_RUNNING,同时会启动DownloadThread下载线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line">  </span><br><span class="line">    State state = <span class="keyword">new</span> State(mInfo);  </span><br><span class="line">    PowerManager.WakeLock wakeLock = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">int</span> finalStatus = Downloads.STATUS_UNKNOWN_ERROR;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        PowerManager pm = (PowerManager) mContext  </span><br><span class="line">                .getSystemService(Context.POWER_SERVICE);  </span><br><span class="line">        wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,  </span><br><span class="line">                Constants.TAG);  </span><br><span class="line">        wakeLock.acquire();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"initiating download for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;  </span><br><span class="line">            Log.i(Constants.TAG, <span class="string">"Initiating request for download "</span>  </span><br><span class="line">                    + mInfo.mId);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">            Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder();  </span><br><span class="line">            InnerState innerState = <span class="keyword">new</span> InnerState();  </span><br><span class="line">            setupDestinationFile(state, innerState);  </span><br><span class="line">            addRequestHeaders(innerState, requestBuilder);  </span><br><span class="line">            requestBuilder.url(state.mRequestUri);  </span><br><span class="line">  </span><br><span class="line">            Request request = requestBuilder.build();  </span><br><span class="line">            Call call = mOkHttpClient.newCall(request);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                executeDownload(innerState, state, call);  </span><br><span class="line">                finished = <span class="keyword">true</span>;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RetryDownload exc) &#123;  </span><br><span class="line">                <span class="comment">// fall through  </span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                call.cancel();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"download completed for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">        finalizeDestinationFile(state);  </span><br><span class="line">        finalStatus = Downloads.STATUS_SUCCESS;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (StopRequest error) &#123;  </span><br><span class="line">        <span class="comment">// remove the cause before printing, in case it contains PII  </span></span><br><span class="line">        Log.w(Constants.TAG, <span class="string">"Aborting request for download "</span> + mInfo.mId  </span><br><span class="line">                + <span class="string">": "</span> + error.getMessage());  </span><br><span class="line">        finalStatus = error.mFinalStatus;  </span><br><span class="line">        <span class="comment">// fall through to finally block  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">// sometimes the socket code throws unchecked  </span></span><br><span class="line">        <span class="comment">// exceptions  </span></span><br><span class="line">        Log.w(Constants.TAG, <span class="string">"Exception for id "</span> + mInfo.mId + <span class="string">": "</span> + ex);  </span><br><span class="line">        finalStatus = Downloads.STATUS_UNKNOWN_ERROR;  </span><br><span class="line">        <span class="comment">// falls through to the code that reports an error  </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (wakeLock != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            wakeLock.release();  </span><br><span class="line">            wakeLock = <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (mOkHttpClient != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mOkHttpClient.cancel(<span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        cleanupDestination(state, finalStatus);  </span><br><span class="line">        notifyDownloadCompleted(finalStatus, state.mCountRetry,  </span><br><span class="line">                state.mRetryAfter, state.mGotData, state.mFilename,  </span><br><span class="line">                state.mNewUri, state.mMimeType);  </span><br><span class="line">        mInfo.mHasActiveThread = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setupDestinationFile(state, innerState);</span><br></pre></td></tr></table></figure></p>
<p>这个方法是实现断点续传的关键点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDestinationFile</span><span class="params">(State state, InnerState innerState)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(state.mFilename)) &#123; <span class="comment">// only true if we've already  </span></span><br><span class="line">        <span class="comment">// run a thread for this  </span></span><br><span class="line">        <span class="comment">// download  </span></span><br><span class="line">        <span class="keyword">if</span> (!Helpers.isFilenameValid(state.mFilename)) &#123;  </span><br><span class="line">            <span class="comment">// this should never happen  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_FILE_ERROR,  </span><br><span class="line">                    <span class="string">"found invalid internal destination filename"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// We're resuming a download that got interrupted  </span></span><br><span class="line">        File f = <span class="keyword">new</span> File(state.mFilename);  </span><br><span class="line">        <span class="keyword">if</span> (f.exists()) &#123;  </span><br><span class="line">            <span class="keyword">long</span> fileLength = f.length();  </span><br><span class="line">            <span class="keyword">if</span> (fileLength == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// The download hadn't actually started, we can restart from  </span></span><br><span class="line">                <span class="comment">// scratch  </span></span><br><span class="line">                f.delete();  </span><br><span class="line">                state.mFilename = <span class="keyword">null</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInfo.mETag == <span class="keyword">null</span> &amp;&amp; !mInfo.mNoIntegrity) &#123;  </span><br><span class="line">                <span class="comment">// This should've been caught upon failure  </span></span><br><span class="line">                f.delete();  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_CANNOT_RESUME,  </span><br><span class="line">                        <span class="string">"Trying to resume a download that can't be resumed"</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// All right, we'll be able to resume this download  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    state.mStream = <span class="keyword">new</span> FileOutputStream(state.mFilename,  </span><br><span class="line">                            <span class="keyword">true</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException exc) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_FILE_ERROR,  </span><br><span class="line">                            <span class="string">"while opening destination for resuming: "</span>  </span><br><span class="line">                                    + exc.toString(), exc);  </span><br><span class="line">                &#125;  </span><br><span class="line">                innerState.mBytesSoFar = (<span class="keyword">int</span>) fileLength;  </span><br><span class="line">                <span class="keyword">if</span> (mInfo.mTotalBytes != -<span class="number">1</span>) &#123;  </span><br><span class="line">                    innerState.mHeaderContentLength = Long  </span><br><span class="line">                            .toString(mInfo.mTotalBytes);  </span><br><span class="line">                &#125;  </span><br><span class="line">                innerState.mHeaderETag = mInfo.mETag;  </span><br><span class="line">                innerState.mContinuingDownload = <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (state.mStream != <span class="keyword">null</span>  </span><br><span class="line">            &amp;&amp; mInfo.mDestination == Downloads.DESTINATION_EXTERNAL) &#123;  </span><br><span class="line">        closeDestination(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 方法的流程大概是：先根据文件名建立一个文件对象，判断文件对象是否存在，如果存在再判断文件的大小，当文件大小为0的时候，把文件删除。同时，会把当前的文件的输出流保存到state.mStream，把当前文件的长度、要下载文件的总长度、文件继续下载状态保存到innerState中。<br>&ensp;&ensp; 再分析addRequestHeader（）方法，该方法也是实现断点续传的关键。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRequestHeaders</span><span class="params">(InnerState innerState, Request.Builder requestBuilder)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (Pair&lt;String, String&gt; header : mInfo.getHeaders()) &#123;  </span><br><span class="line">        requestBuilder.addHeader(header.first, header.second);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (innerState.mContinuingDownload) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (innerState.mHeaderETag != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            requestBuilder.addHeader(<span class="string">"If-Match"</span>, mInfo.mETag);  </span><br><span class="line">        &#125;  </span><br><span class="line">        requestBuilder.addHeader(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + innerState.mBytesSoFar + <span class="string">"-"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 该方法会把请求头添加到请求中，最重要的是：如果是断点续传的话，会把当前的文件大小也放到请求头中，这样服务器就会知道当前的文件已经下载了多少。</p>
<p>&ensp;&ensp; 下面来分析最重要的executeDownload方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeDownload</span><span class="params">(InnerState innerState, State state, Call call)</span> <span class="keyword">throws</span> StopRequest, RetryDownload, IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[Constants.BUFFER_SIZE];  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// check just before sending the request to avoid using an invalid  </span></span><br><span class="line">    <span class="comment">// connection at all  </span></span><br><span class="line">    checkConnectivity(state);  </span><br><span class="line">  </span><br><span class="line">    Response response = call.execute();  </span><br><span class="line">    handleExceptionalStatus(state, innerState, response);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (Constants.LOGV) &#123;  </span><br><span class="line">        Log.v(Constants.TAG, <span class="string">"received response for "</span> + mInfo.mUri);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    processResponseHeaders(state, innerState, response);  </span><br><span class="line">    InputStream entityStream = openResponseEntity(state, response);  </span><br><span class="line">    transferData(state, innerState, data, entityStream);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到这个下载工具用到okhttp这个开源库进行网络的请求。使用okhttp得到了Response对象。</p>
<ul>
<li>先分析processResponseHeaders（）这个方法，这个方法中会获取Http请求的header，同时，根据这次下载是否为断点下载，如果是则返回，如果不是，则会把要下载的文件的输入流对象保存到state.mStream变量中。</li>
<li>再分析openResponseEntity()这个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">openResponseEntity</span><span class="params">(State state, Response response)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> response.body().byteStream();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">        logNetworkState();  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(getFinalStatusForHttpError(state),  </span><br><span class="line">                <span class="string">"while getting entity: "</span> + ex.toString(), ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp; 该方法是获取Response对象的输出流变量,最后是transferData（）方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(State state, InnerState innerState, <span class="keyword">byte</span>[] data,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          InputStream entityStream)</span> <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;  </span><br><span class="line">        <span class="keyword">int</span> bytesRead = readFromResponse(state, innerState, data,  </span><br><span class="line">                entityStream);  </span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123; <span class="comment">// success, end of stream already reached  </span></span><br><span class="line">            handleEndOfStream(state, innerState);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        state.mGotData = <span class="keyword">true</span>;  </span><br><span class="line">        writeDataToDestination(state, data, bytesRead);  </span><br><span class="line">        innerState.mBytesSoFar += bytesRead;  </span><br><span class="line">        reportProgress(state, innerState);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Constants.LOGVV) &#123;  </span><br><span class="line">            Log.v(Constants.TAG, <span class="string">"downloaded "</span> + innerState.mBytesSoFar  </span><br><span class="line">                    + <span class="string">" for "</span> + mInfo.mUri);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        checkPausedOrCanceled(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp; 可以看到，这是一个for(;;)死循环，用于读取下载的文件流。</p>
<ul>
<li>先调用readFromResponse()函数，从文件输出流中读取数据，保存到data字节数组中。</li>
<li>然后调用writeDataToDestination()数，把data字节数组中的数据写到本地的文件中。</li>
<li>然后调用reportProgress()数，把已下载的文件的大小更新到数据库中。用于更新进度条的显示。</li>
</ul>
<p>&ensp;&ensp; 可以看到checkPauseOrCanceled()数。这是实现暂停下载的关键函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPausedOrCanceled</span><span class="params">(State state)</span> <span class="keyword">throws</span> StopRequest </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (mInfo) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mInfo.mControl == Downloads.CONTROL_PAUSED) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_PAUSED_BY_APP,  </span><br><span class="line">                    <span class="string">"download paused by owner"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mInfo.mStatus == Downloads.STATUS_CANCELED) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StopRequest(Downloads.STATUS_CANCELED,  </span><br><span class="line">                <span class="string">"download canceled"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;可以分析，这里会根据下载任务的当前状态进行判断，如果当前的任务状态被更改为Downloads.CONTROL_PAUSED时，就会抛出StopRequest的异常，当前的文件下载就会被终止，这样就可以实现暂停下载了。</p>
<p> 到此为止，DownloadManager下载的整个流程就分析完了。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>&ensp;&ensp;通过上面的分析，我们几乎理解了DownloadManager的整个工作流程。在我们下载文件的时候，我们几乎都是需要暂停下载和继续下载还有断点续传的功能。DownloadProvider代码是可以让我们能够实现这个功能了。</p>
<p>&ensp;&ensp;实现断点续传的原理其实就是我们每次添加下载任务，都会把任务的信息保存到数据库中，包括下载的URL，已下载的文件大小，总的文件大小。下次我们再进行下载的时候，把已下载的大小传到服务器中，就可以从上一次已下载的文件的基础上继续下载，就可以实现断点下载了。</p>
<p>&ensp;&ensp;暂停下载和继续下载的实现，其实只需要更新下载任务的状态就可以实现了。因为从上面的下载可以知道，在下载文件的过程中，都会检验当前的下载任务的状态，若是暂停状态，就会停止下载，跳出死循环。当我们再次改变状态为继续下载时，下载任务会被再次启动。</p>
<p>来源：<br><a href="http://blog.csdn.net/carrey1989/article/details/8060155" target="_blank" rel="noopener">http://blog.csdn.net/carrey1989/article/details/8060155</a><br><a href="http://blog.csdn.net/garment1991/article/details/54178557" target="_blank" rel="noopener">http://blog.csdn.net/garment1991/article/details/54178557</a><br><a href="http://www.trinea.cn/android/android-downloadmanager-pro/" target="_blank" rel="noopener">http://www.trinea.cn/android/android-downloadmanager-pro/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/06/19/android-download-manager使用/" data-id="cjicvd90s0009wqs6kj9xilqa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/7/">7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/">Annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DynamicLoadApk/">DynamicLoadApk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Instant-Run/">Instant Run</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC-MVP-MVVM/">MVC MVP MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MulitiDex/">MulitiDex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NestedScrolling/">NestedScrolling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Options/">Options</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Small/">Small</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Support/">Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle-plugin/">gradle plugin</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/7/" style="font-size: 10px;">7</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Annotation/" style="font-size: 15px;">Annotation</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/BitmapFactory/" style="font-size: 10px;">BitmapFactory</a> <a href="/tags/Download-Manager/" style="font-size: 15px;">Download Manager</a> <a href="/tags/DynamicLoadApk/" style="font-size: 10px;">DynamicLoadApk</a> <a href="/tags/Instant-Run/" style="font-size: 10px;">Instant Run</a> <a href="/tags/MVC-MVP-MVVM/" style="font-size: 10px;">MVC MVP MVVM</a> <a href="/tags/MulitiDex/" style="font-size: 10px;">MulitiDex</a> <a href="/tags/NestedScrolling/" style="font-size: 10px;">NestedScrolling</a> <a href="/tags/Options/" style="font-size: 10px;">Options</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Small/" style="font-size: 10px;">Small</a> <a href="/tags/Support/" style="font-size: 10px;">Support</a> <a href="/tags/Tool/" style="font-size: 15px;">Tool</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gradle-plugin/" style="font-size: 10px;">gradle plugin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/13/java单例模式/">java单例模式</a>
          </li>
        
          <li>
            <a href="/2018/06/06/DDComponent原理剖析/">DDComponentForAndroid原理剖析</a>
          </li>
        
          <li>
            <a href="/2018/05/29/Android自定义注解处理器/">Android自定义注解处理器</a>
          </li>
        
          <li>
            <a href="/2018/04/15/mvc-mvp和mvvm理解/">mvc_mvp和mvvm理解</a>
          </li>
        
          <li>
            <a href="/2017/06/28/插件化种种和思考/">插件化种种和思考</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 CallteFoot<br>
      Powered by <a href="https://cattlefoot.github.io" target="_blank">CallteFoot</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>