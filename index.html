<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android, SpringBoot" />










<meta name="description" content="The blog from a Android coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="The blog from a Android coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="The blog from a Android coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/02/12/Android通过系统获取图片及截图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/Android通过系统获取图片及截图/" itemprop="url">Android通过系统获取图片及截图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:44:54+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>日常开发当中,调用相机或者从相册中选择照片裁剪并上传是很常见的功能,虽然网上有很多框架,但是导入<br>别人的库, 无疑会增加App的体积和后期维护难度,因此这里讲一下如何使用系统自带的相机,相册,并裁剪。<br>这里是在Android7.0以上版本上运行。</p>
<h3 id="第一步FileProvider准备"><a href="#第一步FileProvider准备" class="headerlink" title="第一步FileProvider准备"></a>第一步FileProvider准备</h3><ol>
<li><p>在AndroidManifest.xml中增加provider节点，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"一般为包名"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/filepaths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>android:authorities 表示授权列表，填写你的应用包名，当有多个授权时，用分号隔开；</li>
<li>android:exported 表示该内容提供器(ContentProvider)是否能被第三方程序组件使用，必须为false，<br>否则会报异常：Java.lang.RuntimeException: Unable to get provider android.support.v4.content.FileProvider: java.lang.SecurityException: Provider must not be exported；</li>
<li>android:grantUriPermissions=”true” 表示授予 URI 临时访问权限；</li>
<li>android:resource 属性指向创建的xml文件的路径，文件名可以随便起；</li>
</ul>
</li>
<li><p>在资源(res)目录下创建一个xml目录，并建立一个以上面名字（filepaths）为文件名的xml文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">path</span>=<span class="string">"."</span> <span class="attr">name</span>=<span class="string">"external_path"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>external-path 代表根目录为: Environment.getExternalStorageDirectory() ，也可以写其他的，<br>如： files-path 代表根目录为:Context.getFilesDir()<br>cache-path 代表根目录为:getCacheDir() 其path属性的值代表路径后层级名称，为空则代表就是根目录，<br>假如为“pictures”,就代表对应根目录下的pictures目录</li>
</ul>
</li>
</ol>
<h3 id="第二步使用FileProvider"><a href="#第二步使用FileProvider" class="headerlink" title="第二步使用FileProvider"></a>第二步使用FileProvider</h3><p>⚠️在使用FileProvider前需要在需要在AndroidManifest.xml中增加必要的读写权限：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>通过相机获取图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拍照</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于保存调用相机拍照后所生成的文件</span></span><br><span class="line">    <span class="keyword">if</span> (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureFile = <span class="keyword">new</span> File(rootFile, <span class="string">"temp.jpg"</span>);</span><br><span class="line">    <span class="comment">//跳转到调用系统相机</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">//判断版本 如果在Android7.0以上,使用FileProvider获取Uri</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        intent.setFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">        Uri contentUri = FileProvider.getUriForFile(mContext, getPackageName(), captureFile);</span><br><span class="line">        intent.putExtra(MediaStore.EXTRA_OUTPUT, contentUri);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则使用Uri.fromFile(file)方法获取Uri</span></span><br><span class="line">        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(captureFile));</span><br><span class="line">    &#125;</span><br><span class="line">    startActivityForResult(intent, REQUEST_PERMISSION_CAMERA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过相册获取图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从相册选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">choosePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Intent photoPickerIntent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK);</span><br><span class="line">   photoPickerIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">   startActivityForResult(photoPickerIntent, REQUEST_PERMISSION_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片剪裁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cropPhoto</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    cropFile = <span class="keyword">new</span> File(rootFile, <span class="string">"avatar.jpg"</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);</span><br><span class="line">    intent.setDataAndType(uri, <span class="string">"image/*"</span>);</span><br><span class="line">    <span class="comment">//crop=true是设置在开启的Intent中设置显示的VIEW可裁剪</span></span><br><span class="line">    intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="comment">//aspectX aspectY 是宽高的比例</span></span><br><span class="line">    intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//outputX outputY 是裁剪图片宽高</span></span><br><span class="line">    intent.putExtra(<span class="string">"outputX"</span>, <span class="number">300</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"outputY"</span>, <span class="number">300</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"return-data"</span>, <span class="keyword">false</span>);<span class="comment">//注意这里返回false,因为在部分手机上获取不到返回的数据</span></span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(cropFile));</span><br><span class="line">    intent.putExtra(<span class="string">"outputFormat"</span>, Bitmap.CompressFormat.PNG.toString());</span><br><span class="line">    intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);  <span class="comment">//人脸识别</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    startActivityForResult(intent, CROP_REQUEST_CODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三部接收图片信息"><a href="#第三部接收图片信息" class="headerlink" title="第三部接收图片信息"></a>第三部接收图片信息</h3><p>在onActivityResult方法中获得返回的图片信息,在这里先调用剪裁去剪裁图片,然后对剪裁返回的图片进行设置、保存、上传等操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="comment">//拍照后逻辑</span></span><br><span class="line">          <span class="keyword">case</span> REQUEST_PERMISSION_CAMERA:</span><br><span class="line">              <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">                  Uri contentUri = FileProvider.getUriForFile(mContext, getPackageName(), captureFile);</span><br><span class="line">                  cropPhoto(contentUri);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  cropPhoto(Uri.fromFile(captureFile));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//图片获取后逻辑</span></span><br><span class="line">          <span class="keyword">case</span> REQUEST_PERMISSION_WRITE:</span><br><span class="line">              cropPhoto(data.getData());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//图片裁剪后逻辑</span></span><br><span class="line">          <span class="keyword">case</span> CROP_REQUEST_CODE:</span><br><span class="line">              saveImage(cropFile.getAbsolutePath());</span><br><span class="line">              ivAvatar.setImageBitmap(BitmapFactory.decodeFile(cropFile.getAbsolutePath()));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>保存图片在本地<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(cropFile);</span><br><span class="line">    bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, fos);</span><br><span class="line">    fos.flush();</span><br><span class="line">    fos.close();</span><br><span class="line">    <span class="keyword">return</span> cropFile.getAbsolutePath();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>⚠️在使用相机等动态权限时要注意权限的获取</p>
<p>参考：<br>[1] <a href="https://www.jianshu.com/p/0a2d8466fe6d" target="_blank" rel="noopener">https://www.jianshu.com/p/0a2d8466fe6d</a><br>[2]7.0FileProvider使用 <a href="http://yifeng.studio/2017/05/03/android-7-0-compat-fileprovider/" target="_blank" rel="noopener">http://yifeng.studio/2017/05/03/android-7-0-compat-fileprovider/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/02/12/kotlin笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/kotlin笔记/" itemprop="url">kotlin笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:41:35+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>变量 &amp; 常量:<ul>
<li>可变性: var 可变;  val 不可变</li>
<li>编译期常量: val定义的是运行时常量, 如果定义编译器常量, 需要添加  const</li>
<li>变量的声明和赋值<br>  var p0 = 1           // 类型推断<br>  var p1: Int = 2      // 指明类型</li>
</ul>
</li>
<li><p>基本类型</p>
<ul>
<li>数字(Number): (Kotlin中的数字没有隐式拓宽, 比如 Int 不能自动转换为 Long)<ul>
<li>类型<ul>
<li>Byte     8 bit        </li>
<li>Short    16bit</li>
<li>Int      32bit          </li>
<li>Long     64bit          整数默认是 Int, 可以使用 L 表示 Long       123L</li>
<li>Float    32bit          浮点数默认为 Double,  可以使用 f/F表示 Float     1.1f</li>
<li>Double   64bit</li>
</ul>
</li>
<li>进制<ul>
<li>二进制:    0b00001011</li>
<li>八进制:    不支持</li>
<li>十进制:    123</li>
<li>十六进制:  0x0F</li>
</ul>
</li>
<li>数字下划线: 提高数字常量的易读性<br>  val a = 1_000_000;<br>  val b = 123_456L<br>  var c = 0xFF_EC_DE<br>  var d = 0b11010010_01101001</li>
<li>显示转换:<ul>
<li>显示转换: toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar()、、、、、<br>  val b: Byte = 1<br>  val i: Int = b.toInt()</li>
<li>计算时自动转换<br>  val l = 1L + 3                      // Long + Int =&gt; Long</li>
</ul>
</li>
</ul>
</li>
<li>字符(Char):<ul>
<li>字符字面量用 单引号 表示   val c: Char = ‘a’</li>
<li>特殊字符可以使用 \ 转义: \t、\n、\b、\r、\、\$、…</li>
<li>字符不能直接作为数字使用, 但是可以通过方法显示的转为 Int<br>  fun decimalDigit(c: Char): Int{<pre><code>if(c !in &apos;0&apos;..&apos;9&apos;)
    throw IllegalArgumentException(&quot;out of range&quot;)
return c.toInt() - &apos;0&apos;.toInt
</code></pre>  }</li>
</ul>
</li>
<li>布尔(Boolean)<ul>
<li>两个取值:         true,  false</li>
<li>内置的布尔运算符:  ||,    &amp;&amp;,      !</li>
</ul>
</li>
<li>数组(Array)<ul>
<li>定义数组的方式<br>  var arr0 = arrayOfNulls()                          // 创建一个指定大小、元素都为空的数组<br>  var arr1 = arrayOf(1, 2, 3)                        // [1, 2, 3]<br>  val arr2 = Array(5, { i -&gt; (i * i).toString() })   // 创建一个 Array<string> 初始化为 [“0”, “1”, “4”, “9”, “16”]</string></li>
<li>通过 [] 访问(取值 和 赋值)数组元素 (运算符重载, 实际调用 get  set 方法)</li>
<li>无装箱开销的原生类型数组: ByteArray、 ShortArray、IntArray …<ul>
<li>这些类和 Array 并没有继承关系，但是 它们有同样的方法属性集。它们也都有相应的工厂方法:<br>  val x: IntArray = intArrayOf(1, 2, 3)<br>  x[0] = x[1] + x[2]</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串(String)</p>
<ul>
<li>字符串的不可变性</li>
<li>转义字符串: 用  “ “ 表示, 其内部可以使用 转义字符<br>  val s0: String = “Hello \n World”</li>
<li><p>原始字符串: 用 “”” “”” 表示, 其内部可以包含换行和任意字符(都表示字面量), 不识别 转义字符<br>  val s1: String = “””</p>
<pre><code>   for (c in &quot;foo&quot;)
     print(c)
&quot;&quot;&quot;
</code></pre><p>  PS: 因为原始字符串内部任意字符($除外)都表示字面量, 所以其每一行前面可能都会带有空格, 可以使用 trimMargin() 去除每一行前面的空格</p>
<pre><code>- trimMargin() 默认参数 &quot;|&quot;, 所以可以使用 | 作为每一行的前缀
    val text1 = &quot;&quot;&quot;
                    |第一行
                    |第二行
                &quot;&quot;&quot;.trimMargin()
- 也可以自定义前缀, 比如使用 &gt;
    val text2 = &quot;&quot;&quot;
                    &gt;第一行
                    &gt;第二行
                &quot;&quot;&quot;.trimMargin(&quot;&gt;&quot;)
</code></pre></li>
<li><p>字符串模板(转义字符串 和 原始字符串 都支持)<br>  val a = 1<br>  val s = “$a + $a = ${a + a}”<br>  PS: 因为原始字符串也支持 字符串模板, 但是不支持 转义符号, 所有如果要在原始字符串中表示 $ 字面量, 方式如下</p>
<pre><code>val price = &quot;&quot;&quot;
        ${&apos;$&apos;}9.99
        &quot;&quot;&quot;
</code></pre></li>
<li>字符串 就是 一串字符<ul>
<li>用字符数组构建字符串:<br>  val s3: String = String(charArrayOf(‘a’,’b’,’c’))</li>
<li>可以通过下标访问 字符串 中的 字符<br>  val c: Char = s3[0];</li>
<li>可以使用 for 循环迭代字符串<br>  for (c in str) {<pre><code>println(c)
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同一性 &amp; 相等性<br> val a: Int = 1000;<br> val a1: Int? = a;<br> val a2: Int? = a;<br> print(a1 === a2);                       // false, 可空引用会对变量装箱(不要和Java的装箱混淆), 不再相等<br> print(a1 == a2);                        // true,</li>
<li>运算符<ul>
<li>基本运算符: + - * / % += -=</li>
<li>比较符: == === != !==                  // === 比较地址,  == 比较字面量</li>
<li>逻辑运算符: ||  &amp;&amp;  !</li>
<li>位运算(只用于 Int 和 Long)<br>  shl(bits)  – 有符号左移 (Java 的 &lt;&lt;)<br>  shr(bits)  – 有符号右移 (Java 的 &gt;&gt;)<br>  ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;)<br>  and(bits)  – 位与<br>  or(bits)   – 位或<br>  xor(bits)  – 位异或<br>  inv()      – 位非</li>
<li>自定义基本运算<br>  operator fun plus(xxx){xxx}            // 要对某个类自定义运算符, 用 operator 修饰相关成员方法<br>  infix fun on(place: String){}          // 可以通过  xxx on “aaa” 调用, 类似于运算符的效果, 其实等效于 xxx.on(“aaa”)</li>
</ul>
</li>
<li>空类型 &amp; 空安全<ul>
<li>可空类型<br>  var s: String? = null</li>
<li>安全的调用<br>  val l1: Int? = s?.length               // 如果 s 为 null , 则直接返回 null<br>  val l2: Int = s?.length ?: -1          // 如果 ?: 左侧表达式非空, 就返回其左侧表达式，否则返回右侧表达式。<br>  val l3: Int = s!!.length               // 如果 s 为 null, 则抛出异常</li>
<li>安全的类型转换<br>  val aInt: Int? = a as? Int             // 如果转换失败, 则返回 null</li>
<li>空条件<br>  data?.let{<pre><code>// 如果不为空执行该语句块
</code></pre>  }<br>  data?:let{<pre><code>// 当data为空时才会执行
</code></pre>  }</li>
<li>可空类型的集合<br>  val nullableList: List<int?> = listOf(1, 2, null, 4)<br>  val intList: List<int> = nullableList.filterNotNull()     // 过滤非空元素</int></int?></li>
</ul>
</li>
<li>类型检查与类型转换<ul>
<li>智能类型转换: 检查类型后, 可以直接按照该类型使用<br>  if (obj is String) {<pre><code>print(obj.length)
</code></pre>  }<br>  if (obj !is String) {                                     // 与 !(obj is String) 相同<pre><code>print(&quot;Not a String&quot;)
</code></pre>  } else {<pre><code>print(obj.length)
</code></pre>  }</li>
<li>智能类型转换适用的情况<ul>
<li>val 局部变量</li>
<li>val 属性(private 或 internal)，或者该检查在声明属性的同一模块中执行.不适用于 open 的属性或者具有自定义 getter 的属性；</li>
<li>var 局部变量——如果变量在检查和使用之间没有修改、并且没有在会修改它的 lambda 中捕获；</li>
</ul>
</li>
<li>强制类型转换<br>  val x: String = y as String<br>  val x: String? = y as? String                // 转换失败则返回 null</li>
</ul>
</li>
<li>包<ul>
<li>源文件通常以包声明开头: 包名可不与文件路径一致;  源文件的内容都在包名所在空间(外部使用需要导包), 如果不声明包, 则文件内容都属于无名称的默认包<br>  package my.demo  </li>
<li>导入包<br>  import foo.Bar                         // 现在 Bar 可以不用限定符访问<br>  import foo.*                           // “foo”中的一切都可访问<br>  import bar.Bar as bBar                 // 名字冲突时, 使用别名 bBar 代表“bar.Bar”</li>
<li>import不仅限于导入类, 还可以导入: 顶层函数及属性、枚举常量、对象中声明的函数和属性</li>
</ul>
</li>
<li>流程控制<ul>
<li>区间 (Ranges)<br>  for (i in 1..100) { … }         // [1, 100]<br>  for (i in 1 until 100) { … }    // [1, 100)<br>  for (x in 2..10 step 2) { … }   // 步进<br>  for (x in 10 downTo 1) { … }    // 倒序<br>  if (x in 1..10) { … }           // 判断</li>
<li>分支<ul>
<li>if<ul>
<li>传统用法:<br>  var max = a<br>  if (a &lt; b) max = b</li>
<li>在 kotlin 中, if 可以作为表达式使用, 它每个分支的最后的表达式作为该分支的返回值<br>  val max = if (a &gt; b) a else b<br>  val max = if (a &gt; b) {<pre><code>print(&quot;Choose a&quot;)
a
</code></pre>  } else {<pre><code>print(&quot;Choose b&quot;)
b
</code></pre>  }</li>
</ul>
</li>
<li>when: 增强版的 switch<ul>
<li>最简单的用法<br>  when (x) {<pre><code>1 -&gt; print(&quot;x == 1&quot;)
2 -&gt; print(&quot;x == 2&quot;)
else -&gt; { // 注意这个块
    print(&quot;x is neither 1 nor 2&quot;)
}
</code></pre>  }</li>
<li>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：<br>  when (x) {<pre><code>0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;)
else -&gt; print(&quot;otherwise&quot;)
</code></pre>  }</li>
<li>可以用任意表达式（而不只是常量）作为分支条件<br>  when (x) {<pre><code>parseInt(s) -&gt; print(&quot;s encodes x&quot;)
else -&gt; print(&quot;s does not encode x&quot;)
</code></pre>  }</li>
<li>也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：<br>  when (x) {<pre><code>in 1..10 -&gt; print(&quot;x is in the range&quot;)
in validNumbers -&gt; print(&quot;x is valid&quot;)
!in 10..20 -&gt; print(&quot;x is outside the range&quot;)
else -&gt; print(&quot;none of the above&quot;)
</code></pre>  }</li>
<li>检测一个值是（is）或者不是（!is）一个特定类型的值<br>  val hasPrefix = when(x) {                   // 和if一样, 也可以作为表达式使用, 每个分支的最后的表达式作为该分支的返回值<pre><code>is String -&gt; x.startsWith(&quot;prefix&quot;)
else -&gt; false
</code></pre>  }</li>
<li>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：<br>  when {<pre><code>x.isOdd() -&gt; print(&quot;x is odd&quot;)
x.isEven() -&gt; print(&quot;x is even&quot;)
else -&gt; print(&quot;x is funny&quot;)
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>异常<ul>
<li>普通用法<ul>
<li>抛异常:<br>  throw MyException(“Hi There!”)  </li>
<li>捕获异常<br>  try {  }catch (e: SomeException) {  }finally { }</li>
</ul>
</li>
<li>作为表达式使用, 每个分支中最后的表达式作为该分支的结果<br>  val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }</li>
</ul>
</li>
<li>循环<ul>
<li>for<ul>
<li>循环 数组 或 list 的索引<br>  for (index in list.indices) {<pre><code>println(&quot;item at $index is ${items[index]}&quot;)
</code></pre>  }</li>
<li>遍历 索引 和 值<br>  for ((index, value) in array.withIndex()) {<pre><code>println(&quot;the element at $index is $value&quot;)
</code></pre>  }</li>
<li>可以对任何提供迭代器（iterator）的对象进行遍历<br>  for (item in collection) print(item)</li>
<li>遍历 Map 集合<br>  for ((k, v) in map) {<pre><code>print(&quot;$k -&gt; $v&quot;)
</code></pre>  }</li>
<li>遍历 区间 (如上)</li>
</ul>
</li>
<li>while   &amp;    do … while<br>  while (x &gt; 0) {<pre><code>x--
</code></pre>  }<br>  do {<pre><code>val y = retrieveData()
</code></pre>  } while (y != null)           // y 在此处可见</li>
</ul>
</li>
</ul>
</li>
<li>返回与跳转: return、break、continue<ul>
<li>基本用法<br>  return      默认从最直接包围它的函数或者匿名函数返回<br>  break       终止最直接包围它的循环<br>  continue    继续下一次最直接包围它的循环</li>
<li>使用标签来限制 break 和 continue<br>  loop@ for (i in 1..100) {<pre><code>for (j in 1..100) {
    if (……) break@loop
}
</code></pre>  }</li>
<li>使用标签来限制 reutrn :   函数可以嵌套使用, return会从最直接包围它的函数返回, 但是会忽略 lambda表达式, 可以通过标签使其从 lambda表达式返回<br>  fun foo() {<pre><code>ints.forEach lit@ {
    if (it == 0) return@lit
    print(it)
}
</code></pre>  }<br>   fun foo() {<pre><code>ints.forEach {
    if (it == 0) return@forEach            // 隐式标签, 该标签与接受该 lambda 的函数同名
    print(it)
}
</code></pre>  }</li>
<li>return 的标签语法也可以带有返回值<br>  return@a 1                                     // 从标签 @a 返回 1</li>
</ul>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p>类</p>
<ul>
<li>类的声明:  <ul>
<li>class关键字 + 类名 + 类头(主构造函数、参数) + 类体<br>  class Person public constructor(name: String){}</li>
<li>如果没有类体, 可生路 {}:<br>  class Person public constructor(name: String)</li>
<li>如果主构造函数没有 注解 或 权限修饰(默认 public), 可省略 constructor 关键字<br>  class Person()</li>
<li>如果主构造函数没有参数, 类头也可以省略<br>  class Person</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造函数中的参数可在 init 代码块中访问<br>  class Person public constructor(name: String){<pre><code>val age = 18                                 // 只读属性
var xxx = &quot;yyy&quot;                              // 读写属性
init{ print(name) }                          // 初始化代码块: 按照其在类中的顺序执行(包括属性初始化)
</code></pre>  }</li>
<li>构造函数中的参数也可以在类属性的初始化器中使用<br>  class Person (name: String){<pre><code>val upperName : String = name.toUpperCase()
</code></pre>  }</li>
<li>可以直接在主构造函数中声明 属性<br>  class Person (val name: String, val age: Int = 18, var xxx: String){ … }</li>
<li>次级构造函数: 可在类体中通过 constructor 关键字 声明任意个次级构造函数<br>  class Person{<pre><code>constructor(name: String){
    print(name)
}
</code></pre>  }</li>
<li>如果存在主构造函数, 那么所有 次级构造函数必须 直接(或间接)委托给 主构造函数.<br>  class Person(val name: String, val age: Int){<pre><code>constructor(name: String) : this(name, 18) {
    print(name)
}
</code></pre>  }</li>
<li>实际上即使没有主构造函数, 次级构造函数任然隐式的存在这种委托关系<br>  class Person{<pre><code>init{
    print(&quot;这段代码会在次级构造函数体之前执行, 因为 init 代码块是主构造函数的一部分, 而委托代码是在次级构造函数的含数体之前&quot;)
}
constructor(name: String){
    print(name)
}
</code></pre>  }</li>
<li>如果没有声明任何构造函数(主和次), 默认会自动有一个 public 的无参主构造函数</li>
</ul>
</li>
<li><p>属性和字段</p>
<ul>
<li>声明属性的方式<br>  class A{<pre><code>// 可变属性: 初始化器、getter、setter都是可选的; 如果类型可推断(从初始化器或 getter返回值), 那么类型也可以省略
var &lt;propertyName&gt; [: PropertyType] [= &lt;property_initializer&gt;]      
    [&lt;getter&gt;]                                                      // 就是一个函数 get() {}
    [&lt;setter&gt;]                                                      // set(value){}
val &lt;propertyName&gt; [: PropertyType] [= &lt;property_initializer&gt;]      // 只读属性, 没有setter
    [&lt;getter&gt;]
</code></pre>  }</li>
<li>改变访问器的可见性(或添加注解): 默认情况下 属性访问器的可见性和属性时一致的, 但是也可以单独指定<br>  var setterVisibility: String = “abc”<pre><code>private set                                   // 可以只添加修饰符, 而不改变其默认实现
</code></pre>  var setterWithAnnotation: Any? = null<pre><code>@Inject set
</code></pre></li>
<li>幕后字段: 如果属性至少有一个访问器使用默认实现, 或者通过 field 引用幕后字段,将会为该属性生成一个幕后字段<br>  var counter = 0<pre><code>set(value){
    field = value
}
</code></pre></li>
<li>编译期常量: 使用 const 修饰, 位于顶层或是 object 的成员, 使用 String或原生类型初始化, 没有自定义 getter</li>
<li>属性延迟初始化: 一般情况下属性必须通过 构造函数 或 初始化器 或 getter 初始化, 使用以下方式可以延迟初始化时机<br>  class Test{<pre><code>lateinit var a: String       // 方式一: 必须是可变属性, 必须是非空类型, 不能自定义 getter 和 setter
var/val b by lazy{}          // 方式二:
</code></pre>  }<br>-</li>
</ul>
</li>
<li><p>创建类的实例: 调用构造方法,   没有  new 关键字<br>  val p = Person()</p>
</li>
</ul>
</li>
<li>继承<ul>
<li>Any 是所有类的基类</li>
<li>继承的写法<ul>
<li>如果基类有主构造函数, 则必须使用该主构造函数就地初始化<br>  class Derived(p: Int) : Base(p)</li>
<li>如果基类没有主构造函数, 那么每个次构造函数必须使用 super 关键字初始化基类, 或者委托另一构造函数做到这一点<br>  class MyView : View {<pre><code>constructor(ctx: Context) : super(ctx)
</code></pre>  }</li>
</ul>
</li>
<li>super 关键字<ul>
<li>调用基类的函数和属性访问器<br>  open class F{<pre><code>open fun test() { print(&quot;aaaaa&quot;) }
open val x: Int get() = 1
</code></pre>  }<br>  class S: F(){<pre><code>override test(){
    super.test()
    print(&quot;bbbbbb&quot;)
}
override val x: Int get() = super.x + 1
</code></pre>  }<br>-</li>
<li>在内部类中, 通过外部类类名限定的 super, 访问外部类的超类<br>  class S: F(){<pre><code>...
inner class SI{
    fun test2(){
        super@S.test()
        print(super@S.x)
    }
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>修饰符号<ul>
<li>open/final:<ul>
<li>类默认为 final, 如果希望被继承, 需要加上 open 修饰</li>
<li>函数默认为 final, 如果希望被重写, 需加上 open 修饰, 且子类重写时必须加上 override修饰, 如果子类不希望再被重写, 加上 final</li>
<li>属性和函数类似, 此外: val 可以重写为 var, var不能重写为 val</li>
</ul>
</li>
<li>abstract: 可用于修饰 类 或 函数 (抽象类或函数肯定可以被继承和重写, 不需要再添加 open 修饰)</li>
<li>可见性修饰符 (作用目标: 类、对象、接口、构造函数、方法、属性及其setter, getter可见性总是和属性本身一致)<br>  private(自己可见)、 protected(不适用顶层声明)、 internal(相同模块内可见) 和 public(缺省默认)</li>
</ul>
</li>
<li>接口<ul>
<li>使用 interface 关键字, 多继承</li>
<li>可以有抽象方法 和 实现方法(java8)</li>
<li>可以有属性, 但必须为 抽象的 或者 提供访问器实现<br>  interface A{<pre><code>val a: Int
val b: String
    get() = &quot;bbb&quot;                  // 接口中不支持 幕后字段
</code></pre>  }</li>
<li>多继承与 覆盖冲突<br>  interface A{<pre><code>fun a(){}
</code></pre>  }<br>  interface B{<pre><code>fun a(){}
</code></pre>  }<br>  class C: A, B{<pre><code>override fun a() {                // 虽然 a 方法在父类中是实现方法, 但这里必须要重写, 且可以通过 super&lt;父类名&gt;选择性调用父类实现
    super&lt;A&gt;.a()
}
</code></pre>  }</li>
</ul>
</li>
<li>扩展<ul>
<li>定义扩展函数<br>  fun 类型名称.方法名(){ // 扩展函数体可通过 this 访问调用对象 }</li>
<li>扩展函数式静态解析的: 并没有在目标类中插入新的成员, 仅仅表示可以通过该类型变量使用点语法调用函数</li>
<li>如果扩展函数和成员方法冲突了, 那么成员方法总是优先的</li>
<li>可空接受者<br>  fun Any?.toString(): String? = if(this == null){ null } else { this.toString() }</li>
<li>扩展属性: 扩展属性不能使用幕后字段, 不能有初始化器, 只能有 访问器<br>  val <t> List<t>.lastIndex: Int<pre><code>get() = size - 1
</code></pre></t></t></li>
<li>为伴生对象 定义扩展<br>  class A{<pre><code>companion object{}
</code></pre>  }<br>  fun A.Companion.test(){ … }<br>  A.test();                         // 可直接通过类名访问</li>
<li>定义扩展的位置<ul>
<li>一般情况下定义在顶层</li>
<li>也可以在一个类(扩展分发者) 内部 为 另一个类(扩展接受者) 定义扩展<ul>
<li>在此扩展方法中可以同时访问 扩展分发者 以及 扩展接受者 的成员</li>
<li>如果 扩展分发者 和 扩展接受者的成员名称冲突时, 默认访问的是 扩展分发者的成员, 但是也可以通过 this 的限定语法指定访问<br>  class A{<pre><code>fun a1(){}
fun a2(){}
</code></pre>  }<br>  class B{<pre><code>fun a2(){}
fun b(){}
fun A.aa(){
    b();            // 调用了 B 的方法
    a1();           // 调用了 A 的方法
    a2();           // 调用了 B 的方法
    this@A.a2();     // 通过 this 的限定语法, 调用了 A 的方法
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>扩展的作用: 代替 工具类</li>
</ul>
</li>
<li>数据类<ul>
<li>定义数据类<br>  data class Uer(val name: String, val age: Int)</li>
<li>数据类的要求<ul>
<li>必须有主构造函数, 且至少有一个参数, 且参数必须声明为属性(使用 var 或 val 标记)</li>
<li>如果希望使用无参构造函数, 可以给属性设置默认值</li>
<li>数据类不能是抽象、开放、密封或者内部的</li>
</ul>
</li>
<li>编译器会通过主构造函数为数据类自动生成以下函数 (没有收到声明, 且父类没有设置为 final)<ul>
<li>equals()、 hashCode()</li>
<li>toString()                 // 格式是 “User(name=John, age=42)” …</li>
<li>componentN()               // 按声明顺序对应于所有属性</li>
<li>copy()                     // 用于复制一个对象, 并只改变部分属性<br>  val jack = User(name = “Jack”, age = 1)<br>  val olderJack = jack.copy(age = 2)</li>
</ul>
</li>
<li>在类体中声明属性: 编译器自动生成的函数只会使用主构造函数中的属性, 而不会使用类体中声明的属性</li>
<li>数据类的解构<br>  val jane = User(“Jane”, 35)<br>  val (name, age) = jane</li>
</ul>
</li>
<li>内部类<ul>
<li>在类的内部定义的类<br>  class Outer{<pre><code>private val bar: Int = 1
class Inner1{                // 表示静态内部类                     -&gt;  val i1 = Outer.Inner2().foo()
    fun foo() = 2
}
inner class Inner2{          // 使用inner关键字标记, 表示非静态内部类 -&gt;  val i2 = Outer().Inner2().foo()
    fun foo() = bar          // 可访问外部类成员, 并且可通过 this@Outer 引用外部类实例
}
</code></pre>  }</li>
<li>匿名内部类: 使用 对象表达式.          // 如果是函数式java接口的实例, 可使用lambda chipLayout.setOnClickListener { v -&gt; print(v?.id) }<br>  view.setOnClickListener(object: View.OnClickListener{<pre><code>override fun onClick(v: View?) { }
</code></pre>  })</li>
</ul>
</li>
<li>密封类<ul>
<li>定义一个密封类<br>  sealed class XXX</li>
<li>密封类的限制:<ul>
<li>不允许有非 private 的构造函数(其构造函数默认是 private), 其所有直接子类必须和其写在同一个文件中</li>
<li>在使用 when表达式时, 如果各个分支条件可以覆盖所有情况, 那么就不需要 else 分支. 密封类可以满足这一点</li>
</ul>
</li>
</ul>
</li>
<li>枚举类<ul>
<li>最基本的用法: (每一个枚举常量都是对象)<br>  enum class Direction {<pre><code>NORTH, SOUTH, WEST, EAST
</code></pre>  }</li>
<li>每一个枚举常量都是枚举类的实例<br>  enum class Color(val rgb: Int) {<pre><code>RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)
</code></pre>  }</li>
<li>枚举常量也可以声明自己的匿名类<br>  enum class ProtocolState {<pre><code>WAITING {
    override fun signal() = TALKING
},
TALKING {
    override fun signal() = WAITING
};
abstract fun signal(): ProtocolState
</code></pre>  }</li>
</ul>
</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li>对象表达式 (匿名对象)<ul>
<li>使用 object 关键字表示匿名对象<br>  view.setOnClickListener(object: View.OnClickListener{<pre><code>override fun onClick(v: View?) { }
</code></pre>  })</li>
<li>可以有多个超类型(逗号分隔), 如果超类型存在构造函数, 则必须传递参数<br>  val ab: A = object : A(1), B {<pre><code>// 重写方法 或 属性
</code></pre>  }</li>
<li>甚至可以不指定超类型<br>  val adHoc = object {<pre><code>var x: Int = 0
var y: Int = 0
</code></pre>  }</li>
<li>使用匿名对象作为 共有函数 的返回值 或 参数时, 其实际类型是匿名对象的超类型(如果为指明, 则是 Any 类型)</li>
<li>使用匿名对象作为 私有函数 的返回值 或 参数时, 其实际类型是匿名对象类型</li>
</ul>
</li>
<li>对象声明 (不是表达式, 不能用在赋值语句的右边)<ul>
<li>使用 object 关键字 声明对象 (等效于 java 中的 饿汉式单例)<br>  object AppScope{<pre><code>fun saveData(key: String, value: String){ ... }
</code></pre>  }</li>
<li>如何访问对象成员<ul>
<li>kotlin中: AppScope.saveData(…)</li>
<li>java中:   AppScope.INSTANCE.saveData(…)</li>
</ul>
</li>
<li>对象可以有超类型<br>  object MyLisener: MessageListener(){<pre><code>override fun ...
</code></pre>  }</li>
</ul>
</li>
<li>伴生对象<ul>
<li>定义伴生对象: 类内部的object 用 companion 关键字标记, 一个类只能有一个伴生对象,<br>  class MyClass {               <pre><code>companion object Factory {
    @JvmStatic   
    fun create(): MyClass = MyClass()
    @JvmField
    val TAG: String = &quot;tag&quot;
}
</code></pre>  }</li>
<li>访问伴生对象的成员<ul>
<li>kotlin中: val instance = MyClass.create()</li>
<li>java中:<ul>
<li>如果没有添加 @JvmStatic 、@JvmField 注解: val instance = MyClass.Factory.create()</li>
<li>如果添加了 @JvmStatic 、@JvmField 注解: val instance = MyClass.create()</li>
</ul>
</li>
</ul>
</li>
<li>伴生对象的名称可以省略, 此时将使用默认的名称 Companion<br>  class MyClass {<pre><code>companion object {
    fun create(): MyClass = MyClass()
}
</code></pre>  }<br>  MyClass.Companion.create()</li>
<li>虽然访问伴生对象的成员类似 java中的静态成员, 但实际在运行时他们任然是真实对象的实例成员</li>
<li>在 jvm平台, 如果使用了 @JvmStatic 、@JvmField 注解, 可以将伴生对象的成员生成为真正的静态成员</li>
<li>kotlin中使用静态成员时, 应考虑是否有必要, 是否用 包级函数/变量 替代</li>
</ul>
</li>
<li>单例模式<ul>
<li>饿汉式:<br>  objcet APIHelper{}</li>
<li>懒汉式:<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    private var instance: SingletonDemo? = null
        get() {
            if (field == null) {
                field = SingletonDemo()
            }
            return field
        }
    // @Synchronized   添加该注解表示 同步
    fun get(): SingletonDemo{
        return instance!!
    }
}
</code></pre>  }</li>
<li>双重校验锁式<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    val instance: SingletonDemo by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { SingletonDemo() }
}
</code></pre>  }</li>
<li>静态内部类式<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    val instance = SingletonHolder.holder
}
private object SingletonHolder {
    val holder = SingletonDemo()
}
</code></pre>  }<ul>
<li>带参 ?<br>  class SToast private constructor(val context: Context) : Toast(context) {<pre><code>private object Builder{
    var instance: SToast? = null
}
companion object{
    fun with(context: Context): SToast{
        Builder.instance?:let{
            Builder.instance = SToast(context)
        }
        return Builder.instance!!
    }
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="代理-委托"><a href="#代理-委托" class="headerlink" title="代理(委托)"></a>代理(委托)</h2><ol>
<li>kotlin中可以简单的实现代理模式 (静态代理)<br> interface Animal{<pre><code>fun bark()
</code></pre> }<br> class Dog :Animal {<pre><code>override fun bark() {
    println(&quot;Wang Wang&quot;)
}
</code></pre> }<br> class Cat(animal: Animal) : Animal by animal        // 将 Cat 的所有公有成员都委托给指定的对象<br> Cat(Dog()).bark()                                   // 用 Dog 作为 Cat 的代理</li>
<li>委托属性<ul>
<li>属性委托的语法: val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;<br>  class Example {<pre><code>var p: String by Delegate()
</code></pre>  }<br>  class Delegate {<pre><code>// 必须有 getValue方法, 对应 getter,  参数: 属性的拥有者, 对属性的描述
operator fun getValue(thisRef: Any?, property: KProperty&lt;* &gt;): String {
    return &quot;$thisRef, thank you for delegating &apos;${property.name}&apos; to me!&quot;
}
// var属性还要有 setValue方法, 对应 setter,  参数: 属性的拥有者, 对属性的描述, 属性的值
operator fun setValue(thisRef: Any?, property: KProperty&lt;* &gt;, value: String) {
    println(&quot;$value has been assigned to &apos;${property.name} in $thisRef.&apos;&quot;)
}
</code></pre>  }</li>
<li>kotlin为委托提供的几个工厂方法<ul>
<li>延迟属性 Lazy:   lazy()接受一个 lambda表达式 并返回一个 Lazy实例(在第一次访问属性的getter时执行 lambda并返回结果)<br>  val propLazy: Int by lazy{1}                                // 默认是所有线程同步的<br>  val v: Int by lazy(LazyThreadSafetyMode.PUBLICATION, {1})   // 指定线程不安全<br>  val v: Int by lazy(LazyThreadSafetyMode.NONE, {1})          // 不会有任何线程安全的保证和相关的开销</li>
<li>可观察属性 Observable: (接受两个参数: 初始值, 处理函数)<ul>
<li>在赋值之后执行<br>  var name: String by Delegates.observable(“初始值”) {<pre><code>// 被赋值的属性、旧值和新值
prop, old, new -&gt;
println(&quot;$old -&gt; $new&quot;)
</code></pre>  }</li>
<li>在赋值之前执行(可以拦截)<br>  var name: String by Delegates.vetoable(“初始值”) {<pre><code>// 被赋值的属性、旧值和新值
prop, old, new -&gt;
println(&quot;$old -&gt; $new&quot;)
false
</code></pre>  }</li>
</ul>
</li>
<li>把属性储存在映射中<br>  class User(val map: Map<string, any?="">) {<pre><code>val name: String by map
val age: Int     by map
</code></pre>  }<br>  val user = User(mapOf(<pre><code>&quot;name&quot; to &quot;John Doe&quot;,
&quot;age&quot;  to 25
</code></pre>  ))<br>  // var 属性<br>  class MutableUser(val map: MutableMap<string, any?="">) {<pre><code>var name: String by map
var age: Int     by map
</code></pre>  }</string,></string,></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>定义一个函数<br> fun double(x: Int): Int { return 2 * x }</li>
<li>关于参数<ul>
<li>参数的默认值: (可以减少重载数量,   注意: 重写带默认值的函数时, 需要省略默认值))<br>  fun read(b: Array<byte>, off: Int = 0, len: Int = b.size()) {}</byte></li>
<li>命名参数: 调用函数时, 可以显示的指定名称传参<br>  fun foo(p1: Int = 0, p2: Int){ … }<br>  foo(p2 = 10)</li>
<li>可变参: 使用关键字 vararg  (可变参可以不是最后一个, 但是对于其后面的参数, 需要使用 命名参数 的语法传参)<br>  fun <t> asList(vararg ts: T): List<t> {<pre><code>val result = ArrayList&lt;T&gt;()
for (t in ts) // ts is an Array
    result.add(t)
return result
</code></pre>  }<br>  // 对于可变参可以一个一个的传, 但如果已经有了一个数组, 可以使用 伸展符号( <em> )<br>  val arr = arrayOf(1, 2, 3)<br>  val list = asList(-1, 0, </em> arr, 4)</t></t></li>
<li>泛型参数<br>  fun <t> singletonList(item: T): List<t> {}</t></t></li>
</ul>
</li>
<li>关于返回值<ul>
<li>无返回值: 如果一个函数没有返回值, 那么其返回类型应该是 Unit, 或者直接省略返回类型</li>
<li>单表达式函数: 当函数返回单个表达式时, 可省略 {}, 并使用 = 表示返回值<br>  fun double(x: Int): Int = x <em> 2<br>  fun double(x: Int) = x </em> 2               // 当返回类型可以推断时, 可省略返回类型</li>
</ul>
</li>
<li>中缀语法:<ul>
<li>使用 infix 关键字标识函数<br>  infix fun Int.sh1(x: Int): Int{ …}<br>  1 sh1 2                                  // 使用中缀语法调用函数,  等效于 1.sh1(2)</li>
<li>中缀函数必须满足一下条件<ul>
<li>必须是成员函数 或 扩展函数</li>
<li>必须且只有一个参数</li>
<li>参数不能是 可变参, 且不能有默认值</li>
</ul>
</li>
</ul>
</li>
<li>函数的作用域<ul>
<li>成员函数</li>
<li>顶层函数: kotlin中的函数可以直接声明在 顶层</li>
<li>局部函数: kotlin中的函数可以声明在另一个函数内部 (闭包: 内部函数可访问外部函数中的变量)</li>
</ul>
</li>
<li>尾递归函数用: 使用 tailrec 关键字标记, 并满足要求(递归调用必须是最后一步,并且不能用在 try/catch/finally 块中), 只有后端支持<br> tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))</li>
</ol>
<h2 id="高阶函数-amp-Lambda"><a href="#高阶函数-amp-Lambda" class="headerlink" title="高阶函数 &amp; Lambda"></a>高阶函数 &amp; Lambda</h2><ol>
<li>函数类型<ul>
<li>如何声明函数类型<br>  val click : (View) -&gt; Unit = …</li>
<li>函数类型的一些说明<ul>
<li>如果没有返回值, Unit 也不能省略</li>
<li>如何表示可空类型:  val a: ((Int) -&gt; String)? = …</li>
<li>可选择性的设置参数名(提高可读性):  val click : (view: View) -&gt; Unit = …</li>
<li>函数类型的取值<ul>
<li>使用匿名函数:<br>  val click : (View) -&gt; Unit = fun (v: View){ print(v.id) }</li>
<li>使用Lambda表达式:<br>  val click : (View) -&gt; Unit = { v -&gt; print(v.id) }</li>
<li>使用已有函数的引用<br>  fun test(view: View){  print(view.id) }<br>  val click : (View) -&gt; Unit = ::test</li>
<li>使用函数类型的实现类的实例<br>  class Test : (View) -&gt; Unit{<pre><code>override fun invoke(view: View) {
    print(view.id)
}
</code></pre>  }<br>  val click : (View) -&gt; Unit = Test()</li>
</ul>
</li>
<li>如果信息足够推断函数类型时, 可省略类型<br>  val plus = {i : Int -&gt; i + 1}</li>
<li>调用函数类型的方式<ul>
<li>方式一: 直接调用<br>  var result = plus(3)</li>
<li>方式二: 使用 invoke<br>  var result = plus.invoke(3)</li>
</ul>
</li>
<li>带接受者的函数类型<ul>
<li>定义带接受者的函数类型(类似 扩展函数)<br>  val myConcat: String.(String) -&gt; String = { string -&gt; this + string }     // this表示该函数的调用者<br>  val result = “abc”.myConcat(“efg”)                 // 用 “abc” 调用该函数, 等价于  myConcat(“abc”, “efg”)</li>
<li>函数类型的接受者, 可以相互转化为其参数列表的第一个参数<br>  fun a(str1: String, str2: String) = str1 + str2<br>  val myConcat: String.(String) -&gt; String = ::a         </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Lambda表达式<ul>
<li>例子<br>  val map = mapOf(“key1” to “value1”, “key2” to “values”)<br>  map.forEach({key: String, value: String -&gt;<pre><code>print(&quot;$key &amp; $value&quot;)
</code></pre>  })</li>
<li>Lambda表达式写在 {} 中, 参数列表 与 函数体 之间用 -&gt; 分开</li>
<li>参数类型可省略<br>  map.forEach({key, value -&gt;<pre><code>print(&quot;$key &amp; $value&quot;)
</code></pre>  })</li>
<li>对于没有使用的参数, 可以用 <em> 表示<br>  map.forEach({</em> , value -&gt;<pre><code>print(value)
</code></pre>  })</li>
<li>如果Lambda表达式的参数列表只有一个参数, 那么可以省略参数列表 和 -&gt;, 在函数体中如果要使用该参数, 可以用 it代替<br>  val list = listOf(1,2,3)<br>  list.forEach({ print(it) })</li>
<li>如果Lambda表达式需要有返回值, 那么函数体中的最后一个表达式会作为其返回值<br>  val newList = list.map({ 2 <em> it })                       // 不要使用 return, 除非带上限定符号, 比如 return@map<br>  // val newList = list.map({ return@map 2 </em> it })</li>
<li>如果 Lambda 是另一个函数的最后一个参数, 那么可以写在 () 之外<br>  val newList = list.map() { 2 * it }   </li>
<li>如果 Lambda 是另一个函数的唯一个参数, 那么 () 可省略<br>  val newList = list.map { 2 * it }   </li>
</ul>
</li>
<li>高阶函数: 使用函数作为 参数 或 返回值</li>
<li>内联函数<ul>
<li>使用高阶函数会造成额外的消耗(函数也是对象, 需要单独开辟空间, 寻址..), 使用内联函数可以解决这一问题<br>  inline fun lock<t>(lock: Lock, body: () -&gt; T): T {}</t></li>
<li>inline会影响函数本身和作为参数的 lambda表达式. 内联会导致生成的代码量增加, 可以通过 noinline 标识哪些参数不进行内联<br>  inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {}</li>
<li>lambda表达式中不允许使用单独的 return; 但是在内联情况下, 可以直接 return, 标识从包裹该lambda表达式最近的函数返回</li>
<li>内联属性: inline 也可以用来修饰 没有幕后字段 的属性<ul>
<li>作用于访问器<br>  val foo: Foo<pre><code>inline get() = Foo()
</code></pre>  var bar: Bar<pre><code>get() = ……
inline set(v) { …… }
</code></pre></li>
<li>直接作用于整个属性, 表示所有访问器都标记为内联<br>  inline var bar: Bar<pre><code>get() = ……
set(v) { …… }
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>类型别名<br> typealias NodeSet = Set<network.node>               // 为泛型起别名<br> typealias AInner = A.Inner                           // 为内部类起别名<br> typealias MyHandler = (Int, String, Any) -&gt; Unit    // 为函数起别名 (可以简化函数类型的书写)<br> typealias Predicate<t> = (T) -&gt; Boolean</t></network.node></li>
<li>集合<ul>
<li>不可变集合: List<out t=""> .  Set<out t=""> .  Map<k, out="" v=""><br>  val list: List<int> = listOf(1,2,3)<br>  val set = setOf(‘a’,’b’)<br>  val map = mapOf<string, int="">(“key1” to 1, “key2” to 2)</string,></int></k,></out></out></li>
<li>可变集合: MutableList<t> .  MutableSet<t> .  MutableMap<k, v=""><br>  val list: MutableList<int> = mutableListOf(1,2,3)<br>  val set = mutableSetOf(‘a’,’b’)<br>  val map = mutableMapOf<string, int="">(“key1” to 1, “key2” to 2)</string,></int></k,></t></t></li>
<li>访问 map 集合<br> println(map[“key”])<br> map[“key”] = value</li>
<li>集合的复制以及可变性变化<br> toList()  toMutableList() …</li>
</ul>
</li>
<li>解构<ul>
<li>对象解构<br>  val (name, age) = person           // 对于不需要用到的变量, 可以使用 <em> 代替   val (name, </em> ) = person</li>
<li>在 lambda 表达式中解构<ul>
<li>示例<br>  map.mapValues { entry -&gt; “${entry.value}!” }<br>  map.mapValues { (key, value) -&gt; “$value!” }</li>
<li>声明 两个参数 和 声明一个 解构来取代单个参数之间的区别：<br>  { a -&gt; …… }                  // 一个参数<br>  { a, b -&gt; …… }               // 两个参数<br>  { (a, b) -&gt; …… }             // 一个解构<br>  { (a, b), c  -&gt; …… }         // 一个解构对以及其他参数</li>
<li>解构中未被使用的变量可以使用 <em> 代替<br>  map.mapValues { (</em> , value) -&gt; “$value!” }</li>
<li>可以指定整个解构的参数的类型 或者 分别指定特定组件的类型：<br>  map.mapValues { (<em> , value): Map.Entry<int, string=""> -&gt; “$value!” }<br>  map.mapValues { (</int,></em> , value: String) -&gt; “$value!” }</li>
</ul>
</li>
</ul>
</li>
<li>利用 with 调用一个对象实例的多个方法<br> class Turtle {<pre><code>fun penDown()
fun penUp()
fun turn(degrees: Double)
fun forward(pixels: Double)
</code></pre> }<br> with(Turtle()) {<pre><code>penDown()
for(i in 1..4) {
forward(100.0)
    turn(90.0)
}
penUp()
</code></pre> }</li>
<li>泛型<ul>
<li>类泛型<br>  class Box<t>(t: T) {<pre><code>var value = t
</code></pre>  }<br>  val box: Box<int> = Box<int>(1)                 // 如果泛型可以推断, 那么可以省略 val box = Box(1)</int></int></t></li>
<li>函数泛型<br>  fun <t> singletonList(item: T): List<t> {}      // 普通函数泛型<br>  fun <t> T.basicToString() : String {}           // 扩展函数泛型<br>  val l = singletonList<int>(1)                   // 调用泛型函数需要在 &lt;&gt; 中指明类型</int></t></t></t></li>
<li>泛型变异<ul>
<li>Java中是在使用处型变<ul>
<li>协变: &lt;? extends T&gt;  可以使用父类型的地方, 就可以接受子类型;   只能取值, 不能写入, 称为 生产者<br>  public class Utils{<pre><code>public static void test(List&lt;? extends View&gt; list){
    // 只能从 list 中取值, 而不能写入
    View view = list.get(0);                 // 可以通过编译
    // list.add(new TextView(context));      // 不能通过编译
}
</code></pre>  }<br>  List<imageview> imgs = new ArrayList&lt;&gt;();<br>  Utils.test(imgs);</imageview></li>
<li>逆变 &lt;? super T&gt;   可以使用子类型的地方, 就可以接受父类型;    可以写入, 取值都是 Object,  称为 消费者<br>  public class Utils{<pre><code>public static void test(List&lt;? super ImageView&gt; list){
    // 可以往 list 中写入, 但取值都是 Object
    list.add(new ImageView(context));
    Object object = list.get(0);
}
</code></pre>  }<br>  List<view> views = new ArrayList&lt;&gt;();<br>  Utils.test(views);</view></li>
</ul>
</li>
<li>Kotlin中是在声明处型变<ul>
<li>out: 类似 协变, 表示泛型只能被生产, 不能被消费(就是只能作为返回值, 不能作为参数)<br>  class Test<out t="">{<pre><code>fun test(): T { ... }
</code></pre>  }<br>  val t: Test<view> = Test<imageview>()           // 这是合法的, 因为泛型只能被读取, 不能写入 (安全)</imageview></view></out></li>
<li>in: 类似 逆变, 表示泛型只能被消费, 不能被生产 (就是只能作为参数, 不能作为返回值)<br>  class Test<in t="">{<pre><code>fun test(t: T) { ... }
</code></pre>  }<br>  val t: Test<imageview> = Test<view>()           // 这是合法的, 因为泛型只能被写入, 不能读取 (安全)</view></imageview></in></li>
</ul>
</li>
</ul>
</li>
<li>泛型约束<br>  fun <t: number=""> test(t: T){  }                // 泛型约束为 Number子类及其子类<br>  test(1)                                       // 可以通过编译<br>  test(“a”)                                     // 不能通过编译<br>  fun <t> test(t: T) where T : A, T: B{  }      // 泛型约束为: 必须是 A的子类 也是 B的子类</t></t:></li>
</ul>
</li>
<li>注解<ul>
<li>元注解<br>  @Target              指定注解可作用的地方(类, 函数, 属性, 表达式)<br>  @Retention           指定注解被保留的时间长短(AnnotationRetention.SOURCE, ..CLASS, ..RUNTIME)<br>  @Repeatable         允许 在单个元素上多次使用相同的该注解<br>  @MustBeDocumented   指定 该注解是公有 API 的一部分，并且应该包含在 生成的 API 文档中显示的类或方法的签名中。</li>
<li>利用元注解 自定义注解<br>  @Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,<pre><code>AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)
</code></pre>  @Retention(AnnotationRetention.SOURCE)<br>  @MustBeDocumented<br>  annotation class Fancy</li>
<li>注解可以有接受参数的构造函数<br>  annotation class Special(val why: String)</li>
<li>使用注解<br>  @Special(“example”) class Foo {}</li>
</ul>
</li>
<li>反射<ul>
<li>类引用<ul>
<li>通过类名获取<br>  val c = MyClass::class               // 该引用是KClass类型, 要获得 Java 类引用， 需要在 KClass 实例上使用 .java 属性。</li>
<li>通过对象获取<br>  val widget: Widget = ……<br>  widget::class</li>
</ul>
</li>
<li>函数的引用 (用于高阶函数, lamada 表达式也可以实现类似功能)<ul>
<li>获取函数的引用<br>  fun isOdd(x: Int) = x % 2 != 0<br>  listOf(1, 2, 3).filter(::isOdd)  </li>
<li>函数的引用可以存储到变量中<br>  val predicate: (Int) -&gt; Boolean = ::isOdd</li>
<li>在外部引用 类的成员函数(或构造函数) 需要指定接受者<br>  val isListEmpty: List<string>.() -&gt; Boolean = List<string>::isEmpty    // 函数类型一定要指明接受者, 因为无法自动推断出来<br>  val list = listOf(“1”)<br>  print(“isEmpty: ${isListEmpty(list)}”)                                 // 可将调用者作为第一个参数传入<br>  print(“isEmpty: ${list.isListEmpty()}”)                                // 和上面是等价的</string></string></li>
<li>引用需要接受者的函数时, 使用 类名 和 类实例 都可以<br>  class Test{<pre><code>fun double (p: Int) = 2 * p
</code></pre>  }<br>  val test = Test()<br>  val d1: Test.(Int) -&gt; Int = Test::double                               // 使用类名限定<br>  val d2: (Int) -&gt; Int = test::double                                    // 使用类实例限定<br>  val result1 = d1(test, 3)                                              // 需要将调用者作为第一个参数, 或者直接  test.d1(3)<br>  val result2 = d2(3)                                                    // 无需再设置调用者</li>
<li>引用特定对象的函数<br>  val numberRegex = “\d+”.toRegex()<br>  println(numberRegex.matches(“29”))                                     // 输出“true”<br>  val isNumber = numberRegex::matches<br>  println(isNumber(“29”))                                                // 输出“true”</li>
<li>构造函数引用<br>  ::类名                // 表示 零参数构造函数 的引用</li>
</ul>
</li>
<li>属性引用<ul>
<li>获取属性的引用<br>  var x = 1<br>  ::x.name              // 获取属性名<br>  ::x.get()             // 获取值<br>  ::x.set(3)            // 对于 var 属性, 还可以赋值</li>
<li>在外部引用类的属性<br>  class A(var p: Int)<br>  val a = A(3)<br>  A::p.set(a, 5)<br>  val value = A::p.get(a)</li>
<li>引用类的扩展属性<br>  val String.lastChar: Char<pre><code>get() = this[length - 1]
</code></pre>  val str = “abc”<br>  val result = String::lastChar.get(str)</li>
<li>引用特定对象的属性<br>  val prop = “abc”::length<br>  val l = prop.get()</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>1.</p>
<ol>
<li>通过 launch、 runBlocking 开启协程<ul>
<li>一个关于协程的小案例<br>  override fun onCreate(savedInstanceState: Bundle?){<pre><code>setContentView(R.layout.activity_main)
launch(CommonPool) {                    // 在后台启动一个协程
    delay(1000L)                        // 延迟1s,  delay是一个特殊的 suspend fun, 不会锁死线程, 只会挂起协程, 只能在协程内使用
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
runBlocking{                            // 在当前线程启动协程, 会阻塞当前线程, 直到协程内部的代码运行完毕
    delay(1000L)  
}
</code></pre>  }</li>
<li>直接用 runBlocking 包裹整个函数 (泛型是指当前函数的返回值类型, 如果需要返回值, runBlocking 代码块的最后一个表达式会作为返回值)<br> override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{    <pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
launch(CommonPool) {
    delay(2000L)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
delay(2100L)
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre> }</unit></li>
<li>等待协程运行完毕<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {                                  // 启动新的协程, 并通过变量保留其引用
    delay(2000L)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
job.join()                                                           // 等待子协程结束后才会执行后面的代码
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
</ul>
</li>
<li>协程的取消<ul>
<li>通过 lauch返回的 job,  调用 cancel() 可以取消协程<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {
    repeat(100){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i @ ${Thread.currentThread().name}&quot;)
        delay(1000L)
    }
}
delay(3100L)
job.cancel()                                // 取消协程
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>如果协程一直在运行, 那么它就不会去检查取消标志, 结构就无法取消成功. 解决方式是 在代码中主动去检查取消标志<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
var time = System.currentTimeMillis()
val job: Job = launch(CommonPool) {
    var i = 0
    while (isActive &amp;&amp; i &lt; 1000){                  // isActive是协程内部的一个属性,可以检查该协程是否被取消
        if(System.currentTimeMillis() &gt;= time){
            Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;${i++} @ ${Thread.currentThread().name}&quot;)
            time += 1000
        }
    }
}
delay(3100L)
job.cancel()
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>协程取消时时候回抛出 CancellationException, 可以通过  try {} finally {} 处理<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {
    try {
        repeat(1000){ i -&gt;
            Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i @ ${Thread.currentThread().name}&quot;)
            delay(500)
        }
    }catch (e: Exception){                        // catch不是必须的, 这里只是验证确实抛出了异常
        Log.e(&quot;&gt;&gt;&gt;&quot;, e.toString())
    }fianlly{ ... }
}
delay(3100L)
job.cancel()
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>超时自动取消 (withTimeout): 在当前线程启动协程, 如果协程内的代码在指定时间内未执行完毕, 就抛出异常 TimeoutException<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val result = withTimeout(3000){                                             
    repeat(10){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i: @ ${Thread.currentThread().name}&quot;)
        delay(1000)
    }
    &quot;最后一行表达式就是结果&quot;
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;结果等于: $result&quot;)
</code></pre>  }</unit></li>
<li>安全的超时自动取消(withTimeoutOrNull): 超时后不会抛出异常, 只是返回结果是 null<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val result = withTimeoutOrNull(3000){
    repeat(1){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i: @ ${Thread.currentThread().name}&quot;)
        delay(1000)
    }
    &quot;最后一行表达式就是结果&quot;
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;结果等于: $result&quot;)
</code></pre>  }</unit></li>
</ul>
</li>
<li>suspend fun :  由 suspend 修饰的方法, 和普通方法结构完全一样<ul>
<li>suspend fun 只能在另一个 suspend fun 中调用<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) { test() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }<br>  suspend fun test(){<pre><code>delay(2000L)
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>多个 suspend fun 的执行顺序<ul>
<li>默认是串行执行<br>  suspend fun one(): Int{         // 延迟 1s 后返回 1<pre><code>delay(1000L)
return 1
</code></pre>  }<br>  suspend fun two(): Int{         // 延迟 1s 后返回 2<pre><code>delay(1000L)
return 2
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {                   // 在当前线程启动协程, 会阻塞当前线程, 最后会返回该协程消耗的时长
    val one = one()
    val two = two()
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one + two}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)                   // 时间差不多是 2s
</code></pre>  }</unit></li>
<li>async &amp; await<ul>
<li>说明:<br>  async 的作用是在后台启动一个协程, 并返回一个 Deferred 对象, 它是Job的子类, 表示一个承诺(promise) 会在稍后返回一个结果<br>  await 是 Deferred 上的一个方法, 作用是获取最终的结果 (会挂起当前协程, 直到获取到结果才会执行后面的代码)</li>
<li>示例:<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {
    val one = async(CommonPool){ one() }     // 在后台启动一个新的协程
    val two = async(CommonPool){ two() }
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}   @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)               // 因为是 并行执行的, 时间差不多缩短一半
</code></pre>  }</unit></li>
<li>async 的惰性求值: async函数可以传入一个参数 CoroutineStart.LAZY, 开启惰性求值, 表示只有调用 awaite 或 start 时开会开启协程<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {
    val one = async(CommonPool, CoroutineStart.LAZY){ one() }     
    val two = async(CommonPool, CoroutineStart.LAZY){ two() }
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}   @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)               // 时间 又 差不多是 2s
</code></pre>  }</unit></li>
<li>async 风格的函数<br>  fun oneAsync() = async(CommonPool){              // oneAsync 就是一个普通函数, 不过调用它时会异步开启一个协程<pre><code>one()   
</code></pre>  }<br>  fun twoAsync() = async(CommonPool){<pre><code>two()
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) {           // 注意这里没有了 runBlocking<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val one = oneAsync()                                       // 可以在协程之外调用
val two = twoAsync()
runBlocking {
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}&quot;)  // 但是 await 还是必须要在协程中调用
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>协程的上下文:  协程总是在 CoroutineContext 类型的上下文中执行<ul>
<li>协程调度器: 决定协程将要在 哪个(或哪些)线程中执行<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val jobs = arrayListOf&lt;Job&gt;()
jobs += launch(Unconfined){           // 无限制, 会在当前线程开启协程
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Unconfined @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(coroutineContext){     // 限制使用 父级上下文, 这里是 runBlocking的上下文(任何协程内都能获取 coroutineContext)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;coroutineContext @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(CommonPool){           // 一个线程池 ForkJoinPool.commonPool
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;CommonPool @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(newSingleThreadContext(&quot;MyNewThread&quot;)){ // 开启新的线程, 实际项目中如果不再使用它, 需要通过 close 方法释放
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;newSingleThreadContext @ ${Thread.currentThread().name}&quot;)
}
jobs.forEach { it.join() }
</code></pre>  }</unit></li>
<li>父子协程: 如果 协程B 使用了 协程A 的上下文, 那么 B 就是 A 的子协程<ul>
<li>父协程会等其所有子协程执行完毕后才会结束</li>
<li>取消父协程, 它所有的子协程也会取消</li>
</ul>
</li>
</ul>
</li>
<li>Channel: 用于在 协程间 发送 和 接收 数据<ul>
<li>send &amp; receive : 发送数据与接受 (都会将协挂起)<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val channel = Channel&lt;Int&gt;()
val job = launch(CommonPool){
    for (i in 1 .. 5)
        channel.send( i * i)           // 发送数据
    channel.close()                    // 发送结束
}
for (value in channel)                 // 迭代获取数据 (底层通过 receive) , 直到 channel 关闭
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$value&quot;)
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Over&quot;)
</code></pre>  }</unit></li>
<li>使用 produce &amp; consumeEach 简化 channel 的生产和消费<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val product = product()
product.consumeEach { Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$it&quot;) }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Over&quot;)
</code></pre>  }<br>  fun product() = produce<int>(CommonPool){<pre><code>for (i in 1 .. 5) send( i * i)
</code></pre>  }</int></unit></li>
<li>Channel缓冲区:<ul>
<li>Channel 默认不开启缓冲, 它会等 send 和 receive都准备好之后再进行数据传输. 如果 send先调用, 也会挂起直到 receive被调用</li>
<li>构建 Channel 是可以指定缓冲区大小. 设置缓冲的情况下, 允许在没有 receive的时候先发送几条数据, 直到填满缓冲区<br>  val channel = Channel<int>(5)</int></li>
</ul>
</li>
</ul>
</li>
<li>多个协程更改共享数据<ul>
<li>数据安全问题: 多个协程同时对数据进行修改, 导致结果的未知性<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val jobs = List(1000){
    launch(CommonPool){
        count++
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)                // 结果不可预知
</code></pre>  }</unit></li>
<li>解决方式<ul>
<li>方式一: 粗粒度的控制, 将所有协程 限制在 一个线程上<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val ctx = newSingleThreadContext(&quot;ctx1&quot;)
val jobs = List(1000){
    launch(ctx){
        count++
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)           // 结果是 1000
</code></pre>  }</unit></li>
<li>方式二: 细粒度的控制, 使用互斥锁 Mutex<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val mutex = Mutex()
val jobs = List(1000){
    launch(CommonPool){
        mutex.withLock { count++ }        // 等价于  mutex.lock(); try{ count++ } finally{ mutex.unlock() }
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)                    // 结果是 1000
</code></pre>  }</unit></li>
<li>方式三: 使用 Actor (就是一个协程, 其中可以保存数据, 并带有一个和其它协程通信的 channel )<br>  sealed class CounterMsg<br>  object IncCounter: CounterMsg()<br>  class GetCounter(val response: CompletableDeferred<int>): CounterMsg()<br>  fun counterActor() = actor<countermsg>(CommonPool){<pre><code>var counter = 0
for (msg in channel){                                      // 迭代收到的数据
    when(msg){
        is IncCounter -&gt; counter++                         // 修改数据
        is GetCounter -&gt; msg.response.complete(counter)    // 将结果返回
    }
}
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
val counter = counterActor()                          // 创建 Actor
val jobs = List(1000){
    launch(CommonPool){
        counter.send(IncCounter)                      // 发送消息 通知修改数据
    }
}
jobs.forEach { it.join() }
val res = CompletableDeferred&lt;Int&gt;()                  // 用于获取数据
counter.send(GetCounter(res))                         // 发送消息 通知需要获取结果
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;${res.await()}&quot;)                        // 结果是 1000
counter.close()
</code></pre>  }</unit></countermsg></int></li>
</ul>
</li>
</ul>
</li>
<li>在 Android中使用协程<ul>
<li>添加依赖: implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-android:0.18’</li>
<li>一个简单的案例<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job = launch(UI){                      // 使用 UI 上下文 开启协程
    for (i in 10 downTo 1){
        tv.text = &quot;CountDown $i&quot;           // 修改 TextView 的 文本
        delay(500L)                        // 延迟 500  (不会阻塞线程, 只会挂起协程)
    }
    tv.text = &quot;Done&quot;
}
bt.setOnClickListener { job.cancel() }     // 点击按钮 取消协程
</code></pre>  }</unit></li>
<li>通过UI上下文使用 actor<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
bt.onClick {
    for (i in 10 downTo 1){
        tv.text = &quot;Hellow: $i&quot;
        delay(500)
    }
    tv.text = &quot;Done!!!&quot;
}
</code></pre>  }<br>  fun View.onClick(action: suspend () -&gt; Unit){<pre><code>val eventActor = actor&lt;Unit&gt;(UI){
    for (event in channel) action()
}
setOnClickListener{
    // offer方法会尝试给 actor传递数据, 如果此时actor正在处理其它数据, 则会根据情况做不同处理
        // 通过 actor&lt;Unit&gt;(UI) 创建的 actor                   -&gt;  直接将新的数据丢弃
        // 通过 actor&lt;Unit&gt;(UI, Channel.CONFLATED) 创建的数据   -&gt;  保留最新的那条数据, 等 actor空闲后再传入
        // 通过 actor&lt;Unit&gt;(UI, Channel.UNLIMITED) 创建的数据   -&gt;  将所有新数据依次保存, 等 actor空闲后再依次传入
    eventActor.offer(Unit)
}
</code></pre>  }</unit></li>
<li>使用协程的一些建议<ul>
<li>为了便于在页面销毁时统一释放资源, 建议将页面中的所有协程用一个 Job管理<br>  interface JobHolder{<pre><code>val job: Job
</code></pre>  }<br>  class MainActivity : AppCompatActivity(), JobHolder {<pre><code>override val job: Job = Job()                           // 每个页面都持有一个顶层 job
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    launch(job + UI){ ... }                             // 开启协程时, 这样传递上下文
}
override fun onDestroy() {
    super.onDestroy()
    job.cancel()                                         // 页面销毁时取消
}
</code></pre>  }</li>
<li>假如需要在自定义View中获取 Job, 可以通过扩展属性实现<br>  val View.contextJob: Job<pre><code>get() = (context as? JobHolder)?.job ?: NonCancellable
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/02/12/Eventbus使用及源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/Eventbus使用及源码分析/" itemprop="url">Eventbus使用及源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:37:04+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="EventBus基础"><a href="#EventBus基础" class="headerlink" title="EventBus基础"></a>EventBus基础</h2><h3 id="何为EventBus"><a href="#何为EventBus" class="headerlink" title="何为EventBus"></a>何为EventBus</h3><p>EventBus是Android和Java的publish/subscribe事件总线。</p>
<h4 id="EventBus框架"><a href="#EventBus框架" class="headerlink" title="EventBus框架"></a>EventBus框架</h4><p>对于EventBus除了greenrobot的EventBus，实际上还有Google出品的Guava以及square的otto（修改自Guava），<br>Guava是一个庞大的库，EventBus只是它附带的一个小功能，实际项目使用较少。用的最多的是greenrobot<br>的EventBus，该库优点是接口简洁、集成方便。</p>
<h3 id="EventBus基本使用"><a href="#EventBus基本使用" class="headerlink" title="EventBus基本使用"></a>EventBus基本使用</h3><p>本文主要讨论greenrobot的EventBus（3.1.1）库。</p>
<h4 id="EventBus中的三个主要角色"><a href="#EventBus中的三个主要角色" class="headerlink" title="EventBus中的三个主要角色"></a>EventBus中的三个主要角色</h4><ol>
<li>Event：事件，它可以是任意类型，EventBus会根据事件类型进行全局的通知；</li>
<li>Subscribe：事件订阅者，而在3.0之后事件处理的方法名可以随意取，不过需要加上注解@subscribe，<br>并且指定线程模型，默认是POSTING。</li>
<li>Publisher：事件的发布者，可以在任意线程里发布事件。一般情况下，使用 EventBus.getDefault()<br>就可以得到一个EventBus对象，然后再调用 post(Object) 方法发布事件即可。<br>各角色协作流程如下：<br><img src="./images/EventBus-Publish-Subscribe.png" alt="角色协作"><h4 id="EventBus的5种线程模型，分别是"><a href="#EventBus的5种线程模型，分别是" class="headerlink" title="EventBus的5种线程模型，分别是:"></a>EventBus的5种线程模型，分别是:</h4></li>
<li><strong>POSTING</strong> ：订阅者将直接在同一个线程中调用，该线程将发布该事件，这是默认值。事件传递意<br>味着开销最小，因为它完全避免了线程切换。 因此，这是已知在很短的时间内完成而不需要主线程的简单任<br>务的推荐模式。 使用此模式的事件处理程序必须快速返回以避免阻止发布线程，这可能是主线程；</li>
<li><strong>MAIN</strong>：在Android上，将在Android的主线程（UI线程）中调用订阅者。 如果发布线程是主线程，<br>订阅者方法将直接调用，阻止发布线程。 否则事件排队等待交付（非阻塞）。 使用此模式的订户必须快速返<br>回以避免阻止主线程。如果不在Android上，则行为与{@link #POSTING}相同；</li>
<li><strong>MAIN_ORDERED</strong>：在Android上，将在Android的主线程（UI线程）中调用订阅者。 与{@link<br>#MAIN}不同，该事件将始终排队等待传递。 这可确保后置调用是非阻塞的；</li>
<li><strong>BACKGROUND</strong>：在Android上，将在后台线程中调用订阅者。 如果发布线程不是主线程，则将在发<br>布线程中直接调用订阅者方法。 如果发布线程是主线程，则EventBus使用单个后台线程，该线程将按顺序传<br>递其所有事件。 使用此模式的订阅者应尝试快速返回以避免阻止后台线程。 如果不在Android上，则始终使<br>用后台线程。</li>
<li><strong>ASYNC</strong>： 订阅者将在单独的线程中调用。 这始终独立于发布线程和主线程。 发布事件永远不会等<br>待使用此模式的订阅者方法。 订阅者方法如果执行可能需要一些时间，则应使用此模式，例如 用于网络访问。<br>避免同时触发大量长时间运行的异步订阅者方法以限制并发线程数。 EventBus使用线程池从已完成的异步订<br>阅者通知中有效地重用线程;</li>
</ol>
<h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ol>
<li><p>在项目中引入依赖  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅/解除订阅</p>
<ul>
<li><p>订阅   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);<span class="comment">//订阅</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解除订阅  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);<span class="comment">//解除订阅</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>发布事件</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件是POJO（普通旧Java对象），没有任何特定要求。如此处的BeanObject。</span></span><br><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> BeanObject());</span><br></pre></td></tr></table></figure>
<ol>
<li><p>订阅事件处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BeanObject为发布的对象，这个要对应发布的对象（或称事件）</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN) <span class="comment">//在ui线程执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataSynEvent</span><span class="params">(BeanObject event)</span> </span>&#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"event----&gt;"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅事件的优先级<br>事件的优先级类似广播的优先级，优先级越高优先获得消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN,priority = <span class="number">100</span>) <span class="comment">//在ui线程执行 优先级100</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataSynEvent</span><span class="params">(BeanObject event)</span> </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"event----&gt;"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中止事件往下传递<br>发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().cancelEventDelivery(event) ;<span class="comment">//优先级高的订阅者可以终止事件往下传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码混淆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keepclassmembers class ** &#123;</span><br><span class="line">    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line">-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;</span><br><span class="line"></span><br><span class="line"># Only required if you use AsyncExecutor</span><br><span class="line">-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123;</span><br><span class="line">    &lt;init&gt;(java.lang.Throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="EventBus黏性事件"><a href="#EventBus黏性事件" class="headerlink" title="EventBus黏性事件"></a>EventBus黏性事件</h4><p>EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加sticky = true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN,sticky = <span class="keyword">true</span>) <span class="comment">//在ui线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataSynEvent</span><span class="params">(BeanObject event)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"event----&gt;"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>发送粘性事件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> BeanObject());</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消粘性事件<br>对于 <strong>粘性广播其属于常驻广播（事件一直会保留，除非用户主动移除，且只要有新的订阅者订阅就会把这个事件发送给新的订阅者）</strong> ，对于EventBus粘性事件也类似，因此如果不再需要该粘性事件时可以移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⚠️一般在订阅者消费过该事件后调用，其还有一个参数为class的方法，取消class这类事件</span></span><br><span class="line">EventBus.getDefault().removeStickyEvent(<span class="keyword">new</span> DataSynEvent());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>或者移除所有粘性事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().removeAllStickyEvents();</span><br></pre></td></tr></table></figure></p>
<h4 id="EventBus-processor使用"><a href="#EventBus-processor使用" class="headerlink" title="EventBus processor使用"></a>EventBus processor使用</h4><p>EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,<br>处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就 <strong>比在运行时使用反射来获得这些订阅者的<br>信息速度要快</strong>.</p>
<ol>
<li><p>具体使用：在模块下的build.gradle文件中加入（以下针对Android Gradle Plugin version 2.2.0 及更高版本）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ eventBusIndex : &apos;项目包名.MyEventBusIndex&apos; ]   //参数设置</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">    annotationProcessor &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;  //注解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用索引</p>
</li>
</ol>
<p>此时编译一次，自动生成生成索引类。在\build\generated\source\apt\debug(或release)\PakageName\下看到通过注解分析生成的索引类，这样便可以在初始化EventBus时应用已经生成的索引了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(com.mugwort.lockscreen.ui.BaseActivity.class, <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"doEventMessage"</span>, com.mugwort.lockscreen.entities.EventMessage.class,</span><br><span class="line">                    ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加索引到EventBus默认的单例中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure></p>
<ol>
<li>添加后注册效率会得到很大提升。</li>
</ol>
<h3 id="EventBus优缺点"><a href="#EventBus优缺点" class="headerlink" title="EventBus优缺点"></a>EventBus优缺点</h3><ul>
<li>优点：简化组件之间的通信方式，实现解耦让业务代码更加简洁，可以动态设置事件处理线程以及优先级</li>
<li>缺点：目前发现唯一的缺点就是类似之前策略模式一样的诟病，每个事件都必须自定义一个事件类，造成事件类太多，无形中加大了维护成本</li>
</ul>
<p>参考：<br>[0]. 官网文档 <a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="noopener">http://greenrobot.org/eventbus/documentation/</a><br>[1]. <a href="https://www.cnblogs.com/whoislcj/p/5595714.html" target="_blank" rel="noopener">https://www.cnblogs.com/whoislcj/p/5595714.html</a><br>[2]. <a href="https://juejin.im/post/5b6859706fb9a04fbc2218d2" target="_blank" rel="noopener">https://juejin.im/post/5b6859706fb9a04fbc2218d2</a></p>
<h2 id="EventBus源码解析"><a href="#EventBus源码解析" class="headerlink" title="EventBus源码解析"></a>EventBus源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line"><span class="comment">/** 通过使用一个进程范围的实例生成一个便捷单例*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">              <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> defaultInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span></span><br><span class="line"><span class="comment">    * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       logger = builder.getLogger();</span><br><span class="line">       subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">       mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">       mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">       backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">       asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">       indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">       subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">               builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">       logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">       logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">       sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">       sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">       throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">       eventInheritance = builder.eventInheritance;</span><br><span class="line">       executorService = builder.executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>EventBus 初始化的三个步骤，直观上看用到 <strong>单例模式和Builder模式</strong> ，将构造参数给分离了出来，实际上还用到了 <strong>策略模式</strong> ，其中 <strong>Builder</strong> 中有些参数用于代码执行的策略，即传的参数不一样，执行的方式也就不一样，像 <strong>ignoreGeneratedIndex</strong> 作用就是让 <strong>EventBus</strong> 如何查找出订阅方法的策略。这些布尔类型的参数，在分析代码中可以逐步的了解到，先了解一些缓存对象，以更容易的了解源码：</p>
<ul>
<li><strong>subscriptionsByEventType</strong>: 内部是一个Map集合，可以根据 <strong>EventType</strong> 查找订阅事件。</li>
<li><strong>typesBySubscriber</strong>: 根据订阅对象找到 <strong>EventType</strong>。</li>
<li><strong>stickyEvents</strong>: 粘性事件的并发缓存。</li>
<li><strong>事件投递者</strong> : <strong>mainThreadPoster</strong>, <strong>backgroundPoster</strong>, <strong>asyncPoster</strong> 根据订阅注解 ThreadMode 去选择不同的投递者，不同投递者投递事件，接收函数会执行在不同的线程中。</li>
<li><strong>subscriberMethodFinder</strong>：查找方法用的，内部维护了一个订阅方法的集合。</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Registers the given subscriber to receive events. Subscribers must call &#123;<span class="doctag">@link</span> #unregister(Object)&#125; once they</span></span><br><span class="line"><span class="comment">    * are no longer interested in receiving events.</span></span><br><span class="line"><span class="comment">    * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">    * Subscribers have event handling methods that must be annotated by &#123;<span class="doctag">@link</span> Subscribe&#125;.</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@link</span> Subscribe&#125; annotation also allows configuration like &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    * ThreadMode&#125; and priority.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">               subscribe(subscriber, subscriberMethod);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>调用 <strong>register(this)</strong> 的时候就把订阅者给传了进来，代码量很少，主要就两个步骤，第一个 <strong>findSubscriberMethods</strong> 找出一个 <strong>SubscriberMethod</strong> 的集合，然后就遍历 <strong>SubscriberMethod</strong> 去订阅事件，先看看 <strong>findSubscriberMethods()</strong> 里面到底做了什么，返回的是什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是通过 <strong>订阅者的类文件</strong> 查找里面对事件处理的订阅方法即添加了注解 <strong>@Subscribe</strong> 的方法。首先从缓存中查找（缓存的key是类文件class），如果找到了就立马返回。如果缓存中没有的话，则根据 <strong>ignoreGeneratedIndex</strong> 选择如何查找订阅方法，最后，找到订阅方法后，放入缓存，以免下次继续查找。<strong>ignoreGeneratedIndex</strong> 默认就是 <strong>false</strong> ，执行 <strong>findUsingInfo()</strong> 方法，但是这里先分析 <strong>findUsingReflection()</strong> ，因为默认配置的情况下还是会执行上面的 <strong>findUsingReflection()</strong>，就是通过反射来解析注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       FindState findState = prepareFindState();    <span class="comment">// 1</span></span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           findUsingReflectionInSingleClass(findState); <span class="comment">// 2</span></span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在真正执行反射查找方法时，会传递一个 <strong>FindState</strong>，跟进 <strong>prepareFindState()</strong> 看下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">              FindState state = FIND_STATE_POOL[i];</span><br><span class="line">              <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">return</span> state;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里第一步从池中拿出一个 <strong>FindState</strong> 对象，<strong>FindState</strong> 中维护的是对订阅方法查找结果的封装。其实，往后面会发现作者这里设计的非常精妙。第二步，<strong>initForSubscriber()</strong> 就是将订阅者传给 <strong>FindState</strong> 对象。第三步做的就是不断从订阅者和订阅者的父类去查找订阅方法，一起看 <strong>findUsingReflectionInSingleClass()</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里才是真正的查找订阅者下的订阅方法。通过对订阅者方法的遍历，看有没有注解，有的话就解析注解，然后将找到的订阅方法的集合封装到 <strong>FindState</strong> 对象中的 <strong>subscriberMethods</strong> 集合中。解析完了之后，在看 <strong>findUsingReflection()</strong> 方法的最后，返回了 <strong>getMethodsAndRelease(FindState)</strong>，将 <strong>FindState</strong> 传给了 <strong>getMethodsAndRelease(FindState)</strong> 方法，跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">      List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">      findState.recycle();</span><br><span class="line">      <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  FIND_STATE_POOL[i] = findState;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里，可以知道作者设计 <strong>FindState池</strong> 的初心了，解析完了之后，将订阅方法赋给List集合，再回收 <strong>FindState</strong> ，继续接收解析，内存没有半点浪费。最后返回的是一个订阅方法的集合。这样，通过反射解析注解，找到订阅方法的方式已经分析完了。再看看通过apt处理器来找，apt处理是针对源码的处理，是执行在编译过程中的。所以性能要比反射好的多，也是推荐大家使用的方式。回到 <strong>findUsingInfo()</strong>，方法在没有配置时还是使用反射呢，一起看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       <span class="comment">//将订阅类交给findState</span></span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="comment">//扫描完当前类和其父类的订阅方法</span></span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">           <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">               <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                 <span class="comment">//根据eventType对SubscriberMethod检查</span></span><br><span class="line">                 <span class="comment">//如果有这个类型的方法，或者有这个方法类型的子类就返回false</span></span><br><span class="line">                   <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                       findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//没有EventBusIndex的信息时使用反射</span></span><br><span class="line">               findUsingReflectionInSingleClass(findState);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//上移到父类</span></span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//置空FindState池</span></span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面查找订阅方法，和通过反射查找基本一致，主要看看 <strong>getSubscriberInfo（findstate）</strong> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查找是否有订阅信息，无则直接放回</span></span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码主要针对缓存，从缓存中获取订阅信息， 当使用apt处理时从 <strong>subscriberInfoIndexes</strong> 中<br>查找订阅信息的。而subscriberInfoIndexes是从 <strong>EventBus Builder</strong> 对象中获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, <span class="keyword">boolean</span> strictMethodVerification,</span><br><span class="line">                          <span class="keyword">boolean</span> ignoreGeneratedIndex) &#123;</span><br><span class="line">       <span class="keyword">this</span>.subscriberInfoIndexes = subscriberInfoIndexes;</span><br><span class="line">       <span class="keyword">this</span>.strictMethodVerification = strictMethodVerification;</span><br><span class="line">       <span class="keyword">this</span>.ignoreGeneratedIndex = ignoreGeneratedIndex;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <strong>subscriberInfoIndexes</strong> 默认为空，结合之前的代码，还是执行了 <strong>findUsingReflection()</strong> 方法，<br>那么其何时才得到赋值。要使 <strong>subscriberInfoIndexes</strong> 得到赋值需要引入 <strong>EventBusAnnotationProcessor</strong> 库。这个在 <strong>EventBus processor使用</strong> 片段已经做了介绍。</p>
<p>继续分析 <strong>findUsingInfo（）</strong> 方法，需要注意：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">  <span class="comment">//根据eventType对SubscriberMethod检查</span></span><br><span class="line">  <span class="comment">//如果有这个类型的方法，或者有这个方法类型的子类就返回false</span></span><br><span class="line">                   <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                       findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里添加订阅方法的时候做了各检查，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></span><br><span class="line">           <span class="comment">// Usually a subscriber doesn't have methods listening to the same event type.</span></span><br><span class="line">           Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">           <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">                 <span class="comment">//只有子类中没有发现这种类型的方法才返回true</span></span><br><span class="line">                   <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                       <span class="comment">// Paranoia check</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">                   anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里做了两步检查，第一步类型检查，第二步签名检查：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">          methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">          methodKeyBuilder.append(method.getName());</span><br><span class="line">          methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">          <span class="comment">//使用方法名称和事件类型做key，保持方法</span></span><br><span class="line">          String methodKey = methodKeyBuilder.toString();</span><br><span class="line">          Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">          Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">          <span class="comment">//如果传递过来的methodclass为父类，则直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">              <span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">              subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实作者，这里又做了一个优化，将方法名和事件类型当作key，来保存方法，将传来的方法类型和我们签名的保存的比较，如果保存的是父类，就返回 true，如果是子类，就将传来的方法保存起来，返回 false。这样做的意图是，如果有父类的方法了，就没有必要添加子类的方法了，因为继承会执行到的。至此查找订阅方法的过程已经完全分析完了。看懂了之后，非常的过瘾。无论哪种方式查找，都返回了 <strong>SubscriberMethod</strong> 对象，我们看看它维护了什么属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** Used internally by EventBus and generated subscriber indexes. */</span><br><span class="line">public class SubscriberMethod &#123;</span><br><span class="line">    final Method method;</span><br><span class="line">    final ThreadMode threadMode;</span><br><span class="line">    final Class&lt;?&gt; eventType;</span><br><span class="line">    final int priority;</span><br><span class="line">    final boolean sticky;</span><br><span class="line">    /** Used for efficient comparison */</span><br><span class="line">    String methodString;</span><br></pre></td></tr></table></figure></p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        <span class="comment">//根据订阅者和订阅方法构造一个订阅事件</span></span><br><span class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">        <span class="comment">//根据eventType查找Subscription集合</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="comment">//查看是否缓存过该订阅事件，没有则放进缓存</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历订阅事件，找到比subsecriptions中订阅事件的位置，然后根据priority插进队列</span></span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据订阅者查找Eventype的缓存</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        <span class="comment">//如果是粘性事件。立马处理</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实里面就做了两件事，将订阅方法和订阅者，封装到 <strong>subscriptionsByEventType</strong> 和 <strong>ypesBySubscriber</strong> ，至于这两个对象是干什么的呢？第一个是投递订阅事件的时候，就是根据 <strong>EventType</strong> 找到订阅事件，从而去分发事件，处理事件的；第二个是在调用 <strong>unregister(this)</strong> 的时候，根据订阅者找到 <strong>EventType</strong>，又根据 <strong>EventType</strong> 找到订阅事件，从而解绑用的。第二件事，就是如果是粘性事件的话，就立马投递、执行。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程维护一个投递状态</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post(Object object) 的方法的时候就执行了上面的代码，<strong>PostingThreadState</strong> 是维护了投递的状态，最后循环投递，直到 <strong>PostingThreadState</strong> 中的 <strong>EventQueue</strong> 为空。那么代码最终执行到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">           <span class="keyword">case</span> POSTING:</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MAIN:</span><br><span class="line">               <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">               <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">               <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                   backgroundPoster.enqueue(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ASYNC:</span><br><span class="line">               asyncPoster.enqueue(subscription, event);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里根据 <strong>ThreadMode</strong> 去处理事件了。由于篇幅的问题，就分析一种了，当线程模式是主线程的时候，意味着，需要执行的代码在主线程中操作。如果是主线程，就是通过 <strong>反射，直接运行订阅的方法</strong>，如果不是主线程，需要 <strong>mainThreadPoster</strong> 将订阅事件入队列，一起看看 <strong>mainThreadPoster</strong> 的工作原理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  其实，在 <strong>EventBus</strong> 初始化的时候，<strong>mainThreadPoster</strong> 就已经获取主线程的Looper了，<br>就是用到了我们Android的消息处理机制：<strong>Looper</strong>,<strong>Handler</strong> 。至于消息队列是自己维护的一个<br>单向的链表。每次向Andorid的主线程Looper投递一个空消息，然后在 <strong>HandlerMessage()</strong> 方法里<br>面从自己维护的队列中取出 <strong>PendingPost</strong> 进行处理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList&lt;PendingPost&gt;();</span><br><span class="line"></span><br><span class="line">    Object event;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    PendingPost next;</span><br><span class="line">  &#125;</span><br><span class="line">```  </span><br><span class="line">而 PendingPost 中维护的是订阅事件，EventType 和下一个 PendingPost 的地址。</span><br><span class="line"></span><br><span class="line">### 反注册</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">               unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">           typesBySubscriber.remove(subscriber);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>反注册就是通过EventBus中 <strong>typesBySubscriber</strong> 这个属性，通过订阅者去查找订阅事件，然后去一一解绑的。当然，反注册主要是为了提高效率的，不然订阅的事件太多，非常影响性能。</p>
<h3 id="新特性-粘性事件"><a href="#新特性-粘性事件" class="headerlink" title="新特性-粘性事件"></a>新特性-粘性事件</h3><p>在订阅方法后半部分，关于粘性事件的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看下 <strong>checkPostStickyEventToSubscription</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">            <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在注册的时候，指定要发布粘性事件，那么在订阅的时候，就立马调用 <strong>postToSubscription</strong> ，去发布了，至于它从缓存中 <strong>stickyEvents</strong> 中获取订阅事件，可能有疑问，什么时候把 <strong>EventType</strong> 放进去的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky</span></span><br><span class="line"><span class="comment">    * event of an event's type is kept in memory for future access by subscribers using &#123;<span class="doctag">@link</span> Subscribe#sticky()&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">           stickyEvents.put(event.getClass(), event);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">       post(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>粘性事件在调用 <strong>postSticky（）</strong> 方法的时候就已经放入缓存。自此关于EventBus的源码也分析完了。</p>
<p>参考：<br>[0]. 官网git <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a><br>[1]. <a href="http://www.10tiao.com/html/227/201607/2650236358/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/227/201607/2650236358/1.html</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/01/24/Android之Boradcast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/Android之Boradcast/" itemprop="url">Android之Boradcast</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T20:30:56+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android应用可以从 <strong>Android系统</strong> 和 <strong>其他Android应用</strong> 发送或接收广播消息，类似于 <strong>发<br>布-订阅</strong> 设计模式。当感兴趣的事件发生时，发送这些广播。例如，Android系统在发生各种系统事件时<br>发送广播，例如系统启动或设备开始充电时。例如，应用程序还可以发送自定义广播，以通知其他应用程序他<br>们可能感兴趣的内容（例如，已下载了一些新数据）。</p>
<p>应用可以注册以接收特定广播。当发送广播时，系统自动将广播路由到已订阅接收该特定类型广播的应用。</p>
<p>一般而言，广播可以用作跨应用程序和普通用户流程之外的消息传递系统。但是，您必须小心，不要滥用机会<br>响应广播并在后台运行可能导致系统性能降低的作业。</p>
<p>通过以上介绍可以知道：在Android系统中，广播（Broadcast）是在组件之间传播数据的一种机制，这些组件<br>可以位于不同的进程中，起到进程间通信的作用。</p>
<h3 id="关于系统广播"><a href="#关于系统广播" class="headerlink" title="关于系统广播"></a>关于系统广播</h3><p>当系统发生各种系统事件时，系统会自动发送广播，例如当系统进出飞行模式时。系统广播将发送到订阅接收<br>事件的所有应用程序。</p>
<p>广播消息本身包装在一个 <strong>Intent</strong> 对象中，该对象的动作字符串标识发生的事件（例如 android.intent.action.AIRPLANE_MODE）。意图还可以包括捆绑到其额外字段中的附加信息。例如，<br>飞行模式意图包括一个布尔额外值，用于指示飞行模式是否打开。</p>
<p>有关如何读取意图并从意图获取操作字符串的更多信息，请参阅<a href="https://developer.android.com/guide/components/intents-filters.html" target="_blank" rel="noopener">意图和意图过滤器</a>。</p>
<p>有关系统广播操作的完整列表，请参阅Android SDK中的 <strong>BROADCAST_ACTIONS.TXT</strong> 文件。每个广播动作都有一个与之相关的常量字段。例如，常量的值 ACTION_AIRPLANE_MODE_CHANGED是 android.intent.action.AIRPLANE_MODE。每个广播操作的文档都在其关联的常量字段中提供。</p>
<h4 id="系统广播的变化"><a href="#系统广播的变化" class="headerlink" title="系统广播的变化"></a>系统广播的变化</h4><p>随着Android平台的发展，它会定期更改系统广播的行为方式。如果您的应用针对Android 7.0（API级别24）或更高版本，或者如果它安装在运行Android 7.0或更高版本的设备上，请记住以下更改。</p>
<h5 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h5><p>从Android 9（API级别28）开始， NETWORK_STATE_CHANGED_ACTION 广播不会收到有关 <strong>用户位置或个人身份数据的信息</strong> 。</p>
<p>此外，如果您的应用安装在运行Android 9或更高版本的设备上，则来自Wi-Fi的系统广播不包含SSID，BSSID，连接信息或扫描结果。要获取此信息，请调用getConnectionInfo() 。</p>
<h5 id="Android-8-0"><a href="#Android-8-0" class="headerlink" title="Android 8.0"></a>Android 8.0</h5><p>从Android 8.0（API级别26）开始，系统对清单声明的接收器施加了额外的限制。</p>
<p>如果您的应用面向Android 8.0或更高版本，则无法使用清单为大多数隐式广播声明接收方（广告不会专门针对您的应用）。当用户主动使用您的应用时，您仍然可以使用 上下文注册的接收器。</p>
<h5 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h5><p>Android 7.0（API级别24）及更高版本不发送以下系统广播：</p>
<ul>
<li>ACTION_NEW_PICTURE</li>
<li>ACTION_NEW_VIDEO<br>此外，针对Android 7.0及更高版本的应用必须CONNECTIVITY_ACTION使用注册广播registerReceiver(BroadcastReceiver, IntentFilter)。在清单中声明接收器不起作用。</li>
</ul>
<h3 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h3><p>应用程序可以通过两种方式接收广播：通过 <strong>清单声明的接收器</strong> 和 <strong>上下文注册的接收器</strong>。</p>
<h4 id="清单声明的接收器"><a href="#清单声明的接收器" class="headerlink" title="清单声明的接收器"></a>清单声明的接收器</h4><p>如果您在清单中声明了广播接收器，系统会在发送广播时启动您的应用（如果应用尚未运行）。</p>
<p>⚠️注意：如果您的应用程序的目标是API级别26或更高级别，则不能使用清单来声明隐式广播的接收者（特定于您的应用程序的广播），除了一些<a href="https://developer.android.com/guide/components/broadcast-exceptions.html" target="_blank" rel="noopener">免于该限制</a>的隐式广播。在大多数情况下，您可以使用<a href="https://developer.android.com/topic/performance/scheduling.html" target="_blank" rel="noopener">预定作业</a>。<br>要在清单中声明广播接收器，请执行以下步骤：</p>
<ol>
<li><receiver> 在应用清单中指定元素。  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span>  <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.INPUT_METHOD_CHANGED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
</receiver></li>
</ol>
<p>intent过滤器指定接收者订阅的广播操作。</p>
<ol>
<li>子类BroadcastReceiver并实现onReceive(Context, Intent)。以下示例中的广播接收器记录并显示广播的内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> val TAG = <span class="string">"MyBroadcastReceiver"</span></span><br><span class="line"></span><br><span class="line">class MyBroadcastReceiver : BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onReceive</span><span class="params">(context: Context, intent: Intent)</span> </span>&#123;</span><br><span class="line">        StringBuilder().apply &#123;</span><br><span class="line">            append(<span class="string">"Action: $&#123;intent.action&#125;\n"</span>)</span><br><span class="line">            append(<span class="string">"URI: $&#123;intent.toUri(Intent.URI_INTENT_SCHEME)&#125;\n"</span>)</span><br><span class="line">            toString().also &#123; log -&gt;</span><br><span class="line">                Log.d(TAG, log)</span><br><span class="line">                Toast.makeText(context, log, Toast.LENGTH_LONG).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>系统软件包管理器在安装应用程序时注册接收器。然后，接收器成为应用程序的单独入口点，这意味着如果应用程序当前未运行，系统可以启动应用程序并发送广播。</p>
<p>系统创建一个新的BroadcastReceiver组件对象来处理它接收的每个广播。 此对象仅在调用onReceive（Context，Intent）期间有效。 一旦您的代码从此方法返回，系统会认为该组件不再处于活动状态。</p>
<h4 id="上下文注册的接收器"><a href="#上下文注册的接收器" class="headerlink" title="上下文注册的接收器"></a>上下文注册的接收器</h4><p>要使用上下文注册接收器，请执行以下步骤：</p>
<ol>
<li><p>创建一个实例BroadcastReceiver。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val br: BroadcastReceiver = MyBroadcastReceiver()</span><br></pre></td></tr></table></figure>
</li>
<li><p>IntentFilter通过调用registerReceiver(BroadcastReceiver, IntentFilter)以下命令创建并注册接收器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply &#123;</span><br><span class="line">    addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)</span><br><span class="line">&#125;</span><br><span class="line">registerReceiver(br, filter)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>⚠️注意：要注册本地广播，请调用LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)。<br>只要注册上下文有效，上下文注册的接收器就会接收广播。例如，如果您在Activity上下文中注册 ，只要Activity未被销毁，您就会收到广播。如果您在应用程序上下文中注册，则只要应用程序正在运行，您就会收到广播。</p>
<ol>
<li>要停止接收广播，请调用unregisterReceiver(android.content.BroadcastReceiver)。当您不再需要接收器或上下文不再有效时，请务必取消注册接收器。</li>
</ol>
<p>请注意注册和取消注册接收器的位置，例如，如果使用活动的上下文在onCreate（Bundle）中注册接收器，则应在onDestroy（）中取消注册，以防止接收器泄漏到活动上下文之外。 如果在onResume（）中注册接收器，则应在onPause（）中注销它以防止多次注册（如果您不希望在暂停时接收广播，这可以减少不必要的系统开销）。 不要在onSaveInstanceState（Bundle）中取消注册，因为如果用户在历史堆栈中向后移动，则不会调用此方法。</p>
<h3 id="对过程状态的影响"><a href="#对过程状态的影响" class="headerlink" title="对过程状态的影响"></a>对过程状态的影响</h3><p>BroadcastReceiver的状态（无论是否正在运行）会影响其包含进程的状态，从而影响其被系统杀死的可能性。例如，当进程执行接收器（即，当前在其onReceive（）方法中运行代码）时，它被认为是前台进程。除极端内存压力外，系统保持运行。</p>
<p>但是，一旦您的代码从onReceive（）返回，BroadcastReceiver就不再处于活动状态。接收方的主机进程与其中运行的其他应用程序组件一样重要。如果该进程仅承载清单声明的接收者（用户从未或最近未与之交互的应用程序的常见情况），则从onReceive（）返回时，系统将其进程视为低优先级进程并且可能杀死它以使资源可用于其他更重要的过程。</p>
<p>因此，您不应该从广播接收器开始长时间运行后台线程。在onReceive（）之后，系统可以随时终止进程以回收内存，并且这样做会终止在进程中运行的生成线程。要避免这种情况，您应该调用goAsync（）（如果您希望在后台线程中处理广播更多时间）或使用JobScheduler从接收器调度JobService，以便系统知道该进程继续执行活动工作。有关更多信息，请参阅<a href="https://developer.android.com/guide/topics/processes/process-lifecycle.html" target="_blank" rel="noopener">进程和应用程序生命周期</a>。</p>
<p>以下代码段显示了一个BroadcastReceiver，它使用goAsync（）标记在onReceive（）完成后需要更多时间才能完成。 如果要在onReceive（）中完成的工作足够长，导致UI线程错过一个帧（&gt; 16ms），使其更适合后台线程，则此功能尤其有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private const val TAG = &quot;MyBroadcastReceiver&quot;</span><br><span class="line"></span><br><span class="line">class MyBroadcastReceiver : BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onReceive(context: Context, intent: Intent) &#123;</span><br><span class="line">        val pendingResult: PendingResult = goAsync()</span><br><span class="line">        val asyncTask = Task(pendingResult, intent)</span><br><span class="line">        asyncTask.execute()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class Task(</span><br><span class="line">            private val pendingResult: PendingResult,</span><br><span class="line">            private val intent: Intent</span><br><span class="line">    ) : AsyncTask() &#123;</span><br><span class="line"></span><br><span class="line">        override fun doInBackground(vararg params: String?): String &#123;</span><br><span class="line">            val sb = StringBuilder()</span><br><span class="line">            sb.append(&quot;Action: $&#123;intent.action&#125;\n&quot;)</span><br><span class="line">            sb.append(&quot;URI: $&#123;intent.toUri(Intent.URI_INTENT_SCHEME)&#125;\n&quot;)</span><br><span class="line">            return toString().also &#123; log -&gt;</span><br><span class="line">                Log.d(TAG, log)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onPostExecute(result: String?) &#123;</span><br><span class="line">            super.onPostExecute(result)</span><br><span class="line">            // Must call finish() so the BroadcastReceiver can be recycled.</span><br><span class="line">            pendingResult.finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>Android为应用发送广播提供了三种方式：</p>
<ul>
<li>sendOrderedBroadcast（Intent，String）方法一次向一个接收器发送广播。 当每个接收器依次执行时，它可以将结果传播到下一个接收器，或者它可以完全中止广播，以便它不会传递给其他接收器。 可以使用android：priority属性来控制匹配intent-filter顺序接收器; 具有相同优先级的接收器将以任意顺序运行。</li>
<li>sendBroadcast(Intent)方法以未定义的顺序向所有接收器发送广播。这称为正常广播。这更有效，但意味着接收器无法从其他接收器读取结果，传播从广播接收的数据或中止广播。</li>
<li>LocalBroadcastManager.sendBroadcast方法将广播发送到与发送者位于同一应用程序中的接收者。如果您不需要跨应用程序发送广播，请使用本地广播。实现效率更高（无需进程间通信），您无需担心与其他应用程序能够接收或发送广播相关的任何安全问题。</li>
</ul>
<p>以下代码段演示了如何通过创建Intent和调用来发送广播sendBroadcast(Intent)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent().also &#123; intent -&gt;</span><br><span class="line">    intent.setAction(<span class="string">"com.example.broadcast.MY_NOTIFICATION"</span>)</span><br><span class="line">    intent.putExtra(<span class="string">"data"</span>, <span class="string">"Notice me senpai!"</span>)</span><br><span class="line">    sendBroadcast(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>广播消息包含在Intent对象中。 intent的操作字符串必须提供应用程序的Java包名称语法，并唯一标识广播事件。 您可以使用putExtra（String，Bundle）将其他信息附加到intent。 您还可以通过调用intent上的setPackage（String）将广播限制为同一组织中的一组应用程序。</p>
<p>⚠️注意：尽管意图用于发送广播和使用startActivity（Intent）启动活动，但这些操作完全不相关。 广播接收器无法查看或捕获用于启动活动的意图; 同样，当您广播意图时，您无法找到或开始活动。</p>
<h4 id="限制具有权限的广播"><a href="#限制具有权限的广播" class="headerlink" title="限制具有权限的广播"></a>限制具有权限的广播</h4><p>权限允许您将广播限制为具有特定权限的应用程序集。您可以对广播的发送者或接收者实施限制。</p>
<h5 id="发送权限"><a href="#发送权限" class="headerlink" title="发送权限"></a>发送权限</h5><p>当您调用sendBroadcast（Intent，String）或sendOrderedBroadcast（Intent，String，BroadcastReceiver，Handler，int，String，Bundle）时，您可以指定权限参数。 只有那些已经在其清单中请求带有标签的许可的接收者（并且如果它是危险的，则随后被授予许可）可以接收广播。 例如，以下代码发送广播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendBroadcast(Intent(<span class="string">"com.example.NOTIFY"</span>), Manifest.permission.SEND_SMS)</span><br></pre></td></tr></table></figure></p>
<p>要接收广播，接收应用必须请求权限，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SEND_SMS"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>您可以指定现有的系统权限SEND_SMS也可以使用该<permission>元素定义自定义权限 。有关一般权限和安全性的信息，请参<a href="https://developer.android.com/guide/topics/security/permissions.html" target="_blank" rel="noopener">阅系统权限</a>。</permission></p>
<p>⚠️注意：安装应用程序时会注册自定义权限。 必须在使用该应用程序的应用程序之前安装定义自定义权限的应用程序。</p>
<h5 id="接收权限"><a href="#接收权限" class="headerlink" title="接收权限"></a>接收权限</h5><p>如果您在注册广播接收器时指定了权限参数（在清单中带有registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)或 带有<receiver>标签），那么只有已经<uses-permission>在其清单中请求带有标签的权限的广播公司 （如果它是危险的，则随后被授予权限）可以发送对接收者的意图。</uses-permission></receiver></p>
<p>例如，假设您的接收应用程序具有清单声明的接收器，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:permission</span>=<span class="string">"android.permission.SEND_SMS"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.AIRPLANE_MODE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或者您的接收应用程序有一个上下文注册的接收器，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)</span><br><span class="line">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, <span class="keyword">null</span> )</span><br></pre></td></tr></table></figure></p>
<p>然后，为了能够向这些接收者发送广播，发送应用必须请求许可，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SEND_SMS"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安全考虑因素和最佳实践"><a href="#安全考虑因素和最佳实践" class="headerlink" title="安全考虑因素和最佳实践"></a>安全考虑因素和最佳实践</h3><p>以下是发送和接收广播的一些安全注意事项和最佳做法：</p>
<ul>
<li><p>如果您不需要向应用程序外部的组件发送广播，则发送和接收支持库中LocalBroadcastManager提供的 本地广播。的效率要高得多（不需要进程间通信），并可以让你避免考虑与其他应用程序能够接收或发送你的广播任何安全问题。本地广播可以在您的应用程序中用作通用发布/子事件总线，而无需系统范围广播的任何开销。LocalBroadcastManager</p>
</li>
<li><p>如果许多应用已注册在其清单中接收相同的广播，则可能导致系统启动大量应用，从而对设备性能和用户体验产生重大影响。为避免这种情况，请优先使用上下文注册而不是清单声 有时，Android系统本身会强制使用上下文注册的接收器。例如，CONNECTIVITY_ACTION广播仅被传送到上下文注册的接收器。</p>
</li>
<li><p>不要使用隐式意图广播敏感信息。任何注册接收广播的应用都可以读取该信息。有三种方法可以控制谁可以接收您的广播：</p>
<ul>
<li>您可以在发送广播时指定权限。</li>
<li>在Android 4.0及更高版本，可以指定一个 包与 setPackage(String)发送广播时。系统将广播限制为与包匹配的应用程序集。</li>
<li>您可以发送本地广播LocalBroadcastManager。</li>
</ul>
</li>
<li><p>当您注册接收器时，任何应用都可以向您的应用接收器发送潜在的恶意广播。有三种方法可以限制应用收到的广播：</p>
<ul>
<li>您可以在注册广播接收器时指定权限。</li>
<li>对于清单声明的接收器，您可以在清单中将 android：exported 属性设置为“false”。接收方不接收来自应用程序之外的来源的广播。</li>
<li>您可以将自己限制为仅限本地广播LocalBroadcastManager。</li>
</ul>
</li>
<li><p>广播操作的命名空间是全局的。确保操作名称和其他字符串都写在您拥有的命名空间中，否则您可能会无意中与其他应用程序发生冲突。</p>
</li>
<li><p>因为接收者的onReceive(Context, Intent)方法在主线程上运行，所以它应该执行并快速返回。如果需要执行长时间运行的工作，请注意生成线程或启动后台服务，因为系统可能会在onReceive()返回后终止整个进程 。有关更多信息，请参阅对进程状态的影响要执行长时间运行的工作，我们建议：</p>
<ul>
<li>调用goAsync()接收者的onReceive()方法并将其传递BroadcastReceiver.PendingResult给后台线程。这使得广播在返回后保持活动状态onReceive()。但是，即使采用这种方法，系统也希望您能够非常快速地完成广播（10秒以内）。它允许您将工作移动到另一个线程，以避免故障主线程。</li>
<li>使用计划安排工作JobScheduler。有关更多信息，请参阅<a href="https://developer.android.com/topic/performance/scheduling.html" target="_blank" rel="noopener">智能作业计划</a>。</li>
</ul>
</li>
<li>不要从广播接收器开始活动，因为用户体验很不稳定; 特别是如果有多个接收器。相反，请考虑<a href="https://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">显示通知</a>。</li>
</ul>
<p>原文：<br>[1]. <a href="https://developer.android.com/guide/components/broadcasts" target="_blank" rel="noopener">https://developer.android.com/guide/components/broadcasts</a><br>参考：<br>[1]. <a href="https://www.jianshu.com/p/f348f6d7fe59" target="_blank" rel="noopener">https://www.jianshu.com/p/f348f6d7fe59</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/01/16/Navigation-leaning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/Navigation-leaning/" itemprop="url">Navigation官方译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T10:12:08+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/androidx/" itemprop="url" rel="index">
                    <span itemprop="name">androidx</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/androidx/Navigation/" itemprop="url" rel="index">
                    <span itemprop="name">Navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>导航是应用程序设计的重要组成部分。通过导航，您可以设计允许用户在应用内的不同内容区域移动，进出和退出的交互。</p>
<h4 id="导航架构组件"><a href="#导航架构组件" class="headerlink" title="导航架构组件"></a>导航架构组件</h4><p>导航架构组件可帮助您在应用程序中实现常见但复杂的导航要求，使您能够更轻松地为用户提供一致且可预测的体验。</p>
<p>导航可处理在应用程序的目的地之间导航- 也就是说，在应用程序中用户可以导航到任何位置。虽然目标通常通过Fragments代表特定的屏幕，但导航架构组件支持下面列出的其他目标类型：</p>
<ul>
<li>Activities</li>
<li>导航图和子图 - 当目标是图形或子图时，用户导航到该图或子图的起始目标</li>
<li><a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-add-new.html" target="_blank" rel="noopener">自订目标类型</a></li>
</ul>
<p>这些目的地通过操作连接，一系列的目的地和连接操作组成应用程序的导航图。</p>
<p>导航架构组件提供了许多其他好处，包括：  </p>
<ul>
<li>处理Fragment事务</li>
<li>默认情况下正确处理向上和向后操作</li>
<li>为动画和过渡提供标准化资源</li>
<li>将深层链接视为一级操作</li>
<li>包括导航UI模式，例如导航抽屉和底部导航，只需最少的额外工作</li>
<li>在导航传递参数时提供类型安全性</li>
<li>使用Android Studio的<a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing" target="_blank" rel="noopener">导航编辑器</a>可视化和编辑导航图</li>
</ul>
<p>⚠️：如果要将导航架构组件与Android Studio一起使用，则必须使用<a href="https://developer.android.com/studio/preview/" target="_blank" rel="noopener">Android Studio 3.2 Canary 14或更高版本</a>。</p>
<h4 id="导航原理"><a href="#导航原理" class="headerlink" title="导航原理"></a>导航原理</h4><p>导航架构组件基于以下设计原则：</p>
<h5 id="固定起始目的地"><a href="#固定起始目的地" class="headerlink" title="固定起始目的地"></a>固定起始目的地</h5><p>应用应具有固定的起始目的地，即用户从启动器启动应用时看到的屏幕，以及用户在按下后退按钮返回启动器之前看到的最后一个屏幕。</p>
<p>⚠️：应用可能具有一次性设置或一系列登录屏幕。这些条件屏幕不应被视为您应用的起始目的地。</p>
<h5 id="导航状态应该通过堆栈目的地来表示"><a href="#导航状态应该通过堆栈目的地来表示" class="headerlink" title="导航状态应该通过堆栈目的地来表示"></a>导航状态应该通过堆栈目的地来表示</h5><p>一个导航堆栈应该有应用程序的起始目标在堆栈的底部，并在堆栈顶部的当前目标。</p>
<p>更改导航堆栈的操作应始终在导航堆栈的顶部操作，方法是将新目标推送到堆栈顶部或从堆栈顶部弹出最顶层目标。</p>
<h5 id="“向上”按钮永远不会退出您的应用"><a href="#“向上”按钮永远不会退出您的应用" class="headerlink" title="“向上”按钮永远不会退出您的应用"></a>“向上”按钮永远不会退出您的应用</h5><p>如果用户位于起始目的地，则不应显示“向上”按钮。当您的应用程序使用其他应用程序任务的深层链接启动时，Up应该将用户带到分层父目标，而不是返回到其他应用程序。</p>
<h5 id="在应用程序的任务中，向上和向后相同"><a href="#在应用程序的任务中，向上和向后相同" class="headerlink" title="在应用程序的任务中，向上和向后相同"></a>在应用程序的任务中，向上和向后相同</h5><p>当系统“后退”按钮不会退出您的应用程序时，例如当您执行自己的任务而不是启动目标时，“向上”按钮的功能应与系统“后退”按钮完全相同。</p>
<h5 id="深度链接和导航到目标应该产生相同的堆栈"><a href="#深度链接和导航到目标应该产生相同的堆栈" class="headerlink" title="深度链接和导航到目标应该产生相同的堆栈"></a>深度链接和导航到目标应该产生相同的堆栈</h5><p>用户应该能够使用“后退”或“上移”按钮，无论他们如何到达目的地，都可以通过目的地返回到起始目的地。<br>深度链接时，将删除任何现有的导航堆栈，并替换为深层链接的导航堆栈。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过导航组件实现导航，Jetpack的架构组件通过提供一组处理大部分细节的导航组件，可以轻松实现应用内导航。</p>
<p>使用Navigation，您可以创建导航图，这是一种XML资源，表示应用程序中的各个目标节点以及连接节点的操作。</p>
<p>下图显示了一个示例应用程序的导航图的直观表示，该应用程序包含通过5个操作连接的6个目标。<br><img src="./images/navigation-grap.png" alt="导航图"></p>
<p>一个目标就是你可以在你的应用程序导航到任何地方。虽然目标通常是表示特定屏幕的Fragments，但导航支持其他目标类型：</p>
<ul>
<li>Activities</li>
<li>导航图和子图-当目标是图形或子图时，导航到该图或子图的起始目标</li>
<li><a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-add-new.html" target="_blank" rel="noopener">自订目标类型</a><br>⚠️：导航组件专为具有一个具有多个Fragment目标的主要activity的应用程序而设计。主activity托管导航图，并负责根据需要交换目标。在具有多个activity目标的应用中，每个附加activity都会托管自己的导航图。有关更多信息，请参阅<a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#Modify-activity" target="_blank" rel="noopener">修改活动以主持导航</a> 。</li>
</ul>
<h4 id="为项目引入导航组件"><a href="#为项目引入导航组件" class="headerlink" title="为项目引入导航组件"></a>为项目引入导航组件</h4><p>⚠️：如果您要使用Android Studio导航，则必须使用 <a href="https://developer.android.com/studio/preview/" target="_blank" rel="noopener">Android Studio 3.2 Canary 14或更高版本</a>。</p>
<p>要在项目中包含导航支持，请将以下内容添加到应用程序的 build.gradle文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def nav_version = <span class="string">"1.0.0-alpha09"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"android.arch.navigation:navigation-fragment:$nav_version"</span> <span class="comment">// use -ktx for Kotlin</span></span><br><span class="line">    implementation <span class="string">"android.arch.navigation:navigation-ui:$nav_version"</span> <span class="comment">// use -ktx for Kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关向项目添加其他体系结构组件的信息，请参阅向项目 <a href="https://developer.android.com/topic/libraries/architecture/adding-components#navigation" target="_blank" rel="noopener">添加组件</a>。</p>
<h4 id="创建导航图"><a href="#创建导航图" class="headerlink" title="创建导航图"></a>创建导航图</h4><p>要向项目添加导航图，请执行以下操作：</p>
<ol>
<li>在“项目”窗口中，右键单击该res目录，然后选择 <strong>New &gt; Android Resource File</strong>。出现 <strong>New Resource File</strong> 对话框。</li>
<li>在 <strong> File name</strong> 字段中键入名称，例如“nav_graph”。</li>
<li>从 <strong>Resource type</strong> 下拉列表中选择 <strong>Navigation</strong>。</li>
<li><p>单击 <strong>OK</strong> 。发生以下情况：</p>
<ul>
<li>在navigation目录中创建资源res目录。</li>
<li>nav_graph.xml在导航目录中创建一个文件。</li>
<li>该 nav_graph.xml文件将在导航编辑器中打开。此XML文件包含导航图。</li>
</ul>
</li>
<li><p>单击 <strong>Text</strong> 选项卡以切换到XML文本视图。您应该看到一个空的导航图，如以下示例所示：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>单击 <strong>Design</strong> 返回 Navigation Editor。</li>
</ol>
<h4 id="浏览导航编辑器"><a href="#浏览导航编辑器" class="headerlink" title="浏览导航编辑器"></a>浏览导航编辑器</h4><p>在Navigation Editor中，您可以直观地编辑导航图，而不是直接编辑基础XML。<br><img src="./images/navigation-editor.png" alt="导航编辑器"></p>
<ul>
<li>目的地：列出导航主机和当前位于“ 曲线图编辑器”中的所有目的地。</li>
<li>图表编辑器：包含导航图的可视化表示。</li>
<li>属性：显示导航图中当前所选项的属性。</li>
</ul>
<h4 id="创建目的地"><a href="#创建目的地" class="headerlink" title="创建目的地"></a>创建目的地</h4><p>创建导航图的第一步是识别和创建应用的各个目标。您可以在现有项目中的Fragments和Activities中创建目标，也可以创建占位符目标，以后可以使用Fragments或Activities替换它们。</p>
<p>如果您要将现有片段或活动添加到导航图中，或者如果要添加占位符，请单击 <strong>New Destination</strong> ➕，然后在下拉列表中单击相应的片段，活动或占位符目标。出现。现在，您可以在 <strong>Design</strong> 视图中查看目标的预览以及导航图的“ 文本”视图中的相应XML 。</p>
<p>要创建新的目标类型，请执行以下操作：  </p>
<ol>
<li>在导航编辑器中，单击 <strong>New Destination</strong> ➕，然后单击 <strong>Create blank destination</strong> 。</li>
<li>在出现的 <strong>New Android Component </strong> 对话框中，输入 <strong>Fragment Name</strong> 。这是Fragment类的名称。</li>
<li>要让Android Studio为Fragment创建相应的布局资源文件，请选中 <strong>Create layout XML</strong> 旁边的框，然后在 <strong>Fragment Layout Name</strong> 字段中输入资源名称。</li>
<li>在 <strong>Source Language</strong> 下拉列表中，为类源文件选择Kotlin或Java。</li>
<li>单击完成。<br>新目标类型显示在导航编辑器中。Android Studio还以指定的源语言创建相应的类文件，如果指定，还会为新目标类型创建布局资源文件。</li>
</ol>
<p>图显示了目标和占位符的示例。<br><img src="./images/navigation-destination-and-placeholder_2x.png" alt="目标和占位符"></p>
<p>可以单击任何目的地以选择它。选择目标时，<strong>Attributes</strong> 面板中将显示以下属性：</p>
<ul>
<li><strong>Type</strong> 字段指示目标是否在源代码中实现为片段或活动。</li>
<li><strong>Label</strong> 字段包含目标的XML布局文件的名称。</li>
<li><strong>ID</strong> 字段包含被用于指在代码中的目的地的目的地的ID。</li>
<li><strong>Class</strong> 下拉列表显示与目标关联的类的名称。您可以单击此下拉列表将关联的类更改为其他目标类型。</li>
</ul>
<p>⚠️：占位符与类无关。请务必在运行应用程序之前更改类值。</p>
<p>单击 <strong>Text</strong> 选项卡以显示导航图的XML视图。XML包含相同的id，name，label，和layout属性的目的地，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/blankFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"Blank"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="连接目的地"><a href="#连接目的地" class="headerlink" title="连接目的地"></a>连接目的地</h4><p>您必须有多个目标才能连接目标。以下是包含两个空白目标的导航图的XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/blankFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"fragment_blank"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"Blank2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank_fragment2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>目的地使用动作连接。要连接两个目标，请执行以下操作：</p>
<ol>
<li>在 <strong>Design</strong> 选项卡中，将鼠标悬停在您希望用户导航的目标的右侧。目的地上会出现一个圆圈。<br><img src="./images/navigation-actioncircle_2x.png" alt="视图设计"><br>图4.动作连接圈</li>
<li><p>单击并按住，将光标拖到您希望用户导航到的目标上，然后释放。绘制一条线以指示两个目的地之间的导航。<br><img src="./images/navigation-connected_2x.png" alt="连接目的地"><br>图5.连接目的地<br>单击箭头以突出显示该操作。<strong>Attributes</strong> 面板中显示以下属性：</p>
<ul>
<li>Type 字段包含 Action。</li>
<li>该ID字段包含动作ID。</li>
<li>Destination 字段包含所述目的地片Fragment或Activity的ID。<br>单击 <strong>Text</strong> 选项卡以切换到XML视图。现在，操作元素已添加到源目标。该操作具有ID和目标属性，其中包含下一个目标的ID，如下例所示：</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/blankFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"fragment_blank"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/action_blankFragment_to_blankFragment2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">"@id/blankFragment2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"fragment_blank_fragment2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank_fragment2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="将屏幕指定为起始目的地"><a href="#将屏幕指定为起始目的地" class="headerlink" title="将屏幕指定为起始目的地"></a>将屏幕指定为起始目的地</h4><p>导航编辑器使用🏠来指示用户在打开应用程序时看到的第一个屏幕，也称为 起始目的地。</p>
<p>要选择其他起始目的地，请执行以下操作：</p>
<ol>
<li><p>在 <strong>Design</strong> 选项卡中，单击新的起始目标以突出显示它。</p>
</li>
<li><p>单击 <strong>Assign start destination</strong> 按钮🏠。或者，您可以右键单击目标，然后单击 <strong>Set as Start Destination</strong>。</p>
</li>
</ol>
<h4 id="修改活动以主持导航"><a href="#修改活动以主持导航" class="headerlink" title="修改活动以主持导航"></a>修改活动以主持导航</h4><p>Activity为NavHost中的应用程序提供导航。 NavHost是一个空容器，当用户浏览您的应用程序时，目的地会被换入和换出。<br>Navigation组件中默认NavHost的实现是NavHostFragment。</p>
<h5 id="使用布局编辑器添加NavHostFragment"><a href="#使用布局编辑器添加NavHostFragment" class="headerlink" title="使用布局编辑器添加NavHostFragment"></a>使用布局编辑器添加NavHostFragment</h5><p>您可以使用布局编辑器通过以下步骤将NavHostFragment添加到Activity：   </p>
<ol>
<li>如果您还没有导航图资源，请创建导航图资源。</li>
<li>在项目文件列表中，双击活动的布局XML文件，在布局编辑器中将其打开。</li>
<li>在Palette窗格中，选择Containers类别，或者搜索“NavHostFragment”。</li>
<li>将NavHostFragment视图拖到您的活动上。</li>
<li>接下来，在出现的 <strong>Navigation Graphs</strong> 对话框中，选择要与其关联的相应导航图NavHostFragment，然后单击 <strong>OK</strong> 。</li>
</ol>
<p>回到 <strong>Text</strong> 视图，请注意Android Studio添加了类似于以下内容的XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">"@navigation/mobile_navigation"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该app:defaultNavHost=”true”属性确保您NavHostFragment 拦截系统后退按钮。您还可以通过覆盖AppCompatActivity.onSupportNavigateUp() 和调用来实现此行为NavController.navigateUp，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  override fun onSupportNavigateUp(): Boolean &#123;</span></span><br><span class="line"><span class="comment">          return Navigation.findNavController(this, R.id.fragment_nav).navigateUp()</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onSupportNavigateUp</span><span class="params">()</span> </span>= Navigation.findNavController(<span class="keyword">this</span>, R.id.fragment_nav).navigateUp()</span><br></pre></td></tr></table></figure>
<h4 id="以编程方式创建NavHostFragment"><a href="#以编程方式创建NavHostFragment" class="headerlink" title="以编程方式创建NavHostFragment"></a>以编程方式创建NavHostFragment</h4><p>您还可以使用NavHostFragment.create() 以编程方式创建NavHostFragment具有特定图形资源的资源，如以下示例所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val finalHost = NavHostFragment.create(R.navigation.example_graph)</span><br><span class="line">supportFragmentManager.beginTransaction()</span><br><span class="line">    .replace(R.id.nav_host, finalHost)</span><br><span class="line">    .setPrimaryNavigationFragment(finalHost) <span class="comment">// this is the equivalent to app:defaultNavHost="true"</span></span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure></p>
<h4 id="将目标绑定到ui小部件"><a href="#将目标绑定到ui小部件" class="headerlink" title="将目标绑定到ui小部件"></a>将目标绑定到ui小部件</h4><p>使用NavController类导航到目标。 可以使用以下静态方法之一检索NavController：：</p>
<ul>
<li>NavHostFragment.findNavController(Fragment)</li>
<li>Navigation.findNavController(Activity, @IdRes int viewId)</li>
<li>Navigation.findNavController(View)<br>检索后 NavController，使用其 navigate() 方法导航到目标。该 navigate() 方法接受资源ID。ID可以是导航图或操作中特定目标的ID。使用操作的ID而不是目标的资源ID具有优势，例如将过渡与导航相关联。有关转换的更多信息，请参阅<a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#Create-transition" target="_blank" rel="noopener">创建目标之间的转换</a>。</li>
</ul>
<p>以下代码段显示了如何导航到 ViewTransactionsFragment：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewTransactionsButton.setOnClickListener &#123; view -&gt;</span><br><span class="line">   view.findNavController().navigate(R.id.viewTransactionsAction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Android系统维护一个包含最后访问目的地的 <strong>back stack</strong> 。当用户打开应用程序时，应用程序的第一个目标位于堆栈中。每次调用该 navigate() 方法都会将另一个目标放在堆栈顶部。相反，按“向上”或“返回”按钮分别调用 NavController.navigateUp() 和 NavController.popBackStack() 方法，将顶部目标弹出堆栈。</p>
<p>对于按钮，您还可以使用 Navigation类的 createNavigateOnClickListener() 便捷方法导航到目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(Navigation.createNavigateOnClickListener(R.id.next_fragment, null))</span><br></pre></td></tr></table></figure></p>
<p>要处理其他常见UI组件，例如顶部应用栏和底部导航，请参阅<a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-ui" target="_blank" rel="noopener">使用NavigationUI更新UI组件</a>。</p>
<h4 id="为目标创建深层链接"><a href="#为目标创建深层链接" class="headerlink" title="为目标创建深层链接"></a>为目标创建深层链接</h4><p>在Android中，<a href="https://developer.android.com/training/app-links/deep-linking" target="_blank" rel="noopener">深层链接</a>是指向应用中特定目标的URI。当您想要将用户发送到特定目的地以在您的应用中执行某项任务时，这些URI很有用，例如发送资金流，允许用户快速汇款给某人。</p>
<h5 id="为目标分配深层链接"><a href="#为目标分配深层链接" class="headerlink" title="为目标分配深层链接"></a>为目标分配深层链接</h5><p>要在导航图中为目标指定深层链接，请执行以下操作：</p>
<ul>
<li>在 <strong>Design</strong> 视图中，选择深层链接的目标。</li>
<li>单击 <strong>Add deep link</strong> 按钮🔗（或单击 <strong>Attributes</strong> 面板的 <strong>Deep Links</strong> 部分中的➕）。出现 <strong>Add Deep Link</strong> 对话框。</li>
<li>在URI字段中键入URI，例如“www.cashdog.com/sendmoney”，它表示应用中发送货币嵌套图的起始目的地。</li>
</ul>
<p>请注意以下事项：  </p>
<ul>
<li>未指定协议的URI被假定为http或https。例如， www.cashdog.com匹配<a href="http://www.cashdog.com" target="_blank" rel="noopener">http://www.cashdog.com</a> 或<a href="https://www.cashdog.com。" target="_blank" rel="noopener">https://www.cashdog.com。</a></li>
<li>占位符的{placeholder_name}匹配形式为1个或多个字符。String占位符的值在Bundle带有相同名称的键的参数中可用。例如，<a href="http://www.example.com/users/{id}匹配http://www.example.com/users/4" target="_blank" rel="noopener">http://www.example.com/users/{id}匹配http://www.example.com/users/4</a>.</li>
<li>。*通配符可用于匹配0个或多个字符。<ul>
<li>（可选）选中 <strong>Auto Verify</strong> 以要求Google验证您是URI的所有者。有关更多信息，请参阅<a href="deepLink app:uri=&quot;https://cashdog.com/sendmoney&quot;/">验证Android应用程序链接</a>。</li>
<li>单击 <strong>Add</strong>。 所选目标上方会显示一个链接图标，表示该目标具有深层链接。</li>
<li>单击 <strong>Text</strong> 选项卡以切换到XML视图。已将嵌套的深层链接元素添加到目标：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">deepLink</span> <span class="attr">app:uri</span>=<span class="string">"https://cashdog.com/sendmoney"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>当用户从深层链接目标按下“后退”按钮时，他们会导航回导航堆栈，就像他们从应用程序的入口点进入您的应用程序一样。</p>
<h5 id="为深层链接添加意图过滤器"><a href="#为深层链接添加意图过滤器" class="headerlink" title="为深层链接添加意图过滤器"></a>为深层链接添加意图过滤器</h5><p>您必须添加manifest.xml文件以在您的应用中启用深层链接：</p>
<p>对于Android Studio 3.0和3.1，您必须手动添加intent-filter 元素。有关更多信息，请参阅 创建应用程序内容的深层链接。<br>对于Android Studio 3.2+，您可以nav-graph向活动元素添加元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nav-graph</span> <span class="attr">android:value</span>=<span class="string">"@navigation/main_nav"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作为清单合并构建步骤的一部分，此元素将替换<intent-filter>为匹配导航图中所有深层链接所需的生成元素。</intent-filter></p>
<h5 id="以编程方式使用NavDeepLinkBuilder创建深层链接"><a href="#以编程方式使用NavDeepLinkBuilder创建深层链接" class="headerlink" title="以编程方式使用NavDeepLinkBuilder创建深层链接"></a>以编程方式使用NavDeepLinkBuilder创建深层链接</h5><p>您可以使用NavDeepLinkBuilder该类构建一个PendingIntent 将用户带到特定目标的类。</p>
<p>触发此深层链接时，将清除任务后台堆栈并替换为深层链接目标。当嵌套图表，从每一级的开始目的地嵌套的，也就是说，从每个目的地开始 <navigation>在元件层次结构也被添加到堆栈中。</navigation></p>
<p>您可以PendingIntent直接 构造一个NavDeepLinkBuilder(Context)，如下面的示例所示。请注意，如果提供的上下文不是a Activity，则构造函数将使用 PackageManager.getLaunchIntentForPackage() 作为默认活动来启动（如果可用）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pendingIntent = NavDeepLinkBuilder(context)</span><br><span class="line">    .setGraph(R.navigation.mobile_navigation)</span><br><span class="line">    .setDestination(R.id.android)</span><br><span class="line">    .setArguments(args)</span><br><span class="line">    .createPendingIntent()</span><br></pre></td></tr></table></figure></p>
<p>有关包含此示例的完整导航项目，请参阅 <a href="https://codelabs.developers.google.com/codelabs/android-navigation/#0" target="_blank" rel="noopener">Navigation Codelab</a>。</p>
<p>⚠️：如果您有现有的NavController，您还可以通过创建深层链接NavController.createDeepLink()。</p>
<h5 id="在目的地之间创建过渡"><a href="#在目的地之间创建过渡" class="headerlink" title="在目的地之间创建过渡"></a>在目的地之间创建过渡</h5><p>导航组件提供了在目的地之间轻松添加转换（例如淡入和淡出）的功能。要添加转换，请执行以下操作：</p>
<ol>
<li>创建动画资源文件。导航支持属性和视图动画。有关详细信息，请参阅 <a href="https://developer.android.com/guide/topics/resources/animation-resource" target="_blank" rel="noopener">Animation resources</a>。</li>
<li>在导航编辑器的 <strong><a href="https://developer.android.com/guide/topics/resources/animation-resource" target="_blank" rel="noopener">https://developer.android.com/guide/topics/resources/animation-resource</a></strong> 选项卡中，单击要进行转换的操作。</li>
<li>在 <strong>Attributes</strong> 面板的 <strong>Transitions</strong> 部分中，单击 <strong>Enter</strong> 旁边的向下箭头以显示项目中可用过渡的列表。</li>
<li>选择用户进入目的地时发生的转换。</li>
<li>回到 <strong>Transitions</strong> 部分，单击 <strong>Exit</strong> 旁边的向下箭头，然后选择当用户退出目标时发生的转换。</li>
<li>单击 <strong>Text</strong> 选项卡以切换到XML文本视图。转换的XML出现在指定操作的<action>元素中。该操作嵌入在转换发生之前处于活动状态的目标的XML中。在以下示例中，   specifyAmountFragment是活动目标，因此它包含具有过渡动画的操作：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/specifyAmountFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.buybuddy.buybuddy.SpecifyAmountFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"fragment_specify_amount"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_specify_amount"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/confirmationAction"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:destination</span>=<span class="string">"@id/confirmationFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:enterAnim</span>=<span class="string">"@anim/slide_in_right"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:exitAnim</span>=<span class="string">"@anim/slide_out_left"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:popEnterAnim</span>=<span class="string">"@anim/slide_in_left"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:popExitAnim</span>=<span class="string">"@anim/slide_out_right"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
</action></li>
</ol>
<p>在此示例中，我们在移动到目的地时（enterAnim以及exitAnim退出该目标（popEnterAnim 和popExitAnim）时发生转换）。</p>
<h5 id="在Fragment目标之间添加共享元素转换"><a href="#在Fragment目标之间添加共享元素转换" class="headerlink" title="在Fragment目标之间添加共享元素转换"></a>在Fragment目标之间添加共享元素转换</h5><p>除了过渡动画之外，Navigation还支持在目标之间添加共享元素过渡。</p>
<p>与动画不同，共享元素转换是以编程方式提供的，而不是通过导航XML文件提供的，因为它们需要引用View您希望包含在共享元素转换中的 实例。</p>
<p>每种类型的目标都通过Navigator.Extras 接口的子类实现此编程API 。将Extras被传递到一个呼叫navigate()。</p>
<p>Fragment目标共享元素转换<br>在FragmentNavigator.Extras 类允许您附加共享元素到navigate()呼叫目的地的片段，如图下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val extras = FragmentNavigatorExtras(</span><br><span class="line">    imageView to <span class="string">"header_image"</span>,</span><br><span class="line">    titleView to <span class="string">"header_title"</span>)</span><br><span class="line">view.findNavController().navigate(R.id.confirmationAction,</span><br><span class="line">    <span class="keyword">null</span>, <span class="comment">// Bundle of args</span></span><br><span class="line">    <span class="keyword">null</span>, <span class="comment">// NavOptions</span></span><br><span class="line">    extras)</span><br></pre></td></tr></table></figure></p>
<p>⚠️：这里的header_image和header_title要确保在当前布局的android:transitionName和需要调整的布局的android:transitionName一样</p>
<h5 id="Activity目标共享元素转换"><a href="#Activity目标共享元素转换" class="headerlink" title="Activity目标共享元素转换"></a>Activity目标共享元素转换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Rename the Pair class from the Android framework to avoid a name clash</span><br><span class="line">import android.util.Pair as UtilPair</span><br><span class="line">///...</span><br><span class="line">val options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity,</span><br><span class="line">        UtilPair.create(imageView, &quot;header_image&quot;),</span><br><span class="line">        UtilPair.create(titleView, &quot;header_title&quot;))</span><br><span class="line">val extras = ActivityNavigator.Extras(options)</span><br><span class="line">view.findNavController().navigate(R.id.details,</span><br><span class="line">    null, // Bundle of args</span><br><span class="line">    null, // NavOptions</span><br><span class="line">    extras)</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用NavigationUI更新UI组件</span><br><span class="line"></span><br><span class="line">导航架构组件包括NavigationUI类。 此类包含使用顶部应用栏，导航抽屉和底部导航管理导航的静态方法。</span><br><span class="line"></span><br><span class="line">#### 监听导航事件</span><br><span class="line">与NavController交互是在目的地之间导航的主要方法。 NavController负责用新目标替换NavHost的内容。 在许多情况下，UI元素 - 例如顶级应用栏或其他持久性导航控件（如BottomNavigationBar）在NavHost之外存在，并且需要在目的地之间导航时进行更新。</span><br><span class="line"></span><br><span class="line">NavController提供了一个OnDestinationChangedListener接口，当NavController的当前目标或其参数发生更改时，该接口将被调用。 可以通过addOnDestinationChangedListener（）方法注册新的侦听器，如下面的示例所示。 请注意，在调用addOnDestinationChangedListener（）时，如果当前目标存在，则会立即将其发送给您的侦听器。</span><br><span class="line"></span><br><span class="line">```Kotlin</span><br><span class="line">navController.addOnDestinationChangedListener &#123; navController, destination, arguments -&gt;</span><br><span class="line">  textView.setText(destination.label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NavigationUI使用OnDestinationChangedListener使这些常见的UI组件可以感知导航事件。 但请注意，您还可以单独使用OnDestinationChangedListener来使任何自定义UI或业务逻辑感知导航事件。</p>
<h4 id="顶部应用栏"><a href="#顶部应用栏" class="headerlink" title="顶部应用栏"></a>顶部应用栏</h4><p>顶部应用栏在应用顶部 提供了一致的位置，用于显示当前屏幕的信息和操作。<br><img src="./images/top-app-bar.png" alt="顶部导航"><br>NavigationUI包含在用户浏览应用时自动更新顶部应用栏中内容的方法。例如，NavigationUI使用导航图中的目标标签可以使顶部应用栏的标题保持最新。</p>
<p>使用NavigationUI下面讨论的顶级应用栏方法时，可以使用{argName}标签中的格式从提供给目标的参数中自动填充附加到目标的标签。</p>
<p>NavigationUI 提供以下顶级应用栏类型的支持：</p>
<ul>
<li>Toolbar</li>
<li>CollapsingToolbarLayout</li>
<li>ActionBar</li>
</ul>
<h4 id="AppBarConfiguration"><a href="#AppBarConfiguration" class="headerlink" title="AppBarConfiguration"></a>AppBarConfiguration</h4><p>NavigationUI使用AppBarConfiguration 对象来管理应用程序显示区域左上角的“导航”按钮的行为。默认情况下，当用户位于导航图的顶级目标位置时，导航按钮将隐藏，并在任何其他目标位置显示为“向上”按钮。</p>
<p>要将导航图的起始目的地用作唯一的顶级目的地，您可以创建一个AppBarConfiguration对象并传入相应的导航图，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appBarConfiguration = AppBarConfiguration(navController.graph)</span><br></pre></td></tr></table></figure></p>
<p>如果要自定义哪些目标被视为顶级目标，则可以将一组目标ID传递给构造函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val appBarConfiguration = AppBarConfiguration(setOf(R.id.main, R.id.android))</span><br></pre></td></tr></table></figure></p>
<h4 id="创建Toolbar"><a href="#创建Toolbar" class="headerlink" title="创建Toolbar"></a>创建Toolbar</h4><p>要使用NavigationUI创建工具栏，请首先在Activity中定义工具栏，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，setupWithNavController() 从您的主要活动的onCreate()方法调用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    //主导航Fragment</span><br><span class="line">    val navHostFragment = nav_host_fragment as NavHostFragment</span><br><span class="line">    // 其中toolbal为需要绑定的视图控件，目前支持12种视图控件；</span><br><span class="line">    NavigationUI.setupWithNavController(toolbar, navHostFragment.navController)</span><br></pre></td></tr></table></figure>
<p>⚠️：注意：使用工具栏时，导航会自动处理“导航”按钮的单击事件，因此您无需覆盖onSupportNavigateUp（）。<strong>！！！如果使用带menu菜单的控件如BottomNavigationView时，需要确保menu的id和需要跳转的导航图中的fragment的ID一致！！！</strong></p>
<h4 id="包括CollapsingToolbarLayout"><a href="#包括CollapsingToolbarLayout" class="headerlink" title="包括CollapsingToolbarLayout"></a>包括CollapsingToolbarLayout</h4><p>要CollapsingToolbarLayout在工具栏中添加a ，请先在主要活动中定义工具栏和周围布局，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"@dimen/tall_toolbar_height"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar_layout"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentScrim</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:expandedTitleGravity</span>=<span class="string">"top"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed|snap"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，setupWithNavController() 从您的主要活动的onCreate方法调用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //主导航Fragment</span><br><span class="line">    val navHostFragment = nav_host_fragment as NavHostFragment</span><br><span class="line">    // 其中toolbal为需要绑定的视图控件，目前支持12种视图控件；</span><br><span class="line">    NavigationUI.setupWithNavController(toolbar, navHostFragment.navController)</span><br></pre></td></tr></table></figure>
<h4 id="Action-bar"><a href="#Action-bar" class="headerlink" title="Action bar"></a>Action bar</h4><p>要使用默认操作栏包含导航支持，请setupActionBarWithNavController() 从主Activity的onCreate()方法中调用 ，如下所示。请注意，您需要声明自己的AppBarConfiguration外部onCreate()，因为您在覆盖时也使用它onSupportNavigateUp():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private lateinit var appBarConfiguration: AppBarConfiguration</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    val navController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    appBarConfiguration = AppBarConfiguration(navController.graph)</span><br><span class="line">    setupActionBarWithNavController(navController, appBarConfiguration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，覆盖onSupportNavigateUp()以处理向上导航：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun onSupportNavigateUp(): Boolean &#123;</span><br><span class="line">    return navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="将目的地绑定到菜单项"><a href="#将目的地绑定到菜单项" class="headerlink" title="将目的地绑定到菜单项"></a>将目的地绑定到菜单项</h4><p>NavigationUI还提供了将目标绑定到菜单驱动的UI组件的帮助程序。NavigationUI包含一个辅助方法，onNavDestinationSelected()它MenuItem与NavController托管关联目标的方法一起使用 。如果id在的MenuItem比赛的id目标时，NavController可以然后导航到目的地。</p>
<p>作为一个例子，下面的XML片断定义一个菜单项，并具 <strong>有共同的目的地id（id需要一致）</strong>  ，details_page_fragment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;navigation xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    ... &gt;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &lt;fragment android:id=&quot;@+id/details_page_fragment&quot;</span><br><span class="line">         android:label=&quot;@string/details&quot;</span><br><span class="line">         android:name=&quot;com.example.android.myapp.DetailsFragment&quot; /&gt;</span><br><span class="line">&lt;/navigation&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@id/details_page_fragment&quot;</span><br><span class="line">        android:icon=&quot;@drawable/ic_details&quot;</span><br><span class="line">        android:title=&quot;@string/details&quot; /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<p>例如，如果您的菜单是通过Activity的onCreateOptionsMenu（）添加的，则可以通过覆盖Activity的onOptionsItemSelected（）来调用onNavDestinationSelected（）来关联菜单项和目标，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> navController = findNavController(R.id.nav_host)</span><br><span class="line">    <span class="keyword">return</span> item.onNavDestinationSelected(navController) || <span class="keyword">super</span>.onOptionsItemSelected(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，当用户单击details_page_fragment菜单项时，应用程序会自动导航到 <strong>具有相同ID的相应目标</strong> 。</p>
<h4 id="添加导航抽屉"><a href="#添加导航抽屉" class="headerlink" title="添加导航抽屉"></a>添加导航抽屉</h4><p>导航抽屉是一个UI面板，显示应用程序的主导航菜单。 当用户触摸应用栏中的抽屉图标或用户从屏幕的左边缘滑动手指时，抽屉出现。<br><img src="./images/navigation-drawer.png" alt="导航抽屉"><br>抽屉图标显示在使用DrawerLayout的所有顶级目标上。 顶级目标是应用程序的根级目标。 它们不会在应用栏中显示“向上”按钮。</p>
<p>要添加导航抽屉，首先将DrawerLayout声明为根视图。 在DrawerLayout内，添加主UI内容的布局和包含导航抽屉内容的另一个视图。</p>
<p>例如，以下布局使用具有两个子视图的DrawerLayout：NavHostFragment包含主要内容，NavigationView用于导航抽屉的内容。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- Use DrawerLayout as root container for activity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Layout to contain contents of main body of screen (drawer will slide over this) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">"@navigation/nav_graph"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Container for contents of drawer - use NavigationView to make configuration easier --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，DrawerLayout 通过将其传递到导航图，将其连接到AppBarConfiguration，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val appBarConfiguration = AppBarConfiguration(navController.graph, drawerLayout)</span><br></pre></td></tr></table></figure>
<p>⚠️：使用时NavigationUI，顶部应用栏帮助器会在当前目标更改时自动在抽屉图标和“向上”图标之间切换。你不需要使用 ActionBarDrawerToggle。<br>接下来，在主Activity类中，setupWithNavController() 从主活动的onCreate()方法调用 ，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    val navController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    findViewById&lt;NavigationView&gt;(R.id.nav_view)</span><br><span class="line">        .setupWithNavController(navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="底部导航"><a href="#底部导航" class="headerlink" title="底部导航"></a>底部导航</h4><p>NavigationUI也可以处理底部导航。当用户选择菜单项时，NavController调用 onNavDestinationSelected() 并自动更新底部导航栏中的所选项。<br><img src="./images/bottom-navigation.png" alt="底部导航"><br>要在应用中创建底部导航栏，请先在主要活动中定义栏，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.BottomNavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/bottom_nav"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">"@menu/menu_bottom_nav"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，在Activity中，setupWithNavController() 从主活动的onCreate()方法调用 ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    val navController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    findViewById&lt;BottomNavigationView&gt;(R.id.bottom_nav)</span><br><span class="line">        .setupWithNavController(navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套导航图"><a href="#嵌套导航图" class="headerlink" title="嵌套导航图"></a>嵌套导航图</h3><p>可以将一系列目标分组为称为根图的父导航图中的嵌套图。 嵌套图对于组织和重用应用程序UI的各个部分非常有用，例如自包含的登录流程。</p>
<p>嵌套图封装了其目标。 与根图一样，嵌套图必须将目标标识为起始目标。 嵌套图外部的目标（例如根图上的目标）仅通过其起始目标访问嵌套图。</p>
<p>图显示了一个简单的汇款应用程序的导航图。 从左侧的起始目的地开始，图表有两个流程：一个沿着顶部用于发送货币，另一个沿着底部用于查看帐户余额。<br><img src="./images/navigation-pre-nestedgraph_2x.png" alt="汇款导航图"><br>要将目标分组到嵌套图中，请执行以下操作：</p>
<ol>
<li>在导航编辑器中，按住Shift键，然后单击要包含在嵌套图中的目标。</li>
<li>右键单击以打开上下文菜单，然后选择 <strong>Move to Nested Graph &gt; New Graph</strong> 。目标包含在嵌套图中。图显示了 <strong>Navigation Editor</strong> 中的嵌套图：<br><img src="./images/navigation-nestedgraph_2x.png" alt="Graph Editor中的嵌套图"></li>
<li><p>单击嵌套图。<strong>Attributes</strong> 面板中显示以下属性 ：</p>
<ul>
<li>Type，其中包含”Nested Graph”</li>
<li>ID，包含嵌套图的系统分配ID。此ID用于引用代码中的嵌套图。</li>
</ul>
</li>
<li><p>双击嵌套图形以显示其目标。</p>
</li>
<li><p>单击 <strong>Text</strong> 选项卡以切换到XML视图。图表中添加了嵌套导航图。此导航图有自己的navigation 元素，以及它自己的ID和startDestination指向嵌套图中第一个目标的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;navigation xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    app:startDestination=&quot;@id/mainFragment&quot;&gt;</span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/mainFragment&quot;</span><br><span class="line">        android:name=&quot;com.example.cashdog.cashdog.MainFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_main&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_main&quot; &gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_mainFragment_to_chooseRecipient&quot;</span><br><span class="line">            app:destination=&quot;@id/sendMoneyGraph&quot; /&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_mainFragment_to_viewBalanceFragment&quot;</span><br><span class="line">            app:destination=&quot;@id/viewBalanceFragment&quot; /&gt;</span><br><span class="line">    &lt;/fragment&gt;</span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/viewBalanceFragment&quot;</span><br><span class="line">        android:name=&quot;com.example.cashdog.cashdog.ViewBalanceFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_view_balance&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_view_balance&quot; /&gt;</span><br><span class="line">    &lt;navigation android:id=&quot;@+id/sendMoneyGraph&quot; app:startDestination=&quot;@id/chooseRecipient&quot;&gt;</span><br><span class="line">        &lt;fragment</span><br><span class="line">            android:id=&quot;@+id/chooseRecipient&quot;</span><br><span class="line">            android:name=&quot;com.example.cashdog.cashdog.ChooseRecipient&quot;</span><br><span class="line">            android:label=&quot;fragment_choose_recipient&quot;</span><br><span class="line">            tools:layout=&quot;@layout/fragment_choose_recipient&quot;&gt;</span><br><span class="line">            &lt;action</span><br><span class="line">                android:id=&quot;@+id/action_chooseRecipient_to_chooseAmountFragment&quot;</span><br><span class="line">                app:destination=&quot;@id/chooseAmountFragment&quot; /&gt;</span><br><span class="line">        &lt;/fragment&gt;</span><br><span class="line">        &lt;fragment</span><br><span class="line">            android:id=&quot;@+id/chooseAmountFragment&quot;</span><br><span class="line">            android:name=&quot;com.example.cashdog.cashdog.ChooseAmountFragment&quot;</span><br><span class="line">            android:label=&quot;fragment_choose_amount&quot;</span><br><span class="line">            tools:layout=&quot;@layout/fragment_choose_amount&quot; /&gt;</span><br><span class="line">    &lt;/navigation&gt;</span><br><span class="line">&lt;/navigation&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在您的代码中，将连接根图的操作的资源ID传递给嵌套图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.findNavController().navigate(R.id.action_mainFragment_to_sendMoneyGraph)</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回 <strong>Design</strong> 选项卡，可以通过单击 <strong>Root</strong> 返回到根图 。</p>
</li>
</ol>
<h4 id="使用引用其他导航图"><a href="#使用引用其他导航图" class="headerlink" title="使用引用其他导航图"></a>使用<include>引用其他导航图</include></h4><p>在导航图中，您可以使用include引用其他图形。 虽然这在功能上与使用嵌套图相同，但include允许您使用其他项目模块或库项目中的图形，如下例所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- (root) nav_graph.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/nav_graph"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/fragment"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">app:graph</span>=<span class="string">"@navigation/included_graph"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.myapplication.BlankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"Fragment in Root Graph"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/action_fragment_to_second_graph"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">"@id/second_graph"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- included_graph.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/second_graph"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/includedStart"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/includedStart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.myapplication.IncludedStart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"fragment_included_start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_included_start"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>导航允许您通过定义目标的参数将数据附加到导航操作。例如，用户配置文件目标可能会使用用户ID参数来确定要显示的用户。</p>
<p>通常，您应该更倾向于仅在目标之间传递最少量的数据。例如，您应该传递一个键来检索一个对象而不是传递该对象本身，因为所有已保存状态的总空间在Android上是有限的。如果需要传递大量数据，请考虑使用片段之间共享数据中ViewModel所述的方法 。</p>
<h4 id="定义目标参数"><a href="#定义目标参数" class="headerlink" title="定义目标参数"></a>定义目标参数</h4><p>要在目标之间传递数据，首先通过以下步骤将参数添加到接收它的目标来定义参数：</p>
<ol>
<li>在导航编辑器中，单击接收参数的目标。</li>
<li>在 <strong>Attributes</strong> 面板中，单击 <strong>Add（+）</strong>。</li>
<li>在出现的 <strong>Add Argument Link</strong> 窗口中，输入参数名称，参数类型，参数是否可为空，以及默认值（如果需要）。</li>
<li>单击 <strong>Add</strong> 。请注意，该参数现在显示 在 <strong>Arguments</strong> 面板的 <strong>Attributes</strong> 列表中。</li>
<li>接下来，单击将您带到此目的地的相应操作。在 <strong>Attributes</strong> 面板中，您现在应该在  <strong>Argument Default Values</strong> 部分中看到新添加的参数。</li>
<li>您还可以看到该参数是以XML格式添加的。单击 <strong>Text</strong> 选项卡以切换到XML视图，并注意您的参数已添加到接收参数的目标。一个例子如下所示：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/myFragment"</span> &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"myArg"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">app:argType</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:defaultValue</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="覆盖操作中的目标参数"><a href="#覆盖操作中的目标参数" class="headerlink" title="覆盖操作中的目标参数"></a>覆盖操作中的目标参数</h4><p>目标级参数和默认值由导航到目标的所有操作使用。如果需要，您可以通过在操作级别定义参数来覆盖参数的默认值（如果尚不存在，则设置一个参数）。此参数必须与目标中声明的参数 <strong>具有相同的名称和类型</strong> 。</p>
<p>下面的XML声明了一个带有参数的操作，该参数覆盖了上面示例中的目标级参数：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:id</span>=<span class="string">"@+id/startMyFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:destination</span>=<span class="string">"@+id/myFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"myArg"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:argType</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:defaultValue</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用Safe-Args传递类型安全的数据"><a href="#使用Safe-Args传递类型安全的数据" class="headerlink" title="使用Safe Args传递类型安全的数据"></a>使用Safe Args传递类型安全的数据</h4><p>Navigation Architecture Component有一个名为Safe Args的Gradle插件，它生成简单的对象和构建器类，以便对目标和操作指定的参数进行类型安全访问。</p>
<p>要使用Safe Args，请先将androidx.navigation.safeargs插件添加到应用程序的build.gradle文件中，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">apply plugin: <span class="string">'androidx.navigation.safeargs'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例外还需在项目build.gradle中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath &quot;android.arch.navigation:navigation-safe-args-gradle-plugin:1.0.0-alpha09&quot;</span><br></pre></td></tr></table></figure></p>
<p>启用插件后，生成的代码包含操作的其他简单对象和构建器类以及发送和接收目标。这些类描述如下：</p>
<ul>
<li>为动作发起的每个目标创建一个类。此类的名称是始发目标的名称，后面附加 <strong>“Directions”</strong> 一词。例如，如果始发目标是已命名的片段，SpecifyAmountFragment则将调用生成的类 SpecifyAmountFragmentDirections。</li>
<li>此类具有针对始发目标中定义的每个操作的方法。</li>
<li>对于用于传递参数的每个操作，将创建一个内部类，其名称基于操作。例如，如果调用confirmationAction,该操作 ，则命名该类ConfirmationAction。</li>
<li>为接收目标创建一个类。此类的名称是目标的名称，后面附加单词“Args”。例如，如果命名目标片段，ConfirmationFragment,则调用生成的类ConfirmationFragmentArgs。使用此类的fromBundle()方法来检索参数。</li>
</ul>
<p>以下示例说明如何使用这些方法设置参数并将其传递给navigate() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onClick</span><span class="params">(v: View)</span> </span>&#123;</span><br><span class="line">   val amountTv: EditText = view!!.findViewById(R.id.editTextAmount)</span><br><span class="line">   val amount = amountTv.text.toString().toInt()</span><br><span class="line">   val action = SpecifyAmountFragmentDirections.confirmationAction(amount)</span><br><span class="line">   v.findNavController().navigate(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在接收目标的代码中，使用该 getArguments()方法检索包并使用其内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onViewCreated</span><span class="params">(view: View, savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">    val tv: TextView = view.findViewById(R.id.textViewAmount)</span><br><span class="line">    val amount = ConfirmationFragmentArgs.fromBundle(arguments).amount</span><br><span class="line">    tv.text = amount.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用具有全局操作的Safe-Args"><a href="#使用具有全局操作的Safe-Args" class="headerlink" title="使用具有全局操作的Safe Args"></a>使用具有全局操作的Safe Args</h5><p>使用具有全局操作的 Safe Args时 ，必须为android:id根<navigation>元素提供值，如以下示例所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/main_nav"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:startDestination</span>=<span class="string">"@id/mainFragment"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure></navigation></p>
<p>导航为基于该值Directions的<navigation>元素生成一个类android:id。例如，如果您有一个<navigation> 元素android:id=@+id/main_nav，则调用生成的类 MainNavDirections。<navigation>元素中的所有目标都扩展了MainNavDirections类，并且可以使用与上一节中描述的方法相同的方法访问所有关联的全局操作。</navigation></navigation></navigation></p>
<h4 id="使用Bundle对象在目标之间传递数据"><a href="#使用Bundle对象在目标之间传递数据" class="headerlink" title="使用Bundle对象在目标之间传递数据"></a>使用Bundle对象在目标之间传递数据</h4><p>如果您不使用Gradle，则仍可以使用Bundle对象在目标之间传递参数。使用创建Bundle对象并将其传递到目标navigate()，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bundle = bundleOf(<span class="string">"amount"</span> to amount)</span><br><span class="line">view.findNavController().navigate(R.id.confirmationAction, bundle)</span><br></pre></td></tr></table></figure></p>
<p>在接收目标的代码中，使用该 getArguments()方法检索Bundle并使用其内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val tv = view.findViewById&lt;TextView&gt;(R.id.textViewAmount)</span><br><span class="line">tv.text = arguments.getString(<span class="string">"amount"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h3><p>添加对新目标类型的支持<br>NavControllers依靠一个或多个Navigator对象来执行导航操作。默认情况下，所有 NavControllers支持通过使用ActivityNavigator 类及其嵌套 ActivityNavigator.Destination 类导航到另一个活动而离开导航图 。为了能够导航到任何其他类型的目标，Navigator必须将一个或多个其他对象添加到 NavController。例如，当使用片段作为目标时，会 NavHostFragment 自动将FragmentNavigator 类添加到其中 NavController。</p>
<p>要向a添加新的Navigator对象 NavController，必须使用相应的Navigator类的 getNavigatorProvider()方法，然后使用类的addNavigator()方法。以下代码显示了将虚构CustomNavigator 对象添加到以下内容的示例NavController：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val customNavigator = CustomNavigator()</span><br><span class="line">navController.navigatorProvider += customNavigator</span><br></pre></td></tr></table></figure></p>
<p>大多数Navigator 类都有一个嵌套的目标子类。此子类可用于指定目标唯一的其他属性。有关Destination子类的详细信息，请参阅相应Navigator类的参考文档 。</p>
<h3 id="条件导航"><a href="#条件导航" class="headerlink" title="条件导航"></a>条件导航</h3><p>您的应用程序可能有一系列条件目标，这些目标仅在某些条件下使用，例如当用户需要登录时。这些目标应创建为单独的目标，或嵌套导航图，另一个目标作为另一个目标启动需要。图1显示了导航到配置文件目的地的用户，该配置文件目的地确定用户未登录后，要求用户导航到登录目的地。登录目的地然后在登录完成后将用户返回到配置文件目的地。<br><img src="./images/navigation-conditional-graph.png" alt=""><br>登录目标应在返回到配置文件目标后从导航堆栈中弹出。popBackStack() 导航回原始目的地时调用 方法。原始目标将从导航堆栈“弹出”并变为活动状态。</p>
<h3 id="全局导航"><a href="#全局导航" class="headerlink" title="全局导航"></a>全局导航</h3><p>您可以使用全局操作来创建多个目标可以使用的公共操作。例如，您可能希望不同目的地的按钮导航到同一主应用程序屏幕。</p>
<p>导航编辑器中的一个全局操作由指向关联目标的小箭头表示，如图1所示<br><img src="./images/navigation-global-action.png" alt="导入嵌套图的全局操作"></p>
<h4 id="创建一个全局行动"><a href="#创建一个全局行动" class="headerlink" title="创建一个全局行动"></a>创建一个全局行动</h4><p>要创建全局操作，请执行以下操作：</p>
<ol>
<li>在“ 曲线图编辑器”中，单击目标以突出显示它。</li>
<li>右键单击目标以显示上下文菜单。</li>
<li>选择添加操作&gt;全局。箭头（）出现在目的地的左侧。</li>
<li>单击“ 文本”选项卡以导航到XML文本视图。全局操作的XML类似于以下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;navigation xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">            xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">            xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">            android:id=&quot;@+id/main_nav&quot;</span><br><span class="line">            app:startDestination=&quot;@id/mainFragment&quot;&gt;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &lt;action android:id=&quot;@+id/action_global_mainFragment&quot;</span><br><span class="line">          app:destination=&quot;@id/mainFragment&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/navigation&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用全局操作"><a href="#使用全局操作" class="headerlink" title="使用全局操作"></a>使用全局操作</h4><p>要在代码中使用全局操作，请将全局操作的资源ID传递navigate() 给每个UI元素的方法，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewTransactionButton.setOnClickListener &#123; view -&gt;</span><br><span class="line">    view.findNavController().navigate(R.id.action_global_mainFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迁移到导航"><a href="#迁移到导航" class="headerlink" title="迁移到导航"></a>迁移到导航</h3><p>该NavController导航图及其导航图包含在单个活动中。因此，在迁移现有项目以使用导航架构组件时，请通过为每个活动中的目标创建导航图，重点关注一次迁移一个活动。<br><img src="./images/navigation-migrate1.png" alt="活动及其各个导航图"><br>然后，可以通过向导航图添加活动目标来链接单独的活动，从而替换startActivity()整个代码库中的现有用法。</p>
<p><img src="./images/navigation-migrate2.png" alt="一个Activity中的导航图指向第二个Activity"><br>在多个活动共享相同布局的情况下，可以组合导航图，将导航调用替换为活动目标，以直接在两个导航图之间导航调用。</p>
<p><img src="./images/navigation-migrate3.png" alt="包含组合导航图的活动。"></p>
<p>参考：<br>[1]. 官网 <a href="https://developer.android.com/topic/libraries/architecture/navigation/" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/navigation/</a><br>[2]. 官网demo <a href="https://github.com/googlecodelabs/android-navigation" target="_blank" rel="noopener">https://github.com/googlecodelabs/android-navigation</a><br>[3]. 官网教程 <a href="https://codelabs.developers.google.com/codelabs/android-navigation/#0" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/android-navigation/#0</a><br>[4]. 关于navigation的解析 <a href="https://www.jianshu.com/p/ad040aab0e66" target="_blank" rel="noopener">https://www.jianshu.com/p/ad040aab0e66</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/12/24/SpringBoot-Database-H2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/SpringBoot-Database-H2/" itemprop="url">SpringBoot Database H2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-24T15:03:13+08:00">
                2018-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  内存数据库（Embedded database或in-momery database）具有配置简单、启动速度快、尤其是其可测试性等优点，使其成为开发过程中非常有用的轻量级数据库。在spring中支持HSQL、H2和Derby三种数据库。H2是Thomas Mueller提供的一个开源的、纯java实现的关系数据库。</p>
<p>各数据库特性对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>H2</th>
<th>Derby</th>
<th>HSQLDB</th>
<th>MySQL</th>
<th style="text-align:left">PostgreSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure Java</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>Memory Mode</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>Encrypted Database</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>ODBC Driver</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Fulltext Search</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Multi Version Concurrency</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Footprint (jar/dll size)</td>
<td>~1 MB</td>
<td>~2 MB</td>
<td>~1 MB</td>
<td>~4 MB</td>
<td style="text-align:left">~6 MB</td>
</tr>
</tbody>
</table>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>JDK 1.8或更高版本</li>
<li>Maven 3.5或更高版本</li>
</ul>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Spring Data JPA</li>
<li>Spring Boot</li>
</ul>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="./images/project_package.png" alt="项目目录结构"></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mugwort<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring web开发依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库依赖 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- h2 嵌入式数据库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jpa 依赖，持久化操作依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String lastaudit;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastaudit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastaudit</span><span class="params">(String lastaudit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastaudit = lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">" | "</span> + name + <span class="string">" | "</span> + lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Id  声明此属性为主键。该属性值可以通过应该自身创建，但是Hibernate推荐通过Hibernate生成；</li>
<li>@GeneratedValue<br>指定主键的生成策略。<ul>
<li>TABLE：使用表保存id值；</li>
<li>IDENTITY：identitycolumn；</li>
<li>SEQUENCR ：sequence；</li>
<li>AUTO：根据数据库的不同使用上面三个，默认值；</li>
</ul>
</li>
<li>@Column 声明该属性与数据库字段的映射关系。</li>
</ul>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SystemRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">SystemBean</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA包含了一些内置的Repository，实现了一些常用的方法：findone，findall，save等。</p>
<h3 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="string">spring.application.name=Bootstrap</span> <span class="string">Spring</span> <span class="string">boot</span> <span class="string">web</span> <span class="string">with</span> <span class="string">H2</span></span><br><span class="line"><span class="comment">### jpa 只进行更新,默认是启动的时候不管三七二十一就删除原来的表结构重新生成</span></span><br><span class="line"><span class="string">spring.jpa.hibernate.ddl-auto=update</span></span><br><span class="line"><span class="string">spring.jpa.database-platform=org.hibernate.dialect.H2Dialect</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#显示SQL语句</span></span><br><span class="line"><span class="string">spring.jpa.show-sql=true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 每次启动程序，程序都会运行resources/db/schema.sql文件，对数据库的结构进行操作。</span></span><br><span class="line"><span class="string">spring.datasource.schema=classpath:schema.sql</span></span><br><span class="line"><span class="comment"># 每次启动程序，程序都会运行resources/db/data.sql文件，对数据库的数据操作。</span></span><br><span class="line"><span class="string">spring.datasource.data=classpath:data.sql</span></span><br><span class="line"><span class="comment">#### 驱动类</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#When using database URLs like jdbc:h2:~/test, the database is stored in the user directory. For Windows, this is usually C:\Documents and #Settings\&lt;userName&gt; or C:\Users\&lt;userName&gt;. If the base directory is not set (as in jdbc:h2:./test), the database files are stored in the directory where #the application is started (the current working directory). When using the H2 Console application from the start menu, this is &lt;Installation Directory&gt;/#bin. The base directory can be set in the database URL. A fixed or relative path can be used. When using the URL jdbc:h2:file:./data/sample, the database #is stored in the directory data (relative to the current working directory). The directory is created automatically if it does not yet exist. It is also #possible to use the fully qualified directory name (and for Windows, drive name). Example: jdbc:h2:file:C:/data/test</span></span><br><span class="line"><span class="comment">####===== connect to  ======</span></span><br><span class="line"><span class="comment">##这里设置的是数据存储在内存中，也可以存储在磁盘</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:h2:mem:h2test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=org.h2.Driver</span></span><br><span class="line"><span class="string">spring.datasource.name=sa</span></span><br><span class="line"><span class="string">spring.datasource.password=</span></span><br><span class="line"><span class="string">spring.datasource.platform=h2</span></span><br><span class="line"><span class="comment">### h2 properties</span></span><br><span class="line"><span class="string">spring.h2.console.path=/console</span></span><br><span class="line"><span class="string">spring.h2.console.enabled=true</span></span><br><span class="line"><span class="comment">###### web 访问接口</span></span><br><span class="line"><span class="string">server.port=8081</span></span><br><span class="line"><span class="comment">### 日志</span></span><br><span class="line"><span class="string">logging.level.root=info</span></span><br></pre></td></tr></table></figure>
<p>在application.properties文件中对数据库进行连接配置</p>
<p>spring.datasource.url=jdbc:h2:mem:h2test，配置h2数据库的连接地址<br>spring.datasource.driver-class-name=org.h2.Driver，配置JDBC Driver<br>spring.datasource.username=sa，配置数据库用户名<br>spring.datasource.password=，配置数据库密码</p>
<p>当你完成依赖和连接配置这两步之后，你就可以在程序种使用h2了。spring会自动帮你完成DataSource的注入。</p>
<h4 id="数据初始化配置"><a href="#数据初始化配置" class="headerlink" title="数据初始化配置"></a>数据初始化配置</h4><p>如果你需要在程序启动时对数据库进行初始化操作，则在application.properties文件中对数据库进接配置</p>
<p>spring.datasource.schema=classpath:schema.sql，进行该配置后，每次启动程序，程序都会运行resources/schema.sql文件，对数据库的结构进行操作。<br>spring.datasource.data=classpath:data.sql,进行该配置后，每次启动程序，程序都会运行resources/data.sql文件，对数据库的数据操作。</p>
<p>该配置非常适合开发环境，我会把数据库的结构构建sql放在resources/schema.sql，数据sql放在resources/data.sql中。这样每次运行程序我都可以得到一个新的数据库。这样就不需要我每次为了测试而修改数据中的内容了。<br>schema.sql代码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span>  system_bean;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> system_bean(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">lastaudit <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>  (<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>data.sql代码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'Windows Server 2012 R2 '</span>,<span class="string">'2017-08-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'RHEL 7'</span>,<span class="string">'2017-07-21'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'Solaris 11'</span>,<span class="string">'2017-08-13'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="h2-web-consloe配置"><a href="#h2-web-consloe配置" class="headerlink" title="h2 web consloe配置"></a>h2 web consloe配置</h4><p>h2 web consloe是一个数据库GUI管理应用，就和phpMyAdmin类似。程序运行时，会自动启动h2 web consloe。当然你也可以进行如下的配置。</p>
<p>spring.h2.console.settings.web-allow-others=true，进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。<br>spring.h2.console.path=/h2-console，进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。<br>spring.h2.console.enabled=true，进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。</p>
<p>参考：<br>[1]. <a href="https://juejin.im/post/5ab4b339f265da238c3a9d0a" target="_blank" rel="noopener">https://juejin.im/post/5ab4b339f265da238c3a9d0a</a><br>[2]. <a href="https://412887952-qq-com.iteye.com/blog/2322756" target="_blank" rel="noopener">https://412887952-qq-com.iteye.com/blog/2322756</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/10/12/Android-pie-slice开发小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/Android-pie-slice开发小记/" itemprop="url">Android pie slice开发小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T12:51:02+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android-pie-slice开发小记"><a href="#Android-pie-slice开发小记" class="headerlink" title="Android pie slice开发小记"></a>Android pie slice开发小记</h2><h3 id="slice创建和运行"><a href="#slice创建和运行" class="headerlink" title="slice创建和运行"></a>slice创建和运行</h3><ol>
<li>首先新建一个项目并选择使用的api为API 28:Android 9（pie）或者在已有的项目调整其编译、最低和目标版本为28（最低）。</li>
<li>创建 slice provider：<br><img src="./images/new-slice.png" alt="new slice step"><br>当生成slice provider后，编译器会报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest merger failed : Attribute application@appComponentFactory value=(androidx.core.app.CoreComponentFactory) from [androidx.core:core:1.0.0] AndroidManifest.xml:22:18-86</span><br><span class="line">	is also present at [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91 value=(android.support.v4.app.CoreComponentFactory).</span><br><span class="line">	Suggestion: add &apos;tools:replace=&quot;android:appComponentFactory&quot;&apos; to &lt;application&gt; element at AndroidManifest.xml:5:5-35:19 to override.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上错误主要是android在api 28版本后，appconmpat、cardview和constraintlayout等都移到Androidx包名下，所以修正方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">//    implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">//    implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos;</span><br><span class="line">  implementation &apos;androidx.appcompat:appcompat:1.0.0&apos;</span><br><span class="line">  implementation &apos;androidx.constraintlayout:constraintlayout:1.1.3&apos;</span><br><span class="line"></span><br><span class="line">  implementation &apos;androidx.annotation:annotation:1.0.0&apos;</span><br><span class="line">  implementation &apos;androidx.slice:slice-builders:1.0.0&apos;</span><br><span class="line"></span><br><span class="line">  testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">  androidTestImplementation &apos;androidx.test:runner:1.1.0-alpha3&apos;</span><br><span class="line">  androidTestImplementation &apos;androidx.test.espresso:espresso-core:3.1.0-alpha3&apos;</span><br></pre></td></tr></table></figure></p>
<p>参考地址：<a href="https://stackoverflow.com/questions/50782435/android-design-support-library-for-api-28-p-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/50782435/android-design-support-library-for-api-28-p-not-working</a></p>
<ol>
<li>sliceProvider编码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieSliceProvider</span> <span class="keyword">extends</span> <span class="title">SliceProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instantiate any required objects. Return true if the provider was successfully created,</span></span><br><span class="line"><span class="comment">     * false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateSliceProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Converts URL to content URI (i.e. content://com.mugwort.demo...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">onMapIntentToUri</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: implementing this is only required if you plan on catching URL requests.</span></span><br><span class="line">        <span class="comment">// This is an example solution.</span></span><br><span class="line">        Uri.Builder uriBuilder = <span class="keyword">new</span> Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT);</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) <span class="keyword">return</span> uriBuilder.build();</span><br><span class="line">        Uri data = intent.getData();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.getPath() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String path = data.getPath().replace(<span class="string">"/"</span>, <span class="string">""</span>);</span><br><span class="line">            uriBuilder = uriBuilder.path(path);</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uriBuilder = uriBuilder.authority(context.getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct the Slice and bind data if available.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Slice <span class="title">onBindSlice</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        SliceAction activityAction = createActivityAction();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span> || activityAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(sliceUri.getPath())) &#123;</span><br><span class="line">            <span class="comment">// Path recognized. Customize the Slice using the androidx.slice.builders API.</span></span><br><span class="line">            <span class="comment">// Note: ANRs and strict mode is enforced here so don't do any heavy operations.</span></span><br><span class="line">            <span class="comment">// Only bind data that is currently available in memory.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                    .addRow(</span><br><span class="line">                            <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                    .setTitle(<span class="string">"URI found.hello i'am here"</span>)</span><br><span class="line">                                    .setPrimaryAction(activityAction)</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error: Path not found.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                    .addRow(</span><br><span class="line">                            <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                    .setTitle(<span class="string">"URI not found."</span>)</span><br><span class="line">                                    .setPrimaryAction(activityAction)</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SliceAction <span class="title">createActivityAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return null;</span></span><br><span class="line">        <span class="comment">//Instead of returning null, you should create a SliceAction. Here is an example:</span></span><br><span class="line">        <span class="keyword">return</span> SliceAction.create(</span><br><span class="line">            PendingIntent.getActivity(</span><br><span class="line">                getContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(getContext(), MainActivity.class), <span class="number">0</span></span><br><span class="line">            ),</span><br><span class="line">            IconCompat.createWithResource(getContext(), R.drawable.ic_launcher_foreground),</span><br><span class="line">            ListBuilder.ICON_IMAGE,</span><br><span class="line">            <span class="string">"Open App"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slice has been pinned to external process. Subscribe to data source if necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSlicePinned</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// When data is received, call context.contentResolver.notifyChange(sliceUri, null) to</span></span><br><span class="line">        <span class="comment">// trigger PieSliceProvider#onBindSlice(Uri) again.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unsubscribe from data source if necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSliceUnpinned</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove any observers if necessary to avoid memory leaks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分析：</p>
<ul>
<li>通过类我们发现SliceProvider继承于ContentProvider，其APP间数据的传递通过<br>ContentProvider的方式，应用APP向搜索APP对外提供其对应Slice的Uri，封装成Slice对象通过Parcelable序列化的方式实现APP之间的数据传递。</li>
<li>slice的绑定和展示：onBindSlice，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Slice <span class="title">onBindSlice</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    SliceAction activityAction = createActivityAction();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || activityAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//“/”是在manifest中定义的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(sliceUri.getPath())) &#123;</span><br><span class="line">        <span class="comment">// Path recognized. Customize the Slice using the androidx.slice.builders API.</span></span><br><span class="line">        <span class="comment">// Note: ANRs and strict mode is enforced here so don't do any heavy operations.</span></span><br><span class="line">        <span class="comment">// Only bind data that is currently available in memory.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                .addRow(</span><br><span class="line">                        <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                .setTitle(<span class="string">"URI found.hello i'am here"</span>)</span><br><span class="line">                                .setPrimaryAction(activityAction)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Error: Path not found.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                .addRow(</span><br><span class="line">                        <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                .setTitle(<span class="string">"URI not found."</span>)</span><br><span class="line">                                .setPrimaryAction(activityAction)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Uri的scheme统一为content,如上述例子的Uri为:<br>content://x.x.x/</p>
<ul>
<li><p>SliceAction,这个类似notifications，可以使用PendingIntents 来处理用户的点击事件，比如点击Slice模块打开宿主APP：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SliceAction <span class="title">createActivityAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return null;</span></span><br><span class="line">    <span class="comment">//Instead of returning null, you should create a SliceAction. Here is an example:</span></span><br><span class="line">    <span class="keyword">return</span> SliceAction.create(</span><br><span class="line">        PendingIntent.getActivity(</span><br><span class="line">            getContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(getContext(), MainActivity.class), <span class="number">0</span></span><br><span class="line">        ),</span><br><span class="line">        IconCompat.createWithResource(getContext(), R.drawable.ic_launcher_foreground),</span><br><span class="line">        ListBuilder.ICON_IMAGE,</span><br><span class="line">        <span class="string">"Open App"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过安装<br><a href="https://github.com/googlesamples/android-SliceViewer/releases" target="_blank" rel="noopener"> SliceViewer</a>，在搜索框输入uri即可添加slice并跳转:<br><img src="./images/slice-view.png" alt="SliceViewer"></p>
</li>
</ul>
<h3 id="Slice模板"><a href="#Slice模板" class="headerlink" title="Slice模板"></a>Slice模板</h3><ul>
<li>ListBuilder:Slices通过ListBuilder类来创建。在ListBuilder中，你可以添加不同类型的行模块在你的Slice中进行展示。</li>
</ul>
<ul>
<li>SliceAction:对于每一个Slice来说，最基础的构造实现类是SliceAction，在SliceAction你可以添加PendingIntent来实现用户操作，比如Toggle选择操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SliceAction toggleAction =SliceAction.createToggle(createToggleIntent(),<span class="string">"Toggle adaptive brightness"</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>SliceAction可以配置在搜索APP中显示的模块三种不同的显示方式：</p>
<p>  ICON_IMAGE:tiny size and tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-745370335b55ea66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/406/format/webp" alt="shortcut"></p>
<p> SMALL_IMAGE:small size and non-tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-c4bdc8a2370df185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="small">  </p>
<p>  LARGE_IMAGE: largest size and non-tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-2fa70505db53e281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420/format/webp" alt="large"></p>
<h3 id="模块构造Builder"><a href="#模块构造Builder" class="headerlink" title="模块构造Builder"></a>模块构造Builder</h3><p>  对于每个Slice模块的创建构造，谷歌官方提供了HeaderBuilder、RowBuilder、GridBuilder、RangeBuilder模块四种构造器。其中，HeaderBuilder只支持一行头部的展示view；RowBuilder可以添加一行view进行展示，如此前没有添加header，则首行row默认为header；GridBuilder支持上述所说的三种模块展示方式；而RangeBuilder则支持进度条相关的view展示。</p>
<h3 id="延时加载"><a href="#延时加载" class="headerlink" title="延时加载"></a>延时加载</h3><p>  对于一些需要耗时加载数据的操作，比如网络请求图片等，可以采取与ListView加载图片类似的方法，先本地加载一个默认的占位数据，等耗时操作完成回调回来真实数据的时候调用getContentResolver().notifyChange(sliceUri) 方法，通知搜索APP调用Slice Uri，完成真实数据的显示。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>  Slice的功能模板非常的强大，通过不同的builder组合可以在搜索模块中搭配出丰富多彩的Slice，快速直达用户想要的功能。但是Slice只提供了三种模板，自带模板中对安卓原生控件的支持有所欠缺，比如ScollView等，可能需要用户自定义自己的模板才能实现更强大的功能。</p>
<p>参考：<br>[0].<a href="https://www.androidauthority.com/android-slices-872250/" target="_blank" rel="noopener">https://www.androidauthority.com/android-slices-872250/</a><br>[1].<a href="https://www.jianshu.com/p/a90563606e1f" target="_blank" rel="noopener">https://www.jianshu.com/p/a90563606e1f</a><br>[2].<a href="http://digi.aili.com/1642/2811309.html" target="_blank" rel="noopener">http://digi.aili.com/1642/2811309.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/27/基础数据与byte间的转化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/基础数据与byte间的转化/" itemprop="url">基础数据与byte间的转化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T16:42:52+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>   <strong>计算机中存储是用补码！！，同时注意一下计算省略了高位不变部分和 字节大小端问题</strong>  </p>
<h4 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h4><ul>
<li>byte：有符号，在网络传输中都是会用到byte的，它占1个字节，共8位，比如说11111111就可以用1个<br>byte表示，转化为10进制：- （2的6次+2的5次+2的4次+2的3次+2的2次+2的1次+2的0次） = -127。<br>其中前7位表示数字，最高位表示符号，0为正，1为负。范围是 （-2的7次 ~ 2的7次 - 1），那为什么前<br>面最小是-127，范围最小又是-128呢？因为规定-0（10000000）为-128。</li>
<li>short：有符号，占2个字节，共16位。同byte一样，它的取值范围就是 （-2的15次 ~ 2的15次 - 1）。</li>
<li>int：有符号，占4个字节，共32位。它的取值范围就是（-2的31次 ~ 2的31次）。</li>
<li>long：有符号，占8个字节，共64位，它的取值范围就是（-2的63次 ~ 2的63次）。</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ul>
<li>^：表示异或位运算，两者相同则为0，两者不同则为1。比如说15^2，15用二进制表示就是1111，2用2<br>进制表示就是0010，两者进行异或运算，结果就是1101，转换为十进制就是13。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A^B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>|：表示或运算，两者只有有一个为1就为1， 比如说13|2，13用二进制表示就是1101，2用二进制表示<br>就是0010，两者进行或运算，那么结果就是1111，转换为十进制就是15。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A &#124; B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>&amp;：表示与运算，两者都为1就为1，其余都为0，比如说15&amp;2， 13用二进制表示就是1111，2用二进制<br>表示就是0010， 两者进行与运算，那么结果就是0010，转换为十进制就是2。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A&amp;B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>~：取反，就是本来是0变成1，本来是1变成0。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">～A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<ul>
<li><p>&lt;&lt;:左移运算符，不需要考虑符号位，因为在后面补0，把二进制的数字向左移动，低位补0。比如说 3&lt;&lt;2。<br>3的二进制码为11，向左移动2位就是1100，那么结果就是12。</p>
</li>
<li><p>>&gt;：右移运算符，带符号位。根据这个要移动的数字决定正负，如果是正数，那么就在前面补0，如果是<br>负数就在前面补1。比如说 3&gt;&gt;2，3的二进制码为00000011，向右移动2位，就变成00000000，转化为十<br>进制就是0了（3是正数所以在高位补0）。再比如说-3&gt;&gt;2，-3的二进制码为10000011，转化为补码<br>（只要涉及到负数，就需要转换到补码计算，正数之所以不用转化，是因为他们的补码和原码是一致的）<br>11111101，进行位移运算，就是11111111，这个是补码，需要再转回原码。那么就是取反+1，结果就是<br>10000001，转化为十进制就是-1。</p>
</li>
<li><p>>&gt;&gt;：右移运算符，与上面的区别就是这个运算符是 <strong>无符号的</strong>。不论正负，高位都补0。如果要用<br>-3&gt;&gt;2来验证，因为高位补0，就需要把所有的位数都写全了。如果是int，那就要写成32位来运算。切记切记。<br>上面很多因为高位的变化“取反再取反”会导致前面所有的位都没变所以我就简化了，但是这个&gt;&gt;&gt;运算符不行哦，<br>它会把负数变为正数。</p>
</li>
</ul>
<p>栗子（eg）：<br>比如说-15|3等于多少呢？有些人会觉得-15转化为二进制就是10001111，而3转化为二进制就是00000011，<br>那么结果应该是10001111呀，转换为十进制就是-15呀？大家可以自己写个demo就会发现是不对的。要注意<br>在计算机中所有的都是用补码的形式存储的，之所以上面介绍两个正数是对的，因为 <strong>正数的反码和补码都是一样的。而负数求补码应该是除去符号位取反+1</strong>，我们再来看看这个题-15|3，其中-15的原码为10001111，反码为11110000，那么补码就是11110001，然后3的补码为00000011，两者进行或操作就是11110011，你以为结束了么？还没有，再又要求它的原码了，<strong>原码就是补码再求补码再+1</strong>（是不是已经晕掉了？），也就是<br>10001101，结果就是-13。为了大家都好理解，我这里用算式整理一下：</p>
<p>求 -15|3</p>
<p>[-15]原码 = 10001111<br>[-15]反码 = 11110000 //原码求反码符号位不变<br>[-15]补码 = 11110001 //反码+1等于补码</p>
<p>[3]原码 = 00000011<br>[3]反码 = 00000011 //正数都一致<br>[3]补码 = 00000011 //正数都一致</p>
<p>-15|3 = 11110011 //两个补码进行或操作</p>
<p>[结果]补码 = 11110011 //上面求得的值<br>[结果]反码 = 10001100 //符号位不变<br>[结果]原码 = 10001101 //反码+1</p>
<p>100001101 转化为十进制就是-13。<br>不知道我这么解释会不会更加清楚一些呢？同理的，上面那些（尤其是求反‘~’我故意没写例子，大家自己去试试吧）。</p>
<p>在说一次，正数的原码，补码，反码都一样，如果一定要说为什么一样，我就举个例子。有这么一个等式7+（-7）=0。<br>我们知道<br>[-7]原 = 10000111<br>[-7]反 = 11111000<br>[-7]补 = 11111001</p>
<p>那么如果要存在一个值和[-7]补码相加等于0，是不是就是00000111！！所以正数的补码和原码是一致的。<br>这样解释虽然怪怪的，但是可以知道的确是这样的。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>基本步骤：<br>① 分析转化和代转化之间位数的关系<br>② 计算偏移量。每次都取最后8位<br>③ 把最后8位和0xff进行&amp;操作<br>④ 得出结果。  </p>
<p>有人会问，为什么要和0xff进行&amp;操作？这里解释下，因为再分割的时候，我们要保证最后8位是一致的，更高位都要置0，这样才能保证数据的一致性。比如说由byte转化成short。位数从8位变成了16位，那么在计算机自己看来，它会把前面多出来的8位置1。而&amp;0xff就可以把前面所有的位数都置0。</p>
<ol>
<li>short与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前提：在计算机中所有的都是用补码的形式存储的。</span></span><br><span class="line"><span class="comment">    * 将short转换为字节</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 例如 8的补码为0000 0000 0000 1000，所以要将转换为两个字节，第一个字节是将8右移8位然后和0x00ff求与，</span></span><br><span class="line"><span class="comment">    * 而第二个字节则是右移0位，然后求与</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] short2byte(<span class="keyword">short</span> s)&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">16</span> - (i+<span class="number">1</span>)*<span class="number">8</span>;          <span class="comment">//因为byte占1个字节，所以要计算偏移量</span></span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)((s &gt;&gt; offset)&amp;<span class="number">0xff</span>); <span class="comment">//把16位分为2个8位进行分别存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">byte2short</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">short</span> l = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">           l&lt;&lt;=<span class="number">8</span>;               <span class="comment">//&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span></span><br><span class="line">           l |= (b[i] &amp; <span class="number">0xff</span>); <span class="comment">//和上面也是一样的  l = l | (b[i]&amp;0xff)</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>int与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2byte(<span class="keyword">int</span> s)&#123;</span><br><span class="line">         <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> offset = <span class="number">16</span> - (i+<span class="number">1</span>)*<span class="number">8</span>;         <span class="comment">//因为byte占1个字节，所以要计算偏移量</span></span><br><span class="line">             b[i] = (<span class="keyword">byte</span>)((s &gt;&gt; offset)&amp;<span class="number">0xff</span>); <span class="comment">//把32位分为4个8位进行分别存储</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byte2int</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            l&lt;&lt;=<span class="number">8</span>;              <span class="comment">//&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span></span><br><span class="line">            l |= (b[i] &amp; <span class="number">0xff</span>); <span class="comment">//和上面也是一样的  l = l | (b[i]&amp;0xff)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>long与byte的相互转化   </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @方法功能 字节数组和长整型的转换</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 长整型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] longToByte(<span class="keyword">long</span> number) &#123;</span><br><span class="line">		<span class="keyword">long</span> temp = number;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = <span class="keyword">new</span> Long(temp &amp; <span class="number">0xff</span>).byteValue();</span><br><span class="line">			<span class="comment">// 将最低位保存在最低位</span></span><br><span class="line">			temp = temp &gt;&gt; <span class="number">8</span>;</span><br><span class="line">			<span class="comment">// 向右移8位</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @方法功能 字节数组和长整型的转换</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 长整型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteToLong</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> s0 = b[<span class="number">0</span>] &amp; <span class="number">0xff</span>;<span class="comment">// 最低位</span></span><br><span class="line">		<span class="keyword">long</span> s1 = b[<span class="number">1</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s2 = b[<span class="number">2</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s3 = b[<span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s4 = b[<span class="number">4</span>] &amp; <span class="number">0xff</span>;<span class="comment">// 最低位</span></span><br><span class="line">		<span class="keyword">long</span> s5 = b[<span class="number">5</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s6 = b[<span class="number">6</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s7 = b[<span class="number">7</span>] &amp; <span class="number">0xff</span>; <span class="comment">// s0不变</span></span><br><span class="line">		s1 &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">		s2 &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">		s3 &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">		s4 &lt;&lt;= <span class="number">8</span> * <span class="number">4</span>;</span><br><span class="line">		s5 &lt;&lt;= <span class="number">8</span> * <span class="number">5</span>;</span><br><span class="line">		s6 &lt;&lt;= <span class="number">8</span> * <span class="number">6</span>;</span><br><span class="line">		s7 &lt;&lt;= <span class="number">8</span> * <span class="number">7</span>;</span><br><span class="line">		s = s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>char与byte的转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 字符到字节转换</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ch</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">char</span> ch, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = (<span class="keyword">int</span>) ch;</span><br><span class="line">		<span class="comment">// byte[] b = new byte[2];</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ ) &#123;</span><br><span class="line">			bb[index + i] = <span class="keyword">new</span> Integer(temp &amp; <span class="number">0xff</span>).byteValue(); <span class="comment">// 将最高位保存在最低位</span></span><br><span class="line">			temp = temp &gt;&gt; <span class="number">8</span>; <span class="comment">// 向右移8位</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 字节到字符转换</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[index + <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">			s += b[index + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			s += <span class="number">256</span> + b[index + <span class="number">0</span>];</span><br><span class="line">		s *= <span class="number">256</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[index + <span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">			s += b[index + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			s += <span class="number">256</span> + b[index + <span class="number">0</span>];</span><br><span class="line">		<span class="keyword">char</span> ch = (<span class="keyword">char</span>) s;</span><br><span class="line">		<span class="keyword">return</span> ch;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>float与byte的转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * float转换byte</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putFloat</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">float</span> x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// byte[] b = new byte[4];</span></span><br><span class="line">	<span class="keyword">int</span> l = Float.floatToIntBits(x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		bb[index + i] = <span class="keyword">new</span> Integer(l).byteValue();</span><br><span class="line">		l = l &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过byte数组取得float</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	l = b[index + <span class="number">0</span>];</span><br><span class="line">	l &amp;= <span class="number">0xff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	l &amp;= <span class="number">0xffff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>);</span><br><span class="line">	l &amp;= <span class="number">0xffffff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">	<span class="keyword">return</span> Float.intBitsToFloat(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>double与byte的转化   </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * double转换byte</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDouble</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">double</span> x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// byte[] b = new byte[8];</span></span><br><span class="line">		<span class="keyword">long</span> l = Double.doubleToLongBits(x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			bb[index + i] = <span class="keyword">new</span> Long(l).byteValue();</span><br><span class="line">			l = l &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过byte数组取得float</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> l;</span><br><span class="line">		l = b[<span class="number">0</span>];</span><br><span class="line">		l &amp;= <span class="number">0xff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">4</span>] &lt;&lt; <span class="number">32</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">5</span>] &lt;&lt; <span class="number">40</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">6</span>] &lt;&lt; <span class="number">48</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">7</span>] &lt;&lt; <span class="number">56</span>);</span><br><span class="line">		<span class="keyword">return</span> Double.longBitsToDouble(l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>boolean与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将boolean转成byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] Boolean2ByteArray(<span class="keyword">boolean</span> val) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (val == <span class="keyword">false</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ByteBuffer.allocate(<span class="number">4</span>).putInt(tmp).array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将byte[]转成boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">ByteArray2Boolean</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = ByteBuffer.wrap(data, <span class="number">0</span>, <span class="number">4</span>).getInt();</span><br><span class="line">        <span class="keyword">return</span> (tmp == <span class="number">0</span>) ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考地址：<br>[1].long、shrot和int转化 <a href="https://blog.csdn.net/u012403290/article/details/68943827" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/68943827</a><br>[2].long、shrot和int转化 <a href="https://blog.csdn.net/thanklife/article/details/17002641" target="_blank" rel="noopener">https://blog.csdn.net/thanklife/article/details/17002641</a><br>[3]. char、float、double与byte转化 <a href="https://blog.csdn.net/LEEtcWorks/article/details/7390731" target="_blank" rel="noopener">https://blog.csdn.net/LEEtcWorks/article/details/7390731</a><br>[4]. 通过buffer转换 <a href="https://blog.csdn.net/u010983881/article/details/60870360" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/60870360</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/23/NIO-Buffer解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/NIO-Buffer解析/" itemprop="url">NIO-Buffer解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T16:18:47+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp; &nbsp; &nbsp; &nbsp;在NIO中，数据的读写操作始终是与缓冲区相关联的。Channel将数据<br>读入缓冲区，然后我们又从缓冲区访问数据。写数据时，首先将要发送的数据按顺序填入缓冲区。基本上，<br>缓冲区只是一个列表，它的所有元素都是基本数据类型（通常为字节型）。缓冲区是定长的，它不像一些类<br>那样可以扩展容量（例如，List，StringBuffer等）。注意，ByteBuffer是最常用的缓冲区，因为：1）<br>它提供了读写其他数据类型的方法，2）信道的读写方法只接收ByteBuffer。</p>
<h4 id="Buffer索引"><a href="#Buffer索引" class="headerlink" title="Buffer索引"></a>Buffer索引</h4><p>缓冲区不仅仅是用来存放一组元素的列表。在读写数据时，它有内部状态来跟踪缓冲区的当前位置，以及有效<br>可读数据的结束位置等。为了实现这些功能，每个缓冲区维护了指向其元素列表的4个索引，如下表所示。<br>（不久我们将看到如何使用缓冲区的各种方法来修改索引值。）   </p>
<table>
<thead>
<tr>
<th style="text-align:left">索引</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">存取器/修改器/用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">capacity</td>
<td style="text-align:left">缓冲区的元素总是（不可修改）</td>
<td style="text-align:left">int capacity（）</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">下一个要读/写的元素（从0开始）</td>
<td style="text-align:left">int position(), Buffer position(int newPosition)</td>
</tr>
<tr>
<td style="text-align:left">limit</td>
<td style="text-align:left">第一个不可读/写元素</td>
<td style="text-align:left">int limit(), Buffer limit(int newLimit)</td>
</tr>
<tr>
<td style="text-align:left">mark</td>
<td style="text-align:left">用户选定的position 高的前一个位置或0</td>
<td style="text-align:left">Buffer mark(),Buffer reset()</td>
</tr>
</tbody>
</table>
<p>position和limit之间的距离指示了可读取/存入的字节数，java中提供了两个方便的方法来计算这个距离。  </p>
<ul>
<li>boolean hasRemaining（）：当缓冲区至少还有一个元素时，返回true；</li>
<li>int remaining（）：返回缓冲区包含的元素个数；<br>在这些变量中，始终保持以下关系不变：<br>0  ≤ mark ≤ position ≤ limit ≤ capacity<br>mark变量的值“记录”了一个将来可返回的位置，reset（）方法则将postion的值还原成上次调用mark（）<br>方法后的position值（除非这样做会违背上面的不变关系）；</li>
</ul>
<h4 id="Buffer创建"><a href="#Buffer创建" class="headerlink" title="Buffer创建"></a>Buffer创建</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;通常使用分配空间或包装一个现有的基本类型数组来创建缓冲区。创建ByteBuffer的静态工厂方法，以及<br>相应的capacity，position，和limit的初始值下表。所有新创建的Buffer实例都没有定义其mark值，<br>在调用mark()方法前，任何试图使用reset()方法来设置position的值的操作都将抛出InvalidMarkException异常。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteBuffer    allocate(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    allocateDirect(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">0</td>
<td style="text-align:left">array.length</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array,int offer,int length)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">offset</td>
<td style="text-align:left">offset-array.length</td>
</tr>
</tbody>
</table>
<p>要分配一个新的实例，只需要简单地调用想要创建的缓冲区类型的allocate()静态方法，并指定元素的总数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(20);</span><br><span class="line">DoubleBuffer dblBuf = DoubleBuffer.allocate(5);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在上面代码中，byteBuf分配了20个字节，dblBuf分配了5个Java的<br>double型数据。这些缓冲区都是定长的，因此无法扩展或缩减它们的容量。如果发现刚创建的缓冲区容量太小，<br>惟一的选择就是重新创建一个大小合适的缓冲区。<br>还可以通过调用wrap()静态方法，以一个已有的数组为参数，来创建缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byteArray[] = new byte[BUFFERSIZE];</span><br><span class="line">// ...Fill array...</span><br><span class="line">ByteBuffer byteWrap = ByteBuffer.wrap(byteArray);</span><br><span class="line">ByteBuffer subByteWrap = ByteBuffer.wrap(byteArray, 3,3);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过包装的方法创建的缓冲区 <strong>保留了被包装数组内保存的数据</strong>。实际上，<br>wrap()方法只是简单地创建了一个具有指向被包装数组的引用的缓冲区，该数组称为 <strong>后援数组</strong>。对后援数组<br>中的数据做的任何修改都将改变缓冲区中的数据，反之亦然。如果我们为wrap()方法指定了偏移量（offset）<br>和长度（length），缓冲区将使用整个数组为后援数组，同时将position和limit的值初始化为偏移量<br>（offset）和偏移量+长度（offset+length）。在偏移量之前和长度之后的元素依然可以通过缓冲区访问。<br>使用分配空间的方式来创建缓冲区其实与使用包装的方法区别不大。惟一的区别是allocate()方法创建了<br>自己的后援数组。在缓冲区上调用array()方法即可获得后援数组的引用。通过调用arrayOffset()方法，<br>甚至还可以获取缓冲区中第一个元素在后援数组中的偏移量。使用wrap()方法和非零偏移量参数创建的缓冲区，<br>其数组偏移量依然是0。<br>&nbsp; &nbsp; &nbsp; &nbsp;到目前为止，我们实现的所有缓冲区都将数据存放在Java分配的后援数组中。<br>通常，底层平台（操作系统）不能使用这些缓冲区进行I/O操作。操作系统必须使用自己的缓冲区来进行I/O，<br>并将结果复制到缓冲区的后援数组中。这些复制过程 <strong>可能非常耗费系统资源</strong>，尤其是在有很多读写需求的时候。<br>Java的NIO提供了一种 <strong>直接缓冲区（direct buffers）</strong> 来解决这个问题。使用直接缓冲区，Java将从平台<br>能够直接进行I/O操作的存储空间中为缓冲区分配后援存储空间，从而省略了数据的复制过程。这种低层的、<br>本地的I/O通常在字节层进行操作，因此只能为 <strong>ByteBuffer进行直接缓冲区分配</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBufDirect =ByteBuffer.allocateDirect(BUFFERSIZE);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过调用isDirect()方法可以查看一个缓冲区是否是直接缓冲区。由于<br>直接缓冲区没有后援数组，在它上面调用array()或arrayOffset()方法都将抛出<br>UnsupportedOperationException异常。在考虑是否使用直接缓冲区时需要牢记几点。首先，要知道调用<br>allocateDirect()方法并不能保证能成功分配直接缓冲区–有的平台或JVM可能不支持这个操作，因此在<br>尝试分配直接缓冲区后必须调用isDirect()方法进行检查。其次，要知道 <strong>分配和销毁直接缓冲区通常比分配<br>和销毁非直接缓冲区要消耗更多的系统资源</strong>，因为直接缓冲区的后援存储空间通常存在与JVM之外，对它的管理<br>需要与操作系统进行交互。所以，只有当需要在很多I/O操作上长时间使用时，才分配直接缓冲区。实际上，<br>在相对于非直接缓冲区能明显提高系统性能时，使用直接缓冲区是个不错的主意。</p>
<h4 id="存储和接受数据"><a href="#存储和接受数据" class="headerlink" title="存储和接受数据"></a>存储和接受数据</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;只要有了缓冲区，就可以用它来存放数据了。作为数据的”容器”，缓冲区<br><strong>既可用来输入也可用来输出。这一点就与流不同，流只能向一个方向传递数据</strong>。使用put()方法可以将数据放入<br>缓冲区，使用get()方法则可以从缓冲区获取数据。信道的read()方法隐式调用了给定缓冲区的put()，而其<br>write()方法则隐式调用了缓冲区的get()方法。下面展示ByteBuffer的get()和put()方法，当然，其他<br>类型的缓冲区也有类似的方法。<br>ByteBuffer:获取和存放字节，有两种类型的get()和put()：基于相对位置和基于绝对位置。基于相对位置<br>的版本根据position的当前值，从”下一个”位置读取或存放数据，然后根据数据量给position增加适当的值<br>（即，单字节形式增加1数组形式增加array.length，     数组/偏移量/长度形式则增加length）。也就是<br>说，每次调用put()方法，都是在缓冲区中的已有元素后面追加数据，每次调用get()方法，都是读取缓冲区的<br>后续元素。不过，如果这些操作会导致position的值超出limit的限制，get()方法将抛出BufferUnderflowException异常，<br>put()方法将抛出BufferOverflowException异常。例如，如果传给get()方法的目标数组长度大于缓冲区<br>的剩余空间大小，get()方法将抛出BufferUnderflowException异常，部分数据的get/put是不允许的。<br>基于绝对位置的get()和put()以指定的索引位置为参数，从该位置读取数据或向该位置写入数据。绝对位置<br>形式的get和put不会改变position的值。如果给定的索引值超出了limit的限制，它们将抛出IndexOutOfBoundsException异常。<br>除了字节类型外，ByteBuffer类还提供了其他类型数据的相当位置和绝对位置的get/put方法。这样一来，就有点像DataOutputStream了。</p>
<ul>
<li>相对位置：<ul>
<li>byte get()</li>
<li>ByteBuffer get(byte[] dst)</li>
<li>ByteBuffer get(byte[] dst, int offset, int length)</li>
<li>ByteBuffer put(byte b)</li>
<li>ByteBuffer put(byte[] src)</li>
<li>ByteBuffer put(byte[] src, int offset, int length)</li>
<li>ByteBuffer put(ByteBuffer src)</li>
</ul>
</li>
<li><p>绝对位置：</p>
<ul>
<li>byte get(int index)</li>
<li>ByteBuffer put(int index, byte b)</li>
</ul>
</li>
<li><p>ByteBuffer:读取和存放Java多字节基本数据</p>
<ul>
<li><type> get<type>()</type></type></li>
<li><type> get<type>(int index)</type></type></li>
<li>ByteBuffer put<type>(<type> value)</type></type></li>
<li>ByteBuffer put<type>(int index,<type> value)</type></type></li>
</ul>
</li>
</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp;其中”<type>“代表Char，Double，Int，Long，Short之一，<br>而”<type>“代表char，double，int，long，short之一。<br>每次调用基于相对位置的put()或get()方法，都将根据特定参数类型的长度增加position的值：short加2，<br>int加4，等。不过，如果这样做会导致position的值超出limit的限制，get()和put()方法将分别抛出<br>BufferUnderflowException和BufferOverflowException异常：get和put不允许只对部分数据进行操作。<br>发生了下溢/上溢（under/overflow）时，position的值不变。可能你已经注意到，很多get/put方法都<br>返回一个ByteBuffer。实际上它们返回的就是调用它们的那个ByteBuffer。这样做可以实现 <strong>链式调用（call chaining）</strong>，<br>即第一次调用的结果可以直接用来进行后续的方法调用。例如，可以像下面那样将整数1和2存入ByteBuffer实例<br>myBuffer中：myBuffer.putInt(1).putInt(2);<br>&nbsp; &nbsp; &nbsp; &nbsp;<strong>多字节数据类型有一个字节顺序，称为big-endian或little-endian。<br>Java默认使用big-endian</strong>。通过使用内置的ByteOrder.BIG_ENDIAN和ByteOrder.LITTLE_ENDIAN实例，<br>可以获取和设定多字节数据类型写入字节缓冲区时的字节顺序。</type></type></p>
<ul>
<li>ByteBuffer:缓冲区中的字节顺序<ul>
<li>ByteOrder order()</li>
<li>ByteBuffer order(ByteOrder order)<br>第一个方法以ByteOrder常量的形式返回缓冲区的当前字节顺序。第二个方法用来设置写多字节数据时的字节顺序。</li>
</ul>
</li>
</ul>
<p>下面来看一个使用字节顺序的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(4);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">// Predict the byte values for buffer and test your prediction</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;看了这些有关字节顺序的讨论，你可能希望知道自己的处理器是什么字节<br>顺序，ByteOrder定义了一个方法来解答这个问题：<br>ByteOrder:查找字节顺序<br>static final ByteOrder BIG_ENDIAN<br>static final ByteOrder LITTLE_ENDIAN<br>static ByteOrder nativeOrder()<br>nativeOrder()方法返回常量BIG_ENDIAN或LITTLE_ENDIAN之一。</p>
<h4 id="Buffer准备：clear（）、flip（）和rewind（）"><a href="#Buffer准备：clear（）、flip（）和rewind（）" class="headerlink" title="Buffer准备：clear（）、flip（）和rewind（）"></a>Buffer准备：clear（）、flip（）和rewind（）</h4><p>在使用缓冲区进行输入输出数据之前，必须确定缓冲区的position，limit都已经设置了正确的值。首先<br>我们看看上面三个方法对position和limit的修改操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ByteBuffer方法</th>
<th style="text-align:left">准备Buffer以实现</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clear()</td>
<td style="text-align:left">将数据read()/put()进缓冲区</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">flip()</td>
<td style="text-align:left">从缓冲区write()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">position</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">rewind()</td>
<td style="text-align:left">从缓冲区rewrite()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>三种在Buffer类的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Clears this buffer.  The position is set to zero, the limit is set to</span><br><span class="line">    * the capacity, and the mark is discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span><br><span class="line">    * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.clear();     // Prepare buffer for reading</span><br><span class="line">    * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span><br><span class="line">    * is named as if it did because it will most often be used in situations</span><br><span class="line">    * in which that might as well be the case. &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer clear() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Flips this buffer.  The limit is set to the current position and then</span><br><span class="line">    * the position is set to zero.  If the mark is defined then it is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span><br><span class="line">    * this method to prepare for a sequence of channel-write or relative</span><br><span class="line">    * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.put(magic);    // Prepend header</span><br><span class="line">    * in.read(buf);      // Read data into rest of buffer</span><br><span class="line">    * buf.flip();        // Flip buffer</span><br><span class="line">    * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method is often used in conjunction with the &#123;@link</span><br><span class="line">    * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span><br><span class="line">    * one place to another.  &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer flip() &#123;</span><br><span class="line">       limit = position;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Rewinds this buffer.  The position is set to zero and the mark is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span><br><span class="line">    * operations, assuming that the limit has already been set</span><br><span class="line">    * appropriately.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * out.write(buf);    // Write remaining data</span><br><span class="line">    * buf.rewind();      // Rewind buffer</span><br><span class="line">    * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer rewind() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释：（参考：<a href="https://blog.csdn.net/FS1360472174/article/details/52141800）" target="_blank" rel="noopener">https://blog.csdn.net/FS1360472174/article/details/52141800）</a></p>
<ul>
<li>clear: clear 并没有真正的清除数据，将position设置为0，limit设置为capacity;</li>
<li><p>flip ：一般是切换到读操作。或者是为写操作准备一个新的序列<br>eg：重复向一个ByteBuffer写数据的时候，赋值完毕，必须要flip.开始一个新的新序列，否则position<br>会等于limit，返回空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       byte[] bytes1=new byte[]&#123;1, 6, 3&#125;;</span><br><span class="line">       ByteBuffer buffer =fromByteArray(bytes1);</span><br><span class="line">       System.out.println(buffer);</span><br><span class="line">       byte[] bytes2 =new byte[]&#123;1,2,3&#125;;</span><br><span class="line">       ByteBuffer buffer2=fromByteArray(bytes2);</span><br><span class="line">       System.out.println(buffer2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * If you are building up a ByteBuffer by repeatedly writing into it, and then want to give it away, you must remember to flip() it.</span><br><span class="line">    * If we did not flip() it, the returned ByteBuffer would be empty because the position would be equal to the limit.</span><br><span class="line">    * @param bytes</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static ByteBuffer fromByteArray(byte[] bytes) &#123;</span><br><span class="line">       final ByteBuffer ret = ByteBuffer.wrap(new byte[bytes.length]);</span><br><span class="line"></span><br><span class="line">       ret.put(bytes);</span><br><span class="line">       ret.flip();</span><br><span class="line"></span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rewind:倒回，将position 设置为0，重新读取;</p>
</li>
</ul>
<h4 id="压缩Buffer中数据"><a href="#压缩Buffer中数据" class="headerlink" title="压缩Buffer中数据"></a>压缩Buffer中数据</h4><p>compact()方法将position与limit之间的元素复制到缓冲区的开始位置，从而为后续的put()/read()调<br>用让出空间。position的值将设置为要复制的数据的长度，limit的值将设置为capacity，mark则变成未定义。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">      byte[] bytes = new byte[]&#123;1, 6, 3, 1, 1, 1, 1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">      ByteBuffer buffer = ByteBuffer.wrap(bytes);</span><br><span class="line">      byte b = buffer.get();</span><br><span class="line">      System.out.println(&quot;b:&quot; + b + &quot; position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.compact();</span><br><span class="line">      System.out.println(&quot;compact  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.flip();</span><br><span class="line">      System.out.println(&quot;flip  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>b:1 position:1 limit:11 capacity:11<br>compact  position:10 limit:11 capacity:11<br>flip  position:0 limit:10 capacity:11</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;为什么要使用这个操作呢？假设你有一个缓冲区要写数据。回顾前面的内容我们知道，对write()方法的非阻塞调用只会写出其能够发送的数据，而不会阻塞等待所有数据发送完。因此write()方法不一定会将缓冲区中的所有元素都发送出去。又假设现在要调用read()方法，在缓冲区中没有发送的数据后面读入新数据。处理方法之一就是简单地设置position = limit和limit = capacity。当然，在读入新数据后，再次调用write()方法前，还需要将这些值还原。这样做有个问题即缓冲区的空间最终将消耗殆尽，如上图中，只剩下一个元素位置可以再存入一个字节。此外，缓冲区前面的空间又被浪费掉了。这就是compact()方法要解决的问题。在调用write()方法后和添加新数据的read()方法前调用compact()方法，则将所有”剩余”的数据移动到缓冲区的开头，从而为释放最大的空间来存放新数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for reading</span><br><span class="line">while (channel.read(buffer) != -1) &#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">channel.write(buffer);</span><br><span class="line">buffer.compact();</span><br><span class="line">&#125;</span><br><span class="line">while (buffer.hasRemaining())</span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，如开始已经提到的，复制数据是一个非常耗费系统资源的操作，因此要保守地使用compact()方法。</p>
<h4 id="Buffer透视：duplicate-slice-等"><a href="#Buffer透视：duplicate-slice-等" class="headerlink" title="Buffer透视：duplicate(),slice()等"></a>Buffer透视：duplicate(),slice()等</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;NIO提供了多种方法来创建一个与给定缓冲区共享内容的新缓冲区，这些方法对元素的处理过程各有不同。基本上，这种新缓冲区有自己独立的状态变量（position，limit，capacity和mark），但与原始缓冲区共享了同一个后援存储空间。任何对新缓冲区 <strong>内容</strong> 的修改都将反映到 <strong>原始缓冲区上</strong> 。可以将新缓冲区看作是从另一个角度对同一数据的透视。</p>
<p>duplicate()方法用于创建一个与原始缓冲区共享内容的新缓冲区。新缓冲区的position，limit，mark和capacity都初始化为原始缓冲区的索引值，然而，它们的这些值是相互独立的。如下表格为在ByteBuffer上创建不同透视的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">duplicate()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">slice()</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asReadOnlyBuffer()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">asCharBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asDoubleBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asFloatBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asIntBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asLongBuffer()</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asShortBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由于共享了内容，对原始缓冲区或任何复本所做的改变在所有复本上都可见。<br>下面回到前面的例子，假设要将在网络上发送的所有数据都写进日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for writing</span><br><span class="line">ByteBuffer logBuffer = buffer.duplicate();</span><br><span class="line">while (buffer.hasRemaining()) // Write all data to network</span><br><span class="line">networkChannel.write(buffer);</span><br><span class="line">while (logBuffer.hasRemaining()) // Write all data to</span><br><span class="line">//logger</span><br><span class="line">loggerChannel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，使用了缓冲区复制操作，向网络写数据和写日志就可以在不同的线程中并行进行。slice()方法用于创建一个共享了原始缓冲区子序列的新缓冲区。新缓冲区的position值是0，而其limit和capacity的值都等于原始缓冲区的limit和position的差值。slice()方法将新缓冲区数组的offset值设置为原始缓冲区的position值，然而，在新缓冲区上调用array()方法还是会返回整个数组。<br>Channel在读写数据时只以ByteBuffer为参数，然而我们可能还对使用其他基本类型的数据进行通信感兴趣。ByteBuffer能够创建一种独立的”视图缓冲区（view buffer）”，用于将ByteBuffer的内容解释成其他基本类型（如CharBuffer）。这样就可以从该缓冲区中读取（写入数据是可选操作）新类型的数据。新缓冲区与原始缓冲区共享了同一个后援存储空间，因此，在 <strong>任一缓冲区上的修改在新缓冲区和原始缓冲区上都可以看到</strong>。新创建的视图缓冲区的position值为0，其内容从原始缓冲区的position所指位置开始。这与slice()操作非常相似。不过，由于视图缓冲区操作的是多字节元素，新缓冲区的capacity和limit的值等于剩余总字节数除以每个该类型元素对应的字节数（例如，创建DoubleBuffer时则除以8）。<br>下面来看一个例子。假设通过某个Channel接收到一条消息，该消息由一个单独字节，后跟大量big-endian顺序的双字节整数（如short型）组成。由于该消息是通过Channel送达的，它一定在一个ByteBuffer中，在此为buf。消息的第一个字节包含了消息中双字节整数的数量。你可能要调用第一个字节指定次数的buf.getShort()方法，或者你可以一次获取所有的整数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ...get message by calling channel.read(buf) ...</span><br><span class="line">int numShorts = (int)buf.get();</span><br><span class="line">if (numShorts &lt; 0) &#123;</span><br><span class="line">throw new SomeException()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">short[] shortArray = new short[numShorts];</span><br><span class="line">ShortBuffer sbuf = buf.asShortBuffer();</span><br><span class="line">sbuf.get(shortArray); // note: will throw if header was</span><br><span class="line">incorrect!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asReadOnlyBuffer()方法的功能与duplicate()方法相似，只是任何会修改新缓冲区内容的方法都将抛出ReadOnlyBufferException异常。包括各种型式的put()，compact()等，甚至连在缓冲区上调用无方向性的array()和arrayOffset()方法也会抛出这个异常。当然，对产生这个只读缓冲区的非只读缓冲区进行的任何修改，<br>仍然会与新的只读缓冲区共享。就像用duplicate()创建的缓冲区一样，只读缓冲区也有独立的缓冲区状态变量。可以使用isReadOnly()方法来检查一个缓冲区是否是只读的。如果原缓冲区已经是只读的，调用duplicate()或slice()方法也将创建新的只读缓冲区。</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;字符是由字节序列进行编码的，而且在字节序列与字符集合之间有各种映射（称为字符集）方式。NIO缓冲区的另一个用途是在各种字符集之间进行转换。要使用这个功能，还需要了解java.nio.charset包中另外两个类：CharsetEncoder和CharsetDecoder类。要进行编码，需要使用一个Charset实例来创建一个编码器并调用encode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Charset charSet = Charset.forName(&quot;US-ASCII&quot;);</span><br><span class="line">CharsetEncoder encoder = charSet.newEncoder();</span><br><span class="line">ByteBuffer buffer = encoder.encode(CharBuffer.wrap(&quot;Hi</span><br><span class="line">mom&quot;));</span><br></pre></td></tr></table></figure></p>
<p>要进行解码，需要使用Charset实例来创建一个解码器，并调用decode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = charSet.newDecoder();</span><br><span class="line">CharBuffer cBuf = decoder.decode(buffer);</span><br></pre></td></tr></table></figure></p>
<p>虽然这种方法能够正常工作，但当需要进行多次编码时，效率就会变得较低。例如，每次调用encode/decode<br>方法都会创建一个新Byte/CharBuffer实例。其他导致低效率的地方与编码器的创建和操作有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">encoder.reset();</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Hi &quot;),buffer,false)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... deal with lack of space in buffer ...</span><br><span class="line">&#125;</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Mom&quot;),buffer,true)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... ditto ...</span><br><span class="line">&#125;</span><br><span class="line">encoder.flush(buffer);</span><br></pre></td></tr></table></figure></p>
<p>encode()方法将给定CharBuffer转换为一个字节序列，并将其写入给定的缓冲区。如果缓冲区太小，encode()方法的返回值等于CoderResult.OVERFLOW。如果输入的数据完全被接收，并且编码器还准备对更多数据进行编码，encode()方法的返回值则等于CoderResult.UNDERFLOW。另外，如果输入的数据格式有错误，则将返回一个CoderResult对象，并指示了所存在的问题的位置和类型。只有到达了输入数据的结尾时，才将最后的boolean参数设为true。flush()方法将任何缓存的编码数据推送到缓冲区。注意，在新创建的编码器上调用reset()方法并不是必需的，该方法用来重新设置编码器的内部状态，以使其能够进行再次编码。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后通过一段简短代码展示allocate、flip、get、compact和clear方法对position、limit的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws IOException &#123;</span><br><span class="line"></span><br><span class="line"> ByteBuffer buffer1 = ByteBuffer.allocate(10);</span><br><span class="line"> RandomAccessFile fine = new RandomAccessFile(new File(&quot;b.txt&quot;), &quot;rw&quot;);</span><br><span class="line"> FileChannel fc = fine.getChannel();//分配空间后position为0，limit=capacity=10；</span><br><span class="line"> output(&quot;allocate&quot;, buffer1);</span><br><span class="line"> fc.read(buffer1);</span><br><span class="line"> output(&quot;read&quot;, buffer1);</span><br><span class="line"> buffer1.flip();                 //将limit设置为position，然后将position设置为0</span><br><span class="line"> output(&quot;flip&quot;, buffer1);</span><br><span class="line"> buffer1.get();                          //将position加一</span><br><span class="line"> output(&quot;get&quot;, buffer1);</span><br><span class="line"> buffer1.rewind();                       //重置position为0</span><br><span class="line"> output(&quot;rewind&quot;, buffer1);</span><br><span class="line"> buffer1.compact();                         //将position到limit的数据移到数组前端，并将position设置为（limit-position的距离），limit=capacity</span><br><span class="line"> output(&quot;compact&quot;, buffer1);</span><br><span class="line"> buffer1.clear();                    //重置position为0，limit=capacity</span><br><span class="line"> output(&quot;clear&quot;, buffer1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void output(String tag, ByteBuffer buffer) &#123;</span><br><span class="line">      System.out.println(tag + &quot; position:&quot; + buffer.position() + &quot; limit:&quot; + buffer.limit() + &quot; capacity:&quot; + buffer.capacity());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>allocate position:0 limit:10 capacity:10<br>read position:6 limit:10 capacity:10<br>flip position:0 limit:6 capacity:10<br>get position:1 limit:6 capacity:10<br>rewind position:0 limit:6 capacity:10<br>compact position:6 limit:10 capacity:10<br>clear position:0 limit:10 capacity:10<br>get position:2 limit:10 capacity:10</p>
<p>参考：<br>[1] （译文）java中的ShortBuffer <a href="https://blog.csdn.net/u010142437/article/details/42082735" target="_blank" rel="noopener">https://blog.csdn.net/u010142437/article/details/42082735</a><br>[2] Buffer详解 <a href="https://blog.csdn.net/guofengpu/article/details/51995730" target="_blank" rel="noopener">https://blog.csdn.net/guofengpu/article/details/51995730</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/16/根据Uri获取文档的路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/根据Uri获取文档的路径/" itemprop="url">根据Uri获取文档的路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T14:11:33+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据Url获取文档的绝对路径，解决Android4.4以上版本Uri转换。<br>Android在4.4之后的版本(包括4.4)中，从相册中选取图片返回Uri进行了改动。所以无法通过该Uri来取得文件路径从而解码图片将其显示出来。<br><code>在4.3或以下可以直接用Intent.ACTION_GET_CONTENT打开相册;在4.4或以上,官方建议用ACTION_OPEN_DOCUMENT打开相册</code><br>在Android4.4之前得到的Uri为：</p>
<ul>
<li>content://media/external/images/media/8302  </li>
<li>content://media/external/video/media  </li>
<li>content://media/external/images/media  </li>
</ul>
<p>而在Android4.4后得到的可能是以下：</p>
<ul>
<li>content://com.android.providers.media.documents/document/image:8302</li>
<li>content://com.android.providers.downloads.documents/document/5</li>
</ul>
<p>以下为Android4.4之后的适配：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *</span><br><span class="line"> * 专为Android4.4设计的从Uri获取文件绝对路径</span><br><span class="line"> */</span><br><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public static String getPath(final Context context, final Uri uri) &#123;</span><br><span class="line">    final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line">    LogUtil.d(&quot;uri:&quot; + uri);</span><br><span class="line">    // DocumentProvider</span><br><span class="line">    if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">        // ExternalStorageProvider</span><br><span class="line">        if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1];</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO handle non-primary volumes</span><br><span class="line">        &#125;</span><br><span class="line">        // DownloadsProvider</span><br><span class="line">        else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">            final String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">            return getDataColumn(context, contentUri, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // MediaProvider</span><br><span class="line">        else if (isMediaDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            Uri contentUri = null;</span><br><span class="line">            if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String selection = &quot;_id=?&quot;;</span><br><span class="line">            final String[] selectionArgs = new String[]&#123;split[1]&#125;;</span><br><span class="line">            LogUtil.d(&quot;format uri:&quot; + contentUri);</span><br><span class="line">            return getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // MediaStore (and general)</span><br><span class="line">    else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return getDataColumn(context, uri, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // File</span><br><span class="line">    else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return uri.getPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the value of the data column for this Uri. This is useful for</span><br><span class="line"> * MediaStore Uris, and other file-based ContentProviders.</span><br><span class="line"> *</span><br><span class="line"> * @param context       The context.</span><br><span class="line"> * @param uri           The Uri to query.</span><br><span class="line"> * @param selection     (Optional) Filter used in the query.</span><br><span class="line"> * @param selectionArgs (Optional) Selection arguments used in the query.</span><br><span class="line"> * @return The value of the _data column, which is typically a file path.</span><br><span class="line"> */</span><br><span class="line">public static String getDataColumn(Context context, Uri uri, String selection,</span><br><span class="line">                                   String[] selectionArgs) &#123;</span><br><span class="line"></span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    final String column = &quot;_data&quot;;</span><br><span class="line">    final String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                null);</span><br><span class="line">        if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">            final int column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor != null)</span><br><span class="line">            cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is ExternalStorageProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is DownloadsProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is MediaProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看一个获取Mp3文档的Uri，其格式类似：content://com.android.providers.media.documents/document/audio%3A39，<br>然后我根据代码进一步分析，首先看判断条件：isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)，<br>这里判断了版本号和该Uri是否是文档类Uri，之所以要判断版本号是Uri的生成在Api19以后发送变化，通过官方文档DocumentsContract，我们也可以验证这点，DocumentsContract是在Api19加入的，其定义就是定义文档提供者与平台之间的协议，其主要作用就是关于文档Uri的一系列操作。<br>下面是其内部实现代码（代码都是在DocumentsContract类中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT = &quot;document&quot;;</span><br><span class="line">private static final String PATH_TREE = &quot;tree&quot;;</span><br><span class="line">public static final String PROVIDER_INTERFACE = &quot;android.content.action.DOCUMENTS_PROVIDER&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Test if the given URI represents a &#123;@link Document&#125; backed by a</span><br><span class="line">   * &#123;@link DocumentsProvider&#125;.</span><br><span class="line">   *</span><br><span class="line">   * @see #buildDocumentUri(String, String)</span><br><span class="line">   * @see #buildDocumentUriUsingTree(Uri, String)</span><br><span class="line">   */</span><br><span class="line">  public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">      if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">          final List&lt;String&gt; paths = uri.getPathSegments();</span><br><span class="line">          if (paths.size() == 2) &#123;</span><br><span class="line">              return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">          &#125; else if (paths.size() == 4) &#123;</span><br><span class="line">              return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  /** &#123;@hide&#125; */</span><br><span class="line">   public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">      // public static final String SCHEME_CONTENT = &quot;content&quot;;     !!add by custom</span><br><span class="line">       return uri != null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent = new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos = context.getPackageManager()</span><br><span class="line">            .queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看出，前提条件是判断是否是contentUri&amp;&amp;documentProvider，然后在进一步判断其pathSegments<br>是否是document/或者tree/document/开头。其中isDocumentsProvider方法不是特别理解，希望大神指点下。</p>
<p>参考地址：<br>[1] 解决Android4.4以上版本Uri转换  <a href="https://blog.csdn.net/q445697127/article/details/40537945" target="_blank" rel="noopener">https://blog.csdn.net/q445697127/article/details/40537945</a><br>[2] <a href="https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework" target="_blank" rel="noopener">https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">The blog from a Android coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
