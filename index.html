<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="the blog from a anroid coder">
<meta property="og:type" content="website">
<meta property="og:title" content="CallteFoot&#39;s blog">
<meta property="og:url" content="https://cattlefoot.github.io/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="the blog from a anroid coder">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CallteFoot&#39;s blog">
<meta name="twitter:description" content="the blog from a anroid coder">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/"/>





  <title>CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/12/24/SpringBoot-Database-H2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/SpringBoot-Database-H2/" itemprop="url">SpringBoot Database H2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-24T15:03:13+08:00">
                2018-12-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  内存数据库（Embedded database或in-momery database）具有配置简单、启动速度快、尤其是其可测试性等优点，使其成为开发过程中非常有用的轻量级数据库。在spring中支持HSQL、H2和Derby三种数据库。H2是Thomas Mueller提供的一个开源的、纯java实现的关系数据库。</p>
<p>各数据库特性对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>H2</th>
<th>Derby</th>
<th>HSQLDB</th>
<th>MySQL</th>
<th style="text-align:left">PostgreSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure Java</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>Memory Mode</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>Encrypted Database</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td>ODBC Driver</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Fulltext Search</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Multi Version Concurrency</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td>Footprint (jar/dll size)</td>
<td>~1 MB</td>
<td>~2 MB</td>
<td>~1 MB</td>
<td>~4 MB</td>
<td style="text-align:left">~6 MB</td>
</tr>
</tbody>
</table>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>JDK 1.8或更高版本</li>
<li>Maven 3.5或更高版本</li>
</ul>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Spring Data JPA</li>
<li>Spring Boot</li>
</ul>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="./images/project_package.png" alt="项目目录结构"></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mugwort<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring web开发依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库依赖 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- h2 嵌入式数据库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jpa 依赖，持久化操作依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String lastaudit;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastaudit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastaudit</span><span class="params">(String lastaudit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastaudit = lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">" | "</span> + name + <span class="string">" | "</span> + lastaudit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Id  声明此属性为主键。该属性值可以通过应该自身创建，但是Hibernate推荐通过Hibernate生成；</li>
<li>@GeneratedValue<br>指定主键的生成策略。<ul>
<li>TABLE：使用表保存id值；</li>
<li>IDENTITY：identitycolumn；</li>
<li>SEQUENCR ：sequence；</li>
<li>AUTO：根据数据库的不同使用上面三个，默认值；</li>
</ul>
</li>
<li>@Column 声明该属性与数据库字段的映射关系。</li>
</ul>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SystemRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">SystemBean</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA包含了一些内置的Repository，实现了一些常用的方法：findone，findall，save等。</p>
<h3 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="string">spring.application.name=Bootstrap</span> <span class="string">Spring</span> <span class="string">boot</span> <span class="string">web</span> <span class="string">with</span> <span class="string">H2</span></span><br><span class="line"><span class="comment">### jpa 只进行更新,默认是启动的时候不管三七二十一就删除原来的表结构重新生成</span></span><br><span class="line"><span class="string">spring.jpa.hibernate.ddl-auto=update</span></span><br><span class="line"><span class="string">spring.jpa.database-platform=org.hibernate.dialect.H2Dialect</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#显示SQL语句</span></span><br><span class="line"><span class="string">spring.jpa.show-sql=true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 每次启动程序，程序都会运行resources/db/schema.sql文件，对数据库的结构进行操作。</span></span><br><span class="line"><span class="string">spring.datasource.schema=classpath:schema.sql</span></span><br><span class="line"><span class="comment"># 每次启动程序，程序都会运行resources/db/data.sql文件，对数据库的数据操作。</span></span><br><span class="line"><span class="string">spring.datasource.data=classpath:data.sql</span></span><br><span class="line"><span class="comment">#### 驱动类</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#When using database URLs like jdbc:h2:~/test, the database is stored in the user directory. For Windows, this is usually C:\Documents and #Settings\&lt;userName&gt; or C:\Users\&lt;userName&gt;. If the base directory is not set (as in jdbc:h2:./test), the database files are stored in the directory where #the application is started (the current working directory). When using the H2 Console application from the start menu, this is &lt;Installation Directory&gt;/#bin. The base directory can be set in the database URL. A fixed or relative path can be used. When using the URL jdbc:h2:file:./data/sample, the database #is stored in the directory data (relative to the current working directory). The directory is created automatically if it does not yet exist. It is also #possible to use the fully qualified directory name (and for Windows, drive name). Example: jdbc:h2:file:C:/data/test</span></span><br><span class="line"><span class="comment">####===== connect to  ======</span></span><br><span class="line"><span class="comment">##这里设置的是数据存储在内存中，也可以存储在磁盘</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:h2:mem:h2test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=org.h2.Driver</span></span><br><span class="line"><span class="string">spring.datasource.name=sa</span></span><br><span class="line"><span class="string">spring.datasource.password=</span></span><br><span class="line"><span class="string">spring.datasource.platform=h2</span></span><br><span class="line"><span class="comment">### h2 properties</span></span><br><span class="line"><span class="string">spring.h2.console.path=/console</span></span><br><span class="line"><span class="string">spring.h2.console.enabled=true</span></span><br><span class="line"><span class="comment">###### web 访问接口</span></span><br><span class="line"><span class="string">server.port=8081</span></span><br><span class="line"><span class="comment">### 日志</span></span><br><span class="line"><span class="string">logging.level.root=info</span></span><br></pre></td></tr></table></figure>
<p>在application.properties文件中对数据库进行连接配置</p>
<p>spring.datasource.url=jdbc:h2:mem:h2test，配置h2数据库的连接地址<br>spring.datasource.driver-class-name=org.h2.Driver，配置JDBC Driver<br>spring.datasource.username=sa，配置数据库用户名<br>spring.datasource.password=，配置数据库密码</p>
<p>当你完成依赖和连接配置这两步之后，你就可以在程序种使用h2了。spring会自动帮你完成DataSource的注入。</p>
<h4 id="数据初始化配置"><a href="#数据初始化配置" class="headerlink" title="数据初始化配置"></a>数据初始化配置</h4><p>如果你需要在程序启动时对数据库进行初始化操作，则在application.properties文件中对数据库进接配置</p>
<p>spring.datasource.schema=classpath:schema.sql，进行该配置后，每次启动程序，程序都会运行resources/schema.sql文件，对数据库的结构进行操作。<br>spring.datasource.data=classpath:data.sql,进行该配置后，每次启动程序，程序都会运行resources/data.sql文件，对数据库的数据操作。</p>
<p>该配置非常适合开发环境，我会把数据库的结构构建sql放在resources/schema.sql，数据sql放在resources/data.sql中。这样每次运行程序我都可以得到一个新的数据库。这样就不需要我每次为了测试而修改数据中的内容了。<br>schema.sql代码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span>  system_bean;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> system_bean(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">lastaudit <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>  (<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>data.sql代码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'Windows Server 2012 R2 '</span>,<span class="string">'2017-08-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'RHEL 7'</span>,<span class="string">'2017-07-21'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> system_bean(<span class="keyword">name</span>,lastaudit)<span class="keyword">VALUES</span>(<span class="string">'Solaris 11'</span>,<span class="string">'2017-08-13'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="h2-web-consloe配置"><a href="#h2-web-consloe配置" class="headerlink" title="h2 web consloe配置"></a>h2 web consloe配置</h4><p>h2 web consloe是一个数据库GUI管理应用，就和phpMyAdmin类似。程序运行时，会自动启动h2 web consloe。当然你也可以进行如下的配置。</p>
<p>spring.h2.console.settings.web-allow-others=true，进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。<br>spring.h2.console.path=/h2-console，进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。<br>spring.h2.console.enabled=true，进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。</p>
<p>参考：<br>[1]. <a href="https://juejin.im/post/5ab4b339f265da238c3a9d0a" target="_blank" rel="noopener">https://juejin.im/post/5ab4b339f265da238c3a9d0a</a><br>[2]. <a href="https://412887952-qq-com.iteye.com/blog/2322756" target="_blank" rel="noopener">https://412887952-qq-com.iteye.com/blog/2322756</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/10/12/Android-pie-slice开发小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/Android-pie-slice开发小记/" itemprop="url">Android pie slice开发小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T12:51:02+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android-pie-slice开发小记"><a href="#Android-pie-slice开发小记" class="headerlink" title="Android pie slice开发小记"></a>Android pie slice开发小记</h2><h3 id="slice创建和运行"><a href="#slice创建和运行" class="headerlink" title="slice创建和运行"></a>slice创建和运行</h3><ol>
<li>首先新建一个项目并选择使用的api为API 28:Android 9（pie）或者在已有的项目调整其编译、最低和目标版本为28（最低）。</li>
<li>创建 slice provider：<br><img src="./images/new-slice.png" alt="new slice step"><br>当生成slice provider后，编译器会报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest merger failed : Attribute application@appComponentFactory value=(androidx.core.app.CoreComponentFactory) from [androidx.core:core:1.0.0] AndroidManifest.xml:22:18-86</span><br><span class="line">	is also present at [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91 value=(android.support.v4.app.CoreComponentFactory).</span><br><span class="line">	Suggestion: add &apos;tools:replace=&quot;android:appComponentFactory&quot;&apos; to &lt;application&gt; element at AndroidManifest.xml:5:5-35:19 to override.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上错误主要是android在api 28版本后，appconmpat、cardview和constraintlayout等都移到Androidx包名下，所以修正方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">//    implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">//    implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos;</span><br><span class="line">  implementation &apos;androidx.appcompat:appcompat:1.0.0&apos;</span><br><span class="line">  implementation &apos;androidx.constraintlayout:constraintlayout:1.1.3&apos;</span><br><span class="line"></span><br><span class="line">  implementation &apos;androidx.annotation:annotation:1.0.0&apos;</span><br><span class="line">  implementation &apos;androidx.slice:slice-builders:1.0.0&apos;</span><br><span class="line"></span><br><span class="line">  testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">  androidTestImplementation &apos;androidx.test:runner:1.1.0-alpha3&apos;</span><br><span class="line">  androidTestImplementation &apos;androidx.test.espresso:espresso-core:3.1.0-alpha3&apos;</span><br></pre></td></tr></table></figure></p>
<p>参考地址：<a href="https://stackoverflow.com/questions/50782435/android-design-support-library-for-api-28-p-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/50782435/android-design-support-library-for-api-28-p-not-working</a></p>
<ol>
<li>sliceProvider编码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieSliceProvider</span> <span class="keyword">extends</span> <span class="title">SliceProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instantiate any required objects. Return true if the provider was successfully created,</span></span><br><span class="line"><span class="comment">     * false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateSliceProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Converts URL to content URI (i.e. content://com.mugwort.demo...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">onMapIntentToUri</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: implementing this is only required if you plan on catching URL requests.</span></span><br><span class="line">        <span class="comment">// This is an example solution.</span></span><br><span class="line">        Uri.Builder uriBuilder = <span class="keyword">new</span> Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT);</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) <span class="keyword">return</span> uriBuilder.build();</span><br><span class="line">        Uri data = intent.getData();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.getPath() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String path = data.getPath().replace(<span class="string">"/"</span>, <span class="string">""</span>);</span><br><span class="line">            uriBuilder = uriBuilder.path(path);</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uriBuilder = uriBuilder.authority(context.getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct the Slice and bind data if available.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Slice <span class="title">onBindSlice</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        SliceAction activityAction = createActivityAction();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span> || activityAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(sliceUri.getPath())) &#123;</span><br><span class="line">            <span class="comment">// Path recognized. Customize the Slice using the androidx.slice.builders API.</span></span><br><span class="line">            <span class="comment">// Note: ANRs and strict mode is enforced here so don't do any heavy operations.</span></span><br><span class="line">            <span class="comment">// Only bind data that is currently available in memory.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                    .addRow(</span><br><span class="line">                            <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                    .setTitle(<span class="string">"URI found.hello i'am here"</span>)</span><br><span class="line">                                    .setPrimaryAction(activityAction)</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error: Path not found.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                    .addRow(</span><br><span class="line">                            <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                    .setTitle(<span class="string">"URI not found."</span>)</span><br><span class="line">                                    .setPrimaryAction(activityAction)</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SliceAction <span class="title">createActivityAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return null;</span></span><br><span class="line">        <span class="comment">//Instead of returning null, you should create a SliceAction. Here is an example:</span></span><br><span class="line">        <span class="keyword">return</span> SliceAction.create(</span><br><span class="line">            PendingIntent.getActivity(</span><br><span class="line">                getContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(getContext(), MainActivity.class), <span class="number">0</span></span><br><span class="line">            ),</span><br><span class="line">            IconCompat.createWithResource(getContext(), R.drawable.ic_launcher_foreground),</span><br><span class="line">            ListBuilder.ICON_IMAGE,</span><br><span class="line">            <span class="string">"Open App"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slice has been pinned to external process. Subscribe to data source if necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSlicePinned</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// When data is received, call context.contentResolver.notifyChange(sliceUri, null) to</span></span><br><span class="line">        <span class="comment">// trigger PieSliceProvider#onBindSlice(Uri) again.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unsubscribe from data source if necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSliceUnpinned</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove any observers if necessary to avoid memory leaks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分析：</p>
<ul>
<li>通过类我们发现SliceProvider继承于ContentProvider，其APP间数据的传递通过<br>ContentProvider的方式，应用APP向搜索APP对外提供其对应Slice的Uri，封装成Slice对象通过Parcelable序列化的方式实现APP之间的数据传递。</li>
<li>slice的绑定和展示：onBindSlice，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Slice <span class="title">onBindSlice</span><span class="params">(Uri sliceUri)</span> </span>&#123;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    SliceAction activityAction = createActivityAction();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || activityAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//“/”是在manifest中定义的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(sliceUri.getPath())) &#123;</span><br><span class="line">        <span class="comment">// Path recognized. Customize the Slice using the androidx.slice.builders API.</span></span><br><span class="line">        <span class="comment">// Note: ANRs and strict mode is enforced here so don't do any heavy operations.</span></span><br><span class="line">        <span class="comment">// Only bind data that is currently available in memory.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                .addRow(</span><br><span class="line">                        <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                .setTitle(<span class="string">"URI found.hello i'am here"</span>)</span><br><span class="line">                                .setPrimaryAction(activityAction)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Error: Path not found.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListBuilder(getContext(), sliceUri, ListBuilder.INFINITY)</span><br><span class="line">                .addRow(</span><br><span class="line">                        <span class="keyword">new</span> RowBuilder()</span><br><span class="line">                                .setTitle(<span class="string">"URI not found."</span>)</span><br><span class="line">                                .setPrimaryAction(activityAction)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Uri的scheme统一为content,如上述例子的Uri为:<br>content://x.x.x/</p>
<ul>
<li><p>SliceAction,这个类似notifications，可以使用PendingIntents 来处理用户的点击事件，比如点击Slice模块打开宿主APP：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SliceAction <span class="title">createActivityAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return null;</span></span><br><span class="line">    <span class="comment">//Instead of returning null, you should create a SliceAction. Here is an example:</span></span><br><span class="line">    <span class="keyword">return</span> SliceAction.create(</span><br><span class="line">        PendingIntent.getActivity(</span><br><span class="line">            getContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(getContext(), MainActivity.class), <span class="number">0</span></span><br><span class="line">        ),</span><br><span class="line">        IconCompat.createWithResource(getContext(), R.drawable.ic_launcher_foreground),</span><br><span class="line">        ListBuilder.ICON_IMAGE,</span><br><span class="line">        <span class="string">"Open App"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过安装<br><a href="https://github.com/googlesamples/android-SliceViewer/releases" target="_blank" rel="noopener"> SliceViewer</a>，在搜索框输入uri即可添加slice并跳转:<br><img src="./images/slice-view.png" alt="SliceViewer"></p>
</li>
</ul>
<h3 id="Slice模板"><a href="#Slice模板" class="headerlink" title="Slice模板"></a>Slice模板</h3><ul>
<li>ListBuilder:Slices通过ListBuilder类来创建。在ListBuilder中，你可以添加不同类型的行模块在你的Slice中进行展示。</li>
</ul>
<ul>
<li>SliceAction:对于每一个Slice来说，最基础的构造实现类是SliceAction，在SliceAction你可以添加PendingIntent来实现用户操作，比如Toggle选择操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SliceAction toggleAction =SliceAction.createToggle(createToggleIntent(),<span class="string">"Toggle adaptive brightness"</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>SliceAction可以配置在搜索APP中显示的模块三种不同的显示方式：</p>
<p>  ICON_IMAGE:tiny size and tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-745370335b55ea66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/406/format/webp" alt="shortcut"></p>
<p> SMALL_IMAGE:small size and non-tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-c4bdc8a2370df185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="small">  </p>
<p>  LARGE_IMAGE: largest size and non-tintable:<br><img src="https://upload-images.jianshu.io/upload_images/6572543-2fa70505db53e281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420/format/webp" alt="large"></p>
<h3 id="模块构造Builder"><a href="#模块构造Builder" class="headerlink" title="模块构造Builder"></a>模块构造Builder</h3><p>  对于每个Slice模块的创建构造，谷歌官方提供了HeaderBuilder、RowBuilder、GridBuilder、RangeBuilder模块四种构造器。其中，HeaderBuilder只支持一行头部的展示view；RowBuilder可以添加一行view进行展示，如此前没有添加header，则首行row默认为header；GridBuilder支持上述所说的三种模块展示方式；而RangeBuilder则支持进度条相关的view展示。</p>
<h3 id="延时加载"><a href="#延时加载" class="headerlink" title="延时加载"></a>延时加载</h3><p>  对于一些需要耗时加载数据的操作，比如网络请求图片等，可以采取与ListView加载图片类似的方法，先本地加载一个默认的占位数据，等耗时操作完成回调回来真实数据的时候调用getContentResolver().notifyChange(sliceUri) 方法，通知搜索APP调用Slice Uri，完成真实数据的显示。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>  Slice的功能模板非常的强大，通过不同的builder组合可以在搜索模块中搭配出丰富多彩的Slice，快速直达用户想要的功能。但是Slice只提供了三种模板，自带模板中对安卓原生控件的支持有所欠缺，比如ScollView等，可能需要用户自定义自己的模板才能实现更强大的功能。</p>
<p>参考：<br>[0].<a href="https://www.androidauthority.com/android-slices-872250/" target="_blank" rel="noopener">https://www.androidauthority.com/android-slices-872250/</a><br>[1].<a href="https://www.jianshu.com/p/a90563606e1f" target="_blank" rel="noopener">https://www.jianshu.com/p/a90563606e1f</a><br>[2].<a href="http://digi.aili.com/1642/2811309.html" target="_blank" rel="noopener">http://digi.aili.com/1642/2811309.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/27/基础数据与byte间的转化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/基础数据与byte间的转化/" itemprop="url">基础数据与byte间的转化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T16:42:52+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>   <strong>计算机中存储是用补码！！，同时注意一下计算省略了高位不变部分和 字节大小端问题</strong>  </p>
<h4 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h4><ul>
<li>byte：有符号，在网络传输中都是会用到byte的，它占1个字节，共8位，比如说11111111就可以用1个<br>byte表示，转化为10进制：- （2的6次+2的5次+2的4次+2的3次+2的2次+2的1次+2的0次） = -127。<br>其中前7位表示数字，最高位表示符号，0为正，1为负。范围是 （-2的7次 ~ 2的7次 - 1），那为什么前<br>面最小是-127，范围最小又是-128呢？因为规定-0（10000000）为-128。</li>
<li>short：有符号，占2个字节，共16位。同byte一样，它的取值范围就是 （-2的15次 ~ 2的15次 - 1）。</li>
<li>int：有符号，占4个字节，共32位。它的取值范围就是（-2的31次 ~ 2的31次）。</li>
<li>long：有符号，占8个字节，共64位，它的取值范围就是（-2的63次 ~ 2的63次）。</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ul>
<li>^：表示异或位运算，两者相同则为0，两者不同则为1。比如说15^2，15用二进制表示就是1111，2用2<br>进制表示就是0010，两者进行异或运算，结果就是1101，转换为十进制就是13。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A^B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>|：表示或运算，两者只有有一个为1就为1， 比如说13|2，13用二进制表示就是1101，2用二进制表示<br>就是0010，两者进行或运算，那么结果就是1111，转换为十进制就是15。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A &#124; B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>&amp;：表示与运算，两者都为1就为1，其余都为0，比如说15&amp;2， 13用二进制表示就是1111，2用二进制<br>表示就是0010， 两者进行与运算，那么结果就是0010，转换为十进制就是2。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">A&amp;B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<ul>
<li>~：取反，就是本来是0变成1，本来是1变成0。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">～A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<ul>
<li><p>&lt;&lt;:左移运算符，不需要考虑符号位，因为在后面补0，把二进制的数字向左移动，低位补0。比如说 3&lt;&lt;2。<br>3的二进制码为11，向左移动2位就是1100，那么结果就是12。</p>
</li>
<li><p>>&gt;：右移运算符，带符号位。根据这个要移动的数字决定正负，如果是正数，那么就在前面补0，如果是<br>负数就在前面补1。比如说 3&gt;&gt;2，3的二进制码为00000011，向右移动2位，就变成00000000，转化为十<br>进制就是0了（3是正数所以在高位补0）。再比如说-3&gt;&gt;2，-3的二进制码为10000011，转化为补码<br>（只要涉及到负数，就需要转换到补码计算，正数之所以不用转化，是因为他们的补码和原码是一致的）<br>11111101，进行位移运算，就是11111111，这个是补码，需要再转回原码。那么就是取反+1，结果就是<br>10000001，转化为十进制就是-1。</p>
</li>
<li><p>>&gt;&gt;：右移运算符，与上面的区别就是这个运算符是 <strong>无符号的</strong>。不论正负，高位都补0。如果要用<br>-3&gt;&gt;2来验证，因为高位补0，就需要把所有的位数都写全了。如果是int，那就要写成32位来运算。切记切记。<br>上面很多因为高位的变化“取反再取反”会导致前面所有的位都没变所以我就简化了，但是这个&gt;&gt;&gt;运算符不行哦，<br>它会把负数变为正数。</p>
</li>
</ul>
<p>栗子（eg）：<br>比如说-15|3等于多少呢？有些人会觉得-15转化为二进制就是10001111，而3转化为二进制就是00000011，<br>那么结果应该是10001111呀，转换为十进制就是-15呀？大家可以自己写个demo就会发现是不对的。要注意<br>在计算机中所有的都是用补码的形式存储的，之所以上面介绍两个正数是对的，因为 <strong>正数的反码和补码都是一样的。而负数求补码应该是除去符号位取反+1</strong>，我们再来看看这个题-15|3，其中-15的原码为10001111，反码为11110000，那么补码就是11110001，然后3的补码为00000011，两者进行或操作就是11110011，你以为结束了么？还没有，再又要求它的原码了，<strong>原码就是补码再求补码再+1</strong>（是不是已经晕掉了？），也就是<br>10001101，结果就是-13。为了大家都好理解，我这里用算式整理一下：</p>
<p>求 -15|3</p>
<p>[-15]原码 = 10001111<br>[-15]反码 = 11110000 //原码求反码符号位不变<br>[-15]补码 = 11110001 //反码+1等于补码</p>
<p>[3]原码 = 00000011<br>[3]反码 = 00000011 //正数都一致<br>[3]补码 = 00000011 //正数都一致</p>
<p>-15|3 = 11110011 //两个补码进行或操作</p>
<p>[结果]补码 = 11110011 //上面求得的值<br>[结果]反码 = 10001100 //符号位不变<br>[结果]原码 = 10001101 //反码+1</p>
<p>100001101 转化为十进制就是-13。<br>不知道我这么解释会不会更加清楚一些呢？同理的，上面那些（尤其是求反‘~’我故意没写例子，大家自己去试试吧）。</p>
<p>在说一次，正数的原码，补码，反码都一样，如果一定要说为什么一样，我就举个例子。有这么一个等式7+（-7）=0。<br>我们知道<br>[-7]原 = 10000111<br>[-7]反 = 11111000<br>[-7]补 = 11111001</p>
<p>那么如果要存在一个值和[-7]补码相加等于0，是不是就是00000111！！所以正数的补码和原码是一致的。<br>这样解释虽然怪怪的，但是可以知道的确是这样的。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>基本步骤：<br>① 分析转化和代转化之间位数的关系<br>② 计算偏移量。每次都取最后8位<br>③ 把最后8位和0xff进行&amp;操作<br>④ 得出结果。  </p>
<p>有人会问，为什么要和0xff进行&amp;操作？这里解释下，因为再分割的时候，我们要保证最后8位是一致的，更高位都要置0，这样才能保证数据的一致性。比如说由byte转化成short。位数从8位变成了16位，那么在计算机自己看来，它会把前面多出来的8位置1。而&amp;0xff就可以把前面所有的位数都置0。</p>
<ol>
<li>short与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前提：在计算机中所有的都是用补码的形式存储的。</span></span><br><span class="line"><span class="comment">    * 将short转换为字节</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 例如 8的补码为0000 0000 0000 1000，所以要将转换为两个字节，第一个字节是将8右移8位然后和0x00ff求与，</span></span><br><span class="line"><span class="comment">    * 而第二个字节则是右移0位，然后求与</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] short2byte(<span class="keyword">short</span> s)&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">16</span> - (i+<span class="number">1</span>)*<span class="number">8</span>;          <span class="comment">//因为byte占1个字节，所以要计算偏移量</span></span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)((s &gt;&gt; offset)&amp;<span class="number">0xff</span>); <span class="comment">//把16位分为2个8位进行分别存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">byte2short</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">short</span> l = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">           l&lt;&lt;=<span class="number">8</span>;               <span class="comment">//&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span></span><br><span class="line">           l |= (b[i] &amp; <span class="number">0xff</span>); <span class="comment">//和上面也是一样的  l = l | (b[i]&amp;0xff)</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>int与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2byte(<span class="keyword">int</span> s)&#123;</span><br><span class="line">         <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> offset = <span class="number">16</span> - (i+<span class="number">1</span>)*<span class="number">8</span>;         <span class="comment">//因为byte占1个字节，所以要计算偏移量</span></span><br><span class="line">             b[i] = (<span class="keyword">byte</span>)((s &gt;&gt; offset)&amp;<span class="number">0xff</span>); <span class="comment">//把32位分为4个8位进行分别存储</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byte2int</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            l&lt;&lt;=<span class="number">8</span>;              <span class="comment">//&lt;&lt;=和 +=是一样的，意思就是 l = l &lt;&lt; 8</span></span><br><span class="line">            l |= (b[i] &amp; <span class="number">0xff</span>); <span class="comment">//和上面也是一样的  l = l | (b[i]&amp;0xff)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>long与byte的相互转化   </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @方法功能 字节数组和长整型的转换</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 长整型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] longToByte(<span class="keyword">long</span> number) &#123;</span><br><span class="line">		<span class="keyword">long</span> temp = number;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = <span class="keyword">new</span> Long(temp &amp; <span class="number">0xff</span>).byteValue();</span><br><span class="line">			<span class="comment">// 将最低位保存在最低位</span></span><br><span class="line">			temp = temp &gt;&gt; <span class="number">8</span>;</span><br><span class="line">			<span class="comment">// 向右移8位</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @方法功能 字节数组和长整型的转换</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 长整型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteToLong</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> s0 = b[<span class="number">0</span>] &amp; <span class="number">0xff</span>;<span class="comment">// 最低位</span></span><br><span class="line">		<span class="keyword">long</span> s1 = b[<span class="number">1</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s2 = b[<span class="number">2</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s3 = b[<span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s4 = b[<span class="number">4</span>] &amp; <span class="number">0xff</span>;<span class="comment">// 最低位</span></span><br><span class="line">		<span class="keyword">long</span> s5 = b[<span class="number">5</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s6 = b[<span class="number">6</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="keyword">long</span> s7 = b[<span class="number">7</span>] &amp; <span class="number">0xff</span>; <span class="comment">// s0不变</span></span><br><span class="line">		s1 &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">		s2 &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">		s3 &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">		s4 &lt;&lt;= <span class="number">8</span> * <span class="number">4</span>;</span><br><span class="line">		s5 &lt;&lt;= <span class="number">8</span> * <span class="number">5</span>;</span><br><span class="line">		s6 &lt;&lt;= <span class="number">8</span> * <span class="number">6</span>;</span><br><span class="line">		s7 &lt;&lt;= <span class="number">8</span> * <span class="number">7</span>;</span><br><span class="line">		s = s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>char与byte的转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 字符到字节转换</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ch</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">char</span> ch, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = (<span class="keyword">int</span>) ch;</span><br><span class="line">		<span class="comment">// byte[] b = new byte[2];</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ ) &#123;</span><br><span class="line">			bb[index + i] = <span class="keyword">new</span> Integer(temp &amp; <span class="number">0xff</span>).byteValue(); <span class="comment">// 将最高位保存在最低位</span></span><br><span class="line">			temp = temp &gt;&gt; <span class="number">8</span>; <span class="comment">// 向右移8位</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 字节到字符转换</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[index + <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">			s += b[index + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			s += <span class="number">256</span> + b[index + <span class="number">0</span>];</span><br><span class="line">		s *= <span class="number">256</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[index + <span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">			s += b[index + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			s += <span class="number">256</span> + b[index + <span class="number">0</span>];</span><br><span class="line">		<span class="keyword">char</span> ch = (<span class="keyword">char</span>) s;</span><br><span class="line">		<span class="keyword">return</span> ch;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>float与byte的转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * float转换byte</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putFloat</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">float</span> x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// byte[] b = new byte[4];</span></span><br><span class="line">	<span class="keyword">int</span> l = Float.floatToIntBits(x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		bb[index + i] = <span class="keyword">new</span> Integer(l).byteValue();</span><br><span class="line">		l = l &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过byte数组取得float</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	l = b[index + <span class="number">0</span>];</span><br><span class="line">	l &amp;= <span class="number">0xff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	l &amp;= <span class="number">0xffff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>);</span><br><span class="line">	l &amp;= <span class="number">0xffffff</span>;</span><br><span class="line">	l |= ((<span class="keyword">long</span>) b[index + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">	<span class="keyword">return</span> Float.intBitsToFloat(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>double与byte的转化   </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * double转换byte</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDouble</span><span class="params">(<span class="keyword">byte</span>[] bb, <span class="keyword">double</span> x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// byte[] b = new byte[8];</span></span><br><span class="line">		<span class="keyword">long</span> l = Double.doubleToLongBits(x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			bb[index + i] = <span class="keyword">new</span> Long(l).byteValue();</span><br><span class="line">			l = l &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过byte数组取得float</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bb</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> l;</span><br><span class="line">		l = b[<span class="number">0</span>];</span><br><span class="line">		l &amp;= <span class="number">0xff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffff</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">4</span>] &lt;&lt; <span class="number">32</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">5</span>] &lt;&lt; <span class="number">40</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">6</span>] &lt;&lt; <span class="number">48</span>);</span><br><span class="line">		l &amp;= <span class="number">0xffffffffffffffl</span>;</span><br><span class="line">		l |= ((<span class="keyword">long</span>) b[<span class="number">7</span>] &lt;&lt; <span class="number">56</span>);</span><br><span class="line">		<span class="keyword">return</span> Double.longBitsToDouble(l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>boolean与byte的相互转化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将boolean转成byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] Boolean2ByteArray(<span class="keyword">boolean</span> val) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (val == <span class="keyword">false</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ByteBuffer.allocate(<span class="number">4</span>).putInt(tmp).array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将byte[]转成boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">ByteArray2Boolean</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = ByteBuffer.wrap(data, <span class="number">0</span>, <span class="number">4</span>).getInt();</span><br><span class="line">        <span class="keyword">return</span> (tmp == <span class="number">0</span>) ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考地址：<br>[1].long、shrot和int转化 <a href="https://blog.csdn.net/u012403290/article/details/68943827" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/68943827</a><br>[2].long、shrot和int转化 <a href="https://blog.csdn.net/thanklife/article/details/17002641" target="_blank" rel="noopener">https://blog.csdn.net/thanklife/article/details/17002641</a><br>[3]. char、float、double与byte转化 <a href="https://blog.csdn.net/LEEtcWorks/article/details/7390731" target="_blank" rel="noopener">https://blog.csdn.net/LEEtcWorks/article/details/7390731</a><br>[4]. 通过buffer转换 <a href="https://blog.csdn.net/u010983881/article/details/60870360" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/60870360</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/23/NIO-Buffer解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/NIO-Buffer解析/" itemprop="url">NIO-Buffer解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T16:18:47+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp; &nbsp; &nbsp; &nbsp;在NIO中，数据的读写操作始终是与缓冲区相关联的。Channel将数据<br>读入缓冲区，然后我们又从缓冲区访问数据。写数据时，首先将要发送的数据按顺序填入缓冲区。基本上，<br>缓冲区只是一个列表，它的所有元素都是基本数据类型（通常为字节型）。缓冲区是定长的，它不像一些类<br>那样可以扩展容量（例如，List，StringBuffer等）。注意，ByteBuffer是最常用的缓冲区，因为：1）<br>它提供了读写其他数据类型的方法，2）信道的读写方法只接收ByteBuffer。</p>
<h4 id="Buffer索引"><a href="#Buffer索引" class="headerlink" title="Buffer索引"></a>Buffer索引</h4><p>缓冲区不仅仅是用来存放一组元素的列表。在读写数据时，它有内部状态来跟踪缓冲区的当前位置，以及有效<br>可读数据的结束位置等。为了实现这些功能，每个缓冲区维护了指向其元素列表的4个索引，如下表所示。<br>（不久我们将看到如何使用缓冲区的各种方法来修改索引值。）   </p>
<table>
<thead>
<tr>
<th style="text-align:left">索引</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">存取器/修改器/用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">capacity</td>
<td style="text-align:left">缓冲区的元素总是（不可修改）</td>
<td style="text-align:left">int capacity（）</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">下一个要读/写的元素（从0开始）</td>
<td style="text-align:left">int position(), Buffer position(int newPosition)</td>
</tr>
<tr>
<td style="text-align:left">limit</td>
<td style="text-align:left">第一个不可读/写元素</td>
<td style="text-align:left">int limit(), Buffer limit(int newLimit)</td>
</tr>
<tr>
<td style="text-align:left">mark</td>
<td style="text-align:left">用户选定的position 高的前一个位置或0</td>
<td style="text-align:left">Buffer mark(),Buffer reset()</td>
</tr>
</tbody>
</table>
<p>position和limit之间的距离指示了可读取/存入的字节数，java中提供了两个方便的方法来计算这个距离。  </p>
<ul>
<li>boolean hasRemaining（）：当缓冲区至少还有一个元素时，返回true；</li>
<li>int remaining（）：返回缓冲区包含的元素个数；<br>在这些变量中，始终保持以下关系不变：<br>0  ≤ mark ≤ position ≤ limit ≤ capacity<br>mark变量的值“记录”了一个将来可返回的位置，reset（）方法则将postion的值还原成上次调用mark（）<br>方法后的position值（除非这样做会违背上面的不变关系）；</li>
</ul>
<h4 id="Buffer创建"><a href="#Buffer创建" class="headerlink" title="Buffer创建"></a>Buffer创建</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;通常使用分配空间或包装一个现有的基本类型数组来创建缓冲区。创建ByteBuffer的静态工厂方法，以及<br>相应的capacity，position，和limit的初始值下表。所有新创建的Buffer实例都没有定义其mark值，<br>在调用mark()方法前，任何试图使用reset()方法来设置position的值的操作都将抛出InvalidMarkException异常。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteBuffer    allocate(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    allocateDirect(int capacity)</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">0</td>
<td style="text-align:left">array.length</td>
</tr>
<tr>
<td style="text-align:left">ByteBuffer    wrap(byte[] array,int offer,int length)</td>
<td style="text-align:left">array.length</td>
<td style="text-align:left">offset</td>
<td style="text-align:left">offset-array.length</td>
</tr>
</tbody>
</table>
<p>要分配一个新的实例，只需要简单地调用想要创建的缓冲区类型的allocate()静态方法，并指定元素的总数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(20);</span><br><span class="line">DoubleBuffer dblBuf = DoubleBuffer.allocate(5);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在上面代码中，byteBuf分配了20个字节，dblBuf分配了5个Java的<br>double型数据。这些缓冲区都是定长的，因此无法扩展或缩减它们的容量。如果发现刚创建的缓冲区容量太小，<br>惟一的选择就是重新创建一个大小合适的缓冲区。<br>还可以通过调用wrap()静态方法，以一个已有的数组为参数，来创建缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byteArray[] = new byte[BUFFERSIZE];</span><br><span class="line">// ...Fill array...</span><br><span class="line">ByteBuffer byteWrap = ByteBuffer.wrap(byteArray);</span><br><span class="line">ByteBuffer subByteWrap = ByteBuffer.wrap(byteArray, 3,3);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过包装的方法创建的缓冲区 <strong>保留了被包装数组内保存的数据</strong>。实际上，<br>wrap()方法只是简单地创建了一个具有指向被包装数组的引用的缓冲区，该数组称为 <strong>后援数组</strong>。对后援数组<br>中的数据做的任何修改都将改变缓冲区中的数据，反之亦然。如果我们为wrap()方法指定了偏移量（offset）<br>和长度（length），缓冲区将使用整个数组为后援数组，同时将position和limit的值初始化为偏移量<br>（offset）和偏移量+长度（offset+length）。在偏移量之前和长度之后的元素依然可以通过缓冲区访问。<br>使用分配空间的方式来创建缓冲区其实与使用包装的方法区别不大。惟一的区别是allocate()方法创建了<br>自己的后援数组。在缓冲区上调用array()方法即可获得后援数组的引用。通过调用arrayOffset()方法，<br>甚至还可以获取缓冲区中第一个元素在后援数组中的偏移量。使用wrap()方法和非零偏移量参数创建的缓冲区，<br>其数组偏移量依然是0。<br>&nbsp; &nbsp; &nbsp; &nbsp;到目前为止，我们实现的所有缓冲区都将数据存放在Java分配的后援数组中。<br>通常，底层平台（操作系统）不能使用这些缓冲区进行I/O操作。操作系统必须使用自己的缓冲区来进行I/O，<br>并将结果复制到缓冲区的后援数组中。这些复制过程 <strong>可能非常耗费系统资源</strong>，尤其是在有很多读写需求的时候。<br>Java的NIO提供了一种 <strong>直接缓冲区（direct buffers）</strong> 来解决这个问题。使用直接缓冲区，Java将从平台<br>能够直接进行I/O操作的存储空间中为缓冲区分配后援存储空间，从而省略了数据的复制过程。这种低层的、<br>本地的I/O通常在字节层进行操作，因此只能为 <strong>ByteBuffer进行直接缓冲区分配</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBufDirect =ByteBuffer.allocateDirect(BUFFERSIZE);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;通过调用isDirect()方法可以查看一个缓冲区是否是直接缓冲区。由于<br>直接缓冲区没有后援数组，在它上面调用array()或arrayOffset()方法都将抛出<br>UnsupportedOperationException异常。在考虑是否使用直接缓冲区时需要牢记几点。首先，要知道调用<br>allocateDirect()方法并不能保证能成功分配直接缓冲区–有的平台或JVM可能不支持这个操作，因此在<br>尝试分配直接缓冲区后必须调用isDirect()方法进行检查。其次，要知道 <strong>分配和销毁直接缓冲区通常比分配<br>和销毁非直接缓冲区要消耗更多的系统资源</strong>，因为直接缓冲区的后援存储空间通常存在与JVM之外，对它的管理<br>需要与操作系统进行交互。所以，只有当需要在很多I/O操作上长时间使用时，才分配直接缓冲区。实际上，<br>在相对于非直接缓冲区能明显提高系统性能时，使用直接缓冲区是个不错的主意。</p>
<h4 id="存储和接受数据"><a href="#存储和接受数据" class="headerlink" title="存储和接受数据"></a>存储和接受数据</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;只要有了缓冲区，就可以用它来存放数据了。作为数据的”容器”，缓冲区<br><strong>既可用来输入也可用来输出。这一点就与流不同，流只能向一个方向传递数据</strong>。使用put()方法可以将数据放入<br>缓冲区，使用get()方法则可以从缓冲区获取数据。信道的read()方法隐式调用了给定缓冲区的put()，而其<br>write()方法则隐式调用了缓冲区的get()方法。下面展示ByteBuffer的get()和put()方法，当然，其他<br>类型的缓冲区也有类似的方法。<br>ByteBuffer:获取和存放字节，有两种类型的get()和put()：基于相对位置和基于绝对位置。基于相对位置<br>的版本根据position的当前值，从”下一个”位置读取或存放数据，然后根据数据量给position增加适当的值<br>（即，单字节形式增加1数组形式增加array.length，     数组/偏移量/长度形式则增加length）。也就是<br>说，每次调用put()方法，都是在缓冲区中的已有元素后面追加数据，每次调用get()方法，都是读取缓冲区的<br>后续元素。不过，如果这些操作会导致position的值超出limit的限制，get()方法将抛出BufferUnderflowException异常，<br>put()方法将抛出BufferOverflowException异常。例如，如果传给get()方法的目标数组长度大于缓冲区<br>的剩余空间大小，get()方法将抛出BufferUnderflowException异常，部分数据的get/put是不允许的。<br>基于绝对位置的get()和put()以指定的索引位置为参数，从该位置读取数据或向该位置写入数据。绝对位置<br>形式的get和put不会改变position的值。如果给定的索引值超出了limit的限制，它们将抛出IndexOutOfBoundsException异常。<br>除了字节类型外，ByteBuffer类还提供了其他类型数据的相当位置和绝对位置的get/put方法。这样一来，就有点像DataOutputStream了。</p>
<ul>
<li>相对位置：<ul>
<li>byte get()</li>
<li>ByteBuffer get(byte[] dst)</li>
<li>ByteBuffer get(byte[] dst, int offset, int length)</li>
<li>ByteBuffer put(byte b)</li>
<li>ByteBuffer put(byte[] src)</li>
<li>ByteBuffer put(byte[] src, int offset, int length)</li>
<li>ByteBuffer put(ByteBuffer src)</li>
</ul>
</li>
<li><p>绝对位置：</p>
<ul>
<li>byte get(int index)</li>
<li>ByteBuffer put(int index, byte b)</li>
</ul>
</li>
<li><p>ByteBuffer:读取和存放Java多字节基本数据</p>
<ul>
<li><type> get<type>()</type></type></li>
<li><type> get<type>(int index)</type></type></li>
<li>ByteBuffer put<type>(<type> value)</type></type></li>
<li>ByteBuffer put<type>(int index,<type> value)</type></type></li>
</ul>
</li>
</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp;其中”<type>“代表Char，Double，Int，Long，Short之一，<br>而”<type>“代表char，double，int，long，short之一。<br>每次调用基于相对位置的put()或get()方法，都将根据特定参数类型的长度增加position的值：short加2，<br>int加4，等。不过，如果这样做会导致position的值超出limit的限制，get()和put()方法将分别抛出<br>BufferUnderflowException和BufferOverflowException异常：get和put不允许只对部分数据进行操作。<br>发生了下溢/上溢（under/overflow）时，position的值不变。可能你已经注意到，很多get/put方法都<br>返回一个ByteBuffer。实际上它们返回的就是调用它们的那个ByteBuffer。这样做可以实现 <strong>链式调用（call chaining）</strong>，<br>即第一次调用的结果可以直接用来进行后续的方法调用。例如，可以像下面那样将整数1和2存入ByteBuffer实例<br>myBuffer中：myBuffer.putInt(1).putInt(2);<br>&nbsp; &nbsp; &nbsp; &nbsp;<strong>多字节数据类型有一个字节顺序，称为big-endian或little-endian。<br>Java默认使用big-endian</strong>。通过使用内置的ByteOrder.BIG_ENDIAN和ByteOrder.LITTLE_ENDIAN实例，<br>可以获取和设定多字节数据类型写入字节缓冲区时的字节顺序。</type></type></p>
<ul>
<li>ByteBuffer:缓冲区中的字节顺序<ul>
<li>ByteOrder order()</li>
<li>ByteBuffer order(ByteOrder order)<br>第一个方法以ByteOrder常量的形式返回缓冲区的当前字节顺序。第二个方法用来设置写多字节数据时的字节顺序。</li>
</ul>
</li>
</ul>
<p>下面来看一个使用字节顺序的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(4);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">buffer.putShort((short) 1);</span><br><span class="line">// Predict the byte values for buffer and test your prediction</span><br></pre></td></tr></table></figure></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;看了这些有关字节顺序的讨论，你可能希望知道自己的处理器是什么字节<br>顺序，ByteOrder定义了一个方法来解答这个问题：<br>ByteOrder:查找字节顺序<br>static final ByteOrder BIG_ENDIAN<br>static final ByteOrder LITTLE_ENDIAN<br>static ByteOrder nativeOrder()<br>nativeOrder()方法返回常量BIG_ENDIAN或LITTLE_ENDIAN之一。</p>
<h4 id="Buffer准备：clear（）、flip（）和rewind（）"><a href="#Buffer准备：clear（）、flip（）和rewind（）" class="headerlink" title="Buffer准备：clear（）、flip（）和rewind（）"></a>Buffer准备：clear（）、flip（）和rewind（）</h4><p>在使用缓冲区进行输入输出数据之前，必须确定缓冲区的position，limit都已经设置了正确的值。首先<br>我们看看上面三个方法对position和limit的修改操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ByteBuffer方法</th>
<th style="text-align:left">准备Buffer以实现</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clear()</td>
<td style="text-align:left">将数据read()/put()进缓冲区</td>
<td style="text-align:left">0</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">flip()</td>
<td style="text-align:left">从缓冲区write()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">position</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">rewind()</td>
<td style="text-align:left">从缓冲区rewrite()/get()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>三种在Buffer类的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Clears this buffer.  The position is set to zero, the limit is set to</span><br><span class="line">    * the capacity, and the mark is discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span><br><span class="line">    * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.clear();     // Prepare buffer for reading</span><br><span class="line">    * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span><br><span class="line">    * is named as if it did because it will most often be used in situations</span><br><span class="line">    * in which that might as well be the case. &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer clear() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Flips this buffer.  The limit is set to the current position and then</span><br><span class="line">    * the position is set to zero.  If the mark is defined then it is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span><br><span class="line">    * this method to prepare for a sequence of channel-write or relative</span><br><span class="line">    * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * buf.put(magic);    // Prepend header</span><br><span class="line">    * in.read(buf);      // Read data into rest of buffer</span><br><span class="line">    * buf.flip();        // Flip buffer</span><br><span class="line">    * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method is often used in conjunction with the &#123;@link</span><br><span class="line">    * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span><br><span class="line">    * one place to another.  &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer flip() &#123;</span><br><span class="line">       limit = position;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Rewinds this buffer.  The position is set to zero and the mark is</span><br><span class="line">    * discarded.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span><br><span class="line">    * operations, assuming that the limit has already been set</span><br><span class="line">    * appropriately.  For example:</span><br><span class="line">    *</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * out.write(buf);    // Write remaining data</span><br><span class="line">    * buf.rewind();      // Rewind buffer</span><br><span class="line">    * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return  This buffer</span><br><span class="line">    */</span><br><span class="line">   public final Buffer rewind() &#123;</span><br><span class="line">       position = 0;</span><br><span class="line">       mark = -1;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释：（参考：<a href="https://blog.csdn.net/FS1360472174/article/details/52141800）" target="_blank" rel="noopener">https://blog.csdn.net/FS1360472174/article/details/52141800）</a></p>
<ul>
<li>clear: clear 并没有真正的清除数据，将position设置为0，limit设置为capacity;</li>
<li><p>flip ：一般是切换到读操作。或者是为写操作准备一个新的序列<br>eg：重复向一个ByteBuffer写数据的时候，赋值完毕，必须要flip.开始一个新的新序列，否则position<br>会等于limit，返回空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       byte[] bytes1=new byte[]&#123;1, 6, 3&#125;;</span><br><span class="line">       ByteBuffer buffer =fromByteArray(bytes1);</span><br><span class="line">       System.out.println(buffer);</span><br><span class="line">       byte[] bytes2 =new byte[]&#123;1,2,3&#125;;</span><br><span class="line">       ByteBuffer buffer2=fromByteArray(bytes2);</span><br><span class="line">       System.out.println(buffer2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * If you are building up a ByteBuffer by repeatedly writing into it, and then want to give it away, you must remember to flip() it.</span><br><span class="line">    * If we did not flip() it, the returned ByteBuffer would be empty because the position would be equal to the limit.</span><br><span class="line">    * @param bytes</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static ByteBuffer fromByteArray(byte[] bytes) &#123;</span><br><span class="line">       final ByteBuffer ret = ByteBuffer.wrap(new byte[bytes.length]);</span><br><span class="line"></span><br><span class="line">       ret.put(bytes);</span><br><span class="line">       ret.flip();</span><br><span class="line"></span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rewind:倒回，将position 设置为0，重新读取;</p>
</li>
</ul>
<h4 id="压缩Buffer中数据"><a href="#压缩Buffer中数据" class="headerlink" title="压缩Buffer中数据"></a>压缩Buffer中数据</h4><p>compact()方法将position与limit之间的元素复制到缓冲区的开始位置，从而为后续的put()/read()调<br>用让出空间。position的值将设置为要复制的数据的长度，limit的值将设置为capacity，mark则变成未定义。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">      byte[] bytes = new byte[]&#123;1, 6, 3, 1, 1, 1, 1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">      ByteBuffer buffer = ByteBuffer.wrap(bytes);</span><br><span class="line">      byte b = buffer.get();</span><br><span class="line">      System.out.println(&quot;b:&quot; + b + &quot; position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.compact();</span><br><span class="line">      System.out.println(&quot;compact  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line">      buffer.flip();</span><br><span class="line">      System.out.println(&quot;flip  position:&quot; + buffer.position()+&quot; limit:&quot;+buffer.limit()+&quot; capacity:&quot;+buffer.capacity());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>b:1 position:1 limit:11 capacity:11<br>compact  position:10 limit:11 capacity:11<br>flip  position:0 limit:10 capacity:11</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;为什么要使用这个操作呢？假设你有一个缓冲区要写数据。回顾前面的内容我们知道，对write()方法的非阻塞调用只会写出其能够发送的数据，而不会阻塞等待所有数据发送完。因此write()方法不一定会将缓冲区中的所有元素都发送出去。又假设现在要调用read()方法，在缓冲区中没有发送的数据后面读入新数据。处理方法之一就是简单地设置position = limit和limit = capacity。当然，在读入新数据后，再次调用write()方法前，还需要将这些值还原。这样做有个问题即缓冲区的空间最终将消耗殆尽，如上图中，只剩下一个元素位置可以再存入一个字节。此外，缓冲区前面的空间又被浪费掉了。这就是compact()方法要解决的问题。在调用write()方法后和添加新数据的read()方法前调用compact()方法，则将所有”剩余”的数据移动到缓冲区的开头，从而为释放最大的空间来存放新数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for reading</span><br><span class="line">while (channel.read(buffer) != -1) &#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">channel.write(buffer);</span><br><span class="line">buffer.compact();</span><br><span class="line">&#125;</span><br><span class="line">while (buffer.hasRemaining())</span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，如开始已经提到的，复制数据是一个非常耗费系统资源的操作，因此要保守地使用compact()方法。</p>
<h4 id="Buffer透视：duplicate-slice-等"><a href="#Buffer透视：duplicate-slice-等" class="headerlink" title="Buffer透视：duplicate(),slice()等"></a>Buffer透视：duplicate(),slice()等</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;NIO提供了多种方法来创建一个与给定缓冲区共享内容的新缓冲区，这些方法对元素的处理过程各有不同。基本上，这种新缓冲区有自己独立的状态变量（position，limit，capacity和mark），但与原始缓冲区共享了同一个后援存储空间。任何对新缓冲区 <strong>内容</strong> 的修改都将反映到 <strong>原始缓冲区上</strong> 。可以将新缓冲区看作是从另一个角度对同一数据的透视。</p>
<p>duplicate()方法用于创建一个与原始缓冲区共享内容的新缓冲区。新缓冲区的position，limit，mark和capacity都初始化为原始缓冲区的索引值，然而，它们的这些值是相互独立的。如下表格为在ByteBuffer上创建不同透视的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">capacity</th>
<th style="text-align:left">position</th>
<th style="text-align:left">limit</th>
<th style="text-align:left">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">duplicate()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">slice()</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asReadOnlyBuffer()</td>
<td style="text-align:left">capacity</td>
<td style="text-align:left">position</td>
<td style="text-align:left">limit</td>
<td style="text-align:left">mark</td>
</tr>
<tr>
<td style="text-align:left">asCharBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asDoubleBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asFloatBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asIntBuffer()</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/4</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asLongBuffer()</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/8</td>
<td style="text-align:left">为定义</td>
</tr>
<tr>
<td style="text-align:left">asShortBuffer()</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">remaining()/2</td>
<td style="text-align:left">为定义</td>
</tr>
</tbody>
</table>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由于共享了内容，对原始缓冲区或任何复本所做的改变在所有复本上都可见。<br>下面回到前面的例子，假设要将在网络上发送的所有数据都写进日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Start with buffer ready for writing</span><br><span class="line">ByteBuffer logBuffer = buffer.duplicate();</span><br><span class="line">while (buffer.hasRemaining()) // Write all data to network</span><br><span class="line">networkChannel.write(buffer);</span><br><span class="line">while (logBuffer.hasRemaining()) // Write all data to</span><br><span class="line">//logger</span><br><span class="line">loggerChannel.write(buffer);</span><br></pre></td></tr></table></figure></p>
<p>注意，使用了缓冲区复制操作，向网络写数据和写日志就可以在不同的线程中并行进行。slice()方法用于创建一个共享了原始缓冲区子序列的新缓冲区。新缓冲区的position值是0，而其limit和capacity的值都等于原始缓冲区的limit和position的差值。slice()方法将新缓冲区数组的offset值设置为原始缓冲区的position值，然而，在新缓冲区上调用array()方法还是会返回整个数组。<br>Channel在读写数据时只以ByteBuffer为参数，然而我们可能还对使用其他基本类型的数据进行通信感兴趣。ByteBuffer能够创建一种独立的”视图缓冲区（view buffer）”，用于将ByteBuffer的内容解释成其他基本类型（如CharBuffer）。这样就可以从该缓冲区中读取（写入数据是可选操作）新类型的数据。新缓冲区与原始缓冲区共享了同一个后援存储空间，因此，在 <strong>任一缓冲区上的修改在新缓冲区和原始缓冲区上都可以看到</strong>。新创建的视图缓冲区的position值为0，其内容从原始缓冲区的position所指位置开始。这与slice()操作非常相似。不过，由于视图缓冲区操作的是多字节元素，新缓冲区的capacity和limit的值等于剩余总字节数除以每个该类型元素对应的字节数（例如，创建DoubleBuffer时则除以8）。<br>下面来看一个例子。假设通过某个Channel接收到一条消息，该消息由一个单独字节，后跟大量big-endian顺序的双字节整数（如short型）组成。由于该消息是通过Channel送达的，它一定在一个ByteBuffer中，在此为buf。消息的第一个字节包含了消息中双字节整数的数量。你可能要调用第一个字节指定次数的buf.getShort()方法，或者你可以一次获取所有的整数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ...get message by calling channel.read(buf) ...</span><br><span class="line">int numShorts = (int)buf.get();</span><br><span class="line">if (numShorts &lt; 0) &#123;</span><br><span class="line">throw new SomeException()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">short[] shortArray = new short[numShorts];</span><br><span class="line">ShortBuffer sbuf = buf.asShortBuffer();</span><br><span class="line">sbuf.get(shortArray); // note: will throw if header was</span><br><span class="line">incorrect!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asReadOnlyBuffer()方法的功能与duplicate()方法相似，只是任何会修改新缓冲区内容的方法都将抛出ReadOnlyBufferException异常。包括各种型式的put()，compact()等，甚至连在缓冲区上调用无方向性的array()和arrayOffset()方法也会抛出这个异常。当然，对产生这个只读缓冲区的非只读缓冲区进行的任何修改，<br>仍然会与新的只读缓冲区共享。就像用duplicate()创建的缓冲区一样，只读缓冲区也有独立的缓冲区状态变量。可以使用isReadOnly()方法来检查一个缓冲区是否是只读的。如果原缓冲区已经是只读的，调用duplicate()或slice()方法也将创建新的只读缓冲区。</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;字符是由字节序列进行编码的，而且在字节序列与字符集合之间有各种映射（称为字符集）方式。NIO缓冲区的另一个用途是在各种字符集之间进行转换。要使用这个功能，还需要了解java.nio.charset包中另外两个类：CharsetEncoder和CharsetDecoder类。要进行编码，需要使用一个Charset实例来创建一个编码器并调用encode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Charset charSet = Charset.forName(&quot;US-ASCII&quot;);</span><br><span class="line">CharsetEncoder encoder = charSet.newEncoder();</span><br><span class="line">ByteBuffer buffer = encoder.encode(CharBuffer.wrap(&quot;Hi</span><br><span class="line">mom&quot;));</span><br></pre></td></tr></table></figure></p>
<p>要进行解码，需要使用Charset实例来创建一个解码器，并调用decode方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = charSet.newDecoder();</span><br><span class="line">CharBuffer cBuf = decoder.decode(buffer);</span><br></pre></td></tr></table></figure></p>
<p>虽然这种方法能够正常工作，但当需要进行多次编码时，效率就会变得较低。例如，每次调用encode/decode<br>方法都会创建一个新Byte/CharBuffer实例。其他导致低效率的地方与编码器的创建和操作有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">encoder.reset();</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Hi &quot;),buffer,false)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... deal with lack of space in buffer ...</span><br><span class="line">&#125;</span><br><span class="line">if (encoder.encode(CharBuffer.wrap(&quot;Mom&quot;),buffer,true)</span><br><span class="line">== CoderResult.OVERFLOW) &#123;</span><br><span class="line">// ... ditto ...</span><br><span class="line">&#125;</span><br><span class="line">encoder.flush(buffer);</span><br></pre></td></tr></table></figure></p>
<p>encode()方法将给定CharBuffer转换为一个字节序列，并将其写入给定的缓冲区。如果缓冲区太小，encode()方法的返回值等于CoderResult.OVERFLOW。如果输入的数据完全被接收，并且编码器还准备对更多数据进行编码，encode()方法的返回值则等于CoderResult.UNDERFLOW。另外，如果输入的数据格式有错误，则将返回一个CoderResult对象，并指示了所存在的问题的位置和类型。只有到达了输入数据的结尾时，才将最后的boolean参数设为true。flush()方法将任何缓存的编码数据推送到缓冲区。注意，在新创建的编码器上调用reset()方法并不是必需的，该方法用来重新设置编码器的内部状态，以使其能够进行再次编码。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后通过一段简短代码展示allocate、flip、get、compact和clear方法对position、limit的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws IOException &#123;</span><br><span class="line"></span><br><span class="line"> ByteBuffer buffer1 = ByteBuffer.allocate(10);</span><br><span class="line"> RandomAccessFile fine = new RandomAccessFile(new File(&quot;b.txt&quot;), &quot;rw&quot;);</span><br><span class="line"> FileChannel fc = fine.getChannel();//分配空间后position为0，limit=capacity=10；</span><br><span class="line"> output(&quot;allocate&quot;, buffer1);</span><br><span class="line"> fc.read(buffer1);</span><br><span class="line"> output(&quot;read&quot;, buffer1);</span><br><span class="line"> buffer1.flip();                 //将limit设置为position，然后将position设置为0</span><br><span class="line"> output(&quot;flip&quot;, buffer1);</span><br><span class="line"> buffer1.get();                          //将position加一</span><br><span class="line"> output(&quot;get&quot;, buffer1);</span><br><span class="line"> buffer1.rewind();                       //重置position为0</span><br><span class="line"> output(&quot;rewind&quot;, buffer1);</span><br><span class="line"> buffer1.compact();                         //将position到limit的数据移到数组前端，并将position设置为（limit-position的距离），limit=capacity</span><br><span class="line"> output(&quot;compact&quot;, buffer1);</span><br><span class="line"> buffer1.clear();                    //重置position为0，limit=capacity</span><br><span class="line"> output(&quot;clear&quot;, buffer1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void output(String tag, ByteBuffer buffer) &#123;</span><br><span class="line">      System.out.println(tag + &quot; position:&quot; + buffer.position() + &quot; limit:&quot; + buffer.limit() + &quot; capacity:&quot; + buffer.capacity());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>allocate position:0 limit:10 capacity:10<br>read position:6 limit:10 capacity:10<br>flip position:0 limit:6 capacity:10<br>get position:1 limit:6 capacity:10<br>rewind position:0 limit:6 capacity:10<br>compact position:6 limit:10 capacity:10<br>clear position:0 limit:10 capacity:10<br>get position:2 limit:10 capacity:10</p>
<p>参考：<br>[1] （译文）java中的ShortBuffer <a href="https://blog.csdn.net/u010142437/article/details/42082735" target="_blank" rel="noopener">https://blog.csdn.net/u010142437/article/details/42082735</a><br>[2] Buffer详解 <a href="https://blog.csdn.net/guofengpu/article/details/51995730" target="_blank" rel="noopener">https://blog.csdn.net/guofengpu/article/details/51995730</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/16/根据Uri获取文档的路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/根据Uri获取文档的路径/" itemprop="url">根据Uri获取文档的路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T14:11:33+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据Url获取文档的绝对路径，解决Android4.4以上版本Uri转换。<br>Android在4.4之后的版本(包括4.4)中，从相册中选取图片返回Uri进行了改动。所以无法通过该Uri来取得文件路径从而解码图片将其显示出来。<br><code>在4.3或以下可以直接用Intent.ACTION_GET_CONTENT打开相册;在4.4或以上,官方建议用ACTION_OPEN_DOCUMENT打开相册</code><br>在Android4.4之前得到的Uri为：</p>
<ul>
<li>content://media/external/images/media/8302  </li>
<li>content://media/external/video/media  </li>
<li>content://media/external/images/media  </li>
</ul>
<p>而在Android4.4后得到的可能是以下：</p>
<ul>
<li>content://com.android.providers.media.documents/document/image:8302</li>
<li>content://com.android.providers.downloads.documents/document/5</li>
</ul>
<p>以下为Android4.4之后的适配：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *</span><br><span class="line"> * 专为Android4.4设计的从Uri获取文件绝对路径</span><br><span class="line"> */</span><br><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public static String getPath(final Context context, final Uri uri) &#123;</span><br><span class="line">    final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line">    LogUtil.d(&quot;uri:&quot; + uri);</span><br><span class="line">    // DocumentProvider</span><br><span class="line">    if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">        // ExternalStorageProvider</span><br><span class="line">        if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1];</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO handle non-primary volumes</span><br><span class="line">        &#125;</span><br><span class="line">        // DownloadsProvider</span><br><span class="line">        else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">            final String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">            return getDataColumn(context, contentUri, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // MediaProvider</span><br><span class="line">        else if (isMediaDocument(uri)) &#123;</span><br><span class="line">            final String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            final String[] split = docId.split(&quot;:&quot;);</span><br><span class="line">            final String type = split[0];</span><br><span class="line"></span><br><span class="line">            Uri contentUri = null;</span><br><span class="line">            if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String selection = &quot;_id=?&quot;;</span><br><span class="line">            final String[] selectionArgs = new String[]&#123;split[1]&#125;;</span><br><span class="line">            LogUtil.d(&quot;format uri:&quot; + contentUri);</span><br><span class="line">            return getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // MediaStore (and general)</span><br><span class="line">    else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return getDataColumn(context, uri, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // File</span><br><span class="line">    else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">        return uri.getPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the value of the data column for this Uri. This is useful for</span><br><span class="line"> * MediaStore Uris, and other file-based ContentProviders.</span><br><span class="line"> *</span><br><span class="line"> * @param context       The context.</span><br><span class="line"> * @param uri           The Uri to query.</span><br><span class="line"> * @param selection     (Optional) Filter used in the query.</span><br><span class="line"> * @param selectionArgs (Optional) Selection arguments used in the query.</span><br><span class="line"> * @return The value of the _data column, which is typically a file path.</span><br><span class="line"> */</span><br><span class="line">public static String getDataColumn(Context context, Uri uri, String selection,</span><br><span class="line">                                   String[] selectionArgs) &#123;</span><br><span class="line"></span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    final String column = &quot;_data&quot;;</span><br><span class="line">    final String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                null);</span><br><span class="line">        if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">            final int column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor != null)</span><br><span class="line">            cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is ExternalStorageProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is DownloadsProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * @param uri The Uri to check.</span><br><span class="line">  * @return Whether the Uri authority is MediaProvider.</span><br><span class="line">  */</span><br><span class="line"> public static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">     return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看一个获取Mp3文档的Uri，其格式类似：content://com.android.providers.media.documents/document/audio%3A39，<br>然后我根据代码进一步分析，首先看判断条件：isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)，<br>这里判断了版本号和该Uri是否是文档类Uri，之所以要判断版本号是Uri的生成在Api19以后发送变化，通过官方文档DocumentsContract，我们也可以验证这点，DocumentsContract是在Api19加入的，其定义就是定义文档提供者与平台之间的协议，其主要作用就是关于文档Uri的一系列操作。<br>下面是其内部实现代码（代码都是在DocumentsContract类中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT = &quot;document&quot;;</span><br><span class="line">private static final String PATH_TREE = &quot;tree&quot;;</span><br><span class="line">public static final String PROVIDER_INTERFACE = &quot;android.content.action.DOCUMENTS_PROVIDER&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Test if the given URI represents a &#123;@link Document&#125; backed by a</span><br><span class="line">   * &#123;@link DocumentsProvider&#125;.</span><br><span class="line">   *</span><br><span class="line">   * @see #buildDocumentUri(String, String)</span><br><span class="line">   * @see #buildDocumentUriUsingTree(Uri, String)</span><br><span class="line">   */</span><br><span class="line">  public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">      if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">          final List&lt;String&gt; paths = uri.getPathSegments();</span><br><span class="line">          if (paths.size() == 2) &#123;</span><br><span class="line">              return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">          &#125; else if (paths.size() == 4) &#123;</span><br><span class="line">              return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  /** &#123;@hide&#125; */</span><br><span class="line">   public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">      // public static final String SCHEME_CONTENT = &quot;content&quot;;     !!add by custom</span><br><span class="line">       return uri != null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent = new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos = context.getPackageManager()</span><br><span class="line">            .queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看出，前提条件是判断是否是contentUri&amp;&amp;documentProvider，然后在进一步判断其pathSegments<br>是否是document/或者tree/document/开头。其中isDocumentsProvider方法不是特别理解，希望大神指点下。</p>
<p>参考地址：<br>[1] 解决Android4.4以上版本Uri转换  <a href="https://blog.csdn.net/q445697127/article/details/40537945" target="_blank" rel="noopener">https://blog.csdn.net/q445697127/article/details/40537945</a><br>[2] <a href="https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework" target="_blank" rel="noopener">https://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/LinearLayout源码解读/" itemprop="url">LinearLayout源码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-12T10:01:49+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="LinearLayout基础"><a href="#LinearLayout基础" class="headerlink" title="LinearLayout基础"></a>LinearLayout基础</h3><p>LinearLayout所具有的属性：</p>
<ul>
<li>orientation：视图的布局方向，默认值：-1；</li>
<li>gravity：绘制起始点，默认值：-1；</li>
<li>baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true；</li>
<li>weightSum：子视图权重和，默认值：-1.0f；</li>
<li>baselineAlignedChildIndex：以第Index个子视图的基准线为对齐，该LinearLayout下的view以<br>某个继承TextView的View的基线对齐，默认值：-1；</li>
<li>measureWithLargestChild：以最大子视图宽高，为其子视图的宽高，<strong>其起作用前提是为true，且LinearLayout在该方向的宽或高为warp_content，且子视图具有权重</strong>。默认值：false；</li>
<li>divider：分割线；</li>
<li>showDividers：分割线显示样式（middle|end|beginning|non），默认值：SHOW_DIVIDER_NONE；</li>
<li><p>dividerPadding：分割线内边距，默认值：0；</p>
<p>解释：</p>
</li>
<li>基准线<br>其主要作用是在绘制字母的时候有个基线对齐，这个类似我们学习英语字母的时候用的四线谱：<br><img src="./images/baselineAligned_expand.png" alt="基线示意图"><br>其中红线就是基线（baseline），和下面我们书写英语字母的四线谱是不是很像，基线就是第三条。<br><img src="./images/baselineAligned_ch.png" alt="英语书写四线谱"></li>
</ul>
<ul>
<li>源码之垂直方向测量（void measureVertical(int widthMeasureSpec, int heightMeasureSpec)）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Measures the children when the orientation of this LinearLayout is set</span><br><span class="line">     * to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.</span><br><span class="line">     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.</span><br><span class="line">     *</span><br><span class="line">     * @see #getOrientation()</span><br><span class="line">     * @see #setOrientation(int)</span><br><span class="line">     * @see #onMeasure(int, int)</span><br><span class="line">     */</span><br><span class="line">    void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		// mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">		// maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">		// 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		* 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">		* 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">		* 否则，则跟maxWidth的计算方法一样</span><br><span class="line">		*/</span><br><span class="line">		// 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">		// 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">		// 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">		// 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">		// 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">		// 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">		// 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // See how tall everyone is. Also remember max width.</span><br><span class="line"></span><br><span class="line">		//查看每一个高，并记住最大宽度</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">			//首先获取子View</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">			//如果子View是null就继续测量下一个子View</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">				// 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">			//如果子View是GONE的也不算在总高度里面，这里也能看出GONE和INVISIBLE的区别</span><br><span class="line">            if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">				// 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line">			//有时候我们在代码里面通过Inflater服务，动态加载一个布局，然后去设置他的LayoutParams，</span><br><span class="line">			//如果不引用父容器的LayoutParams就会报一个强转错误，原因就在这个父容器在add,measure的时候都会</span><br><span class="line">			//把子View的LayoutParams强转成自己的类型</span><br><span class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">			//得到每个子控件的LayoutParams后，累加权重和,后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束,基本没有用到</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">			//这里就值得注意下了如果当前的LinearLayout是EXACTLY模式，且子view的高度为0，且权重大于0</span><br><span class="line">			//这个子view只有在LinearLayout高度有剩余的时候，才会根据权重的占比去平分剩余空间</span><br><span class="line">			//上文说的二次测量也就指的这部分</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // Optimization: don&apos;t bother measuring children who are going to use</span><br><span class="line">                // leftover space. These views will get measured again down below if</span><br><span class="line">                // there is any leftover space.</span><br><span class="line">				// 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0   	</span><br><span class="line"></span><br><span class="line">				// 如果LinearLayout的垂直方向测量模式是EXACTLY，即确定值，且子视图的高度为0，weight大于0，</span><br><span class="line">        //则先将总高度加上子视图的topMargin和bottomMargin，并设置skippedMeasure（暂时跳过测量标识）为true</span><br><span class="line"></span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法，此时需要记住view的topMargin和bottomMargin（对于方向为）</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">				// 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // heightMode is !!either UNSPECIFIED or AT_MOST!!, and this</span><br><span class="line">                    // child wanted to stretch to fill available space.</span><br><span class="line">                    // Translate that to WRAP_CONTENT so that it does not end up</span><br><span class="line">                    // with a height of 0</span><br><span class="line">					// 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line"></span><br><span class="line">					//这里其实官方的注释讲了也挺清楚的，到了这步，当前的LinearLayout的模式</span><br><span class="line">					//肯定是UNSPECIFIED或者MOST，因为EXACTLY模式会进入上一个判断</span><br><span class="line">					//然后把子View的高度赋值成-1(WRAP_CONTENT)</span><br><span class="line">					// 如果垂直方向测量模式为UNSPECIFIED或AT_MOST，同时子视图想要尽量获取可用的剩余空间，</span><br><span class="line">          //把子视图的高度改为WRAP_CONTENT，这样子视图的最终高度就不会是0</span><br><span class="line"></span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Determine how big this child would like to be. If this or</span><br><span class="line">                // previous children have given a weight, then we allow it to</span><br><span class="line">                // use all available space (and we will shrink things later</span><br><span class="line">                // if needed).</span><br><span class="line">				/**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line"></span><br><span class="line">				// 这个函数最后会调用child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</span><br><span class="line">        //测量出子视图要占用多大空间，并设置子视图的mMeasuredWidth和mMeasuredHeight</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">				// 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line"></span><br><span class="line">				// getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">				//加上子View的margin值</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">				// 重新设置最大子视图高度</span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * If applicable, compute the additional offset to the child&apos;s baseline</span><br><span class="line">             * we&apos;ll need later when asked &#123;@link #getBaseline&#125;.</span><br><span class="line">             */</span><br><span class="line">			// 计算子视图baseline的偏移量</span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // if we are trying to use a child index for our baseline, the above</span><br><span class="line">            // book keeping only works if there are no children above it with</span><br><span class="line">            // weight.  fail fast to aid the developer.</span><br><span class="line">			// 如果要为baseline指定子视图索引，只有在此子视图之上的视图没有设置weight属性时才有效</span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 下面开始测量宽度</span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // The width of the linear layout will scale, and at least one</span><br><span class="line">                // child said it wanted to match our width. Set a flag</span><br><span class="line">                // indicating that we need to remeasure at least that view when</span><br><span class="line">                // we know our width.</span><br><span class="line">				//如果LinearLayout宽度不是已确定的，如wrap_content,而子视图是MATCH_PARENT，  </span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 计算子视图总宽度（包含左右外边距）</span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">			// 合并子元素的测量状态</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">			// 子视图宽度是否都为MATCH_PARENT</span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Widths of weighted Views are bogus if we end up</span><br><span class="line">                 * remeasuring, so keep them separate.</span><br><span class="line">                 */</span><br><span class="line">				//如设置了weigh属性，则子视图的宽度需要在父视图确定后才能确定。这里并不是真实的宽度  </span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">		//for 循环结束</span><br><span class="line"></span><br><span class="line">		// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过</span><br><span class="line">        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">			// 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，</span><br><span class="line">      //重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                // Account for negative margins</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//在这两段代码之间还有些杂七杂八的处理，如果读者有兴趣可以自己阅读分析下</span><br><span class="line">		//当测量完子View的大小后，总高度会再加上padding的高度</span><br><span class="line">        // Add in our padding</span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        int heightSize = mTotalLength;</span><br><span class="line">		    //如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较</span><br><span class="line">        //然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值</span><br><span class="line">        // Check against our minimum height</span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        // Reconcile our calculated size with the heightMeasureSpe</span><br><span class="line">		// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，</span><br><span class="line">    //剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）</span><br><span class="line">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line">		//到了这里，会再对带weight属性的子View进行一次测绘</span><br><span class="line">        //首先计算剩余高度</span><br><span class="line"></span><br><span class="line">		//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的</span><br><span class="line">        // Either expand children with weight to take up available space or</span><br><span class="line">        // shrink them if they extend beyond our current bounds. If we skipped</span><br><span class="line">        // measurement on any children, we need to measure them now.</span><br><span class="line">        int delta = heightSize - mTotalLength;</span><br><span class="line">        if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123;</span><br><span class="line">			//如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦</span><br><span class="line">            float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = 0;</span><br><span class="line">			//这里的代码就和第一次测量很像了</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                float childExtra = lp.weight;</span><br><span class="line">                if (childExtra &gt; 0) &#123;</span><br><span class="line">					// 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure</span><br><span class="line">					//子控件的weight占比*剩余高度</span><br><span class="line">                    // Child said it could absorb extra space -- give him his share</span><br><span class="line">                    int share = (int) (childExtra * delta / weightSum);</span><br><span class="line">					// weightSum计余</span><br><span class="line">                    weightSum -= childExtra;</span><br><span class="line">					//剩余高度减去分配出去的高度</span><br><span class="line">                    delta -= share;</span><br><span class="line"></span><br><span class="line">                    final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight +</span><br><span class="line">                                    lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line">					//如果是当前LinearLayout的模式是EXACTLY</span><br><span class="line">                    //那么这个子View是没有被测量过的，就需要测量一次</span><br><span class="line">                    //如果不是EXACTLY的，在第一次循环里就被测量一些了</span><br><span class="line">                    // TODO: Use a field like lp.isMeasured to figure out if this</span><br><span class="line">                    // child has been previously measured</span><br><span class="line">                    if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        // child was measured once already above...</span><br><span class="line">                        // base new measurement on stored values</span><br><span class="line">						//如果是非EXACTLY模式下的子View就再加上</span><br><span class="line">                        //weight分配占比*剩余高度</span><br><span class="line">						// 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小</span><br><span class="line">                        int childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                        if (childHeight &lt; 0) &#123;</span><br><span class="line">                            childHeight = 0;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">						//重新测量一次，因为高度发生了变化</span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // child was skipped in the loop above.</span><br><span class="line">                        // Measure for this first time here  </span><br><span class="line"></span><br><span class="line">						//如果是EXACTLY模式下的</span><br><span class="line">                        //这里只会把weight占比所拥有的高度分配给你的子View</span><br><span class="line">						// 上面测量的时候被跳过，那么在这里进行测量    </span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Child may now not fit in vertical dimension.</span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里得到最终高度</span><br><span class="line">            // Add in our padding</span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            // TODO: Should we recompute the heightSpec based on the new total length?</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			 // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // We have no limit, so make all weighted views as tall as the largest child.</span><br><span class="line">            // Children will have already been measured once.</span><br><span class="line">			// 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次</span><br><span class="line">            if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                    if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    float childExtra = lp.weight;</span><br><span class="line">                    if (childExtra &gt; 0) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        // Check against our minimum width</span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">		// 设置测量完的宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        if (matchWidth) &#123;</span><br><span class="line">			// 使宽度一致</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在垂直绘制中主要执行逻辑在两大块代码，第一个for循环，第二个if判断中的for循环，接下来我们分块分析该函数源码：</p>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;      </span><br><span class="line">        // mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">        // maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">        // 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">         * 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">         * 否则，则跟maxWidth的计算方法一样</span><br><span class="line">         */</span><br><span class="line">        // 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">        // 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">        // 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">        // 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">        // 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        // 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        // 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // ...... 底下两个for循环</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在变量定义中，我们主要留意三个方面：</p>
<ul>
<li>mTotalLength：这个就是最终得到的整个LinearLayout的高度（子控件高度累加及自身padding）</li>
<li>三个跟width相关的变量</li>
<li>weight相关的变量</li>
</ul>
<h4 id="第一个for代码块和baselineChildIndex处理"><a href="#第一个for代码块和baselineChildIndex处理" class="headerlink" title="第一个for代码块和baselineChildIndex处理"></a>第一个for代码块和baselineChildIndex处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // ...上面的一大堆局部变量</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                // 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (child.getVisibility() == GONE) &#123;</span><br><span class="line">               // 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerWidth;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            // 得到每个子控件的LayoutParams后，累加权重和，后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            // 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0</span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">                // 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                // getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">        //... 底下第二个for循环</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">  在第一个for循环中，主要是if()&#123;&#125;else&#123;&#125;分支，判断是heightMode == MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">  lp.height == 0 &amp;&amp; lp.weight &gt; 0，这个主要是linearLayout测量模式为EXACTLY且子视图明确</span><br><span class="line"> 了是使用linearLayout的剩余空间，此时将其上下间距计入总高度并以之前的做对比去大值，并设置</span><br><span class="line"> skippedMeasure标志为true。而在else中则为复杂点，else中首先对lp.height == 0 &amp;&amp;</span><br><span class="line">  lp.weight &gt; 0的子视图的height做预处理使其为LayoutParams.WRAP_CONTENT（因为父类即</span><br><span class="line">  LinearLayout此时是wrap_content，或者mode为UNSPECIFIED），接着对子视图进行测量（</span><br><span class="line">  这个受总权重影响），并将其高度和上下间距计入到总高度中。之后对baselineChildIndex做处理，</span><br><span class="line">  计入总的基线高度并判定基线配置是否合理，不合理抛出异常，最后根据子视图设置最大宽度、</span><br><span class="line">  allFillParent、weightedMaxWidth或alternativeMaxWidth变量。</span><br><span class="line"></span><br><span class="line">#### 第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行前的处理 ####</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>// … 局部变量定义和第一个for循环<br>// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过<br>        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) {<br>            mTotalLength += mDividerHeight;<br>        }</p>
<pre><code>  if (useLargestChild &amp;&amp;
          (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
      mTotalLength = 0;

      // 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，
//重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸
      for (int i = 0; i &lt; count; ++i) {
          final View child = getVirtualChildAt(i);

          if (child == null) {
              mTotalLength += measureNullChild(i);
              continue;
          }

          if (child.getVisibility() == GONE) {
              i += getChildrenSkipCount(child, i);
              continue;
          }

          final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                  child.getLayoutParams();
          // Account for negative margins
          final int totalLength = mTotalLength;
          mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                  lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }
  }
  //... 第2个重要代码块
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里主要对useLargestChild属性处理，执行前提是设置了useLargestChild属性，且LinearLayout的垂直</span><br><span class="line">方向测量模式是AT_MOST或UNSPECIFIED，重新测量总高度，useLargestChild属性会使所有带weight属性的子视</span><br><span class="line">图具有最大子视图的最小尺寸</span><br><span class="line"></span><br><span class="line">第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行逻辑</span><br></pre></td></tr></table></figure>
<p>//当测量完子View的大小后，总高度会再加上padding的高度<br>        // Add in our padding<br>        mTotalLength += mPaddingTop + mPaddingBottom;</p>
<pre><code>int heightSize = mTotalLength;
//如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较
//然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值
// Check against our minimum height
heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

// Reconcile our calculated size with the heightMeasureSpe
// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）
int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;

//到了这里，会再对带weight属性的子View进行一次测绘
//首先计算剩余高度

//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的
// Either expand children with weight to take up available space or
// shrink them if they extend beyond our current bounds. If we skipped
// measurement on any children, we need to measure them now.
int delta = heightSize - mTotalLength;
if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) {
    //如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦
    float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;

    mTotalLength = 0;
    //这里的代码就和第一次测量很像了
    for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);

        if (child.getVisibility() == View.GONE) {
            continue;
        }

        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

        float childExtra = lp.weight;
        if (childExtra &gt; 0) {
            // 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure
            //子控件的weight占比*剩余高度
            // Child said it could absorb extra space -- give him his share
            int share = (int) (childExtra * delta / weightSum);
            // weightSum计余
            weightSum -= childExtra;
            //剩余高度减去分配出去的高度
            delta -= share;

            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                    mPaddingLeft + mPaddingRight +
                            lp.leftMargin + lp.rightMargin, lp.width);
            //如果是当前LinearLayout的模式是EXACTLY
            //那么这个子View是没有被测量过的，就需要测量一次
            //如果不是EXACTLY的，在第一次循环里就被测量一些了
            // TODO: Use a field like lp.isMeasured to figure out if this
            // child has been previously measured
            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                // child was measured once already above...
                // base new measurement on stored values
                //如果是非EXACTLY模式下的子View就再加上
                //weight分配占比*剩余高度
                // 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小
                int childHeight = child.getMeasuredHeight() + share;
                if (childHeight &lt; 0) {
                    childHeight = 0;
                }

                //重新测量一次，因为高度发生了变化
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
            } else {
                // child was skipped in the loop above.
                // Measure for this first time here  

                //如果是EXACTLY模式下的
                //这里只会把weight占比所拥有的高度分配给你的子View
                // 上面测量的时候被跳过，那么在这里进行测量    
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,
                                MeasureSpec.EXACTLY));
            }

            // Child may now not fit in vertical dimension.
            childState = combineMeasuredStates(childState, child.getMeasuredState()
                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
        }

        final int margin =  lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);

        boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;
                lp.width == LayoutParams.MATCH_PARENT;

        alternativeMaxWidth = Math.max(alternativeMaxWidth,
                matchWidthLocally ? margin : measuredWidth);

        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
    }
    // 这里得到最终高度
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
} else {
     // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略
    alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);


    // We have no limit, so make all weighted views as tall as the largest child.
    // Children will have already been measured once.
    // 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次
    if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) {
        for (int i = 0; i &lt; count; i++) {
            final View child = getVirtualChildAt(i);

            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            float childExtra = lp.weight;
            if (childExtra &gt; 0) {
                child.measure(
                        MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(largestChildHeight,
                                MeasureSpec.EXACTLY));
            }
        }
    }
}
</code></pre><p>```<br>在进入ifelse分支前，先计算视图的总高度，并与测量模式进行比较（resolveSizeAndState）得到最终高度，<br>在减去总高度，得到最终还剩多高（也就是可以分配给带权重的视图的高）；<br>ifelse首先判断（skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f），</p>
<ul>
<li><p>如果该条件为true，先将总高度置为0再进入for循环，此处根据子视图的权重，再次判定(lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)</p>
<ul>
<li>true：子视图再次测量 则计算子视图可以得到多少高（有可能为负，也就是子视图要吐出一定高度出来），然后子视图测量高度和分配的高度相加，小于0，则重置为0，最后在测量一次。</li>
<li><p>false：直接测量子视图，这个是之前被跳过没有测量的子视图；<br>最后再次测量视图的宽和总高度。</p>
</li>
<li><p>如果该条件为false：看useLargestChild参数，如果都无相关，那就走layout流程了，<br>我们可以看到这里直接判断是useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY，如果条件成立的话，遍历子视图，再次判断子视图是否含有权重，如果有则直接将子视图高度都是largestChildHeight。如果条件不成立，则啥也不做。</p>
</li>
</ul>
</li>
</ul>
<p>最后就是视图maxWidth计算，并setMeasuredDimension（这个是一定要的），自此垂直方向已经测量完毕。</p>
<p><strong>总结</strong><br>这里大篇幅讲解measureVertical()的流程，事实上对于LinearLayout来说，其最大的特性也正是两个<br>方向的排布以及weight的计算方式。回过头来看测量过程，我们可以看出设计者的测量计算思路，就是将有weight<br>和不含有weight的测量分开处理，再利用height跟0比较来更加的细分每一种情况。<br>最后我们在理下其测量不同情况和原理：</p>
<ul>
<li>父控件为match_parent（或者精确值），子控件拥有weight，并且高度给定为0，也即子控件明确表示使用剩余空间：<ul>
<li>子控件的高度比例将会跟我们分配的layout_weight一致，原因在于weight二次测量时走了else分支，传入的是计算出来的share值；</li>
</ul>
</li>
<li>父控件是match_parent（或者精确值），子控件拥有weight，但高度给定为match_parent（或者精确值），子控件使用自己的高度或者父控件的高度，但在父控件空间不足时，其大小可以调整：<ul>
<li>子控件高度比例将会跟我们分配的layout_weight相反，原因在于在此之前子控件测量过一次，同时子控件的测量高度为父控件的高度，在计算剩余空间的时候得出一个负值，加上自身的测量高度的时候反而更小；</li>
</ul>
</li>
<li>父控件是wrap_content，子控件拥有weight：<ul>
<li>子控件的高度将会强行置为其wrap_content给的值并以wrap_content模式进行测量</li>
</ul>
</li>
<li>父控件是wrap_content，子控件没有weight：<ul>
<li>子控件的高度跟其他的viewgroup一致</li>
</ul>
</li>
</ul>
<p>自此，LinearLayout在垂直方向的测量分析已经结束。</p>
<p>参考地址：<br>[1]. baselineAligned解析 <a href="http://www.bubuko.com/infodetail-612730.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-612730.html</a><br>[2]. measureWithLargestChild使用解析 <a href="https://blog.csdn.net/a87b01c14/article/details/49420449" target="_blank" rel="noopener">https://blog.csdn.net/a87b01c14/article/details/49420449</a><br>[3]. LinearLayout垂直测量分析 <a href="https://www.jianshu.com/p/aea27bac7c8e" target="_blank" rel="noopener">https://www.jianshu.com/p/aea27bac7c8e</a><br>[4]. view和LinearLayout源码分析 <a href="https://www.jianshu.com/p/f9b9f05222a8" target="_blank" rel="noopener">https://www.jianshu.com/p/f9b9f05222a8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/22/android-camera2预览拍照录制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/android-camera2预览拍照录制/" itemprop="url">android-camera2预览拍照录制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T10:06:52+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android 5.0(Lollipop)增加了Camera2 API，并将原有的Camera API标记为废弃。对于原有的Camera API来说，Camera2重新定义了相机的API，也重构了相机API的架构。在Camera2中其主要思想是基于会话模式和事件驱动与相机实现交互，对于预览、拍照、录制等操作都是在会话的基础下请求某种类型的会话操作。</p>
<p>比如一次拍照的操作：<br><img src="&quot;./images/take-picture.png&quot;" alt="拍照">    </p>
<p>下面一起看下camera2的操作：</p>
<ol>
<li>相机初始化<br>我们知道要使用相机，首先我们需要获得相关的权限，主要是在manifest中定义，其次在Android6.0还需要动态获取权限。</li>
</ol>
<ul>
<li>在manifest中定义需要的权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果要保存照片、录制视频，还需要两个权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>相机功能：相机特性，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>动态权限申请<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final String[] VIDEO_PERMISSIONS = &#123;</span><br><span class="line">           Manifest.permission.CAMERA,</span><br><span class="line">           Manifest.permission.RECORD_AUDIO,</span><br><span class="line">           Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">           Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">   &#125;;</span><br><span class="line">......</span><br><span class="line">   if (!hasPermissionsGranted(getApplicationContext(), VIDEO_PERMISSIONS)) &#123;</span><br><span class="line">               requestPermissions(VIDEO_PERMISSIONS, 1);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">hasPermissionsGranted(Context context, String[] permissions) &#123;</span><br><span class="line">       for (String permission : permissions) &#123;</span><br><span class="line">           if (ActivityCompat.checkSelfPermission(context, permission)</span><br><span class="line">                   != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上基础工作好了基本可以开始对相机操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//初始化相机设备</span><br><span class="line">private void initCamera() &#123;</span><br><span class="line">       //设备管理类</span><br><span class="line">       cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">       try &#123;</span><br><span class="line">         //获取相机设备特征类，通过该类可以获取相机的一些特性，如相机的方向</span><br><span class="line">           CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraManager.getCameraIdList()[0]);</span><br><span class="line">           mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">           Log.e(TAG, &quot;sensor_orientation is :&quot; + mSensorOrientation);</span><br><span class="line">           StreamConfigurationMap streamConfigurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);</span><br><span class="line">           //获取录制视屏时的宽高，这个通过MediaRecorder类获取系统支持的录制视频的宽高，主要是防止配置录制适配配置时失败</span><br><span class="line">           mVideoSize = chooseVideoSize(streamConfigurationMap.getOutputSizes(MediaRecorder.class));</span><br><span class="line">           //根据录制视频支持的宽高和SurfaceTexture支持的宽高，以及当前视图的宽高设置预览视图的宽高</span><br><span class="line">           mPreviewSize = chooseOptimalSize(streamConfigurationMap.getOutputSizes(SurfaceTexture.class), surfaceView.getWidth(), surfaceView.getHeight(), mVideoSize);</span><br><span class="line">           //imageReader初始化，用于获取拍照信息</span><br><span class="line">           imageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(), ImageFormat.JPEG, 2);</span><br><span class="line">           imageReader.setOnImageAvailableListener(new ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onImageAvailable(ImageReader reader) &#123;</span><br><span class="line">                   imageView.setVisibility(View.VISIBLE);</span><br><span class="line">                   // 拿到拍照照片数据</span><br><span class="line">                   Image image = reader.acquireNextImage();</span><br><span class="line">                   ByteBuffer buffer = image.getPlanes()[0].getBuffer();</span><br><span class="line">                   byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                   buffer.get(bytes);//由缓冲区存入字节数组</span><br><span class="line">                   final Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);</span><br><span class="line">                   if (bitmap != null) &#123;</span><br><span class="line">                       imageView.setImageBitmap(bitmap);</span><br><span class="line">                   &#125;</span><br><span class="line">                   updatePreView();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, mainHandler);</span><br><span class="line">           //打开摄像头，stateCallback为相机的状态监听回调</span><br><span class="line">           cameraManager.openCamera(cameraManager.getCameraIdList()[0], stateCallback, mainHandler);</span><br><span class="line">           mMediaRecorder = new MediaRecorder();</span><br><span class="line">           Log.d(TAG, &quot;open camera&quot;);</span><br><span class="line"></span><br><span class="line">       &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的开启相机后有一个回调，stateCallback,该回调是用来返回相机是否正常打开的状态的</span><br><span class="line">     private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onOpened(@NonNull CameraDevice cameraDevice) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera open&quot;);</span><br><span class="line">             mCameraDevice = cameraDevice;</span><br><span class="line">             takePreview();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onDisconnected(@NonNull CameraDevice cameraDevice) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera onDisconnected&quot;);</span><br><span class="line"></span><br><span class="line">             if (null != mCameraDevice) &#123;</span><br><span class="line">                 mCameraDevice.close();</span><br><span class="line">                 mCameraDevice = null;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onError(@NonNull CameraDevice cameraDevice, int i) &#123;</span><br><span class="line">             Log.d(TAG, &quot;camera onError&quot;);</span><br><span class="line">             cameraDevice.close();</span><br><span class="line">             mCameraDevice = null;</span><br><span class="line">             Toast.makeText(ImageShowActivity.this, &quot;摄像头开启失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>开启相机预览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 开始预览,此处创建一个捕获视频信息的请求，以此来获取一个会话session，在获取会话时监听其配置状态，一旦成功，则此时通过会话构建一个重复预览的请求；</span><br><span class="line">   */</span><br><span class="line">  private void takePreview() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          closePreviewSession();</span><br><span class="line">          SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">          surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">          Log.e(TAG, &quot;preview SurfaceTexture buffer size is width:&quot; + mPreviewSize.getWidth() + &quot; height :&quot; + mPreviewSize.getHeight());</span><br><span class="line">          Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line">          List&lt;Surface&gt; surfaces = new ArrayList&lt;&gt;();</span><br><span class="line">          surfaces.add(previewSurface);</span><br><span class="line">          surfaces.add(imageReader.getSurface());</span><br><span class="line">          // 创建CameraCaptureSession，该对象负责管理处理预览请求和拍照请求</span><br><span class="line">          mCameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() //</span><br><span class="line">          &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void onConfigured(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                  Log.d(&quot;onConfigured&quot;, &quot;onConfigured&quot;);</span><br><span class="line">                  if (null == mCameraDevice) return;</span><br><span class="line">                  // 当摄像头已经准备好时，开始显示预览</span><br><span class="line">                  mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                  updatePreView();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              @Override</span><br><span class="line">              public void onConfigureFailed(CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                  Log.d(&quot;onConfigureFailed&quot;, &quot;onConfigureFailed&quot;);</span><br><span class="line"></span><br><span class="line">                  Toast.makeText(ImageShowActivity.this, &quot;配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, childHandler);</span><br><span class="line">      &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">    * 更新预览视图，构建一个TEMPLATE_PREVIEW捕获请求，此时是对会话进行设置！！！setRepeatingRequest！！！</span><br><span class="line">    */  </span><br><span class="line">  private void updatePreView() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           // 创建预览需要的CaptureRequest.Builder</span><br><span class="line">           CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">           // 将SurfaceView的surface作为CaptureRequest.Builder的目标</span><br><span class="line">           SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">           Log.e(TAG, &quot;update preview SurfaceTexture buffer size is width:&quot; + mPreviewSize.getWidth() + &quot; height :&quot; + mPreviewSize.getHeight());</span><br><span class="line">           surfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">           Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line"></span><br><span class="line">           mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">           mPreviewBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">           mCameraCaptureSession.setRepeatingRequest(mPreviewBuilder.build(), null, childHandler);</span><br><span class="line">       &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拍照</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 拍照，构建一个TEMPLATE_STILL_CAPTURE静态的相机信息捕获请求，需要注意的是需要获取ImageReader的surface并将其作为捕获去请求的目标输出。</span><br><span class="line">     */</span><br><span class="line">private void takePicture() &#123;</span><br><span class="line">      if (mCameraDevice == null)</span><br><span class="line">          return;</span><br><span class="line">      // 创建拍照需要的CaptureRequest.Builder</span><br><span class="line">      try &#123;</span><br><span class="line">          CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">          // 将surfaceHolder的surface作为CaptureRequest.Builder的目标</span><br><span class="line">          captureRequestBuilder.addTarget(imageReader.getSurface());</span><br><span class="line">          // 自动对焦</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">          // 自动曝光</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);</span><br><span class="line">          // 获取手机方向，手机竖屏和平板的方向是不同的，需要调整。</span><br><span class="line">          int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">          // 根据设备方向计算设置照片的方向</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line">          //拍照</span><br><span class="line">          CaptureRequest mCaptureRequest = captureRequestBuilder.build();</span><br><span class="line">          mCameraCaptureSession.capture(mCaptureRequest, null, childHandler);</span><br><span class="line">      &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * Retrieves the JPEG orientation from the specified screen rotation.</span><br><span class="line">    *</span><br><span class="line">    * @param rotation The screen rotation.</span><br><span class="line">    * @return The JPEG orientation (one of 0, 90, 270, and 360)</span><br><span class="line">    */</span><br><span class="line">   private int getOrientation(int rotation) &#123;</span><br><span class="line">       // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)</span><br><span class="line">       // We have to take that into account and rotate JPEG properly.</span><br><span class="line">       // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.</span><br><span class="line">       // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.</span><br><span class="line">       return (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>录制视频</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 视屏录制，比较上层api是直接通过Recorder类来实现录制，通过这个不需要自己对视屏数据进行处理，只需要指定具体编码格式即可，同时注意这里是重启一个会话。</span><br><span class="line">     */</span><br><span class="line">    private void startRecordingVideo() &#123;</span><br><span class="line">        //关闭预览会话</span><br><span class="line">        closePreviewSession();</span><br><span class="line">        //对Recoder类进行设置</span><br><span class="line">        setUpMediaRecorder();</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建录制的session会话中的请求</span><br><span class="line">            CaptureRequest.Builder mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">            //向CaptureRequest添加surface</span><br><span class="line">            SurfaceTexture surfaceTexture = surfaceView.getSurfaceTexture();</span><br><span class="line">            Log.e(TAG, &quot;video SurfaceTexture  buffer size is width:&quot; + mVideoSize.getWidth() + &quot; height :&quot; + mVideoSize.getHeight());</span><br><span class="line">            surfaceTexture.setDefaultBufferSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">            Surface previewSurface = new Surface(surfaceTexture);</span><br><span class="line">            mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line">            //向CaptureRequest添加surface</span><br><span class="line">            mPreviewBuilder.addTarget(mMediaRecorder.getSurface());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            mCameraDevice.createCaptureSession(Arrays.asList(previewSurface, mMediaRecorder.getSurface()), new</span><br><span class="line">                    CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                            mCameraCaptureSession = cameraCaptureSession;</span><br><span class="line">                            updatePreView();</span><br><span class="line">                            runOnUiThread(new Runnable() &#123;</span><br><span class="line">                                @Override</span><br><span class="line">                                public void run() &#123;</span><br><span class="line">                                    mMediaRecorder.start();</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) &#123;</span><br><span class="line">                            Log.d(&quot;onConfigureFailed&quot;, &quot;onConfigureFailed&quot;);</span><br><span class="line"></span><br><span class="line">                            Toast.makeText(ImageShowActivity.this, &quot;RecordingVideo 配置失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, childHandler);</span><br><span class="line">        &#125; catch (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 对Recorder类进行设置，主要包括音频、视频源、视频输出格式、输出路径、编码频率、视频帧频率、视频宽高、视频编码格式、音频编码格式</span><br><span class="line">     */</span><br><span class="line">    private void setUpMediaRecorder() &#123;</span><br><span class="line">        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">        mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">        //!!!这里需要设置路径，要不获取surface时会为空。context.getExternalFilesDir(null);</span><br><span class="line">        mMediaRecorder.setOutputFile(Environment</span><br><span class="line">                .getExternalStorageDirectory() + &quot;/&quot; + System.currentTimeMillis() + &quot;.mp4&quot;);</span><br><span class="line">        mMediaRecorder.setVideoEncodingBitRate(10000000);</span><br><span class="line">        mMediaRecorder.setVideoFrameRate(30);</span><br><span class="line">        // 设置视频录制的分辨率。必须放在设置编码和格式的后面，否则报错!!!!!!需要小心设置，同时需要根据Recorder类来遴选出当前设备支持的分辨率，如果不恰当，则录制视频的时候会显示配置失败</span><br><span class="line">        Log.e(TAG, &quot;video size is width:&quot; + mVideoSize.getWidth() + &quot; height :&quot; + mVideoSize.getHeight());</span><br><span class="line">        mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line"></span><br><span class="line">        mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">        mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">        int rotation = getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        //调整视频的方向</span><br><span class="line">        switch (mSensorOrientation) &#123;</span><br><span class="line">            case SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">                break;</span><br><span class="line">            case SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">                mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mMediaRecorder.prepare();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>手机支持的一些分辨率：<br>width:4608 height:3456<br>width:4608 height:2304<br>width:3456 height:3456<br>width:3840 height:2160<br>width:3280 height:2448<br>width:3264 height:2448<br>width:3264 height:1840<br>width:3264 height:1632<br>width:2448 height:2448<br>width:2592 height:1952<br>width:2048 height:1536<br>width:1920 height:1080<br>width:1440 height:1080<br>width:1536 height:864<br>width:1456 height:1456<br>width:1920 height:960<br>width:1440 height:720<br>width:1280 height:960<br>width:1280 height:720<br>width:960 height:720</p>
<p>参考地址：<br>[1].官网示例 <a href="https://github.com/googlesamples/android-Camera2Basic" target="_blank" rel="noopener">https://github.com/googlesamples/android-Camera2Basic</a><br>[2]. <a href="https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/z_x_Qiang/article/details/77600880?locationNum=1&amp;fps=1</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/17/http之head解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/17/http之head解析/" itemprop="url">http之head解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T11:31:15+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th style="text-align:left">Header</th>
<th style="text-align:left">Header 解释</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">表明服务器是否支持指定范围请求及那种类型的分段请求</td>
<td style="text-align:left">Accept-Ranges: bytes</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td style="text-align:left">Age：12</td>
</tr>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">对某网络资源的有效请求行为，不允许则返回405</td>
<td style="text-align:left">Allow：GET，HEAD</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">告诉所有的缓存机制是否可以缓存及那种类型</td>
<td style="text-align:left">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">web服务器支持的返回内容压缩编码类型</td>
<td style="text-align:left">Content-Encoding:gzip</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">响应体的语言</td>
<td style="text-align:left">Content-Language: en,zh</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">响应体的长度</td>
<td style="text-align:left">Content-Length:348</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">请求资源可替代的备用的另一个地址</td>
<td style="text-align:left">Content-Location: /index.htm</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">返回资源的MD5校验值</td>
<td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">在整个返回体中本部分的字节位置</td>
<td style="text-align:left">Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td style="text-align:left">Content-type</td>
<td style="text-align:left">返回内容的MIME类型</td>
<td style="text-align:left">Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">原始服务器消息发出的时间</td>
<td style="text-align:left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">请求变量的实体标签的当前值</td>
<td style="text-align:left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">响应过期的日期和时间</td>
<td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">请求资源的最后修改时间</td>
<td style="text-align:left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">用来重定向接收方到非请求URL的位置来完成请求和标识新的资源</td>
<td style="text-align:left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td style="text-align:left">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">它指出认证方案和可应用到代理的该URL上的参数</td>
<td style="text-align:left">Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td style="text-align:left">refresh</td>
<td style="text-align:left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td style="text-align:left">Refresh: 5; url=</td>
</tr>
</tbody>
</table>
<p><a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a> |<br>| Retry-After | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试  | Retry-After: 120 |<br>| Server | web服务器软件名称 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) |<br>| Set-Cookie | 设置Http Cookie | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 |<br>| Trailer | 指出头域在分块传输编码的尾部存在 | Trailer: Max-Forwards |<br>| Transfet-Encoding | 文件传输编码 | Transfer-Encoding:chunked |<br>| Vary | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: * |<br>| Via | 告诉代理客户端响应是通过哪里发送的 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) |<br>| Warning | 警告实体可能存在的问题 | Warning: 199 Miscellaneous warning |<br>| WWW-Authenticate | 表明客户端请求实体应该使用的授权方案  | WWW-Authenticate: Basic |</p>
<h3 id="HTTP-Request的Header信息"><a href="#HTTP-Request的Header信息" class="headerlink" title="HTTP Request的Header信息"></a>HTTP Request的Header信息</h3><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文。请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：<br>POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1<br>一个简单的请求头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /rest/sur?dk=28192985&amp;ak=23565637&amp;av=4.5.0&amp;c=default-Channel&amp;v=3.0&amp;s=72eec83f97e2d4b15457f2b348b450d2&amp;d=Wp4zp4JKnXIDAPzAGdNq5Fdp&amp;sv=6.2.0&amp;p=MacOSX&amp;t=1531794939&amp;u=&amp;is=0 HTTP/1.1</span><br><span class="line">Host	adash.m.taobao.com</span><br><span class="line">Content-Type	multipart/form-data; boundary=--iphone_BOUNDARY--</span><br><span class="line">Connection	keep-alive</span><br><span class="line">Accept	*/*</span><br><span class="line">User-Agent	%E9%92%89%E9%92%89/400 CFNetwork/901.1 Darwin/17.6.0 (x86_64)</span><br><span class="line">Accept-Language	zh-cn</span><br><span class="line">Accept-Encoding	gzip</span><br><span class="line">Content-Length	702</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HTTP请求方式</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">向Web服务器请求一个文件</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">向Web服务器发送数据让Web服务器进行处理</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">向Web服务器发送数据并存储在Web服务器内部</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">检查一个对象是否存在</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">从Web服务器上删除一个文件</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">对通道提供支持</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">跟踪到服务器的路径</td>
</tr>
<tr>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">查询Web服务器的性能</td>
</tr>
</tbody>
</table>
<p>说明：<br>主要使用到“GET”和“POST”。</p>
<p>实例：<br>POST /test/tupian/cm HTTP/1.1<br>分成三部分：</p>
<ul>
<li><p>POST：HTTP请求方式</p>
</li>
<li><p>/test/tupian/cm：请求Web服务器的目录地址（或者指令）</p>
</li>
<li><p>HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本</p>
</li>
</ul>
<p><strong>备注：</strong>  在Ajax中，对应method属性设置。</p>
<ol>
<li>Host</li>
</ol>
<p>说明：<br>请求的web服务器域名地址</p>
<p>实例：<br>例如web请求URL：<a href="http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm" target="_blank" rel="noopener">http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cm</a> ，Host就为zjm-forum-test10.zjm.baidu.com:8088</p>
<ol>
<li>User-Agent</li>
</ol>
<p>说明：<br>HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。</p>
<p>实例：<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11</p>
<ol>
<li>Accept</li>
</ol>
<p>说明：<br>指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。</p>
<p>实例：<br>Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,<em>/</em>;q=0.5</p>
<p>备注：<br>在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/javascript, text/html, application/xml, text/xml, <em>/</em>”。这是因为Ajax默认获取服务器返回的Json数据模式。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。</p>
<ol>
<li>Accept-Language</li>
</ol>
<p>说明：<br>指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。</p>
<p>实例：<br>Accept-Language: zh-cn,zh;q=0.5   ,这里默认为中文。</p>
<ol>
<li>Accept-Encoding</li>
</ol>
<p>说明：<br>指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。</p>
<p>实例：<br>Accept-Encoding: gzip,deflate</p>
<p><strong>备注：</strong>  其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。</p>
<p>另外有关deflate压缩介绍：<a href="http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html" target="_blank" rel="noopener">http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html</a></p>
<ol>
<li>Accept-Charset</li>
</ol>
<p>说明：<br>浏览器可以接受的字符编码集。</p>
<p>实例：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7</p>
<ol>
<li>Content-Type</li>
</ol>
<p>说明：  显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。</p>
<p>实例：  Content-type: application/x-www-form-urlencoded;charset:UTF-8</p>
<p>有关Content-Type属性值可以如下两种编码类型：  </p>
<ul>
<li>“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。</li>
<li>“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。  </li>
</ul>
<p>当提交为表单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。</p>
<p>在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。 一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。</p>
<ol>
<li>Connection</li>
</ol>
<p>说明： 表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。</p>
<p>实例： Connection: keep-alive</p>
<ol>
<li>Keep-Alive</li>
</ol>
<p>说明：显示此HTTP连接的Keep-Alive时间。使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<p>以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。</p>
<p>实例： Keep-Alive: 300</p>
<ol>
<li>cookie</li>
</ol>
<p>说明：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p>
<ol>
<li>Referer</li>
</ol>
<p>说明：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</p>
<h3 id="服务器端返回HTTP头部信息"><a href="#服务器端返回HTTP头部信息" class="headerlink" title="服务器端返回HTTP头部信息"></a>服务器端返回HTTP头部信息</h3><p>简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type	text/plain</span><br><span class="line">Content-Length	8</span><br><span class="line">Last-Modified	Mon, 15 May 2017 18:04:40 GMT</span><br><span class="line">ETag	&quot;ae780585f49b94ce1444eb7d28906123&quot;</span><br><span class="line">Accept-Ranges	bytes</span><br><span class="line">Server	AmazonS3</span><br><span class="line">X-Amz-Cf-Id	jodC9tJqDu4my9HVAend7hMtgKNcrlV4SUHJOKveUP-hHSIJ6ewkig==</span><br><span class="line">Cache-Control	no-cache, no-store, must-revalidate</span><br><span class="line">Date	Tue, 17 Jul 2018 02:28:52 GMT</span><br><span class="line">Proxy-Connection	Keep-alive</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Content-Length</li>
</ol>
<p>说明：表示web服务器返回消息正文的长度</p>
<ol>
<li>Content-Type:</li>
</ol>
<p>说明：返回数据的类型（例如text/html文本类型）和字符编码格式。</p>
<p>实例： Content-Type: text/html;charset=utf-8</p>
<ol>
<li>Date<br>说明：显示当前的时间</li>
</ol>
<p>本文根据RFC2616(HTTP/1.1规范),参考</p>
<p><a href="http://www.w3.org/Protocols/rfc2068/rfc2068" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2068/rfc2068</a></p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616</a></p>
<p><a href="http://www.ietf.org/rfc/rfc3229.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3229.txt</a></p>
<p><a href="https://blog.csdn.net/u012359618/article/details/50240617" target="_blank" rel="noopener">https://blog.csdn.net/u012359618/article/details/50240617</a>  </p>
<p><a href="https://www.cnblogs.com/wenqiang/p/5698772.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenqiang/p/5698772.html</a></p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可 选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域 值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/17/okhttp使用记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/17/okhttp使用记录/" itemprop="url">okhttp使用记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T09:27:19+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Applicaion Interceptor和NetworkInterceptor区别<br>Application interceptors：</li>
</ol>
<ul>
<li>Don’t need to worry about intermediate responses like redirects and retries.（不必担心重定向和重试等中间响应，因为它处于第一个拦截器，会获取到最终的响应 response 。）</li>
<li>Are always invoked once, even if the HTTP response is served from the cache.（即使从缓存提供HTTP响应，也始终调用一次）</li>
<li>Observe the application’s original intent. Unconcerned with OkHttp-injected headers like If-None-Match.（观察应用程序的原始意图。 不去关注OkHttp注入的头信息，如If-None-Match。）</li>
<li>Permitted to short-circuit and not call Chain.proceed().（允许短路而不调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有权决定了是否要调用其他拦截，也就是 Chain.proceed() 方法是否要被执行。）</li>
<li>Permitted to retry and make multiple calls to Chain.proceed().（允许重试并多次调用Chain.proceed（），因为是第一个被执行的拦截器，因此它有可以多次调用 Chain.proceed() 方法，其实也就是相当与重新请求的作用了。）</li>
</ul>
<p>Network Interceptors  </p>
<ul>
<li>Able to operate on intermediate responses like redirects and retries.（能够对重定向和重试等中间响应进行操作，因为 NetworkInterceptor 是排在第 6 个拦截器中，因此可以操作经过 RetryAndFollowup 进行失败重试或者重定向之后得到的resposne）</li>
<li>Not invoked for cached responses that short-circuit the network.（未调用使网络短路的缓存响应，对于从缓存获取的 response 则不会去触发 NetworkInterceptor 。因为响应直接从 CacheInterceptor 返回了）</li>
<li>Observe the data just as it will be transmitted over the network.（观察数据，就像它将通过网络传输一样）</li>
<li>Access to the Connection that carries the request.（访问带有请求的Connection）</li>
</ul>
<p>参考地址：<br>[1]. 官网 <a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki/Interceptors</a><br>[2]. 简书 <a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d04b463806c8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2018/07/13/Android开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/13/Android开发记录/" itemprop="url">Android开发记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-13T13:45:40+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="Android-studio中如何修改运行环境中最低版本和目标版本"><a href="#Android-studio中如何修改运行环境中最低版本和目标版本" class="headerlink" title="Android studio中如何修改运行环境中最低版本和目标版本"></a>Android studio中如何修改运行环境中最低版本和目标版本</h4><p>最近发现使用Android Studio创建的项目中，最低版本和目标版本已经不在AndroidManifest.xml中显示了。那我们应该去那里需改呢？</p>
<p>原来放到了File -&gt; Project Structure中了。直接上图吧，一目了然。<br><a href="&quot;images/AndroidDownBuildVersion.jpg&quot;">修改最低版本和目标版本</a></p>
<p>参考地址：   </p>
<ul>
<li><a href="https://blog.csdn.net/kingroc/article/details/50947143" target="_blank" rel="noopener">https://blog.csdn.net/kingroc/article/details/50947143</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">the blog from a anroid coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
