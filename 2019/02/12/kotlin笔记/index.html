<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kotlin," />










<meta name="description" content="基础 变量 &amp;amp; 常量: 可变性: var 可变;  val 不可变 编译期常量: val定义的是运行时常量, 如果定义编译器常量, 需要添加  const 变量的声明和赋值  var p0 = 1           // 类型推断  var p1: Int = 2      // 指明类型   基本类型  数字(Number): (Kotlin中的数字没有隐式拓宽, 比如 Int 不能自">
<meta name="keywords" content="kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin笔记">
<meta property="og:url" content="https://cattlefoot.github.io/2019/02/12/kotlin笔记/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="基础 变量 &amp;amp; 常量: 可变性: var 可变;  val 不可变 编译期常量: val定义的是运行时常量, 如果定义编译器常量, 需要添加  const 变量的声明和赋值  var p0 = 1           // 类型推断  var p1: Int = 2      // 指明类型   基本类型  数字(Number): (Kotlin中的数字没有隐式拓宽, 比如 Int 不能自">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-12T11:42:18.818Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kotlin笔记">
<meta name="twitter:description" content="基础 变量 &amp;amp; 常量: 可变性: var 可变;  val 不可变 编译期常量: val定义的是运行时常量, 如果定义编译器常量, 需要添加  const 变量的声明和赋值  var p0 = 1           // 类型推断  var p1: Int = 2      // 指明类型   基本类型  数字(Number): (Kotlin中的数字没有隐式拓宽, 比如 Int 不能自">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/2019/02/12/kotlin笔记/"/>





  <title>kotlin笔记 | CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2019/02/12/kotlin笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">kotlin笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:41:35+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>变量 &amp; 常量:<ul>
<li>可变性: var 可变;  val 不可变</li>
<li>编译期常量: val定义的是运行时常量, 如果定义编译器常量, 需要添加  const</li>
<li>变量的声明和赋值<br>  var p0 = 1           // 类型推断<br>  var p1: Int = 2      // 指明类型</li>
</ul>
</li>
<li><p>基本类型</p>
<ul>
<li>数字(Number): (Kotlin中的数字没有隐式拓宽, 比如 Int 不能自动转换为 Long)<ul>
<li>类型<ul>
<li>Byte     8 bit        </li>
<li>Short    16bit</li>
<li>Int      32bit          </li>
<li>Long     64bit          整数默认是 Int, 可以使用 L 表示 Long       123L</li>
<li>Float    32bit          浮点数默认为 Double,  可以使用 f/F表示 Float     1.1f</li>
<li>Double   64bit</li>
</ul>
</li>
<li>进制<ul>
<li>二进制:    0b00001011</li>
<li>八进制:    不支持</li>
<li>十进制:    123</li>
<li>十六进制:  0x0F</li>
</ul>
</li>
<li>数字下划线: 提高数字常量的易读性<br>  val a = 1_000_000;<br>  val b = 123_456L<br>  var c = 0xFF_EC_DE<br>  var d = 0b11010010_01101001</li>
<li>显示转换:<ul>
<li>显示转换: toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar()、、、、、<br>  val b: Byte = 1<br>  val i: Int = b.toInt()</li>
<li>计算时自动转换<br>  val l = 1L + 3                      // Long + Int =&gt; Long</li>
</ul>
</li>
</ul>
</li>
<li>字符(Char):<ul>
<li>字符字面量用 单引号 表示   val c: Char = ‘a’</li>
<li>特殊字符可以使用 \ 转义: \t、\n、\b、\r、\、\$、…</li>
<li>字符不能直接作为数字使用, 但是可以通过方法显示的转为 Int<br>  fun decimalDigit(c: Char): Int{<pre><code>if(c !in &apos;0&apos;..&apos;9&apos;)
    throw IllegalArgumentException(&quot;out of range&quot;)
return c.toInt() - &apos;0&apos;.toInt
</code></pre>  }</li>
</ul>
</li>
<li>布尔(Boolean)<ul>
<li>两个取值:         true,  false</li>
<li>内置的布尔运算符:  ||,    &amp;&amp;,      !</li>
</ul>
</li>
<li>数组(Array)<ul>
<li>定义数组的方式<br>  var arr0 = arrayOfNulls()                          // 创建一个指定大小、元素都为空的数组<br>  var arr1 = arrayOf(1, 2, 3)                        // [1, 2, 3]<br>  val arr2 = Array(5, { i -&gt; (i * i).toString() })   // 创建一个 Array<string> 初始化为 [“0”, “1”, “4”, “9”, “16”]</string></li>
<li>通过 [] 访问(取值 和 赋值)数组元素 (运算符重载, 实际调用 get  set 方法)</li>
<li>无装箱开销的原生类型数组: ByteArray、 ShortArray、IntArray …<ul>
<li>这些类和 Array 并没有继承关系，但是 它们有同样的方法属性集。它们也都有相应的工厂方法:<br>  val x: IntArray = intArrayOf(1, 2, 3)<br>  x[0] = x[1] + x[2]</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串(String)</p>
<ul>
<li>字符串的不可变性</li>
<li>转义字符串: 用  “ “ 表示, 其内部可以使用 转义字符<br>  val s0: String = “Hello \n World”</li>
<li><p>原始字符串: 用 “”” “”” 表示, 其内部可以包含换行和任意字符(都表示字面量), 不识别 转义字符<br>  val s1: String = “””</p>
<pre><code>   for (c in &quot;foo&quot;)
     print(c)
&quot;&quot;&quot;
</code></pre><p>  PS: 因为原始字符串内部任意字符($除外)都表示字面量, 所以其每一行前面可能都会带有空格, 可以使用 trimMargin() 去除每一行前面的空格</p>
<pre><code>- trimMargin() 默认参数 &quot;|&quot;, 所以可以使用 | 作为每一行的前缀
    val text1 = &quot;&quot;&quot;
                    |第一行
                    |第二行
                &quot;&quot;&quot;.trimMargin()
- 也可以自定义前缀, 比如使用 &gt;
    val text2 = &quot;&quot;&quot;
                    &gt;第一行
                    &gt;第二行
                &quot;&quot;&quot;.trimMargin(&quot;&gt;&quot;)
</code></pre></li>
<li><p>字符串模板(转义字符串 和 原始字符串 都支持)<br>  val a = 1<br>  val s = “$a + $a = ${a + a}”<br>  PS: 因为原始字符串也支持 字符串模板, 但是不支持 转义符号, 所有如果要在原始字符串中表示 $ 字面量, 方式如下</p>
<pre><code>val price = &quot;&quot;&quot;
        ${&apos;$&apos;}9.99
        &quot;&quot;&quot;
</code></pre></li>
<li>字符串 就是 一串字符<ul>
<li>用字符数组构建字符串:<br>  val s3: String = String(charArrayOf(‘a’,’b’,’c’))</li>
<li>可以通过下标访问 字符串 中的 字符<br>  val c: Char = s3[0];</li>
<li>可以使用 for 循环迭代字符串<br>  for (c in str) {<pre><code>println(c)
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同一性 &amp; 相等性<br> val a: Int = 1000;<br> val a1: Int? = a;<br> val a2: Int? = a;<br> print(a1 === a2);                       // false, 可空引用会对变量装箱(不要和Java的装箱混淆), 不再相等<br> print(a1 == a2);                        // true,</li>
<li>运算符<ul>
<li>基本运算符: + - * / % += -=</li>
<li>比较符: == === != !==                  // === 比较地址,  == 比较字面量</li>
<li>逻辑运算符: ||  &amp;&amp;  !</li>
<li>位运算(只用于 Int 和 Long)<br>  shl(bits)  – 有符号左移 (Java 的 &lt;&lt;)<br>  shr(bits)  – 有符号右移 (Java 的 &gt;&gt;)<br>  ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;)<br>  and(bits)  – 位与<br>  or(bits)   – 位或<br>  xor(bits)  – 位异或<br>  inv()      – 位非</li>
<li>自定义基本运算<br>  operator fun plus(xxx){xxx}            // 要对某个类自定义运算符, 用 operator 修饰相关成员方法<br>  infix fun on(place: String){}          // 可以通过  xxx on “aaa” 调用, 类似于运算符的效果, 其实等效于 xxx.on(“aaa”)</li>
</ul>
</li>
<li>空类型 &amp; 空安全<ul>
<li>可空类型<br>  var s: String? = null</li>
<li>安全的调用<br>  val l1: Int? = s?.length               // 如果 s 为 null , 则直接返回 null<br>  val l2: Int = s?.length ?: -1          // 如果 ?: 左侧表达式非空, 就返回其左侧表达式，否则返回右侧表达式。<br>  val l3: Int = s!!.length               // 如果 s 为 null, 则抛出异常</li>
<li>安全的类型转换<br>  val aInt: Int? = a as? Int             // 如果转换失败, 则返回 null</li>
<li>空条件<br>  data?.let{<pre><code>// 如果不为空执行该语句块
</code></pre>  }<br>  data?:let{<pre><code>// 当data为空时才会执行
</code></pre>  }</li>
<li>可空类型的集合<br>  val nullableList: List<int?> = listOf(1, 2, null, 4)<br>  val intList: List<int> = nullableList.filterNotNull()     // 过滤非空元素</int></int?></li>
</ul>
</li>
<li>类型检查与类型转换<ul>
<li>智能类型转换: 检查类型后, 可以直接按照该类型使用<br>  if (obj is String) {<pre><code>print(obj.length)
</code></pre>  }<br>  if (obj !is String) {                                     // 与 !(obj is String) 相同<pre><code>print(&quot;Not a String&quot;)
</code></pre>  } else {<pre><code>print(obj.length)
</code></pre>  }</li>
<li>智能类型转换适用的情况<ul>
<li>val 局部变量</li>
<li>val 属性(private 或 internal)，或者该检查在声明属性的同一模块中执行.不适用于 open 的属性或者具有自定义 getter 的属性；</li>
<li>var 局部变量——如果变量在检查和使用之间没有修改、并且没有在会修改它的 lambda 中捕获；</li>
</ul>
</li>
<li>强制类型转换<br>  val x: String = y as String<br>  val x: String? = y as? String                // 转换失败则返回 null</li>
</ul>
</li>
<li>包<ul>
<li>源文件通常以包声明开头: 包名可不与文件路径一致;  源文件的内容都在包名所在空间(外部使用需要导包), 如果不声明包, 则文件内容都属于无名称的默认包<br>  package my.demo  </li>
<li>导入包<br>  import foo.Bar                         // 现在 Bar 可以不用限定符访问<br>  import foo.*                           // “foo”中的一切都可访问<br>  import bar.Bar as bBar                 // 名字冲突时, 使用别名 bBar 代表“bar.Bar”</li>
<li>import不仅限于导入类, 还可以导入: 顶层函数及属性、枚举常量、对象中声明的函数和属性</li>
</ul>
</li>
<li>流程控制<ul>
<li>区间 (Ranges)<br>  for (i in 1..100) { … }         // [1, 100]<br>  for (i in 1 until 100) { … }    // [1, 100)<br>  for (x in 2..10 step 2) { … }   // 步进<br>  for (x in 10 downTo 1) { … }    // 倒序<br>  if (x in 1..10) { … }           // 判断</li>
<li>分支<ul>
<li>if<ul>
<li>传统用法:<br>  var max = a<br>  if (a &lt; b) max = b</li>
<li>在 kotlin 中, if 可以作为表达式使用, 它每个分支的最后的表达式作为该分支的返回值<br>  val max = if (a &gt; b) a else b<br>  val max = if (a &gt; b) {<pre><code>print(&quot;Choose a&quot;)
a
</code></pre>  } else {<pre><code>print(&quot;Choose b&quot;)
b
</code></pre>  }</li>
</ul>
</li>
<li>when: 增强版的 switch<ul>
<li>最简单的用法<br>  when (x) {<pre><code>1 -&gt; print(&quot;x == 1&quot;)
2 -&gt; print(&quot;x == 2&quot;)
else -&gt; { // 注意这个块
    print(&quot;x is neither 1 nor 2&quot;)
}
</code></pre>  }</li>
<li>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：<br>  when (x) {<pre><code>0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;)
else -&gt; print(&quot;otherwise&quot;)
</code></pre>  }</li>
<li>可以用任意表达式（而不只是常量）作为分支条件<br>  when (x) {<pre><code>parseInt(s) -&gt; print(&quot;s encodes x&quot;)
else -&gt; print(&quot;s does not encode x&quot;)
</code></pre>  }</li>
<li>也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：<br>  when (x) {<pre><code>in 1..10 -&gt; print(&quot;x is in the range&quot;)
in validNumbers -&gt; print(&quot;x is valid&quot;)
!in 10..20 -&gt; print(&quot;x is outside the range&quot;)
else -&gt; print(&quot;none of the above&quot;)
</code></pre>  }</li>
<li>检测一个值是（is）或者不是（!is）一个特定类型的值<br>  val hasPrefix = when(x) {                   // 和if一样, 也可以作为表达式使用, 每个分支的最后的表达式作为该分支的返回值<pre><code>is String -&gt; x.startsWith(&quot;prefix&quot;)
else -&gt; false
</code></pre>  }</li>
<li>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：<br>  when {<pre><code>x.isOdd() -&gt; print(&quot;x is odd&quot;)
x.isEven() -&gt; print(&quot;x is even&quot;)
else -&gt; print(&quot;x is funny&quot;)
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>异常<ul>
<li>普通用法<ul>
<li>抛异常:<br>  throw MyException(“Hi There!”)  </li>
<li>捕获异常<br>  try {  }catch (e: SomeException) {  }finally { }</li>
</ul>
</li>
<li>作为表达式使用, 每个分支中最后的表达式作为该分支的结果<br>  val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }</li>
</ul>
</li>
<li>循环<ul>
<li>for<ul>
<li>循环 数组 或 list 的索引<br>  for (index in list.indices) {<pre><code>println(&quot;item at $index is ${items[index]}&quot;)
</code></pre>  }</li>
<li>遍历 索引 和 值<br>  for ((index, value) in array.withIndex()) {<pre><code>println(&quot;the element at $index is $value&quot;)
</code></pre>  }</li>
<li>可以对任何提供迭代器（iterator）的对象进行遍历<br>  for (item in collection) print(item)</li>
<li>遍历 Map 集合<br>  for ((k, v) in map) {<pre><code>print(&quot;$k -&gt; $v&quot;)
</code></pre>  }</li>
<li>遍历 区间 (如上)</li>
</ul>
</li>
<li>while   &amp;    do … while<br>  while (x &gt; 0) {<pre><code>x--
</code></pre>  }<br>  do {<pre><code>val y = retrieveData()
</code></pre>  } while (y != null)           // y 在此处可见</li>
</ul>
</li>
</ul>
</li>
<li>返回与跳转: return、break、continue<ul>
<li>基本用法<br>  return      默认从最直接包围它的函数或者匿名函数返回<br>  break       终止最直接包围它的循环<br>  continue    继续下一次最直接包围它的循环</li>
<li>使用标签来限制 break 和 continue<br>  loop@ for (i in 1..100) {<pre><code>for (j in 1..100) {
    if (……) break@loop
}
</code></pre>  }</li>
<li>使用标签来限制 reutrn :   函数可以嵌套使用, return会从最直接包围它的函数返回, 但是会忽略 lambda表达式, 可以通过标签使其从 lambda表达式返回<br>  fun foo() {<pre><code>ints.forEach lit@ {
    if (it == 0) return@lit
    print(it)
}
</code></pre>  }<br>   fun foo() {<pre><code>ints.forEach {
    if (it == 0) return@forEach            // 隐式标签, 该标签与接受该 lambda 的函数同名
    print(it)
}
</code></pre>  }</li>
<li>return 的标签语法也可以带有返回值<br>  return@a 1                                     // 从标签 @a 返回 1</li>
</ul>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p>类</p>
<ul>
<li>类的声明:  <ul>
<li>class关键字 + 类名 + 类头(主构造函数、参数) + 类体<br>  class Person public constructor(name: String){}</li>
<li>如果没有类体, 可生路 {}:<br>  class Person public constructor(name: String)</li>
<li>如果主构造函数没有 注解 或 权限修饰(默认 public), 可省略 constructor 关键字<br>  class Person()</li>
<li>如果主构造函数没有参数, 类头也可以省略<br>  class Person</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造函数中的参数可在 init 代码块中访问<br>  class Person public constructor(name: String){<pre><code>val age = 18                                 // 只读属性
var xxx = &quot;yyy&quot;                              // 读写属性
init{ print(name) }                          // 初始化代码块: 按照其在类中的顺序执行(包括属性初始化)
</code></pre>  }</li>
<li>构造函数中的参数也可以在类属性的初始化器中使用<br>  class Person (name: String){<pre><code>val upperName : String = name.toUpperCase()
</code></pre>  }</li>
<li>可以直接在主构造函数中声明 属性<br>  class Person (val name: String, val age: Int = 18, var xxx: String){ … }</li>
<li>次级构造函数: 可在类体中通过 constructor 关键字 声明任意个次级构造函数<br>  class Person{<pre><code>constructor(name: String){
    print(name)
}
</code></pre>  }</li>
<li>如果存在主构造函数, 那么所有 次级构造函数必须 直接(或间接)委托给 主构造函数.<br>  class Person(val name: String, val age: Int){<pre><code>constructor(name: String) : this(name, 18) {
    print(name)
}
</code></pre>  }</li>
<li>实际上即使没有主构造函数, 次级构造函数任然隐式的存在这种委托关系<br>  class Person{<pre><code>init{
    print(&quot;这段代码会在次级构造函数体之前执行, 因为 init 代码块是主构造函数的一部分, 而委托代码是在次级构造函数的含数体之前&quot;)
}
constructor(name: String){
    print(name)
}
</code></pre>  }</li>
<li>如果没有声明任何构造函数(主和次), 默认会自动有一个 public 的无参主构造函数</li>
</ul>
</li>
<li><p>属性和字段</p>
<ul>
<li>声明属性的方式<br>  class A{<pre><code>// 可变属性: 初始化器、getter、setter都是可选的; 如果类型可推断(从初始化器或 getter返回值), 那么类型也可以省略
var &lt;propertyName&gt; [: PropertyType] [= &lt;property_initializer&gt;]      
    [&lt;getter&gt;]                                                      // 就是一个函数 get() {}
    [&lt;setter&gt;]                                                      // set(value){}
val &lt;propertyName&gt; [: PropertyType] [= &lt;property_initializer&gt;]      // 只读属性, 没有setter
    [&lt;getter&gt;]
</code></pre>  }</li>
<li>改变访问器的可见性(或添加注解): 默认情况下 属性访问器的可见性和属性时一致的, 但是也可以单独指定<br>  var setterVisibility: String = “abc”<pre><code>private set                                   // 可以只添加修饰符, 而不改变其默认实现
</code></pre>  var setterWithAnnotation: Any? = null<pre><code>@Inject set
</code></pre></li>
<li>幕后字段: 如果属性至少有一个访问器使用默认实现, 或者通过 field 引用幕后字段,将会为该属性生成一个幕后字段<br>  var counter = 0<pre><code>set(value){
    field = value
}
</code></pre></li>
<li>编译期常量: 使用 const 修饰, 位于顶层或是 object 的成员, 使用 String或原生类型初始化, 没有自定义 getter</li>
<li>属性延迟初始化: 一般情况下属性必须通过 构造函数 或 初始化器 或 getter 初始化, 使用以下方式可以延迟初始化时机<br>  class Test{<pre><code>lateinit var a: String       // 方式一: 必须是可变属性, 必须是非空类型, 不能自定义 getter 和 setter
var/val b by lazy{}          // 方式二:
</code></pre>  }<br>-</li>
</ul>
</li>
<li><p>创建类的实例: 调用构造方法,   没有  new 关键字<br>  val p = Person()</p>
</li>
</ul>
</li>
<li>继承<ul>
<li>Any 是所有类的基类</li>
<li>继承的写法<ul>
<li>如果基类有主构造函数, 则必须使用该主构造函数就地初始化<br>  class Derived(p: Int) : Base(p)</li>
<li>如果基类没有主构造函数, 那么每个次构造函数必须使用 super 关键字初始化基类, 或者委托另一构造函数做到这一点<br>  class MyView : View {<pre><code>constructor(ctx: Context) : super(ctx)
</code></pre>  }</li>
</ul>
</li>
<li>super 关键字<ul>
<li>调用基类的函数和属性访问器<br>  open class F{<pre><code>open fun test() { print(&quot;aaaaa&quot;) }
open val x: Int get() = 1
</code></pre>  }<br>  class S: F(){<pre><code>override test(){
    super.test()
    print(&quot;bbbbbb&quot;)
}
override val x: Int get() = super.x + 1
</code></pre>  }<br>-</li>
<li>在内部类中, 通过外部类类名限定的 super, 访问外部类的超类<br>  class S: F(){<pre><code>...
inner class SI{
    fun test2(){
        super@S.test()
        print(super@S.x)
    }
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>修饰符号<ul>
<li>open/final:<ul>
<li>类默认为 final, 如果希望被继承, 需要加上 open 修饰</li>
<li>函数默认为 final, 如果希望被重写, 需加上 open 修饰, 且子类重写时必须加上 override修饰, 如果子类不希望再被重写, 加上 final</li>
<li>属性和函数类似, 此外: val 可以重写为 var, var不能重写为 val</li>
</ul>
</li>
<li>abstract: 可用于修饰 类 或 函数 (抽象类或函数肯定可以被继承和重写, 不需要再添加 open 修饰)</li>
<li>可见性修饰符 (作用目标: 类、对象、接口、构造函数、方法、属性及其setter, getter可见性总是和属性本身一致)<br>  private(自己可见)、 protected(不适用顶层声明)、 internal(相同模块内可见) 和 public(缺省默认)</li>
</ul>
</li>
<li>接口<ul>
<li>使用 interface 关键字, 多继承</li>
<li>可以有抽象方法 和 实现方法(java8)</li>
<li>可以有属性, 但必须为 抽象的 或者 提供访问器实现<br>  interface A{<pre><code>val a: Int
val b: String
    get() = &quot;bbb&quot;                  // 接口中不支持 幕后字段
</code></pre>  }</li>
<li>多继承与 覆盖冲突<br>  interface A{<pre><code>fun a(){}
</code></pre>  }<br>  interface B{<pre><code>fun a(){}
</code></pre>  }<br>  class C: A, B{<pre><code>override fun a() {                // 虽然 a 方法在父类中是实现方法, 但这里必须要重写, 且可以通过 super&lt;父类名&gt;选择性调用父类实现
    super&lt;A&gt;.a()
}
</code></pre>  }</li>
</ul>
</li>
<li>扩展<ul>
<li>定义扩展函数<br>  fun 类型名称.方法名(){ // 扩展函数体可通过 this 访问调用对象 }</li>
<li>扩展函数式静态解析的: 并没有在目标类中插入新的成员, 仅仅表示可以通过该类型变量使用点语法调用函数</li>
<li>如果扩展函数和成员方法冲突了, 那么成员方法总是优先的</li>
<li>可空接受者<br>  fun Any?.toString(): String? = if(this == null){ null } else { this.toString() }</li>
<li>扩展属性: 扩展属性不能使用幕后字段, 不能有初始化器, 只能有 访问器<br>  val <t> List<t>.lastIndex: Int<pre><code>get() = size - 1
</code></pre></t></t></li>
<li>为伴生对象 定义扩展<br>  class A{<pre><code>companion object{}
</code></pre>  }<br>  fun A.Companion.test(){ … }<br>  A.test();                         // 可直接通过类名访问</li>
<li>定义扩展的位置<ul>
<li>一般情况下定义在顶层</li>
<li>也可以在一个类(扩展分发者) 内部 为 另一个类(扩展接受者) 定义扩展<ul>
<li>在此扩展方法中可以同时访问 扩展分发者 以及 扩展接受者 的成员</li>
<li>如果 扩展分发者 和 扩展接受者的成员名称冲突时, 默认访问的是 扩展分发者的成员, 但是也可以通过 this 的限定语法指定访问<br>  class A{<pre><code>fun a1(){}
fun a2(){}
</code></pre>  }<br>  class B{<pre><code>fun a2(){}
fun b(){}
fun A.aa(){
    b();            // 调用了 B 的方法
    a1();           // 调用了 A 的方法
    a2();           // 调用了 B 的方法
    this@A.a2();     // 通过 this 的限定语法, 调用了 A 的方法
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
<li>扩展的作用: 代替 工具类</li>
</ul>
</li>
<li>数据类<ul>
<li>定义数据类<br>  data class Uer(val name: String, val age: Int)</li>
<li>数据类的要求<ul>
<li>必须有主构造函数, 且至少有一个参数, 且参数必须声明为属性(使用 var 或 val 标记)</li>
<li>如果希望使用无参构造函数, 可以给属性设置默认值</li>
<li>数据类不能是抽象、开放、密封或者内部的</li>
</ul>
</li>
<li>编译器会通过主构造函数为数据类自动生成以下函数 (没有收到声明, 且父类没有设置为 final)<ul>
<li>equals()、 hashCode()</li>
<li>toString()                 // 格式是 “User(name=John, age=42)” …</li>
<li>componentN()               // 按声明顺序对应于所有属性</li>
<li>copy()                     // 用于复制一个对象, 并只改变部分属性<br>  val jack = User(name = “Jack”, age = 1)<br>  val olderJack = jack.copy(age = 2)</li>
</ul>
</li>
<li>在类体中声明属性: 编译器自动生成的函数只会使用主构造函数中的属性, 而不会使用类体中声明的属性</li>
<li>数据类的解构<br>  val jane = User(“Jane”, 35)<br>  val (name, age) = jane</li>
</ul>
</li>
<li>内部类<ul>
<li>在类的内部定义的类<br>  class Outer{<pre><code>private val bar: Int = 1
class Inner1{                // 表示静态内部类                     -&gt;  val i1 = Outer.Inner2().foo()
    fun foo() = 2
}
inner class Inner2{          // 使用inner关键字标记, 表示非静态内部类 -&gt;  val i2 = Outer().Inner2().foo()
    fun foo() = bar          // 可访问外部类成员, 并且可通过 this@Outer 引用外部类实例
}
</code></pre>  }</li>
<li>匿名内部类: 使用 对象表达式.          // 如果是函数式java接口的实例, 可使用lambda chipLayout.setOnClickListener { v -&gt; print(v?.id) }<br>  view.setOnClickListener(object: View.OnClickListener{<pre><code>override fun onClick(v: View?) { }
</code></pre>  })</li>
</ul>
</li>
<li>密封类<ul>
<li>定义一个密封类<br>  sealed class XXX</li>
<li>密封类的限制:<ul>
<li>不允许有非 private 的构造函数(其构造函数默认是 private), 其所有直接子类必须和其写在同一个文件中</li>
<li>在使用 when表达式时, 如果各个分支条件可以覆盖所有情况, 那么就不需要 else 分支. 密封类可以满足这一点</li>
</ul>
</li>
</ul>
</li>
<li>枚举类<ul>
<li>最基本的用法: (每一个枚举常量都是对象)<br>  enum class Direction {<pre><code>NORTH, SOUTH, WEST, EAST
</code></pre>  }</li>
<li>每一个枚举常量都是枚举类的实例<br>  enum class Color(val rgb: Int) {<pre><code>RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)
</code></pre>  }</li>
<li>枚举常量也可以声明自己的匿名类<br>  enum class ProtocolState {<pre><code>WAITING {
    override fun signal() = TALKING
},
TALKING {
    override fun signal() = WAITING
};
abstract fun signal(): ProtocolState
</code></pre>  }</li>
</ul>
</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li>对象表达式 (匿名对象)<ul>
<li>使用 object 关键字表示匿名对象<br>  view.setOnClickListener(object: View.OnClickListener{<pre><code>override fun onClick(v: View?) { }
</code></pre>  })</li>
<li>可以有多个超类型(逗号分隔), 如果超类型存在构造函数, 则必须传递参数<br>  val ab: A = object : A(1), B {<pre><code>// 重写方法 或 属性
</code></pre>  }</li>
<li>甚至可以不指定超类型<br>  val adHoc = object {<pre><code>var x: Int = 0
var y: Int = 0
</code></pre>  }</li>
<li>使用匿名对象作为 共有函数 的返回值 或 参数时, 其实际类型是匿名对象的超类型(如果为指明, 则是 Any 类型)</li>
<li>使用匿名对象作为 私有函数 的返回值 或 参数时, 其实际类型是匿名对象类型</li>
</ul>
</li>
<li>对象声明 (不是表达式, 不能用在赋值语句的右边)<ul>
<li>使用 object 关键字 声明对象 (等效于 java 中的 饿汉式单例)<br>  object AppScope{<pre><code>fun saveData(key: String, value: String){ ... }
</code></pre>  }</li>
<li>如何访问对象成员<ul>
<li>kotlin中: AppScope.saveData(…)</li>
<li>java中:   AppScope.INSTANCE.saveData(…)</li>
</ul>
</li>
<li>对象可以有超类型<br>  object MyLisener: MessageListener(){<pre><code>override fun ...
</code></pre>  }</li>
</ul>
</li>
<li>伴生对象<ul>
<li>定义伴生对象: 类内部的object 用 companion 关键字标记, 一个类只能有一个伴生对象,<br>  class MyClass {               <pre><code>companion object Factory {
    @JvmStatic   
    fun create(): MyClass = MyClass()
    @JvmField
    val TAG: String = &quot;tag&quot;
}
</code></pre>  }</li>
<li>访问伴生对象的成员<ul>
<li>kotlin中: val instance = MyClass.create()</li>
<li>java中:<ul>
<li>如果没有添加 @JvmStatic 、@JvmField 注解: val instance = MyClass.Factory.create()</li>
<li>如果添加了 @JvmStatic 、@JvmField 注解: val instance = MyClass.create()</li>
</ul>
</li>
</ul>
</li>
<li>伴生对象的名称可以省略, 此时将使用默认的名称 Companion<br>  class MyClass {<pre><code>companion object {
    fun create(): MyClass = MyClass()
}
</code></pre>  }<br>  MyClass.Companion.create()</li>
<li>虽然访问伴生对象的成员类似 java中的静态成员, 但实际在运行时他们任然是真实对象的实例成员</li>
<li>在 jvm平台, 如果使用了 @JvmStatic 、@JvmField 注解, 可以将伴生对象的成员生成为真正的静态成员</li>
<li>kotlin中使用静态成员时, 应考虑是否有必要, 是否用 包级函数/变量 替代</li>
</ul>
</li>
<li>单例模式<ul>
<li>饿汉式:<br>  objcet APIHelper{}</li>
<li>懒汉式:<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    private var instance: SingletonDemo? = null
        get() {
            if (field == null) {
                field = SingletonDemo()
            }
            return field
        }
    // @Synchronized   添加该注解表示 同步
    fun get(): SingletonDemo{
        return instance!!
    }
}
</code></pre>  }</li>
<li>双重校验锁式<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    val instance: SingletonDemo by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { SingletonDemo() }
}
</code></pre>  }</li>
<li>静态内部类式<br>  class SingletonDemo private constructor() {<pre><code>companion object {
    val instance = SingletonHolder.holder
}
private object SingletonHolder {
    val holder = SingletonDemo()
}
</code></pre>  }<ul>
<li>带参 ?<br>  class SToast private constructor(val context: Context) : Toast(context) {<pre><code>private object Builder{
    var instance: SToast? = null
}
companion object{
    fun with(context: Context): SToast{
        Builder.instance?:let{
            Builder.instance = SToast(context)
        }
        return Builder.instance!!
    }
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="代理-委托"><a href="#代理-委托" class="headerlink" title="代理(委托)"></a>代理(委托)</h2><ol>
<li>kotlin中可以简单的实现代理模式 (静态代理)<br> interface Animal{<pre><code>fun bark()
</code></pre> }<br> class Dog :Animal {<pre><code>override fun bark() {
    println(&quot;Wang Wang&quot;)
}
</code></pre> }<br> class Cat(animal: Animal) : Animal by animal        // 将 Cat 的所有公有成员都委托给指定的对象<br> Cat(Dog()).bark()                                   // 用 Dog 作为 Cat 的代理</li>
<li>委托属性<ul>
<li>属性委托的语法: val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;<br>  class Example {<pre><code>var p: String by Delegate()
</code></pre>  }<br>  class Delegate {<pre><code>// 必须有 getValue方法, 对应 getter,  参数: 属性的拥有者, 对属性的描述
operator fun getValue(thisRef: Any?, property: KProperty&lt;* &gt;): String {
    return &quot;$thisRef, thank you for delegating &apos;${property.name}&apos; to me!&quot;
}
// var属性还要有 setValue方法, 对应 setter,  参数: 属性的拥有者, 对属性的描述, 属性的值
operator fun setValue(thisRef: Any?, property: KProperty&lt;* &gt;, value: String) {
    println(&quot;$value has been assigned to &apos;${property.name} in $thisRef.&apos;&quot;)
}
</code></pre>  }</li>
<li>kotlin为委托提供的几个工厂方法<ul>
<li>延迟属性 Lazy:   lazy()接受一个 lambda表达式 并返回一个 Lazy实例(在第一次访问属性的getter时执行 lambda并返回结果)<br>  val propLazy: Int by lazy{1}                                // 默认是所有线程同步的<br>  val v: Int by lazy(LazyThreadSafetyMode.PUBLICATION, {1})   // 指定线程不安全<br>  val v: Int by lazy(LazyThreadSafetyMode.NONE, {1})          // 不会有任何线程安全的保证和相关的开销</li>
<li>可观察属性 Observable: (接受两个参数: 初始值, 处理函数)<ul>
<li>在赋值之后执行<br>  var name: String by Delegates.observable(“初始值”) {<pre><code>// 被赋值的属性、旧值和新值
prop, old, new -&gt;
println(&quot;$old -&gt; $new&quot;)
</code></pre>  }</li>
<li>在赋值之前执行(可以拦截)<br>  var name: String by Delegates.vetoable(“初始值”) {<pre><code>// 被赋值的属性、旧值和新值
prop, old, new -&gt;
println(&quot;$old -&gt; $new&quot;)
false
</code></pre>  }</li>
</ul>
</li>
<li>把属性储存在映射中<br>  class User(val map: Map<string, any?="">) {<pre><code>val name: String by map
val age: Int     by map
</code></pre>  }<br>  val user = User(mapOf(<pre><code>&quot;name&quot; to &quot;John Doe&quot;,
&quot;age&quot;  to 25
</code></pre>  ))<br>  // var 属性<br>  class MutableUser(val map: MutableMap<string, any?="">) {<pre><code>var name: String by map
var age: Int     by map
</code></pre>  }</string,></string,></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>定义一个函数<br> fun double(x: Int): Int { return 2 * x }</li>
<li>关于参数<ul>
<li>参数的默认值: (可以减少重载数量,   注意: 重写带默认值的函数时, 需要省略默认值))<br>  fun read(b: Array<byte>, off: Int = 0, len: Int = b.size()) {}</byte></li>
<li>命名参数: 调用函数时, 可以显示的指定名称传参<br>  fun foo(p1: Int = 0, p2: Int){ … }<br>  foo(p2 = 10)</li>
<li>可变参: 使用关键字 vararg  (可变参可以不是最后一个, 但是对于其后面的参数, 需要使用 命名参数 的语法传参)<br>  fun <t> asList(vararg ts: T): List<t> {<pre><code>val result = ArrayList&lt;T&gt;()
for (t in ts) // ts is an Array
    result.add(t)
return result
</code></pre>  }<br>  // 对于可变参可以一个一个的传, 但如果已经有了一个数组, 可以使用 伸展符号( <em> )<br>  val arr = arrayOf(1, 2, 3)<br>  val list = asList(-1, 0, </em> arr, 4)</t></t></li>
<li>泛型参数<br>  fun <t> singletonList(item: T): List<t> {}</t></t></li>
</ul>
</li>
<li>关于返回值<ul>
<li>无返回值: 如果一个函数没有返回值, 那么其返回类型应该是 Unit, 或者直接省略返回类型</li>
<li>单表达式函数: 当函数返回单个表达式时, 可省略 {}, 并使用 = 表示返回值<br>  fun double(x: Int): Int = x <em> 2<br>  fun double(x: Int) = x </em> 2               // 当返回类型可以推断时, 可省略返回类型</li>
</ul>
</li>
<li>中缀语法:<ul>
<li>使用 infix 关键字标识函数<br>  infix fun Int.sh1(x: Int): Int{ …}<br>  1 sh1 2                                  // 使用中缀语法调用函数,  等效于 1.sh1(2)</li>
<li>中缀函数必须满足一下条件<ul>
<li>必须是成员函数 或 扩展函数</li>
<li>必须且只有一个参数</li>
<li>参数不能是 可变参, 且不能有默认值</li>
</ul>
</li>
</ul>
</li>
<li>函数的作用域<ul>
<li>成员函数</li>
<li>顶层函数: kotlin中的函数可以直接声明在 顶层</li>
<li>局部函数: kotlin中的函数可以声明在另一个函数内部 (闭包: 内部函数可访问外部函数中的变量)</li>
</ul>
</li>
<li>尾递归函数用: 使用 tailrec 关键字标记, 并满足要求(递归调用必须是最后一步,并且不能用在 try/catch/finally 块中), 只有后端支持<br> tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))</li>
</ol>
<h2 id="高阶函数-amp-Lambda"><a href="#高阶函数-amp-Lambda" class="headerlink" title="高阶函数 &amp; Lambda"></a>高阶函数 &amp; Lambda</h2><ol>
<li>函数类型<ul>
<li>如何声明函数类型<br>  val click : (View) -&gt; Unit = …</li>
<li>函数类型的一些说明<ul>
<li>如果没有返回值, Unit 也不能省略</li>
<li>如何表示可空类型:  val a: ((Int) -&gt; String)? = …</li>
<li>可选择性的设置参数名(提高可读性):  val click : (view: View) -&gt; Unit = …</li>
<li>函数类型的取值<ul>
<li>使用匿名函数:<br>  val click : (View) -&gt; Unit = fun (v: View){ print(v.id) }</li>
<li>使用Lambda表达式:<br>  val click : (View) -&gt; Unit = { v -&gt; print(v.id) }</li>
<li>使用已有函数的引用<br>  fun test(view: View){  print(view.id) }<br>  val click : (View) -&gt; Unit = ::test</li>
<li>使用函数类型的实现类的实例<br>  class Test : (View) -&gt; Unit{<pre><code>override fun invoke(view: View) {
    print(view.id)
}
</code></pre>  }<br>  val click : (View) -&gt; Unit = Test()</li>
</ul>
</li>
<li>如果信息足够推断函数类型时, 可省略类型<br>  val plus = {i : Int -&gt; i + 1}</li>
<li>调用函数类型的方式<ul>
<li>方式一: 直接调用<br>  var result = plus(3)</li>
<li>方式二: 使用 invoke<br>  var result = plus.invoke(3)</li>
</ul>
</li>
<li>带接受者的函数类型<ul>
<li>定义带接受者的函数类型(类似 扩展函数)<br>  val myConcat: String.(String) -&gt; String = { string -&gt; this + string }     // this表示该函数的调用者<br>  val result = “abc”.myConcat(“efg”)                 // 用 “abc” 调用该函数, 等价于  myConcat(“abc”, “efg”)</li>
<li>函数类型的接受者, 可以相互转化为其参数列表的第一个参数<br>  fun a(str1: String, str2: String) = str1 + str2<br>  val myConcat: String.(String) -&gt; String = ::a         </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Lambda表达式<ul>
<li>例子<br>  val map = mapOf(“key1” to “value1”, “key2” to “values”)<br>  map.forEach({key: String, value: String -&gt;<pre><code>print(&quot;$key &amp; $value&quot;)
</code></pre>  })</li>
<li>Lambda表达式写在 {} 中, 参数列表 与 函数体 之间用 -&gt; 分开</li>
<li>参数类型可省略<br>  map.forEach({key, value -&gt;<pre><code>print(&quot;$key &amp; $value&quot;)
</code></pre>  })</li>
<li>对于没有使用的参数, 可以用 <em> 表示<br>  map.forEach({</em> , value -&gt;<pre><code>print(value)
</code></pre>  })</li>
<li>如果Lambda表达式的参数列表只有一个参数, 那么可以省略参数列表 和 -&gt;, 在函数体中如果要使用该参数, 可以用 it代替<br>  val list = listOf(1,2,3)<br>  list.forEach({ print(it) })</li>
<li>如果Lambda表达式需要有返回值, 那么函数体中的最后一个表达式会作为其返回值<br>  val newList = list.map({ 2 <em> it })                       // 不要使用 return, 除非带上限定符号, 比如 return@map<br>  // val newList = list.map({ return@map 2 </em> it })</li>
<li>如果 Lambda 是另一个函数的最后一个参数, 那么可以写在 () 之外<br>  val newList = list.map() { 2 * it }   </li>
<li>如果 Lambda 是另一个函数的唯一个参数, 那么 () 可省略<br>  val newList = list.map { 2 * it }   </li>
</ul>
</li>
<li>高阶函数: 使用函数作为 参数 或 返回值</li>
<li>内联函数<ul>
<li>使用高阶函数会造成额外的消耗(函数也是对象, 需要单独开辟空间, 寻址..), 使用内联函数可以解决这一问题<br>  inline fun lock<t>(lock: Lock, body: () -&gt; T): T {}</t></li>
<li>inline会影响函数本身和作为参数的 lambda表达式. 内联会导致生成的代码量增加, 可以通过 noinline 标识哪些参数不进行内联<br>  inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {}</li>
<li>lambda表达式中不允许使用单独的 return; 但是在内联情况下, 可以直接 return, 标识从包裹该lambda表达式最近的函数返回</li>
<li>内联属性: inline 也可以用来修饰 没有幕后字段 的属性<ul>
<li>作用于访问器<br>  val foo: Foo<pre><code>inline get() = Foo()
</code></pre>  var bar: Bar<pre><code>get() = ……
inline set(v) { …… }
</code></pre></li>
<li>直接作用于整个属性, 表示所有访问器都标记为内联<br>  inline var bar: Bar<pre><code>get() = ……
set(v) { …… }
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>类型别名<br> typealias NodeSet = Set<network.node>               // 为泛型起别名<br> typealias AInner = A.Inner                           // 为内部类起别名<br> typealias MyHandler = (Int, String, Any) -&gt; Unit    // 为函数起别名 (可以简化函数类型的书写)<br> typealias Predicate<t> = (T) -&gt; Boolean</t></network.node></li>
<li>集合<ul>
<li>不可变集合: List<out t=""> .  Set<out t=""> .  Map<k, out="" v=""><br>  val list: List<int> = listOf(1,2,3)<br>  val set = setOf(‘a’,’b’)<br>  val map = mapOf<string, int="">(“key1” to 1, “key2” to 2)</string,></int></k,></out></out></li>
<li>可变集合: MutableList<t> .  MutableSet<t> .  MutableMap<k, v=""><br>  val list: MutableList<int> = mutableListOf(1,2,3)<br>  val set = mutableSetOf(‘a’,’b’)<br>  val map = mutableMapOf<string, int="">(“key1” to 1, “key2” to 2)</string,></int></k,></t></t></li>
<li>访问 map 集合<br> println(map[“key”])<br> map[“key”] = value</li>
<li>集合的复制以及可变性变化<br> toList()  toMutableList() …</li>
</ul>
</li>
<li>解构<ul>
<li>对象解构<br>  val (name, age) = person           // 对于不需要用到的变量, 可以使用 <em> 代替   val (name, </em> ) = person</li>
<li>在 lambda 表达式中解构<ul>
<li>示例<br>  map.mapValues { entry -&gt; “${entry.value}!” }<br>  map.mapValues { (key, value) -&gt; “$value!” }</li>
<li>声明 两个参数 和 声明一个 解构来取代单个参数之间的区别：<br>  { a -&gt; …… }                  // 一个参数<br>  { a, b -&gt; …… }               // 两个参数<br>  { (a, b) -&gt; …… }             // 一个解构<br>  { (a, b), c  -&gt; …… }         // 一个解构对以及其他参数</li>
<li>解构中未被使用的变量可以使用 <em> 代替<br>  map.mapValues { (</em> , value) -&gt; “$value!” }</li>
<li>可以指定整个解构的参数的类型 或者 分别指定特定组件的类型：<br>  map.mapValues { (<em> , value): Map.Entry<int, string=""> -&gt; “$value!” }<br>  map.mapValues { (</int,></em> , value: String) -&gt; “$value!” }</li>
</ul>
</li>
</ul>
</li>
<li>利用 with 调用一个对象实例的多个方法<br> class Turtle {<pre><code>fun penDown()
fun penUp()
fun turn(degrees: Double)
fun forward(pixels: Double)
</code></pre> }<br> with(Turtle()) {<pre><code>penDown()
for(i in 1..4) {
forward(100.0)
    turn(90.0)
}
penUp()
</code></pre> }</li>
<li>泛型<ul>
<li>类泛型<br>  class Box<t>(t: T) {<pre><code>var value = t
</code></pre>  }<br>  val box: Box<int> = Box<int>(1)                 // 如果泛型可以推断, 那么可以省略 val box = Box(1)</int></int></t></li>
<li>函数泛型<br>  fun <t> singletonList(item: T): List<t> {}      // 普通函数泛型<br>  fun <t> T.basicToString() : String {}           // 扩展函数泛型<br>  val l = singletonList<int>(1)                   // 调用泛型函数需要在 &lt;&gt; 中指明类型</int></t></t></t></li>
<li>泛型变异<ul>
<li>Java中是在使用处型变<ul>
<li>协变: &lt;? extends T&gt;  可以使用父类型的地方, 就可以接受子类型;   只能取值, 不能写入, 称为 生产者<br>  public class Utils{<pre><code>public static void test(List&lt;? extends View&gt; list){
    // 只能从 list 中取值, 而不能写入
    View view = list.get(0);                 // 可以通过编译
    // list.add(new TextView(context));      // 不能通过编译
}
</code></pre>  }<br>  List<imageview> imgs = new ArrayList&lt;&gt;();<br>  Utils.test(imgs);</imageview></li>
<li>逆变 &lt;? super T&gt;   可以使用子类型的地方, 就可以接受父类型;    可以写入, 取值都是 Object,  称为 消费者<br>  public class Utils{<pre><code>public static void test(List&lt;? super ImageView&gt; list){
    // 可以往 list 中写入, 但取值都是 Object
    list.add(new ImageView(context));
    Object object = list.get(0);
}
</code></pre>  }<br>  List<view> views = new ArrayList&lt;&gt;();<br>  Utils.test(views);</view></li>
</ul>
</li>
<li>Kotlin中是在声明处型变<ul>
<li>out: 类似 协变, 表示泛型只能被生产, 不能被消费(就是只能作为返回值, 不能作为参数)<br>  class Test<out t="">{<pre><code>fun test(): T { ... }
</code></pre>  }<br>  val t: Test<view> = Test<imageview>()           // 这是合法的, 因为泛型只能被读取, 不能写入 (安全)</imageview></view></out></li>
<li>in: 类似 逆变, 表示泛型只能被消费, 不能被生产 (就是只能作为参数, 不能作为返回值)<br>  class Test<in t="">{<pre><code>fun test(t: T) { ... }
</code></pre>  }<br>  val t: Test<imageview> = Test<view>()           // 这是合法的, 因为泛型只能被写入, 不能读取 (安全)</view></imageview></in></li>
</ul>
</li>
</ul>
</li>
<li>泛型约束<br>  fun <t: number=""> test(t: T){  }                // 泛型约束为 Number子类及其子类<br>  test(1)                                       // 可以通过编译<br>  test(“a”)                                     // 不能通过编译<br>  fun <t> test(t: T) where T : A, T: B{  }      // 泛型约束为: 必须是 A的子类 也是 B的子类</t></t:></li>
</ul>
</li>
<li>注解<ul>
<li>元注解<br>  @Target              指定注解可作用的地方(类, 函数, 属性, 表达式)<br>  @Retention           指定注解被保留的时间长短(AnnotationRetention.SOURCE, ..CLASS, ..RUNTIME)<br>  @Repeatable         允许 在单个元素上多次使用相同的该注解<br>  @MustBeDocumented   指定 该注解是公有 API 的一部分，并且应该包含在 生成的 API 文档中显示的类或方法的签名中。</li>
<li>利用元注解 自定义注解<br>  @Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,<pre><code>AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)
</code></pre>  @Retention(AnnotationRetention.SOURCE)<br>  @MustBeDocumented<br>  annotation class Fancy</li>
<li>注解可以有接受参数的构造函数<br>  annotation class Special(val why: String)</li>
<li>使用注解<br>  @Special(“example”) class Foo {}</li>
</ul>
</li>
<li>反射<ul>
<li>类引用<ul>
<li>通过类名获取<br>  val c = MyClass::class               // 该引用是KClass类型, 要获得 Java 类引用， 需要在 KClass 实例上使用 .java 属性。</li>
<li>通过对象获取<br>  val widget: Widget = ……<br>  widget::class</li>
</ul>
</li>
<li>函数的引用 (用于高阶函数, lamada 表达式也可以实现类似功能)<ul>
<li>获取函数的引用<br>  fun isOdd(x: Int) = x % 2 != 0<br>  listOf(1, 2, 3).filter(::isOdd)  </li>
<li>函数的引用可以存储到变量中<br>  val predicate: (Int) -&gt; Boolean = ::isOdd</li>
<li>在外部引用 类的成员函数(或构造函数) 需要指定接受者<br>  val isListEmpty: List<string>.() -&gt; Boolean = List<string>::isEmpty    // 函数类型一定要指明接受者, 因为无法自动推断出来<br>  val list = listOf(“1”)<br>  print(“isEmpty: ${isListEmpty(list)}”)                                 // 可将调用者作为第一个参数传入<br>  print(“isEmpty: ${list.isListEmpty()}”)                                // 和上面是等价的</string></string></li>
<li>引用需要接受者的函数时, 使用 类名 和 类实例 都可以<br>  class Test{<pre><code>fun double (p: Int) = 2 * p
</code></pre>  }<br>  val test = Test()<br>  val d1: Test.(Int) -&gt; Int = Test::double                               // 使用类名限定<br>  val d2: (Int) -&gt; Int = test::double                                    // 使用类实例限定<br>  val result1 = d1(test, 3)                                              // 需要将调用者作为第一个参数, 或者直接  test.d1(3)<br>  val result2 = d2(3)                                                    // 无需再设置调用者</li>
<li>引用特定对象的函数<br>  val numberRegex = “\d+”.toRegex()<br>  println(numberRegex.matches(“29”))                                     // 输出“true”<br>  val isNumber = numberRegex::matches<br>  println(isNumber(“29”))                                                // 输出“true”</li>
<li>构造函数引用<br>  ::类名                // 表示 零参数构造函数 的引用</li>
</ul>
</li>
<li>属性引用<ul>
<li>获取属性的引用<br>  var x = 1<br>  ::x.name              // 获取属性名<br>  ::x.get()             // 获取值<br>  ::x.set(3)            // 对于 var 属性, 还可以赋值</li>
<li>在外部引用类的属性<br>  class A(var p: Int)<br>  val a = A(3)<br>  A::p.set(a, 5)<br>  val value = A::p.get(a)</li>
<li>引用类的扩展属性<br>  val String.lastChar: Char<pre><code>get() = this[length - 1]
</code></pre>  val str = “abc”<br>  val result = String::lastChar.get(str)</li>
<li>引用特定对象的属性<br>  val prop = “abc”::length<br>  val l = prop.get()</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>1.</p>
<ol>
<li>通过 launch、 runBlocking 开启协程<ul>
<li>一个关于协程的小案例<br>  override fun onCreate(savedInstanceState: Bundle?){<pre><code>setContentView(R.layout.activity_main)
launch(CommonPool) {                    // 在后台启动一个协程
    delay(1000L)                        // 延迟1s,  delay是一个特殊的 suspend fun, 不会锁死线程, 只会挂起协程, 只能在协程内使用
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
runBlocking{                            // 在当前线程启动协程, 会阻塞当前线程, 直到协程内部的代码运行完毕
    delay(1000L)  
}
</code></pre>  }</li>
<li>直接用 runBlocking 包裹整个函数 (泛型是指当前函数的返回值类型, 如果需要返回值, runBlocking 代码块的最后一个表达式会作为返回值)<br> override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{    <pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
launch(CommonPool) {
    delay(2000L)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
delay(2100L)
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre> }</unit></li>
<li>等待协程运行完毕<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {                                  // 启动新的协程, 并通过变量保留其引用
    delay(2000L)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
job.join()                                                           // 等待子协程结束后才会执行后面的代码
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
</ul>
</li>
<li>协程的取消<ul>
<li>通过 lauch返回的 job,  调用 cancel() 可以取消协程<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {
    repeat(100){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i @ ${Thread.currentThread().name}&quot;)
        delay(1000L)
    }
}
delay(3100L)
job.cancel()                                // 取消协程
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>如果协程一直在运行, 那么它就不会去检查取消标志, 结构就无法取消成功. 解决方式是 在代码中主动去检查取消标志<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
var time = System.currentTimeMillis()
val job: Job = launch(CommonPool) {
    var i = 0
    while (isActive &amp;&amp; i &lt; 1000){                  // isActive是协程内部的一个属性,可以检查该协程是否被取消
        if(System.currentTimeMillis() &gt;= time){
            Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;${i++} @ ${Thread.currentThread().name}&quot;)
            time += 1000
        }
    }
}
delay(3100L)
job.cancel()
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>协程取消时时候回抛出 CancellationException, 可以通过  try {} finally {} 处理<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) {
    try {
        repeat(1000){ i -&gt;
            Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i @ ${Thread.currentThread().name}&quot;)
            delay(500)
        }
    }catch (e: Exception){                        // catch不是必须的, 这里只是验证确实抛出了异常
        Log.e(&quot;&gt;&gt;&gt;&quot;, e.toString())
    }fianlly{ ... }
}
delay(3100L)
job.cancel()
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>超时自动取消 (withTimeout): 在当前线程启动协程, 如果协程内的代码在指定时间内未执行完毕, 就抛出异常 TimeoutException<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val result = withTimeout(3000){                                             
    repeat(10){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i: @ ${Thread.currentThread().name}&quot;)
        delay(1000)
    }
    &quot;最后一行表达式就是结果&quot;
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;结果等于: $result&quot;)
</code></pre>  }</unit></li>
<li>安全的超时自动取消(withTimeoutOrNull): 超时后不会抛出异常, 只是返回结果是 null<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val result = withTimeoutOrNull(3000){
    repeat(1){ i -&gt;
        Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$i: @ ${Thread.currentThread().name}&quot;)
        delay(1000)
    }
    &quot;最后一行表达式就是结果&quot;
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;结果等于: $result&quot;)
</code></pre>  }</unit></li>
</ul>
</li>
<li>suspend fun :  由 suspend 修饰的方法, 和普通方法结构完全一样<ul>
<li>suspend fun 只能在另一个 suspend fun 中调用<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job: Job = launch(CommonPool) { test() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Hello: @ ${Thread.currentThread().name}&quot;)
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;over: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }<br>  suspend fun test(){<pre><code>delay(2000L)
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;World: @ ${Thread.currentThread().name}&quot;)
</code></pre>  }</unit></li>
<li>多个 suspend fun 的执行顺序<ul>
<li>默认是串行执行<br>  suspend fun one(): Int{         // 延迟 1s 后返回 1<pre><code>delay(1000L)
return 1
</code></pre>  }<br>  suspend fun two(): Int{         // 延迟 1s 后返回 2<pre><code>delay(1000L)
return 2
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {                   // 在当前线程启动协程, 会阻塞当前线程, 最后会返回该协程消耗的时长
    val one = one()
    val two = two()
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one + two}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)                   // 时间差不多是 2s
</code></pre>  }</unit></li>
<li>async &amp; await<ul>
<li>说明:<br>  async 的作用是在后台启动一个协程, 并返回一个 Deferred 对象, 它是Job的子类, 表示一个承诺(promise) 会在稍后返回一个结果<br>  await 是 Deferred 上的一个方法, 作用是获取最终的结果 (会挂起当前协程, 直到获取到结果才会执行后面的代码)</li>
<li>示例:<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {
    val one = async(CommonPool){ one() }     // 在后台启动一个新的协程
    val two = async(CommonPool){ two() }
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}   @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)               // 因为是 并行执行的, 时间差不多缩短一半
</code></pre>  }</unit></li>
<li>async 的惰性求值: async函数可以传入一个参数 CoroutineStart.LAZY, 开启惰性求值, 表示只有调用 awaite 或 start 时开会开启协程<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val time = measureTimeMillis {
    val one = async(CommonPool, CoroutineStart.LAZY){ one() }     
    val two = async(CommonPool, CoroutineStart.LAZY){ two() }
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}   @ ${Thread.currentThread().name}&quot;)
}
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;耗费时长: $time&quot;)               // 时间 又 差不多是 2s
</code></pre>  }</unit></li>
<li>async 风格的函数<br>  fun oneAsync() = async(CommonPool){              // oneAsync 就是一个普通函数, 不过调用它时会异步开启一个协程<pre><code>one()   
</code></pre>  }<br>  fun twoAsync() = async(CommonPool){<pre><code>two()
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) {           // 注意这里没有了 runBlocking<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val one = oneAsync()                                       // 可以在协程之外调用
val two = twoAsync()
runBlocking {
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;计算结果: ${one.await() + two.await()}&quot;)  // 但是 await 还是必须要在协程中调用
}
</code></pre>  }</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>协程的上下文:  协程总是在 CoroutineContext 类型的上下文中执行<ul>
<li>协程调度器: 决定协程将要在 哪个(或哪些)线程中执行<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val jobs = arrayListOf&lt;Job&gt;()
jobs += launch(Unconfined){           // 无限制, 会在当前线程开启协程
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Unconfined @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(coroutineContext){     // 限制使用 父级上下文, 这里是 runBlocking的上下文(任何协程内都能获取 coroutineContext)
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;coroutineContext @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(CommonPool){           // 一个线程池 ForkJoinPool.commonPool
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;CommonPool @ ${Thread.currentThread().name}&quot;)
}
jobs += launch(newSingleThreadContext(&quot;MyNewThread&quot;)){ // 开启新的线程, 实际项目中如果不再使用它, 需要通过 close 方法释放
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;newSingleThreadContext @ ${Thread.currentThread().name}&quot;)
}
jobs.forEach { it.join() }
</code></pre>  }</unit></li>
<li>父子协程: 如果 协程B 使用了 协程A 的上下文, 那么 B 就是 A 的子协程<ul>
<li>父协程会等其所有子协程执行完毕后才会结束</li>
<li>取消父协程, 它所有的子协程也会取消</li>
</ul>
</li>
</ul>
</li>
<li>Channel: 用于在 协程间 发送 和 接收 数据<ul>
<li>send &amp; receive : 发送数据与接受 (都会将协挂起)<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val channel = Channel&lt;Int&gt;()
val job = launch(CommonPool){
    for (i in 1 .. 5)
        channel.send( i * i)           // 发送数据
    channel.close()                    // 发送结束
}
for (value in channel)                 // 迭代获取数据 (底层通过 receive) , 直到 channel 关闭
    Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$value&quot;)
job.join()
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Over&quot;)
</code></pre>  }</unit></li>
<li>使用 produce &amp; consumeEach 简化 channel 的生产和消费<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val product = product()
product.consumeEach { Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$it&quot;) }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;Over&quot;)
</code></pre>  }<br>  fun product() = produce<int>(CommonPool){<pre><code>for (i in 1 .. 5) send( i * i)
</code></pre>  }</int></unit></li>
<li>Channel缓冲区:<ul>
<li>Channel 默认不开启缓冲, 它会等 send 和 receive都准备好之后再进行数据传输. 如果 send先调用, 也会挂起直到 receive被调用</li>
<li>构建 Channel 是可以指定缓冲区大小. 设置缓冲的情况下, 允许在没有 receive的时候先发送几条数据, 直到填满缓冲区<br>  val channel = Channel<int>(5)</int></li>
</ul>
</li>
</ul>
</li>
<li>多个协程更改共享数据<ul>
<li>数据安全问题: 多个协程同时对数据进行修改, 导致结果的未知性<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val jobs = List(1000){
    launch(CommonPool){
        count++
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)                // 结果不可预知
</code></pre>  }</unit></li>
<li>解决方式<ul>
<li>方式一: 粗粒度的控制, 将所有协程 限制在 一个线程上<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val ctx = newSingleThreadContext(&quot;ctx1&quot;)
val jobs = List(1000){
    launch(ctx){
        count++
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)           // 结果是 1000
</code></pre>  }</unit></li>
<li>方式二: 细粒度的控制, 使用互斥锁 Mutex<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
var count = 0
val mutex = Mutex()
val jobs = List(1000){
    launch(CommonPool){
        mutex.withLock { count++ }        // 等价于  mutex.lock(); try{ count++ } finally{ mutex.unlock() }
    }
}
jobs.forEach { it.join() }
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;$count&quot;)                    // 结果是 1000
</code></pre>  }</unit></li>
<li>方式三: 使用 Actor (就是一个协程, 其中可以保存数据, 并带有一个和其它协程通信的 channel )<br>  sealed class CounterMsg<br>  object IncCounter: CounterMsg()<br>  class GetCounter(val response: CompletableDeferred<int>): CounterMsg()<br>  fun counterActor() = actor<countermsg>(CommonPool){<pre><code>var counter = 0
for (msg in channel){                                      // 迭代收到的数据
    when(msg){
        is IncCounter -&gt; counter++                         // 修改数据
        is GetCounter -&gt; msg.response.complete(counter)    // 将结果返回
    }
}
</code></pre>  }<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
val counter = counterActor()                          // 创建 Actor
val jobs = List(1000){
    launch(CommonPool){
        counter.send(IncCounter)                      // 发送消息 通知修改数据
    }
}
jobs.forEach { it.join() }
val res = CompletableDeferred&lt;Int&gt;()                  // 用于获取数据
counter.send(GetCounter(res))                         // 发送消息 通知需要获取结果
Log.e(&quot;&gt;&gt;&gt;&quot;, &quot;${res.await()}&quot;)                        // 结果是 1000
counter.close()
</code></pre>  }</unit></countermsg></int></li>
</ul>
</li>
</ul>
</li>
<li>在 Android中使用协程<ul>
<li>添加依赖: implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-android:0.18’</li>
<li>一个简单的案例<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
val job = launch(UI){                      // 使用 UI 上下文 开启协程
    for (i in 10 downTo 1){
        tv.text = &quot;CountDown $i&quot;           // 修改 TextView 的 文本
        delay(500L)                        // 延迟 500  (不会阻塞线程, 只会挂起协程)
    }
    tv.text = &quot;Done&quot;
}
bt.setOnClickListener { job.cancel() }     // 点击按钮 取消协程
</code></pre>  }</unit></li>
<li>通过UI上下文使用 actor<br>  override fun onCreate(savedInstanceState: Bundle?) = runBlocking<unit>{<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
bt.onClick {
    for (i in 10 downTo 1){
        tv.text = &quot;Hellow: $i&quot;
        delay(500)
    }
    tv.text = &quot;Done!!!&quot;
}
</code></pre>  }<br>  fun View.onClick(action: suspend () -&gt; Unit){<pre><code>val eventActor = actor&lt;Unit&gt;(UI){
    for (event in channel) action()
}
setOnClickListener{
    // offer方法会尝试给 actor传递数据, 如果此时actor正在处理其它数据, 则会根据情况做不同处理
        // 通过 actor&lt;Unit&gt;(UI) 创建的 actor                   -&gt;  直接将新的数据丢弃
        // 通过 actor&lt;Unit&gt;(UI, Channel.CONFLATED) 创建的数据   -&gt;  保留最新的那条数据, 等 actor空闲后再传入
        // 通过 actor&lt;Unit&gt;(UI, Channel.UNLIMITED) 创建的数据   -&gt;  将所有新数据依次保存, 等 actor空闲后再依次传入
    eventActor.offer(Unit)
}
</code></pre>  }</unit></li>
<li>使用协程的一些建议<ul>
<li>为了便于在页面销毁时统一释放资源, 建议将页面中的所有协程用一个 Job管理<br>  interface JobHolder{<pre><code>val job: Job
</code></pre>  }<br>  class MainActivity : AppCompatActivity(), JobHolder {<pre><code>override val job: Job = Job()                           // 每个页面都持有一个顶层 job
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    launch(job + UI){ ... }                             // 开启协程时, 这样传递上下文
}
override fun onDestroy() {
    super.onDestroy()
    job.cancel()                                         // 页面销毁时取消
}
</code></pre>  }</li>
<li>假如需要在自定义View中获取 Job, 可以通过扩展属性实现<br>  val View.contextJob: Job<pre><code>get() = (context as? JobHolder)?.job ?: NonCancellable
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kotlin/" rel="tag"># kotlin</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/12/Eventbus使用及源码分析/" rel="next" title="Eventbus使用及源码分析">
                <i class="fa fa-chevron-left"></i> Eventbus使用及源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/12/Android通过系统获取图片及截图/" rel="prev" title="Android通过系统获取图片及截图">
                Android通过系统获取图片及截图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">The blog from a Android coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">3.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理-委托"><span class="nav-number">4.</span> <span class="nav-text">代理(委托)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数-amp-Lambda"><span class="nav-number">6.</span> <span class="nav-text">高阶函数 &amp; Lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它"><span class="nav-number">7.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">8.</span> <span class="nav-text">协程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
