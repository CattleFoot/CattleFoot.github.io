<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeastRecentlyUsed_最近最少使用 | CallteFoot&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2  CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="LeastRecentlyUsed_最近最少使用">
<meta property="og:url" content="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/index.html">
<meta property="og:site_name" content="CallteFoot's blog">
<meta property="og:description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2  CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c">
<meta property="og:updated_time" content="2017-05-02T11:59:57.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeastRecentlyUsed_最近最少使用">
<meta name="twitter:description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2  CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c">
  
    <link rel="alternate" href="/atom.xml" title="CallteFoot&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CallteFoot&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cattlefoot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-LeastRecentlyUsed-最近最少使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/LeastRecentlyUsed-最近最少使用/" class="article-date">
  <time datetime="2017-04-26T13:13:53.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeastRecentlyUsed_最近最少使用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&ensp;&ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">libcore.io.DiskLruCache</div><div class="line"> 1</div><div class="line"> 100</div><div class="line"> 2</div><div class="line"> </div><div class="line"> CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</div><div class="line"> DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class="line"> CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</div><div class="line"> REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class="line"> DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class="line"> CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class="line"> READ 335c4c6028171cfddfbaae1a9c313c52</div><div class="line"> READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;文件内容解析：</p>
<ol>
<li>第一行固定字符串内容，没有多大意义；</li>
<li>第二行DiskLruCache的版本好，源码常量1；</li>
<li>第三行为app的版本好，这个可以自己传入；</li>
<li>第四行值得是每个key对应几个文件，一般为1；</li>
<li>空行做分割下面内容用；</li>
<li>DIRTY 表示一个正在被写入（其实就是吧文件的outputstream交给你），写入分我两种情况：成功则写入一行CLEAN的记录；失败则写入一条REMOVE的记录,如果一条DIRTY没有一条CLEAN或REMOVE和它对应，那么这条记录就可以删除；</li>
<li>REMOVE除了上述情况，当自己手动调用删除remover（key）方法也会写入一条记录；</li>
<li>READ 说明有一次读取的记录；</li>
<li>Clean的后面记录了文件的长度，和key关联了多少个文件；<br>&ensp;&ensp;这里看出，只有CLEAN且没有REMOVE的记录，才是真正可用的Cache Entry记录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</div><div class="line">      throws IOException &#123;</div><div class="line"></div><div class="line">    // If a bkp file exists, use it instead.</div><div class="line">    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);</div><div class="line">    if (backupFile.exists()) &#123;</div><div class="line">      File journalFile = new File(directory, JOURNAL_FILE);</div><div class="line">      // If journal file also exists just delete backup file.</div><div class="line">      if (journalFile.exists()) &#123;</div><div class="line">        backupFile.delete();</div><div class="line">      &#125; else &#123;</div><div class="line">        renameTo(backupFile, journalFile, false);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Prefer to pick up where we left off.</div><div class="line">    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    if (cache.journalFile.exists()) &#123;</div><div class="line">      try &#123;</div><div class="line">        cache.readJournal();</div><div class="line">        cache.processJournal();</div><div class="line">        return cache;</div><div class="line">      &#125; catch (IOException journalIsCorrupt) &#123;</div><div class="line">        System.out</div><div class="line">            .println(&quot;DiskLruCache &quot;</div><div class="line">                + directory</div><div class="line">                + &quot; is corrupt: &quot;</div><div class="line">                + journalIsCorrupt.getMessage()</div><div class="line">                + &quot;, removing&quot;);</div><div class="line">        cache.delete();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Create a new empty cache.</div><div class="line">    directory.mkdirs();</div><div class="line">    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    cache.rebuildJournal();</div><div class="line">    return cache;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp;验证记录文件是否存在，首先检查存不存在journal.bkp（journal的备份文件）如果存在：然后检查journal文件是否存在，如果正主在，bkp文件就可以删除了；如果不存在，将bkp文件重命名为journal文件。<br>接下里判断journal文件是否存在，</p>
<ul>
<li>如果不存在创建directory；重新构造disklrucache；调用rebuildJournal建立journal文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Creates a new journal that omits redundant information. This replaces the</div><div class="line">   * current journal if it exists.</div><div class="line">   */</div><div class="line">  private synchronized void rebuildJournal() throws IOException &#123;</div><div class="line">    if (journalWriter != null) &#123;</div><div class="line">      journalWriter.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Writer writer = new BufferedWriter(</div><div class="line">        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));</div><div class="line">    try &#123;</div><div class="line">      writer.write(MAGIC);</div><div class="line">      writer.write(&quot;\n&quot;);</div><div class="line">      writer.write(VERSION_1);</div><div class="line">      writer.write(&quot;\n&quot;);</div><div class="line">      writer.write(Integer.toString(appVersion));</div><div class="line">      writer.write(&quot;\n&quot;);</div><div class="line">      writer.write(Integer.toString(valueCount));</div><div class="line">      writer.write(&quot;\n&quot;);</div><div class="line">      writer.write(&quot;\n&quot;);</div><div class="line"></div><div class="line">      for (Entry entry : lruEntries.values()) &#123;</div><div class="line">        if (entry.currentEditor != null) &#123;</div><div class="line">          writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\n&apos;);</div><div class="line">        &#125; else &#123;</div><div class="line">          writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">      writer.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (journalFile.exists()) &#123;</div><div class="line">      renameTo(journalFile, journalFileBackup, true);</div><div class="line">    &#125;</div><div class="line">    renameTo(journalFileTmp, journalFile, false);</div><div class="line">    journalFileBackup.delete();</div><div class="line"></div><div class="line">    journalWriter = new BufferedWriter(</div><div class="line">        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&ensp;&ensp;可以看到首先构建一个journal.tmp文件，然后写入文件头（5行），然后遍历lruEntries（lruEntries = new LinkedHashMap<string, entry="">(0, 0.75f, true);），当然我们这里没有任何数据。接下来将tmp文件重命名为journal文件。</string,></p>
<ul>
<li>如果已经存在，那么调用readJournal</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">private void readJournal() throws IOException &#123;</div><div class="line">StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);</div><div class="line">try &#123;</div><div class="line">  String magic = reader.readLine();</div><div class="line">  String version = reader.readLine();</div><div class="line">  String appVersionString = reader.readLine();</div><div class="line">  String valueCountString = reader.readLine();</div><div class="line">  String blank = reader.readLine();</div><div class="line">  if (!MAGIC.equals(magic)</div><div class="line">      || !VERSION_1.equals(version)</div><div class="line">      || !Integer.toString(appVersion).equals(appVersionString)</div><div class="line">      || !Integer.toString(valueCount).equals(valueCountString)</div><div class="line">      || !&quot;&quot;.equals(blank)) &#123;</div><div class="line">    throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot;</div><div class="line">        + valueCountString + &quot;, &quot; + blank + &quot;]&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  int lineCount = 0;</div><div class="line">  while (true) &#123;</div><div class="line">    try &#123;</div><div class="line">      readJournalLine(reader.readLine());</div><div class="line">      lineCount++;</div><div class="line">    &#125; catch (EOFException endOfJournal) &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  redundantOpCount = lineCount - lruEntries.size();</div><div class="line"></div><div class="line">  // If we ended on a truncated line, rebuild the journal before appending to it.</div><div class="line">  if (reader.hasUnterminatedLine()) &#123;</div><div class="line">    rebuildJournal();</div><div class="line">  &#125; else &#123;</div><div class="line">    journalWriter = new BufferedWriter(new OutputStreamWriter(</div><div class="line">        new FileOutputStream(journalFile, true), Util.US_ASCII));</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  Util.closeQuietly(reader);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp;首先校验文件头，接下来调用readJournalLine按行读取内容。我们来看看readJournalLine中的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private void readJournalLine(String line) throws IOException &#123;</div><div class="line">int firstSpace = line.indexOf(&apos; &apos;);</div><div class="line">if (firstSpace == -1) &#123;</div><div class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int keyBegin = firstSpace + 1;</div><div class="line">int secondSpace = line.indexOf(&apos; &apos;, keyBegin);</div><div class="line">final String key;</div><div class="line">if (secondSpace == -1) &#123;</div><div class="line">  key = line.substring(keyBegin);</div><div class="line">  if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</div><div class="line">    lruEntries.remove(key);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">&#125; else &#123;</div><div class="line">  key = line.substring(keyBegin, secondSpace);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Entry entry = lruEntries.get(key);</div><div class="line">if (entry == null) &#123;</div><div class="line">  entry = new Entry(key);</div><div class="line">  lruEntries.put(key, entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</div><div class="line">  String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);</div><div class="line">  entry.readable = true;</div><div class="line">  entry.currentEditor = null;</div><div class="line">  entry.setLengths(parts);</div><div class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</div><div class="line">  entry.currentEditor = new Editor(entry);</div><div class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</div><div class="line">  // This work was already done by calling lruEntries.get().</div><div class="line">&#125; else &#123;</div><div class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;大家可以回忆下：每个记录至少有一个空格，有的包含两个空格。首先，拿到key，如果是REMOVE的记录呢，会调用lruEntries.remove(key);如果不是REMOVE记录，继续往下，如果该key没有加入到lruEntries，则创建并且加入。接下来，如果是CLEAN开头的合法记录，初始化entry，设置readable=true,currentEditor为null，初始化长度等。如果是DIRTY，设置currentEditor对象。如果是READ，那么直接不管。ok，经过上面这个过程，大家回忆下我们的记录格式，一般DIRTY不会单独出现，会和REMOVE、CLEAN成对出现（正常操作）；也就是说，经过上面这个流程，基本上加入到lruEntries里面的只有CLEAN且没有被REMOVE的key。好了，回到readJournal方法，在我们按行读取的时候，会记录一下lineCount，然后最后给redundantOpCount赋值，这个变量记录的应该是没用的记录条数（文件的行数-真正可以的key的行数）。</p>
<p>最后，如果读取过程中发现journal文件有问题，则重建journal文件。没有问题的话，初始化下journalWriter，关闭reader。<br>readJournal完成了，会继续调用processJournal()这个方法内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private void processJournal() throws IOException &#123;</div><div class="line">deleteIfExists(journalFileTmp);</div><div class="line">for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</div><div class="line">  Entry entry = i.next();</div><div class="line">  if (entry.currentEditor == null) &#123;</div><div class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</div><div class="line">      size += entry.lengths[t];</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    entry.currentEditor = null;</div><div class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</div><div class="line">      deleteIfExists(entry.getCleanFile(t));</div><div class="line">      deleteIfExists(entry.getDirtyFile(t));</div><div class="line">    &#125;</div><div class="line">    i.remove();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>统计所有可用的cache占据的容量，赋值给size；对于所有非法DIRTY状态（就是DIRTY单独出现的）的entry，如果存在文件则删除，并且从lruEntries中移除。此时，剩的就真的只有CLEAN状态的key记录了。<br>&ensp;&ensp;到此就初始化完毕了，太长了，根本记不住，我带大家总结下上面代码。根据我们传入的dir，去找journal文件，如果找不到，则创建个，只写入文件头(5行)。 如果找到，则遍历该文件，将里面所有的CLEAN记录的key，存到lruEntries中。这么长的代码，其实就两句话的意思。经过open以后，journal文件肯定存在了；lruEntries里面肯定有值了；size存储了当前所有的实体占据的容量；</p>
<p><strong>存入缓存</strong><br>存入操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String key = generateKey(url);  </div><div class="line">DiskLruCache.Editor editor = mDiskLruCache.edit(key); </div><div class="line">OuputStream os = editor.newOutputStream(0); </div><div class="line">//...after op</div><div class="line">editor.commit()；</div></pre></td></tr></table></figure></p>
<p>首先就是editor方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Returns an editor for the entry named &#123;@code key&#125;, or null if another</div><div class="line">   * edit is in progress.</div><div class="line">   */</div><div class="line">  public Editor edit(String key) throws IOException &#123;</div><div class="line">    return edit(key, ANY_SEQUENCE_NUMBER);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123;</div><div class="line">      checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null</div><div class="line">        || entry.sequenceNumber != expectedSequenceNumber)) &#123;</div><div class="line">      return null; // Snapshot is stale.</div><div class="line">    &#125;</div><div class="line">    if (entry == null) &#123;</div><div class="line">      entry = new Entry(key);</div><div class="line">      lruEntries.put(key, entry);</div><div class="line">    &#125; else if (entry.currentEditor != null) &#123;</div><div class="line">      return null; // Another edit is in progress.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Editor editor = new Editor(entry);</div><div class="line">    entry.currentEditor = editor;</div><div class="line"></div><div class="line">    // Flush the journal before creating files to prevent file leaks.</div><div class="line">    journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\n&apos;);</div><div class="line">    journalWriter.flush();</div><div class="line">    return editor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&nesp;&nesp;首先验证key，可以必须是字母、数字、下划线、横线（-）组成，且长度在1-120之间。然后通过key获取实体，因为我们是存，只要不是正在编辑这个实体，理论上都能返回一个合法的editor对象。所以接下来判断，如果不存在，则创建一个Entry加入到lruEntries中（如果存在，直接使用），然后为entry.currentEditor进行赋值为new Editor(entry);，最后在journal文件中写入一条DIRTY记录，代表这个文件正在被操作。</p>
<p>注意，如果entry.currentEditor != null不为null的时候，意味着该实体正在被编辑，会retrun null ;拿到editor对象以后，就是去调用newOutputStream去获得一个文件输入流了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Returns a new unbuffered output stream to write the value at</div><div class="line">     * &#123;@code index&#125;. If the underlying output stream encounters errors</div><div class="line">     * when writing to the filesystem, this edit will be aborted when</div><div class="line">     * &#123;@link #commit&#125; is called. The returned output stream does not throw</div><div class="line">     * IOExceptions.</div><div class="line">     */</div><div class="line">    public OutputStream newOutputStream(int index) throws IOException &#123;</div><div class="line">      if (index &lt; 0 || index &gt;= valueCount) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Expected index &quot; + index + &quot; to &quot;</div><div class="line">                + &quot;be greater than 0 and less than the maximum value count &quot;</div><div class="line">                + &quot;of &quot; + valueCount);</div><div class="line">      &#125;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (entry.currentEditor != this) &#123;</div><div class="line">          throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        if (!entry.readable) &#123;</div><div class="line">          written[index] = true;</div><div class="line">        &#125;</div><div class="line">        File dirtyFile = entry.getDirtyFile(index);</div><div class="line">        FileOutputStream outputStream;</div><div class="line">        try &#123;</div><div class="line">          outputStream = new FileOutputStream(dirtyFile);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">          // Attempt to recreate the cache directory.</div><div class="line">          directory.mkdirs();</div><div class="line">          try &#123;</div><div class="line">            outputStream = new FileOutputStream(dirtyFile);</div><div class="line">          &#125; catch (FileNotFoundException e2) &#123;</div><div class="line">            // We are unable to recover. Silently eat the writes.</div><div class="line">            return NULL_OUTPUT_STREAM;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        return new FaultHidingOutputStream(outputStream);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先校验index是否在valueCount范围内，一般我们使用都是一个key对应一个文件所以传入的基本都是0。接下来就是通过entry.getDirtyFile(index);拿到一个dirty File对象，为什么叫dirty file呢，其实就是个中转文件，文件格式为key.index.tmp。<br>将这个文件的FileOutputStream通过FaultHidingOutputStream封装下传给我们。<br>最后，别忘了我们通过os写入数据以后，需要调用commit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void commit() throws IOException &#123;</div><div class="line">      if (hasErrors) &#123;</div><div class="line">        completeEdit(this, false);</div><div class="line">        remove(entry.key); // The previous entry is stale.</div><div class="line">      &#125; else &#123;</div><div class="line">        completeEdit(this, true);</div><div class="line">      &#125;</div><div class="line">      committed = true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先通过hasErrors判断，是否有错误发生，如果有调用completeEdit(this, false)且调用remove(entry.key);。如果没有就调用completeEdit(this, true);。</p>
<p>那么这里这个hasErrors哪来的呢？还记得上面newOutputStream的时候，返回了一个os，这个os是FileOutputStream，但是经过了FaultHidingOutputStream封装么，这个类实际上就是重写了FilterOutputStream的write相关方法，将所有的IOException给屏蔽了，如果发生IOException就将hasErrors赋值为true.</p>
<p>这样的设计还是很nice的，否则直接将OutputStream返回给用户，如果出错没法检测，还需要用户手动去调用一些操作。</p>
<p>接下来看completeEdit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</div><div class="line">    Entry entry = editor.entry;</div><div class="line">    if (entry.currentEditor != editor) &#123;</div><div class="line">      throw new IllegalStateException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If this edit is creating the entry for the first time, every index must have a value.</div><div class="line">    if (success &amp;&amp; !entry.readable) &#123;</div><div class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">        if (!editor.written[i]) &#123;</div><div class="line">          editor.abort();</div><div class="line">          throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</div><div class="line">        &#125;</div><div class="line">        if (!entry.getDirtyFile(i).exists()) &#123;</div><div class="line">          editor.abort();</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">      File dirty = entry.getDirtyFile(i);</div><div class="line">      if (success) &#123;</div><div class="line">        if (dirty.exists()) &#123;</div><div class="line">          File clean = entry.getCleanFile(i);</div><div class="line">          dirty.renameTo(clean);</div><div class="line">          long oldLength = entry.lengths[i];</div><div class="line">          long newLength = clean.length();</div><div class="line">          entry.lengths[i] = newLength;</div><div class="line">          size = size - oldLength + newLength;</div><div class="line">        &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">        deleteIfExists(dirty);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redundantOpCount++;</div><div class="line">    entry.currentEditor = null;</div><div class="line">    if (entry.readable | success) &#123;</div><div class="line">      entry.readable = true;</div><div class="line">      journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</div><div class="line">      if (success) &#123;</div><div class="line">        entry.sequenceNumber = nextSequenceNumber++;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      lruEntries.remove(entry.key);</div><div class="line">      journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\n&apos;);</div><div class="line">    &#125;</div><div class="line">    journalWriter.flush();</div><div class="line"></div><div class="line">    if (size &gt; maxSize || journalRebuildRequired()) &#123;</div><div class="line">      executorService.submit(cleanupCallable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;首先判断if (success &amp;&amp; !entry.readable)是否成功，且是第一次写入（如果以前这个记录有值，则readable=true），内部的判断，我们都不会走，因为written[i]在newOutputStream的时候被写入true了。而且正常情况下，getDirtyFile是存在的。<br>&ensp;&ensp;接下来，如果成功，将dirtyFile 进行重命名为 cleanFile，文件名为：key.index。然后刷新size的长度。如果失败，则删除dirtyFile.<br>&ensp;&ensp;接下来，如果成功或者readable为true，将readable设置为true，写入一条CLEAN记录。如果第一次提交且失败，那么就会从lruEntries.remove(key)，写入一条REMOVE记录。</p>
<p>写入缓存，肯定要控制下size。于是最后，判断是否超过了最大size，或者需要重建journal文件，什么时候需要重建呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private boolean journalRebuildRequired() &#123;</div><div class="line">   final int redundantOpCompactThreshold = 2000;</div><div class="line">   return redundantOpCount &gt;= redundantOpCompactThreshold //</div><div class="line">       &amp;&amp; redundantOpCount &gt;= lruEntries.size();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p> &ensp;&ensp;如果redundantOpCount达到2000，且超过了lruEntries.size()就重建，这里就可以看到redundantOpCount的作用了。防止journal文件过大。<br> &ensp;&ensp;ok，到此我们的存入缓存就分析完成了。再次总结下，首先调用editor，拿到指定的dirtyFile的OutputStream，你可以尽情的进行写操作，写完以后呢，记得调用commit。<br> &ensp;&ensp;commit中会检测是你是否发生IOException，如果没有发生，则将dirtyFile-&gt;cleanFile，将readable=true，写入CLEAN记录。如果发生错误，则删除dirtyFile,从lruEntries中移除，然后写入一条REMOVE记录。<br><strong>读取缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);  </div><div class="line">if (snapShot != null) &#123;  </div><div class="line">  InputStream is = snapShot.getInputStream(0);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么首先看get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public synchronized Snapshot get(String key) throws IOException &#123;</div><div class="line">    checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    if (entry == null) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!entry.readable) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Open all streams eagerly to guarantee that we see a single published</div><div class="line">    // snapshot. If we opened streams lazily then the streams could come</div><div class="line">    // from different edits.</div><div class="line">    InputStream[] ins = new InputStream[valueCount];</div><div class="line">    try &#123;</div><div class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">        ins[i] = new FileInputStream(entry.getCleanFile(i));</div><div class="line">      &#125;</div><div class="line">    &#125; catch (FileNotFoundException e) &#123;</div><div class="line">      // A file must have been deleted manually!</div><div class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">        if (ins[i] != null) &#123;</div><div class="line">          Util.closeQuietly(ins[i]);</div><div class="line">        &#125; else &#123;</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redundantOpCount++;</div><div class="line">    journalWriter.append(READ + &apos; &apos; + key + &apos;\n&apos;);</div><div class="line">    if (journalRebuildRequired()) &#123;</div><div class="line">      executorService.submit(cleanupCallable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>get方法比较简单，如果取到的为null，或者readable=false，则返回null.否则将cleanFile的FileInputStream进行封装返回Snapshot，且写入一条READ语句。 然后getInputStream就是返回该FileInputStream了。<br>好了，到此，我们就分析完成了创建</p>
<p>DiskLruCache，存入缓存和取出缓存的源码。<br>除此以外，还有一些别的方法我们需要了解的。</p>
<p><strong>其他方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Drops the entry for &#123;@code key&#125; if it exists and can be removed. Entries</div><div class="line">   * actively being edited cannot be removed.</div><div class="line">   *</div><div class="line">   * @return true if an entry was removed.</div><div class="line">   */</div><div class="line">  public synchronized boolean remove(String key) throws IOException &#123;</div><div class="line">    checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    if (entry == null || entry.currentEditor != null) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">      File file = entry.getCleanFile(i);</div><div class="line">      if (file.exists() &amp;&amp; !file.delete()) &#123;</div><div class="line">        throw new IOException(&quot;failed to delete &quot; + file);</div><div class="line">      &#125;</div><div class="line">      size -= entry.lengths[i];</div><div class="line">      entry.lengths[i] = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redundantOpCount++;</div><div class="line">    journalWriter.append(REMOVE + &apos; &apos; + key + &apos;\n&apos;);</div><div class="line">    lruEntries.remove(key);</div><div class="line"></div><div class="line">    if (journalRebuildRequired()) &#123;</div><div class="line">      executorService.submit(cleanupCallable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return true;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果实体存在且不在被编辑，就可以直接进行删除，然后写入一条REMOVE记录。</p>
<p>与open对应还有个remove方法，大家在使用完成cache后可以手动关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** Closes this cache. Stored values will remain on the filesystem. */</div><div class="line">  public synchronized void close() throws IOException &#123;</div><div class="line">    if (journalWriter == null) &#123;</div><div class="line">      return; // Already closed.</div><div class="line">    &#125;</div><div class="line">    for (Entry entry : new ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</div><div class="line">      if (entry.currentEditor != null) &#123;</div><div class="line">        entry.currentEditor.abort();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    trimToSize();</div><div class="line">    journalWriter.close();</div><div class="line">    journalWriter = null;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>关闭前，会判断所有正在编辑的实体，调用abort方法，最后关闭journalWriter。至于abort方法，其实我们分析过了，就是存储失败的时候的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void abort() throws IOException &#123;</div><div class="line">      completeEdit(this, false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到此，我们的整个源码分析就结束了。可以看到DiskLruCache，利用一个journal文件，保证了保证了cache实体的可用性（只有CLEAN的可用），且获取文件的长度的时候可以通过在该文件的记录中读取。利用FaultHidingOutputStream对FileOutPutStream很好的对写入文件过程中是否发生错误进行捕获，而不是让用户手动去调用出错后的处理方法。其内部的很多细节都很值得推敲。</p>
<p>不过也可以看到，存取的操作不是特别的容易使用，需要大家自己去操作文件流，但在存储比较小的数据的时候（不存在内存问题），很多时候还是希望有类似put(key,value），getAsT(key)等方法直接使用。我看了ASimpleCache 提供的API属于比较好用的了。于是萌生想法，对DiskLruCache公开的API进行扩展，对外除了原有的存取方式以外，提供类似ASimpleCache那样比较简单的API用于存储，而内部的核心实现，依然是DiskLruCache原本的。</p>
<p>考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/47251585" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/47251585</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/" data-id="cj4dif5u80006iwu34c5mz6wu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/22/reactNative/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          关于react native页面全屏设置
        
      </div>
    </a>
  
  
    <a href="/2017/05/06/python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">python中@的作用</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/7/">7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Options/">Options</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Support/">Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/7/" style="font-size: 10px;">7</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/BitmapFactory/" style="font-size: 10px;">BitmapFactory</a> <a href="/tags/Download-Manager/" style="font-size: 15px;">Download Manager</a> <a href="/tags/Options/" style="font-size: 10px;">Options</a> <a href="/tags/Support/" style="font-size: 10px;">Support</a> <a href="/tags/Tool/" style="font-size: 10px;">Tool</a> <a href="/tags/git/" style="font-size: 10px;">git</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/24/downloadManagerSupport7-0/">downloadManagerSupport7.0</a>
          </li>
        
          <li>
            <a href="/2017/06/24/git命令和使用/">git命令和使用</a>
          </li>
        
          <li>
            <a href="/2017/06/21/Bitmap压缩/">Bitmap压缩</a>
          </li>
        
          <li>
            <a href="/2017/06/19/android-download-manager使用/">android_download_manager使用</a>
          </li>
        
          <li>
            <a href="/2017/06/03/rxjava2基础/">rxjava2基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 CallteFoot<br>
      Powered by <a href="https://cattlefoot.github.io" target="_blank">CallteFoot</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>