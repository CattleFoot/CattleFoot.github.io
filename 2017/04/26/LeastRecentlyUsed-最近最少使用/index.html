<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,LRU," />










<meta name="description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4">
<meta name="keywords" content="Java,LRU">
<meta property="og:type" content="article">
<meta property="og:title" content="LeastRecentlyUsed_最近最少使用">
<meta property="og:url" content="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-19T07:29:49.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeastRecentlyUsed_最近最少使用">
<meta name="twitter:description" content="&amp;ensp;&amp;ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：12345678910111213libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/"/>





  <title>LeastRecentlyUsed_最近最少使用 | CallteFoot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CallteFoot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Victory belongs to the most persevering</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cattlefoot.github.io/2017/04/26/LeastRecentlyUsed-最近最少使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CallteFoot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CallteFoot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeastRecentlyUsed_最近最少使用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T21:13:53+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&ensp;&ensp;LRU是Least Recently Used 近期最少使用算法，DiskLruCache是通过一个记录文件记录操作过程，从而保存各种文件,记录文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache</span><br><span class="line"> 1</span><br><span class="line"> 100</span><br><span class="line"> 2</span><br><span class="line"></span><br><span class="line"> CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line"> DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line"> REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line"> CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line"> READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;文件内容解析：</p>
<ol>
<li>第一行固定字符串内容，没有多大意义；</li>
<li>第二行DiskLruCache的版本好，源码常量1；</li>
<li>第三行为app的版本好，这个可以自己传入；</li>
<li>第四行值得是每个key对应几个文件，一般为1；</li>
<li>空行做分割下面内容用；</li>
<li>DIRTY 表示一个正在被写入（其实就是吧文件的outputstream交给你），写入分我两种情况：成功则写入一行CLEAN的记录；失败则写入一条REMOVE的记录,如果一条DIRTY没有一条CLEAN或REMOVE和它对应，那么这条记录就可以删除；</li>
<li>REMOVE除了上述情况，当自己手动调用删除remover（key）方法也会写入一条记录；</li>
<li>READ 说明有一次读取的记录；</li>
<li>Clean的后面记录了文件的长度，和key关联了多少个文件；<br>&ensp;&ensp;这里看出，只有CLEAN且没有REMOVE的记录，才是真正可用的Cache Entry记录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // If a bkp file exists, use it instead.</span><br><span class="line">    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">    if (backupFile.exists()) &#123;</span><br><span class="line">      File journalFile = new File(directory, JOURNAL_FILE);</span><br><span class="line">      // If journal file also exists just delete backup file.</span><br><span class="line">      if (journalFile.exists()) &#123;</span><br><span class="line">        backupFile.delete();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        renameTo(backupFile, journalFile, false);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prefer to pick up where we left off.</span><br><span class="line">    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    if (cache.journalFile.exists()) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.readJournal();</span><br><span class="line">        cache.processJournal();</span><br><span class="line">        return cache;</span><br><span class="line">      &#125; catch (IOException journalIsCorrupt) &#123;</span><br><span class="line">        System.out</span><br><span class="line">            .println(&quot;DiskLruCache &quot;</span><br><span class="line">                + directory</span><br><span class="line">                + &quot; is corrupt: &quot;</span><br><span class="line">                + journalIsCorrupt.getMessage()</span><br><span class="line">                + &quot;, removing&quot;);</span><br><span class="line">        cache.delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create a new empty cache.</span><br><span class="line">    directory.mkdirs();</span><br><span class="line">    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    return cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;验证记录文件是否存在，首先检查存不存在journal.bkp（journal的备份文件）如果存在：然后检查journal文件是否存在，如果正主在，bkp文件就可以删除了；如果不存在，将bkp文件重命名为journal文件。<br>接下里判断journal文件是否存在，</p>
<ul>
<li>如果不存在创建directory；重新构造disklrucache；调用rebuildJournal建立journal文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Creates a new journal that omits redundant information. This replaces the</span><br><span class="line">   * current journal if it exists.</span><br><span class="line">   */</span><br><span class="line">  private synchronized void rebuildJournal() throws IOException &#123;</span><br><span class="line">    if (journalWriter != null) &#123;</span><br><span class="line">      journalWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Writer writer = new BufferedWriter(</span><br><span class="line">        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">    try &#123;</span><br><span class="line">      writer.write(MAGIC);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(VERSION_1);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(Integer.toString(appVersion));</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(Integer.toString(valueCount));</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line">      writer.write(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">      for (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">        if (entry.currentEditor != null) &#123;</span><br><span class="line">          writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\n&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      renameTo(journalFile, journalFileBackup, true);</span><br><span class="line">    &#125;</span><br><span class="line">    renameTo(journalFileTmp, journalFile, false);</span><br><span class="line">    journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">    journalWriter = new BufferedWriter(</span><br><span class="line">        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&ensp;&ensp;可以看到首先构建一个journal.tmp文件，然后写入文件头（5行），然后遍历lruEntries（lruEntries = new LinkedHashMap<string, entry="">(0, 0.75f, true);），当然我们这里没有任何数据。接下来将tmp文件重命名为journal文件。</string,></p>
<ul>
<li>如果已经存在，那么调用readJournal</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readJournal() throws IOException &#123;</span><br><span class="line">StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">try &#123;</span><br><span class="line">  String magic = reader.readLine();</span><br><span class="line">  String version = reader.readLine();</span><br><span class="line">  String appVersionString = reader.readLine();</span><br><span class="line">  String valueCountString = reader.readLine();</span><br><span class="line">  String blank = reader.readLine();</span><br><span class="line">  if (!MAGIC.equals(magic)</span><br><span class="line">      || !VERSION_1.equals(version)</span><br><span class="line">      || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">      || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">      || !&quot;&quot;.equals(blank)) &#123;</span><br><span class="line">    throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot;</span><br><span class="line">        + valueCountString + &quot;, &quot; + blank + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int lineCount = 0;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      readJournalLine(reader.readLine());</span><br><span class="line">      lineCount++;</span><br><span class="line">    &#125; catch (EOFException endOfJournal) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">  // If we ended on a truncated line, rebuild the journal before appending to it.</span><br><span class="line">  if (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">    rebuildJournal();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    journalWriter = new BufferedWriter(new OutputStreamWriter(</span><br><span class="line">        new FileOutputStream(journalFile, true), Util.US_ASCII));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  Util.closeQuietly(reader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;首先校验文件头，接下来调用readJournalLine按行读取内容。我们来看看readJournalLine中的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void readJournalLine(String line) throws IOException &#123;</span><br><span class="line">int firstSpace = line.indexOf(&apos; &apos;);</span><br><span class="line">if (firstSpace == -1) &#123;</span><br><span class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int keyBegin = firstSpace + 1;</span><br><span class="line">int secondSpace = line.indexOf(&apos; &apos;, keyBegin);</span><br><span class="line">final String key;</span><br><span class="line">if (secondSpace == -1) &#123;</span><br><span class="line">  key = line.substring(keyBegin);</span><br><span class="line">  if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  key = line.substring(keyBegin, secondSpace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry entry = lruEntries.get(key);</span><br><span class="line">if (entry == null) &#123;</span><br><span class="line">  entry = new Entry(key);</span><br><span class="line">  lruEntries.put(key, entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">  String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);</span><br><span class="line">  entry.readable = true;</span><br><span class="line">  entry.currentEditor = null;</span><br><span class="line">  entry.setLengths(parts);</span><br><span class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">  entry.currentEditor = new Editor(entry);</span><br><span class="line">&#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">  // This work was already done by calling lruEntries.get().</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;大家可以回忆下：每个记录至少有一个空格，有的包含两个空格。首先，拿到key，如果是REMOVE的记录呢，会调用lruEntries.remove(key);如果不是REMOVE记录，继续往下，如果该key没有加入到lruEntries，则创建并且加入。接下来，如果是CLEAN开头的合法记录，初始化entry，设置readable=true,currentEditor为null，初始化长度等。如果是DIRTY，设置currentEditor对象。如果是READ，那么直接不管。ok，经过上面这个过程，大家回忆下我们的记录格式，一般DIRTY不会单独出现，会和REMOVE、CLEAN成对出现（正常操作）；也就是说，经过上面这个流程，基本上加入到lruEntries里面的只有CLEAN且没有被REMOVE的key。好了，回到readJournal方法，在我们按行读取的时候，会记录一下lineCount，然后最后给redundantOpCount赋值，这个变量记录的应该是没用的记录条数（文件的行数-真正可以的key的行数）。</p>
<p>最后，如果读取过程中发现journal文件有问题，则重建journal文件。没有问题的话，初始化下journalWriter，关闭reader。<br>readJournal完成了，会继续调用processJournal()这个方法内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void processJournal() throws IOException &#123;</span><br><span class="line">deleteIfExists(journalFileTmp);</span><br><span class="line">for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">  Entry entry = i.next();</span><br><span class="line">  if (entry.currentEditor == null) &#123;</span><br><span class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">      size += entry.lengths[t];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    entry.currentEditor = null;</span><br><span class="line">    for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">      deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">      deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">    &#125;</span><br><span class="line">    i.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>统计所有可用的cache占据的容量，赋值给size；对于所有非法DIRTY状态（就是DIRTY单独出现的）的entry，如果存在文件则删除，并且从lruEntries中移除。此时，剩的就真的只有CLEAN状态的key记录了。<br>&ensp;&ensp;到此就初始化完毕了，太长了，根本记不住，我带大家总结下上面代码。根据我们传入的dir，去找journal文件，如果找不到，则创建个，只写入文件头(5行)。 如果找到，则遍历该文件，将里面所有的CLEAN记录的key，存到lruEntries中。这么长的代码，其实就两句话的意思。经过open以后，journal文件肯定存在了；lruEntries里面肯定有值了；size存储了当前所有的实体占据的容量；</p>
<p><strong>存入缓存</strong><br>存入操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String key = generateKey(url);  </span><br><span class="line">DiskLruCache.Editor editor = mDiskLruCache.edit(key);</span><br><span class="line">OuputStream os = editor.newOutputStream(0);</span><br><span class="line">//...after op</span><br><span class="line">editor.commit()；</span><br></pre></td></tr></table></figure></p>
<p>首先就是editor方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Returns an editor for the entry named &#123;@code key&#125;, or null if another</span><br><span class="line">   * edit is in progress.</span><br><span class="line">   */</span><br><span class="line">  public Editor edit(String key) throws IOException &#123;</span><br><span class="line">    return edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123;</span><br><span class="line">      checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null</span><br><span class="line">        || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">      return null; // Snapshot is stale.</span><br><span class="line">    &#125;</span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">      entry = new Entry(key);</span><br><span class="line">      lruEntries.put(key, entry);</span><br><span class="line">    &#125; else if (entry.currentEditor != null) &#123;</span><br><span class="line">      return null; // Another edit is in progress.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Editor editor = new Editor(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    // Flush the journal before creating files to prevent file leaks.</span><br><span class="line">    journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    return editor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&nesp;&nesp;首先验证key，可以必须是字母、数字、下划线、横线（-）组成，且长度在1-120之间。然后通过key获取实体，因为我们是存，只要不是正在编辑这个实体，理论上都能返回一个合法的editor对象。所以接下来判断，如果不存在，则创建一个Entry加入到lruEntries中（如果存在，直接使用），然后为entry.currentEditor进行赋值为new Editor(entry);，最后在journal文件中写入一条DIRTY记录，代表这个文件正在被操作。</p>
<p>注意，如果entry.currentEditor != null不为null的时候，意味着该实体正在被编辑，会retrun null ;拿到editor对象以后，就是去调用newOutputStream去获得一个文件输入流了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a new unbuffered output stream to write the value at</span><br><span class="line">     * &#123;@code index&#125;. If the underlying output stream encounters errors</span><br><span class="line">     * when writing to the filesystem, this edit will be aborted when</span><br><span class="line">     * &#123;@link #commit&#125; is called. The returned output stream does not throw</span><br><span class="line">     * IOExceptions.</span><br><span class="line">     */</span><br><span class="line">    public OutputStream newOutputStream(int index) throws IOException &#123;</span><br><span class="line">      if (index &lt; 0 || index &gt;= valueCount) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Expected index &quot; + index + &quot; to &quot;</span><br><span class="line">                + &quot;be greater than 0 and less than the maximum value count &quot;</span><br><span class="line">                + &quot;of &quot; + valueCount);</span><br><span class="line">      &#125;</span><br><span class="line">      synchronized (DiskLruCache.this) &#123;</span><br><span class="line">        if (entry.currentEditor != this) &#123;</span><br><span class="line">          throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!entry.readable) &#123;</span><br><span class="line">          written[index] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">        FileOutputStream outputStream;</span><br><span class="line">        try &#123;</span><br><span class="line">          outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          // Attempt to recreate the cache directory.</span><br><span class="line">          directory.mkdirs();</span><br><span class="line">          try &#123;</span><br><span class="line">            outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">          &#125; catch (FileNotFoundException e2) &#123;</span><br><span class="line">            // We are unable to recover. Silently eat the writes.</span><br><span class="line">            return NULL_OUTPUT_STREAM;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new FaultHidingOutputStream(outputStream);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先校验index是否在valueCount范围内，一般我们使用都是一个key对应一个文件所以传入的基本都是0。接下来就是通过entry.getDirtyFile(index);拿到一个dirty File对象，为什么叫dirty file呢，其实就是个中转文件，文件格式为key.index.tmp。<br>将这个文件的FileOutputStream通过FaultHidingOutputStream封装下传给我们。<br>最后，别忘了我们通过os写入数据以后，需要调用commit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void commit() throws IOException &#123;</span><br><span class="line">      if (hasErrors) &#123;</span><br><span class="line">        completeEdit(this, false);</span><br><span class="line">        remove(entry.key); // The previous entry is stale.</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        completeEdit(this, true);</span><br><span class="line">      &#125;</span><br><span class="line">      committed = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过hasErrors判断，是否有错误发生，如果有调用completeEdit(this, false)且调用remove(entry.key);。如果没有就调用completeEdit(this, true);。</p>
<p>那么这里这个hasErrors哪来的呢？还记得上面newOutputStream的时候，返回了一个os，这个os是FileOutputStream，但是经过了FaultHidingOutputStream封装么，这个类实际上就是重写了FilterOutputStream的write相关方法，将所有的IOException给屏蔽了，如果发生IOException就将hasErrors赋值为true.</p>
<p>这样的设计还是很nice的，否则直接将OutputStream返回给用户，如果出错没法检测，还需要用户手动去调用一些操作。</p>
<p>接下来看completeEdit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</span><br><span class="line">    Entry entry = editor.entry;</span><br><span class="line">    if (entry.currentEditor != editor) &#123;</span><br><span class="line">      throw new IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If this edit is creating the entry for the first time, every index must have a value.</span><br><span class="line">    if (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        if (!editor.written[i]) &#123;</span><br><span class="line">          editor.abort();</span><br><span class="line">          throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">          editor.abort();</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">      File dirty = entry.getDirtyFile(i);</span><br><span class="line">      if (success) &#123;</span><br><span class="line">        if (dirty.exists()) &#123;</span><br><span class="line">          File clean = entry.getCleanFile(i);</span><br><span class="line">          dirty.renameTo(clean);</span><br><span class="line">          long oldLength = entry.lengths[i];</span><br><span class="line">          long newLength = clean.length();</span><br><span class="line">          entry.lengths[i] = newLength;</span><br><span class="line">          size = size - oldLength + newLength;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        deleteIfExists(dirty);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    entry.currentEditor = null;</span><br><span class="line">    if (entry.readable | success) &#123;</span><br><span class="line">      entry.readable = true;</span><br><span class="line">      journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</span><br><span class="line">      if (success) &#123;</span><br><span class="line">        entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lruEntries.remove(entry.key);</span><br><span class="line">      journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    journalWriter.flush();</span><br><span class="line"></span><br><span class="line">    if (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;首先判断if (success &amp;&amp; !entry.readable)是否成功，且是第一次写入（如果以前这个记录有值，则readable=true），内部的判断，我们都不会走，因为written[i]在newOutputStream的时候被写入true了。而且正常情况下，getDirtyFile是存在的。<br>&ensp;&ensp;接下来，如果成功，将dirtyFile 进行重命名为 cleanFile，文件名为：key.index。然后刷新size的长度。如果失败，则删除dirtyFile.<br>&ensp;&ensp;接下来，如果成功或者readable为true，将readable设置为true，写入一条CLEAN记录。如果第一次提交且失败，那么就会从lruEntries.remove(key)，写入一条REMOVE记录。</p>
<p>写入缓存，肯定要控制下size。于是最后，判断是否超过了最大size，或者需要重建journal文件，什么时候需要重建呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private boolean journalRebuildRequired() &#123;</span><br><span class="line">   final int redundantOpCompactThreshold = 2000;</span><br><span class="line">   return redundantOpCount &gt;= redundantOpCompactThreshold //</span><br><span class="line">       &amp;&amp; redundantOpCount &gt;= lruEntries.size();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> &ensp;&ensp;如果redundantOpCount达到2000，且超过了lruEntries.size()就重建，这里就可以看到redundantOpCount的作用了。防止journal文件过大。<br> &ensp;&ensp;ok，到此我们的存入缓存就分析完成了。再次总结下，首先调用editor，拿到指定的dirtyFile的OutputStream，你可以尽情的进行写操作，写完以后呢，记得调用commit。<br> &ensp;&ensp;commit中会检测是你是否发生IOException，如果没有发生，则将dirtyFile-&gt;cleanFile，将readable=true，写入CLEAN记录。如果发生错误，则删除dirtyFile,从lruEntries中移除，然后写入一条REMOVE记录。<br><strong>读取缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);  </span><br><span class="line">if (snapShot != null) &#123;  </span><br><span class="line">  InputStream is = snapShot.getInputStream(0);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么首先看get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Snapshot get(String key) throws IOException &#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!entry.readable) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Open all streams eagerly to guarantee that we see a single published</span><br><span class="line">    // snapshot. If we opened streams lazily then the streams could come</span><br><span class="line">    // from different edits.</span><br><span class="line">    InputStream[] ins = new InputStream[valueCount];</span><br><span class="line">    try &#123;</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        ins[i] = new FileInputStream(entry.getCleanFile(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">      // A file must have been deleted manually!</span><br><span class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        if (ins[i] != null) &#123;</span><br><span class="line">          Util.closeQuietly(ins[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(READ + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    if (journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法比较简单，如果取到的为null，或者readable=false，则返回null.否则将cleanFile的FileInputStream进行封装返回Snapshot，且写入一条READ语句。 然后getInputStream就是返回该FileInputStream了。<br>好了，到此，我们就分析完成了创建</p>
<p>DiskLruCache，存入缓存和取出缓存的源码。<br>除此以外，还有一些别的方法我们需要了解的。</p>
<p><strong>其他方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Drops the entry for &#123;@code key&#125; if it exists and can be removed. Entries</span><br><span class="line">   * actively being edited cannot be removed.</span><br><span class="line">   *</span><br><span class="line">   * @return true if an entry was removed.</span><br><span class="line">   */</span><br><span class="line">  public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    if (entry == null || entry.currentEditor != null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">      File file = entry.getCleanFile(i);</span><br><span class="line">      if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">        throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">      &#125;</span><br><span class="line">      size -= entry.lengths[i];</span><br><span class="line">      entry.lengths[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(REMOVE + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">    if (journalRebuildRequired()) &#123;</span><br><span class="line">      executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果实体存在且不在被编辑，就可以直接进行删除，然后写入一条REMOVE记录。</p>
<p>与open对应还有个remove方法，大家在使用完成cache后可以手动关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** Closes this cache. Stored values will remain on the filesystem. */</span><br><span class="line">  public synchronized void close() throws IOException &#123;</span><br><span class="line">    if (journalWriter == null) &#123;</span><br><span class="line">      return; // Already closed.</span><br><span class="line">    &#125;</span><br><span class="line">    for (Entry entry : new ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">      if (entry.currentEditor != null) &#123;</span><br><span class="line">        entry.currentEditor.abort();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize();</span><br><span class="line">    journalWriter.close();</span><br><span class="line">    journalWriter = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关闭前，会判断所有正在编辑的实体，调用abort方法，最后关闭journalWriter。至于abort方法，其实我们分析过了，就是存储失败的时候的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void abort() throws IOException &#123;</span><br><span class="line">      completeEdit(this, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此，我们的整个源码分析就结束了。可以看到DiskLruCache，利用一个journal文件，保证了保证了cache实体的可用性（只有CLEAN的可用），且获取文件的长度的时候可以通过在该文件的记录中读取。利用FaultHidingOutputStream对FileOutPutStream很好的对写入文件过程中是否发生错误进行捕获，而不是让用户手动去调用出错后的处理方法。其内部的很多细节都很值得推敲。</p>
<p>不过也可以看到，存取的操作不是特别的容易使用，需要大家自己去操作文件流，但在存储比较小的数据的时候（不存在内存问题），很多时候还是希望有类似put(key,value），getAsT(key)等方法直接使用。我看了ASimpleCache 提供的API属于比较好用的了。于是萌生想法，对DiskLruCache公开的API进行扩展，对外除了原有的存取方式以外，提供类似ASimpleCache那样比较简单的API用于存储，而内部的核心实现，依然是DiskLruCache原本的。</p>
<p>考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/47251585" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/47251585</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/LRU/" rel="tag"># LRU</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/22/reactNative/" rel="next" title="关于react native页面全屏设置">
                <i class="fa fa-chevron-left"></i> 关于react native页面全屏设置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/06/python/" rel="prev" title="python中@的作用">
                python中@的作用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CallteFoot</p>
              <p class="site-description motion-element" itemprop="description">The blog from a Android coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CallteFoot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
