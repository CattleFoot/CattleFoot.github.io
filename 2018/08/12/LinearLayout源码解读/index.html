<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LinearLayout源码解读 | CallteFoot&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LinearLayout基础LinearLayout所具有的属性：  orientation：视图的布局方向，默认值：-1； gravity：绘制起始点，默认值：-1； baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true； weightSum：子视图权重和，默认值：-1.0f； baselineAlignedChildIndex：以第Inde">
<meta name="keywords" content="Android,LinearLayout,SourceCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LinearLayout源码解读">
<meta property="og:url" content="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/index.html">
<meta property="og:site_name" content="CallteFoot&#39;s blog">
<meta property="og:description" content="LinearLayout基础LinearLayout所具有的属性：  orientation：视图的布局方向，默认值：-1； gravity：绘制起始点，默认值：-1； baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true； weightSum：子视图权重和，默认值：-1.0f； baselineAlignedChildIndex：以第Inde">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/images/baselineAligned_expand.png">
<meta property="og:image" content="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/images/baselineAligned_ch.png">
<meta property="og:updated_time" content="2018-08-13T01:50:16.111Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LinearLayout源码解读">
<meta name="twitter:description" content="LinearLayout基础LinearLayout所具有的属性：  orientation：视图的布局方向，默认值：-1； gravity：绘制起始点，默认值：-1； baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true； weightSum：子视图权重和，默认值：-1.0f； baselineAlignedChildIndex：以第Inde">
<meta name="twitter:image" content="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/images/baselineAligned_expand.png">
  
    <link rel="alternate" href="/atom.xml" title="CallteFoot&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CallteFoot&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cattlefoot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-LinearLayout源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/12/LinearLayout源码解读/" class="article-date">
  <time datetime="2018-08-12T02:01:49.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LinearLayout源码解读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="LinearLayout基础"><a href="#LinearLayout基础" class="headerlink" title="LinearLayout基础"></a>LinearLayout基础</h3><p>LinearLayout所具有的属性：</p>
<ul>
<li>orientation：视图的布局方向，默认值：-1；</li>
<li>gravity：绘制起始点，默认值：-1；</li>
<li>baselineAligned：基准线对齐，其效果可以通过修改xml的属性值直接看到效果，默认值：true；</li>
<li>weightSum：子视图权重和，默认值：-1.0f；</li>
<li>baselineAlignedChildIndex：以第Index个子视图的基准线为对齐，该LinearLayout下的view以<br>某个继承TextView的View的基线对齐，默认值：-1；</li>
<li>measureWithLargestChild：以最大子视图宽高，为其子视图的宽高，<strong>其起作用前提是为true，且LinearLayout在该方向的宽或高为warp_content，且子视图具有权重</strong>。默认值：false；</li>
<li>divider：分割线；</li>
<li>showDividers：分割线显示样式（middle|end|beginning|non），默认值：SHOW_DIVIDER_NONE；</li>
<li><p>dividerPadding：分割线内边距，默认值：0；</p>
<p>解释：</p>
</li>
<li>基准线<br>其主要作用是在绘制字母的时候有个基线对齐，这个类似我们学习英语字母的时候用的四线谱：<br><img src="./images/baselineAligned_expand.png" alt="基线示意图"><br>其中红线就是基线（baseline），和下面我们书写英语字母的四线谱是不是很像，基线就是第三条。<br><img src="./images/baselineAligned_ch.png" alt="英语书写四线谱"></li>
</ul>
<ul>
<li>源码之垂直方向测量（void measureVertical(int widthMeasureSpec, int heightMeasureSpec)）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Measures the children when the orientation of this LinearLayout is set</span><br><span class="line">     * to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.</span><br><span class="line">     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.</span><br><span class="line">     *</span><br><span class="line">     * @see #getOrientation()</span><br><span class="line">     * @see #setOrientation(int)</span><br><span class="line">     * @see #onMeasure(int, int)</span><br><span class="line">     */</span><br><span class="line">    void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		// mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">		// maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">		// 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		* 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">		* 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">		* 否则，则跟maxWidth的计算方法一样</span><br><span class="line">		*/</span><br><span class="line">		// 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">		// 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">		// 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">		// 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">		// 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">		// 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">		// 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // See how tall everyone is. Also remember max width.</span><br><span class="line"></span><br><span class="line">		//查看每一个高，并记住最大宽度</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">			//首先获取子View</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">			//如果子View是null就继续测量下一个子View</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">				// 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">			//如果子View是GONE的也不算在总高度里面，这里也能看出GONE和INVISIBLE的区别</span><br><span class="line">            if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">				// 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line">			//有时候我们在代码里面通过Inflater服务，动态加载一个布局，然后去设置他的LayoutParams，</span><br><span class="line">			//如果不引用父容器的LayoutParams就会报一个强转错误，原因就在这个父容器在add,measure的时候都会</span><br><span class="line">			//把子View的LayoutParams强转成自己的类型</span><br><span class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">			//得到每个子控件的LayoutParams后，累加权重和,后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束,基本没有用到</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">			//这里就值得注意下了如果当前的LinearLayout是EXACTLY模式，且子view的高度为0，且权重大于0</span><br><span class="line">			//这个子view只有在LinearLayout高度有剩余的时候，才会根据权重的占比去平分剩余空间</span><br><span class="line">			//上文说的二次测量也就指的这部分</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // Optimization: don&apos;t bother measuring children who are going to use</span><br><span class="line">                // leftover space. These views will get measured again down below if</span><br><span class="line">                // there is any leftover space.</span><br><span class="line">				// 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0   	</span><br><span class="line"></span><br><span class="line">				// 如果LinearLayout的垂直方向测量模式是EXACTLY，即确定值，且子视图的高度为0，weight大于0，</span><br><span class="line">        //则先将总高度加上子视图的topMargin和bottomMargin，并设置skippedMeasure（暂时跳过测量标识）为true</span><br><span class="line"></span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法，此时需要记住view的topMargin和bottomMargin（对于方向为）</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">				// 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // heightMode is !!either UNSPECIFIED or AT_MOST!!, and this</span><br><span class="line">                    // child wanted to stretch to fill available space.</span><br><span class="line">                    // Translate that to WRAP_CONTENT so that it does not end up</span><br><span class="line">                    // with a height of 0</span><br><span class="line">					// 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line"></span><br><span class="line">					//这里其实官方的注释讲了也挺清楚的，到了这步，当前的LinearLayout的模式</span><br><span class="line">					//肯定是UNSPECIFIED或者MOST，因为EXACTLY模式会进入上一个判断</span><br><span class="line">					//然后把子View的高度赋值成-1(WRAP_CONTENT)</span><br><span class="line">					// 如果垂直方向测量模式为UNSPECIFIED或AT_MOST，同时子视图想要尽量获取可用的剩余空间，</span><br><span class="line">          //把子视图的高度改为WRAP_CONTENT，这样子视图的最终高度就不会是0</span><br><span class="line"></span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Determine how big this child would like to be. If this or</span><br><span class="line">                // previous children have given a weight, then we allow it to</span><br><span class="line">                // use all available space (and we will shrink things later</span><br><span class="line">                // if needed).</span><br><span class="line">				/**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line"></span><br><span class="line">				// 这个函数最后会调用child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</span><br><span class="line">        //测量出子视图要占用多大空间，并设置子视图的mMeasuredWidth和mMeasuredHeight</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">				// 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line"></span><br><span class="line">				// getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">				//加上子View的margin值</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">				// 重新设置最大子视图高度</span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * If applicable, compute the additional offset to the child&apos;s baseline</span><br><span class="line">             * we&apos;ll need later when asked &#123;@link #getBaseline&#125;.</span><br><span class="line">             */</span><br><span class="line">			// 计算子视图baseline的偏移量</span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // if we are trying to use a child index for our baseline, the above</span><br><span class="line">            // book keeping only works if there are no children above it with</span><br><span class="line">            // weight.  fail fast to aid the developer.</span><br><span class="line">			// 如果要为baseline指定子视图索引，只有在此子视图之上的视图没有设置weight属性时才有效</span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// 下面开始测量宽度</span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // The width of the linear layout will scale, and at least one</span><br><span class="line">                // child said it wanted to match our width. Set a flag</span><br><span class="line">                // indicating that we need to remeasure at least that view when</span><br><span class="line">                // we know our width.</span><br><span class="line">				//如果LinearLayout宽度不是已确定的，如wrap_content,而子视图是MATCH_PARENT，  </span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			// 计算子视图总宽度（包含左右外边距）</span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">			// 合并子元素的测量状态</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">			// 子视图宽度是否都为MATCH_PARENT</span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Widths of weighted Views are bogus if we end up</span><br><span class="line">                 * remeasuring, so keep them separate.</span><br><span class="line">                 */</span><br><span class="line">				//如设置了weigh属性，则子视图的宽度需要在父视图确定后才能确定。这里并不是真实的宽度  </span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">		//for 循环结束</span><br><span class="line"></span><br><span class="line">		// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过</span><br><span class="line">        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">			// 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，</span><br><span class="line">      //重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                // Account for negative margins</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//在这两段代码之间还有些杂七杂八的处理，如果读者有兴趣可以自己阅读分析下</span><br><span class="line">		//当测量完子View的大小后，总高度会再加上padding的高度</span><br><span class="line">        // Add in our padding</span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        int heightSize = mTotalLength;</span><br><span class="line">		    //如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较</span><br><span class="line">        //然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值</span><br><span class="line">        // Check against our minimum height</span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        // Reconcile our calculated size with the heightMeasureSpe</span><br><span class="line">		// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，</span><br><span class="line">    //剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）</span><br><span class="line">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line">		//到了这里，会再对带weight属性的子View进行一次测绘</span><br><span class="line">        //首先计算剩余高度</span><br><span class="line"></span><br><span class="line">		//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的</span><br><span class="line">        // Either expand children with weight to take up available space or</span><br><span class="line">        // shrink them if they extend beyond our current bounds. If we skipped</span><br><span class="line">        // measurement on any children, we need to measure them now.</span><br><span class="line">        int delta = heightSize - mTotalLength;</span><br><span class="line">        if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123;</span><br><span class="line">			//如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦</span><br><span class="line">            float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = 0;</span><br><span class="line">			//这里的代码就和第一次测量很像了</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                float childExtra = lp.weight;</span><br><span class="line">                if (childExtra &gt; 0) &#123;</span><br><span class="line">					// 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure</span><br><span class="line">					//子控件的weight占比*剩余高度</span><br><span class="line">                    // Child said it could absorb extra space -- give him his share</span><br><span class="line">                    int share = (int) (childExtra * delta / weightSum);</span><br><span class="line">					// weightSum计余</span><br><span class="line">                    weightSum -= childExtra;</span><br><span class="line">					//剩余高度减去分配出去的高度</span><br><span class="line">                    delta -= share;</span><br><span class="line"></span><br><span class="line">                    final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight +</span><br><span class="line">                                    lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line">					//如果是当前LinearLayout的模式是EXACTLY</span><br><span class="line">                    //那么这个子View是没有被测量过的，就需要测量一次</span><br><span class="line">                    //如果不是EXACTLY的，在第一次循环里就被测量一些了</span><br><span class="line">                    // TODO: Use a field like lp.isMeasured to figure out if this</span><br><span class="line">                    // child has been previously measured</span><br><span class="line">                    if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        // child was measured once already above...</span><br><span class="line">                        // base new measurement on stored values</span><br><span class="line">						//如果是非EXACTLY模式下的子View就再加上</span><br><span class="line">                        //weight分配占比*剩余高度</span><br><span class="line">						// 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小</span><br><span class="line">                        int childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                        if (childHeight &lt; 0) &#123;</span><br><span class="line">                            childHeight = 0;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">						//重新测量一次，因为高度发生了变化</span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // child was skipped in the loop above.</span><br><span class="line">                        // Measure for this first time here  </span><br><span class="line"></span><br><span class="line">						//如果是EXACTLY模式下的</span><br><span class="line">                        //这里只会把weight占比所拥有的高度分配给你的子View</span><br><span class="line">						// 上面测量的时候被跳过，那么在这里进行测量    </span><br><span class="line">                        child.measure(childWidthMeasureSpec,</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Child may now not fit in vertical dimension.</span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里得到最终高度</span><br><span class="line">            // Add in our padding</span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            // TODO: Should we recompute the heightSpec based on the new total length?</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			 // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // We have no limit, so make all weighted views as tall as the largest child.</span><br><span class="line">            // Children will have already been measured once.</span><br><span class="line">			// 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次</span><br><span class="line">            if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">                    if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    float childExtra = lp.weight;</span><br><span class="line">                    if (childExtra &gt; 0) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        // Check against our minimum width</span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">		// 设置测量完的宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        if (matchWidth) &#123;</span><br><span class="line">			// 使宽度一致</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在垂直绘制中主要执行逻辑在两大块代码，第一个for循环，第二个if判断中的for循环，接下来我们分块分析该函数源码：</p>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;      </span><br><span class="line">        // mTotalLength作为LinearLayout成员变量，其主要目的是在测量的时候通过累加得到所有子控件的高度和（Vertical）或者宽度和（Horizontal）</span><br><span class="line">        mTotalLength = 0;</span><br><span class="line">        // maxWidth用来记录所有子控件中控件宽度最大的值。</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">        // 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">        int childState = 0;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 以下两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">         * 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">         * 否则，则跟maxWidth的计算方法一样</span><br><span class="line">         */</span><br><span class="line">        // 子控件中layout_weight&lt;=0的View的最大宽度</span><br><span class="line">        int alternativeMaxWidth = 0;</span><br><span class="line">        // 子控件中layout_weight&gt;0的View的最大宽度</span><br><span class="line">        int weightedMaxWidth = 0;</span><br><span class="line">        // 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">        boolean allFillParent = true;</span><br><span class="line">        // 所有子控件的weight之和</span><br><span class="line">        float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">        // 如您所见，得到所有子控件的数量，准确的说，它得到的是所有同级子控件的数量</span><br><span class="line">        // 在官方的注释中也有着对应的例子</span><br><span class="line">        // 比如TableRow，假如TableRow里面有N个控件，而LinearLayout（TableLayout也是继承LinearLayout哦）下有M个TableRow，那么这里返回的是M，而非M*N</span><br><span class="line">        // 但实际上，官方似乎也只是直接返回getChildCount()，起这个方法名的原因估计是为了让人更加的明白，毕竟如果是getChildCount()可能会让人误认为为什么没有返回所有（包括不同级）的子控件数量</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        // 得到测量模式</span><br><span class="line">        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        // 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">        boolean matchWidth = false;</span><br><span class="line"></span><br><span class="line">        boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">        final int baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">        final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        // ...... 底下两个for循环</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在变量定义中，我们主要留意三个方面：</p>
<ul>
<li>mTotalLength：这个就是最终得到的整个LinearLayout的高度（子控件高度累加及自身padding）</li>
<li>三个跟width相关的变量</li>
<li>weight相关的变量</li>
</ul>
<h4 id="第一个for代码块和baselineChildIndex处理"><a href="#第一个for代码块和baselineChildIndex处理" class="headerlink" title="第一个for代码块和baselineChildIndex处理"></a>第一个for代码块和baselineChildIndex处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // ...上面的一大堆局部变量</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                // 目前而言，measureNullChild()方法返回的永远是0，估计是设计者留下来以后或许有补充的。</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (child.getVisibility() == GONE) &#123;</span><br><span class="line">               // 同上，返回的都是0。</span><br><span class="line">               // 事实上这里的意思应该是当前遍历到的View为Gone的时候，就跳过这个View，下一句的continue关键字也正是这个意思。</span><br><span class="line">               // 忽略当前的View，这也就是为什么Gone的控件不占用布局资源的原因。（毕竟根本没有分配空间）</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据showDivider的值（before/middle/end）来决定遍历到当前子控件时，高度是否需要加上divider的高度</span><br><span class="line">            // 比如showDivider为before，那么只会在第0个子控件测量时加上divider高度，其余情况下都不加</span><br><span class="line">            if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerWidth;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            // 得到每个子控件的LayoutParams后，累加权重和，后面用于跟weightSum相比较</span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            // 我们都知道，测量模式有三种：</span><br><span class="line">            // * UNSPECIFIED：父控件对子控件无约束</span><br><span class="line">            // * Exactly：父控件对子控件强约束，子控件永远在父控件边界内，越界则裁剪。如果要记忆的话，可以记忆为有对应的具体数值或者是Match_parent</span><br><span class="line">            // * AT_Most：子控件为wrap_content的时候，测量值为AT_MOST。</span><br><span class="line"></span><br><span class="line">            // 下面的if/else分支都是跟weight相关</span><br><span class="line">            if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                // 这个if里面需要满足三个条件：</span><br><span class="line">                // * LinearLayout的高度为match_parent(或者有具体值)</span><br><span class="line">                // * 子控件的高度为0</span><br><span class="line">                // * 子控件的weight&gt;0</span><br><span class="line">                // 这其实就是我们通常情况下用weight时的写法</span><br><span class="line">                // 测量到这里的时候，会给个标志位，稍后再处理。此时会计算总高度</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 到这个分支，则需要对不同的情况进行测量</span><br><span class="line">                int oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">                if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                    // 满足这两个条件，意味着父类即LinearLayout是wrap_content，或者mode为UNSPECIFIED</span><br><span class="line">                    // 那么此时将当前子控件的高度置为wrap_content</span><br><span class="line">                    // 为何需要这么做，主要是因为当父类为wrap_content时，其大小实际上由子控件控制</span><br><span class="line">                    // 我们都知道，自定义控件的时候，通常我们会指定测量模式为wrap_content时的默认大小</span><br><span class="line">                    // 这里强制给定为wrap_content为的就是防止子控件高度为0.</span><br><span class="line">                    oldHeight = 0;</span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /**【1】*/</span><br><span class="line">                // 下面这句虽然最终调用的是ViewGroup通用的同名方法，但传入的height值是跟平时不一样的</span><br><span class="line">                // 这里可以看到，传入的height是跟weight有关，关于这里，稍后的文字描述会着重阐述</span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                       totalWeight == 0 ? mTotalLength : 0);</span><br><span class="line"></span><br><span class="line">                // 重置子控件高度，然后进行精确赋值</span><br><span class="line">                if (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.height = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                final int totalLength = mTotalLength;</span><br><span class="line">                // getNextLocationOffset返回的永远是0，因此这里实际上是比较child测量前后的总高度，取大值。</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                if (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                        + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                        + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                        + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean matchWidthLocally = false;</span><br><span class="line"></span><br><span class="line">            // 还记得我们变量里又说到过matchWidthLocally这个东东吗</span><br><span class="line">            // 当父类（LinearLayout）不是match_parent或者精确值的时候，但子控件却是一个match_parent</span><br><span class="line">            // 那么matchWidthLocally和matchWidth置为true</span><br><span class="line">            // 意味着这个控件将会占据父类（水平方向）的所有空间</span><br><span class="line">            if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                matchWidth = true;</span><br><span class="line">                matchWidthLocally = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            if (lp.weight &gt; 0) &#123;</span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">        //... 底下第二个for循环</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">  在第一个for循环中，主要是if()&#123;&#125;else&#123;&#125;分支，判断是heightMode == MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">  lp.height == 0 &amp;&amp; lp.weight &gt; 0，这个主要是linearLayout测量模式为EXACTLY且子视图明确</span><br><span class="line"> 了是使用linearLayout的剩余空间，此时将其上下间距计入总高度并以之前的做对比去大值，并设置</span><br><span class="line"> skippedMeasure标志为true。而在else中则为复杂点，else中首先对lp.height == 0 &amp;&amp;</span><br><span class="line">  lp.weight &gt; 0的子视图的height做预处理使其为LayoutParams.WRAP_CONTENT（因为父类即</span><br><span class="line">  LinearLayout此时是wrap_content，或者mode为UNSPECIFIED），接着对子视图进行测量（</span><br><span class="line">  这个受总权重影响），并将其高度和上下间距计入到总高度中。之后对baselineChildIndex做处理，</span><br><span class="line">  计入总的基线高度并判定基线配置是否合理，不合理抛出异常，最后根据子视图设置最大宽度、</span><br><span class="line">  allFillParent、weightedMaxWidth或alternativeMaxWidth变量。</span><br><span class="line"></span><br><span class="line">#### 第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行前的处理 ####</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>// … 局部变量定义和第一个for循环<br>// 下面的这一段代码主要是为useLargestChild属性服务的，不在本文主要分析范围，略过<br>        if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) {<br>            mTotalLength += mDividerHeight;<br>        }</p>
<pre><code>  if (useLargestChild &amp;&amp;
          (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
      mTotalLength = 0;

      // 如果设置了useLargestChild属性，且LinearLayout的垂直方向测量模式是AT_MOST或UNSPECIFIED，
//重新测量总高度，useLargestChild属性会使所有带weight属性的子视图具有最大子视图的最小尺寸
      for (int i = 0; i &lt; count; ++i) {
          final View child = getVirtualChildAt(i);

          if (child == null) {
              mTotalLength += measureNullChild(i);
              continue;
          }

          if (child.getVisibility() == GONE) {
              i += getChildrenSkipCount(child, i);
              continue;
          }

          final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                  child.getLayoutParams();
          // Account for negative margins
          final int totalLength = mTotalLength;
          mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                  lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }
  }
  //... 第2个重要代码块
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里主要对useLargestChild属性处理，执行前提是设置了useLargestChild属性，且LinearLayout的垂直</span><br><span class="line">方向测量模式是AT_MOST或UNSPECIFIED，重新测量总高度，useLargestChild属性会使所有带weight属性的子视</span><br><span class="line">图具有最大子视图的最小尺寸</span><br><span class="line"></span><br><span class="line">第2个重要代码块（if()&#123;&#125;else&#123;&#125;分支)）执行逻辑</span><br></pre></td></tr></table></figure>
<p>//当测量完子View的大小后，总高度会再加上padding的高度<br>        // Add in our padding<br>        mTotalLength += mPaddingTop + mPaddingBottom;</p>
<pre><code>int heightSize = mTotalLength;
//如果设置了minimumheight属性，会根据当前使用高度和最小高度进行比较
//然后取两者中大的值,getSuggestedMinimumHeight为背景的最小高和视图设置的最小高的大值
// Check against our minimum height
heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

// Reconcile our calculated size with the heightMeasureSpe
// 把测量出来的高度与测量模式进行匹配，得到最终的高度，MeasureSpec实际上是一个32位的int，高两位是测量模式，剩下的就是大小，因此heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;作用就是用来得到大小的精确值（不含测量模式）
int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;

//到了这里，会再对带weight属性的子View进行一次测绘
//首先计算剩余高度

//算出剩余空间，假如之前是skipp的话，那么几乎可以肯定是有剩余空间（同时有weight）的
// Either expand children with weight to take up available space or
// shrink them if they extend beyond our current bounds. If we skipped
// measurement on any children, we need to measure them now.
int delta = heightSize - mTotalLength;
if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) {
    //如果设置了weightSum就会使用你设置的weightSum，否则采用当前所有子View的权重和。所以如果要手动设置weightSum的时候，千万别计算错误哦
    float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;

    mTotalLength = 0;
    //这里的代码就和第一次测量很像了
    for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);

        if (child.getVisibility() == View.GONE) {
            continue;
        }

        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

        float childExtra = lp.weight;
        if (childExtra &gt; 0) {
            // 全篇最精华的一个地方。。。。拥有weight的时候计算方式,ps:执行到这里时，child依然还没进行自身的measure
            //子控件的weight占比*剩余高度
            // Child said it could absorb extra space -- give him his share
            int share = (int) (childExtra * delta / weightSum);
            // weightSum计余
            weightSum -= childExtra;
            //剩余高度减去分配出去的高度
            delta -= share;

            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                    mPaddingLeft + mPaddingRight +
                            lp.leftMargin + lp.rightMargin, lp.width);
            //如果是当前LinearLayout的模式是EXACTLY
            //那么这个子View是没有被测量过的，就需要测量一次
            //如果不是EXACTLY的，在第一次循环里就被测量一些了
            // TODO: Use a field like lp.isMeasured to figure out if this
            // child has been previously measured
            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                // child was measured once already above...
                // base new measurement on stored values
                //如果是非EXACTLY模式下的子View就再加上
                //weight分配占比*剩余高度
                // 上面已经测量过这个子视图，把上面测量的结果加上根据weight分配的大小
                int childHeight = child.getMeasuredHeight() + share;
                if (childHeight &lt; 0) {
                    childHeight = 0;
                }

                //重新测量一次，因为高度发生了变化
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
            } else {
                // child was skipped in the loop above.
                // Measure for this first time here  

                //如果是EXACTLY模式下的
                //这里只会把weight占比所拥有的高度分配给你的子View
                // 上面测量的时候被跳过，那么在这里进行测量    
                child.measure(childWidthMeasureSpec,
                        MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,
                                MeasureSpec.EXACTLY));
            }

            // Child may now not fit in vertical dimension.
            childState = combineMeasuredStates(childState, child.getMeasuredState()
                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
        }

        final int margin =  lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);

        boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;
                lp.width == LayoutParams.MATCH_PARENT;

        alternativeMaxWidth = Math.max(alternativeMaxWidth,
                matchWidthLocally ? margin : measuredWidth);

        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
    }
    // 这里得到最终高度
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
} else {
     // 没有weight的情况下，只看useLargestChild参数，如果都无相关，那就走layout流程了，因此这里忽略
    alternativeMaxWidth = Math.max(alternativeMaxWidth,weightedMaxWidth);


    // We have no limit, so make all weighted views as tall as the largest child.
    // Children will have already been measured once.
    // 使所有具有weight属性 视图都和最大子视图一样高，子视图可能在上面已经被测量过一次
    if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) {
        for (int i = 0; i &lt; count; i++) {
            final View child = getVirtualChildAt(i);

            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            float childExtra = lp.weight;
            if (childExtra &gt; 0) {
                child.measure(
                        MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(largestChildHeight,
                                MeasureSpec.EXACTLY));
            }
        }
    }
}
</code></pre><p>```<br>在进入ifelse分支前，先计算视图的总高度，并与测量模式进行比较（resolveSizeAndState）得到最终高度，<br>在减去总高度，得到最终还剩多高（也就是可以分配给带权重的视图的高）；<br>ifelse首先判断（skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f），</p>
<ul>
<li><p>如果该条件为true，先将总高度置为0再进入for循环，此处根据子视图的权重，再次判定(lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)</p>
<ul>
<li>true：子视图再次测量 则计算子视图可以得到多少高（有可能为负，也就是子视图要吐出一定高度出来），然后子视图测量高度和分配的高度相加，小于0，则重置为0，最后在测量一次。</li>
<li><p>false：直接测量子视图，这个是之前被跳过没有测量的子视图；<br>最后再次测量视图的宽和总高度。</p>
</li>
<li><p>如果该条件为false：看useLargestChild参数，如果都无相关，那就走layout流程了，<br>我们可以看到这里直接判断是useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY，如果条件成立的话，遍历子视图，再次判断子视图是否含有权重，如果有则直接将子视图高度都是largestChildHeight。如果条件不成立，则啥也不做。</p>
</li>
</ul>
</li>
</ul>
<p>最后就是视图maxWidth计算，并setMeasuredDimension（这个是一定要的），自此垂直方向已经测量完毕。</p>
<p><strong>总结</strong><br>这里大篇幅讲解measureVertical()的流程，事实上对于LinearLayout来说，其最大的特性也正是两个<br>方向的排布以及weight的计算方式。回过头来看测量过程，我们可以看出设计者的测量计算思路，就是将有weight<br>和不含有weight的测量分开处理，再利用height跟0比较来更加的细分每一种情况。<br>最后我们在理下其测量不同情况和原理：</p>
<ul>
<li>父控件为match_parent（或者精确值），子控件拥有weight，并且高度给定为0，也即子控件明确表示使用剩余空间：<ul>
<li>子控件的高度比例将会跟我们分配的layout_weight一致，原因在于weight二次测量时走了else分支，传入的是计算出来的share值；</li>
</ul>
</li>
<li>父控件是match_parent（或者精确值），子控件拥有weight，但高度给定为match_parent（或者精确值），子控件使用自己的高度或者父控件的高度，但在父控件空间不足时，其大小可以调整：<ul>
<li>子控件高度比例将会跟我们分配的layout_weight相反，原因在于在此之前子控件测量过一次，同时子控件的测量高度为父控件的高度，在计算剩余空间的时候得出一个负值，加上自身的测量高度的时候反而更小；</li>
</ul>
</li>
<li>父控件是wrap_content，子控件拥有weight：<ul>
<li>子控件的高度将会强行置为其wrap_content给的值并以wrap_content模式进行测量</li>
</ul>
</li>
<li>父控件是wrap_content，子控件没有weight：<ul>
<li>子控件的高度跟其他的viewgroup一致</li>
</ul>
</li>
</ul>
<p>自此，LinearLayout在垂直方向的测量分析已经结束。</p>
<p>参考地址：<br>[1]. baselineAligned解析 <a href="http://www.bubuko.com/infodetail-612730.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-612730.html</a><br>[2]. measureWithLargestChild使用解析 <a href="https://blog.csdn.net/a87b01c14/article/details/49420449" target="_blank" rel="noopener">https://blog.csdn.net/a87b01c14/article/details/49420449</a><br>[3]. LinearLayout垂直测量分析 <a href="https://www.jianshu.com/p/aea27bac7c8e" target="_blank" rel="noopener">https://www.jianshu.com/p/aea27bac7c8e</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cattlefoot.github.io/2018/08/12/LinearLayout源码解读/" data-id="cjl6atnd8000k7ls6cuuhlsj6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinearLayout/">LinearLayout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SourceCode/">SourceCode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/16/根据Uri获取文档的路径/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          根据Uri获取文档的路径
        
      </div>
    </a>
  
  
    <a href="/2018/07/22/android-camera2预览拍照录制/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">android-camera2预览拍照录制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/7/">7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/">Android Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Support/">Android Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/">Annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsynListUtil/">AsynListUtil</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-DataCallback/">AsyncListUtil.DataCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsyncListUtil-ViewCallback/">AsyncListUtil.ViewCallback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitmapFactory/">BitmapFactory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Buffer/">Buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ByteBuffer/">ByteBuffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download-Manager/">Download Manager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DynamicLoadApk/">DynamicLoadApk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Error/">Error</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-App/">First App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Instant-Run/">Instant Run</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interceptors/">Interceptors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinearLayout/">LinearLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC-MVP-MVVM/">MVC MVP MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Media/">Media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaExtractor/">MediaExtractor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MulitiDex/">MulitiDex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NNotificationChannelGroup/">NNotificationChannelGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NestedScrolling/">NestedScrolling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notification/">Notification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NotificationChannel/">NotificationChannel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Options/">Options</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Small/">Small</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SourceCode/">SourceCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Support/">Support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Uri/">Uri</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/andrid/">andrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera2/">camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle-plugin/">gradle plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/head/">head</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ide/">ide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/install/">install</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/okhttp/">okhttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start/">start</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/7/" style="font-size: 10px;">7</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-Studio/" style="font-size: 10px;">Android Studio</a> <a href="/tags/Android-Support/" style="font-size: 10px;">Android Support</a> <a href="/tags/Annotation/" style="font-size: 12.5px;">Annotation</a> <a href="/tags/AsynListUtil/" style="font-size: 10px;">AsynListUtil</a> <a href="/tags/AsyncListUtil-DataCallback/" style="font-size: 10px;">AsyncListUtil.DataCallback</a> <a href="/tags/AsyncListUtil-ViewCallback/" style="font-size: 10px;">AsyncListUtil.ViewCallback</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/BitmapFactory/" style="font-size: 10px;">BitmapFactory</a> <a href="/tags/Buffer/" style="font-size: 10px;">Buffer</a> <a href="/tags/ByteBuffer/" style="font-size: 10px;">ByteBuffer</a> <a href="/tags/Camera2/" style="font-size: 12.5px;">Camera2</a> <a href="/tags/Download-Manager/" style="font-size: 12.5px;">Download Manager</a> <a href="/tags/DynamicLoadApk/" style="font-size: 10px;">DynamicLoadApk</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/First-App/" style="font-size: 10px;">First App</a> <a href="/tags/Flutter/" style="font-size: 17.5px;">Flutter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Instant-Run/" style="font-size: 10px;">Instant Run</a> <a href="/tags/Interceptors/" style="font-size: 10px;">Interceptors</a> <a href="/tags/LinearLayout/" style="font-size: 10px;">LinearLayout</a> <a href="/tags/MVC-MVP-MVVM/" style="font-size: 10px;">MVC MVP MVVM</a> <a href="/tags/Media/" style="font-size: 15px;">Media</a> <a href="/tags/MediaCodeC/" style="font-size: 10px;">MediaCodeC</a> <a href="/tags/MediaExtractor/" style="font-size: 12.5px;">MediaExtractor</a> <a href="/tags/MulitiDex/" style="font-size: 10px;">MulitiDex</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/NNotificationChannelGroup/" style="font-size: 10px;">NNotificationChannelGroup</a> <a href="/tags/NestedScrolling/" style="font-size: 10px;">NestedScrolling</a> <a href="/tags/Notification/" style="font-size: 10px;">Notification</a> <a href="/tags/NotificationChannel/" style="font-size: 10px;">NotificationChannel</a> <a href="/tags/Options/" style="font-size: 10px;">Options</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Small/" style="font-size: 10px;">Small</a> <a href="/tags/SourceCode/" style="font-size: 10px;">SourceCode</a> <a href="/tags/Support/" style="font-size: 10px;">Support</a> <a href="/tags/Tool/" style="font-size: 12.5px;">Tool</a> <a href="/tags/Uri/" style="font-size: 10px;">Uri</a> <a href="/tags/andrid/" style="font-size: 15px;">andrid</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/camera2/" style="font-size: 10px;">camera2</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gradle-plugin/" style="font-size: 10px;">gradle plugin</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/ide/" style="font-size: 10px;">ide</a> <a href="/tags/install/" style="font-size: 12.5px;">install</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/okhttp/" style="font-size: 10px;">okhttp</a> <a href="/tags/start/" style="font-size: 10px;">start</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/23/NIO-Buffer解析/">NIO-Buffer解析</a>
          </li>
        
          <li>
            <a href="/2018/08/16/根据Uri获取文档的路径/">根据Uri获取文档的路径</a>
          </li>
        
          <li>
            <a href="/2018/08/12/LinearLayout源码解读/">LinearLayout源码解读</a>
          </li>
        
          <li>
            <a href="/2018/07/22/android-camera2预览拍照录制/">android-camera2预览拍照录制</a>
          </li>
        
          <li>
            <a href="/2018/07/17/http之head解析/">http之head解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 CallteFoot<br>
      Powered by <a href="https://cattlefoot.github.io" target="_blank">CallteFoot</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>